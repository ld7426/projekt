// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.2

//# unitInfo: Provides: Definicije
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Definicije = [0];
   runtime.caml_register_global(0, Definicije, "Definicije");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Definicije__Stanje
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function iz_niza(oznaka){return [0, oznaka];}
   function v_niz(param){var oznaka = param[1]; return oznaka;}
   var Definicije_Stanje = [0, iz_niza, v_niz];
   runtime.caml_register_global(0, Definicije_Stanje, "Definicije__Stanje");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Definicije__Avtomat
//# unitInfo: Requires: Definicije__Stanje, Stdlib__List, Stdlib__Seq, Stdlib__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Definicije_Stanje = global_data.Definicije__Stanje;
   function prazen_avtomat(zacetno_stanje){
    return [0, [0, zacetno_stanje, 0], zacetno_stanje, 0, 0];
   }
   function dodaj_nesprejemno_stanje(stanje, avtomat){
    return [0, [0, stanje, avtomat[1]], avtomat[2], avtomat[3], avtomat[4]];
   }
   function dodaj_sprejemno_stanje(stanje, avtomat){
    return [0,
            [0, stanje, avtomat[1]],
            avtomat[2],
            [0, stanje, avtomat[3]],
            avtomat[4]];
   }
   function dodaj_prehod(stanje1, znak, stanje2, avtomat){
    return [0,
            avtomat[1],
            avtomat[2],
            avtomat[3],
            [0, [0, stanje1, znak, stanje2], avtomat[4]]];
   }
   function prehodna_funkcija(avtomat, stanje, znak){
    var
     match =
       caml_call2
        (Stdlib_List[40],
         function(param){
          var
           znak$0 = param[2],
           stanje1 = param[1],
           _b_ = runtime.caml_equal(stanje1, stanje),
           _c_ = _b_ ? znak === znak$0 ? 1 : 0 : _b_;
          return _c_;
         },
         avtomat[4]);
    if(! match) return 0;
    var stanje2 = match[1][3];
    return [0, stanje2];
   }
   function zacetno_stanje(avtomat){return avtomat[2];}
   function seznam_stanj(avtomat){return avtomat[1];}
   function seznam_prehodov(avtomat){return avtomat[4];}
   function je_sprejemno_stanje(avtomat, stanje){
    return caml_call2(Stdlib_List[37], stanje, avtomat[3]);
   }
   var
    q0 = caml_call1(Definicije_Stanje[1], "q0"),
    q1 = caml_call1(Definicije_Stanje[1], "q1"),
    q2 = caml_call1(Definicije_Stanje[1], "q2"),
    enke_1mod3 =
      dodaj_prehod
       (q2,
        49,
        q0,
        dodaj_prehod
         (q1,
          49,
          q2,
          dodaj_prehod
           (q0,
            49,
            q1,
            dodaj_prehod
             (q2,
              48,
              q2,
              dodaj_prehod
               (q1,
                48,
                q1,
                dodaj_prehod
                 (q0,
                  48,
                  q0,
                  dodaj_nesprejemno_stanje
                   (q2, dodaj_sprejemno_stanje(q1, prazen_avtomat(q0)))))))));
   function preberi_niz(avtomat, q, niz){
    function aux(acc, znak){
     if(! acc) return 0;
     var q = acc[1];
     return prehodna_funkcija(avtomat, q, znak);
    }
    var _a_ = caml_call1(Stdlib_String[40], niz);
    return caml_call1(caml_call2(Stdlib_Seq[5], aux, [0, q]), _a_);
   }
   var
    Definicije_Avtomat =
      [0,
       prazen_avtomat,
       dodaj_nesprejemno_stanje,
       dodaj_sprejemno_stanje,
       dodaj_prehod,
       prehodna_funkcija,
       zacetno_stanje,
       seznam_stanj,
       seznam_prehodov,
       je_sprejemno_stanje,
       enke_1mod3,
       preberi_niz];
   runtime.caml_register_global(7, Definicije_Avtomat, "Definicije__Avtomat");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Definicije__Trak
//# unitInfo: Requires: Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib_String = global_data.Stdlib__String;
   function trenutni_znak(trak){
    return runtime.caml_string_get(trak[1], trak[2]);
   }
   function je_na_koncu(trak){
    return caml_ml_string_length(trak[1]) === trak[2] ? 1 : 0;
   }
   function premakni_naprej(trak){return [0, trak[1], trak[2] + 1 | 0];}
   function iz_niza(niz){return [0, niz, 0];}
   var prazen = iz_niza(cst);
   function v_niz(trak){return trak[1];}
   function prebrani(trak){
    return caml_call3(Stdlib_String[16], trak[1], 0, trak[2]);
   }
   function neprebrani(trak){
    return caml_call3
            (Stdlib_String[16],
             trak[1],
             trak[2],
             caml_ml_string_length(trak[1]) - trak[2] | 0);
   }
   var
    Definicije_Trak =
      [0,
       prazen,
       trenutni_znak,
       je_na_koncu,
       premakni_naprej,
       iz_niza,
       v_niz,
       prebrani,
       neprebrani];
   runtime.caml_register_global(2, Definicije_Trak, "Definicije__Trak");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Definicije__ZagnaniAvtomat
//# unitInfo: Requires: Definicije__Avtomat, Definicije__Trak
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Definicije_Avtomat = global_data.Definicije__Avtomat,
    Definicije_Trak = global_data.Definicije__Trak;
   function pozeni(avtomat, trak){
    return [0, avtomat, trak, caml_call1(Definicije_Avtomat[6], avtomat)];
   }
   function avtomat(param){var avtomat = param[1]; return avtomat;}
   function trak(param){var trak = param[2]; return trak;}
   function stanje(param){var stanje = param[3]; return stanje;}
   function korak_naprej(param){
    var stanje = param[3], trak = param[2], avtomat = param[1];
    if(caml_call1(Definicije_Trak[3], trak)) return 0;
    var
     _a_ = caml_call1(Definicije_Trak[2], trak),
     stanje$0 = caml_call3(Definicije_Avtomat[5], avtomat, stanje, _a_);
    if(! stanje$0) return 0;
    var stanje$1 = stanje$0[1];
    return [0, [0, avtomat, caml_call1(Definicije_Trak[4], trak), stanje$1]];
   }
   function je_v_sprejemnem_stanju(param){
    var stanje = param[3], avtomat = param[1];
    return caml_call2(Definicije_Avtomat[9], avtomat, stanje);
   }
   var
    Definicije_ZagnaniAvtomat =
      [0, pozeni, avtomat, trak, stanje, korak_naprej, je_v_sprejemnem_stanju];
   runtime.caml_register_global
    (2, Definicije_ZagnaniAvtomat, "Definicije__ZagnaniAvtomat");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Definicije__Pravila
//# unitInfo: Requires: Stdlib__Array
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Array = global_data.Stdlib__Array;
   function sestejlist(seznam){
    var seznam$0 = seznam;
    for(;;){
     if(! seznam$0) return 0;
     if(seznam$0[1]){var tail = seznam$0[2]; return 1 + sestejlist(tail) | 0;}
     var seznam$1 = seznam$0[2];
     seznam$0 = seznam$1;
    }
   }
   function spremeni_stanje(sosedilist, trenutno_stanje){
    var zivisosedi = sestejlist(sosedilist);
    if(4 >= zivisosedi && ! trenutno_stanje) return 0;
    if(3 >= zivisosedi && trenutno_stanje) return 0;
    return trenutno_stanje ? 8 < zivisosedi ? 0 : 1 : 1;
   }
   function spremeni_stanje_zivi(zivisosedi, trenutno_stanje){
    if(3 >= zivisosedi && ! trenutno_stanje) return 0;
    if(1 >= zivisosedi && trenutno_stanje) return 0;
    return trenutno_stanje ? 8 < zivisosedi ? 0 : 1 : 1;
   }
   function matrikasestejizloceni(izloci, matrika){
    var
     m = matrika.length - 1,
     n = caml_check_bound(matrika, 0)[1].length - 1;
    return caml_call2
            (Stdlib_Array[1],
             m,
             function(i){
              return caml_call2
                      (Stdlib_Array[1],
                       n,
                       function(j){
                        return sestejlist(caml_call5(izloci, matrika, m, n, i, j));
                       });
             });
   }
   function kopirajmatriko(matrika){
    return caml_call2(Stdlib_Array[14], Stdlib_Array[7], matrika);
   }
   function korak(izloci, matrika){
    var
     m = matrika.length - 1,
     n = caml_check_bound(matrika, 0)[1].length - 1;
    return caml_call2
            (Stdlib_Array[1],
             m,
             function(i){
              return caml_call2
                      (Stdlib_Array[1],
                       n,
                       function(j){
                        var
                         _a_ =
                           caml_check_bound(caml_check_bound(matrika, i)[1 + i], j)
                            [1 + j];
                        return spremeni_stanje_zivi
                                (sestejlist(caml_call5(izloci, matrika, m, n, i, j)), _a_);
                       });
             });
   }
   var
    zacetnamatrika =
      [0,
       [0, 0, 1, 1, 1, 1, 1, 1].slice(),
       [0, 0, 1, 1, 1, 1, 1, 1].slice(),
       [0, 1, 1, 1, 1, 1, 1, 1].slice(),
       [0, 0, 0, 1, 1, 1, 0, 1].slice(),
       [0, 0, 0, 0, 1, 0, 1, 0].slice()],
    Definicije_Pravila =
      [0,
       sestejlist,
       spremeni_stanje,
       spremeni_stanje_zivi,
       matrikasestejizloceni,
       kopirajmatriko,
       korak,
       zacetnamatrika];
   runtime.caml_register_global(6, Definicije_Pravila, "Definicije__Pravila");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Definicije__Izlocisosede
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_mod = runtime.caml_mod;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = "\n",
    cst$1 = "",
    cst = " ",
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib = global_data.Stdlib;
   function randomarray(n){
    if(0 === n) return [0];
    var
     _R_ = randomarray(n - 1 | 0),
     _S_ = [0, caml_call1(Stdlib_Random[15], 0)];
    return caml_call2(Stdlib_Array[4], _S_, _R_);
   }
   function randommatrika(m, n){
    if(0 === m) return [0];
    var _P_ = randommatrika(m - 1 | 0, n), _Q_ = [0, randomarray(n)];
    return caml_call2(Stdlib_Array[4], _Q_, _P_);
   }
   function symbol(x, y){
    var _O_ = caml_call2(Stdlib[28], cst, y);
    return caml_call2(Stdlib[28], x, _O_);
   }
   function izpisimatrikoint(matrika){
    return caml_call2
            (Stdlib_Array[14],
             function(vrstica){
              var
               _L_ = caml_call2(Stdlib_Array[14], Stdlib[33], vrstica),
               _M_ =
                 caml_call1(caml_call2(Stdlib_Array[18], symbol, cst$1), _L_),
               _N_ = caml_call2(Stdlib[28], _M_, cst$0);
              return caml_call1(Stdlib[42], _N_);
             },
             matrika);
   }
   function mapmatrix(f, mat){
    return caml_call2
            (Stdlib_Array[14],
             function(vrstica){
              return caml_call2(Stdlib_Array[14], f, vrstica);
             },
             mat);
   }
   function intofbool(param){return param ? 1 : 0;}
   function boolofint(param){return 0 === param ? 0 : 1 === param ? 1 : 1;}
   function izpisisosedeint(sosedi){
    if(sosedi){
     var _D_ = sosedi[2];
     if(_D_){
      var _E_ = _D_[2];
      if(_E_){
       var _F_ = _E_[2];
       if(_F_){
        var _G_ = _F_[2];
        if(_G_){
         var _H_ = _G_[2];
         if(_H_){
          var _I_ = _H_[2];
          if(_I_){
           var _J_ = _I_[2];
           if(_J_){
            var _K_ = _J_[2];
            if(_K_ && ! _K_[2]){
             var
              deveti = _K_[1],
              osmi = _J_[1],
              sedmi = _I_[1],
              sesti = _H_[1],
              peti = _G_[1],
              cetrti = _F_[1],
              tretji = _E_[1],
              drugi = _D_[1],
              prvi = sosedi[1];
             return izpisimatrikoint
                     ([0,
                       [0, 0, prvi, 0, drugi, 0, 0],
                       [0, tretji, cetrti, 0, peti, sesti, 0],
                       [0, 0, sedmi, 0, osmi, 0, deveti]]);
            }
           }
          }
         }
        }
       }
      }
     }
    }
    return izpisimatrikoint(caml_call3(Stdlib_Array[2], 3, 6, 0));
   }
   function izlocisosede(matrika, m, n, i, j){
    var
     _l_ = caml_mod((j - 1 | 0) + n | 0, n),
     _m_ = caml_mod((i - 1 | 0) + m | 0, m),
     prvi =
       caml_check_bound(caml_check_bound(matrika, _m_)[1 + _m_], _l_)[1 + _l_],
     _n_ = caml_mod(j + 1 | 0, n),
     _o_ = caml_mod((i - 1 | 0) + m | 0, m),
     drugi =
       caml_check_bound(caml_check_bound(matrika, _o_)[1 + _o_], _n_)[1 + _n_],
     _p_ = caml_mod((j - 2 | 0) + n | 0, n),
     _q_ = caml_mod(i, m),
     tretji =
       caml_check_bound(caml_check_bound(matrika, _q_)[1 + _q_], _p_)[1 + _p_],
     _r_ = caml_mod((j - 1 | 0) + n | 0, n),
     _s_ = caml_mod(i, m),
     cetrti =
       caml_check_bound(caml_check_bound(matrika, _s_)[1 + _s_], _r_)[1 + _r_],
     _t_ = caml_mod(j + 1 | 0, n),
     _u_ = caml_mod(i, m),
     peti =
       caml_check_bound(caml_check_bound(matrika, _u_)[1 + _u_], _t_)[1 + _t_],
     _v_ = caml_mod(j + 2 | 0, n),
     _w_ = caml_mod(i, m),
     sesti =
       caml_check_bound(caml_check_bound(matrika, _w_)[1 + _w_], _v_)[1 + _v_],
     _x_ = caml_mod((j - 1 | 0) + n | 0, n),
     _y_ = caml_mod(i + 1 | 0, m),
     sedmi =
       caml_check_bound(caml_check_bound(matrika, _y_)[1 + _y_], _x_)[1 + _x_],
     _z_ = caml_mod(j + 1 | 0, n),
     _A_ = caml_mod(i + 1 | 0, m),
     osmi =
       caml_check_bound(caml_check_bound(matrika, _A_)[1 + _A_], _z_)[1 + _z_],
     _B_ = caml_mod(j + 3 | 0, n),
     _C_ = caml_mod(i + 1 | 0, m),
     deveti =
       caml_check_bound(caml_check_bound(matrika, _C_)[1 + _C_], _B_)[1 + _B_];
    return [0,
            prvi,
            [0,
             drugi,
             [0,
              tretji,
              [0,
               cetrti,
               [0, peti, [0, sesti, [0, sedmi, [0, osmi, [0, deveti, 0]]]]]]]]];
   }
   function dotprod(matrikaa, matrikab){
    var
     m = matrikaa.length - 1,
     n = caml_check_bound(matrikaa, 0)[1].length - 1,
     vsota = [0, 0],
     _d_ = m - 1 | 0,
     _c_ = 0;
    if(_d_ >= 0){
     var i = _c_;
     for(;;){
      var _f_ = n - 1 | 0, _e_ = 0;
      if(_f_ >= 0){
       var j = _e_;
       for(;;){
        var
         _h_ =
           caml_check_bound(caml_check_bound(matrikaa, i)[1 + i], j)[1 + j],
         _i_ =
           _h_
            ? caml_check_bound(caml_check_bound(matrikab, i)[1 + i], j)[1 + j]
            : _h_,
         _j_ = intofbool(_i_);
        vsota[1] = vsota[1] + _j_ | 0;
        var _k_ = j + 1 | 0;
        if(_f_ === j) break;
        j = _k_;
       }
      }
      var _g_ = i + 1 | 0;
      if(_d_ === i) break;
      i = _g_;
     }
    }
    return vsota[1];
   }
   function init_matrix(rows, cols, f){
    return caml_call2
            (Stdlib_Array[1],
             rows,
             function(i){
              return caml_call2
                      (Stdlib_Array[1],
                       cols,
                       function(j){return caml_call2(f, i, j);});
             });
   }
   function izlocisosedskomatriko(celamatrika, k, prviindeks, drugiindeks){
    var
     m = celamatrika.length - 1,
     n = caml_check_bound(celamatrika, 0)[1].length - 1;
    return init_matrix
            (k,
             k,
             function(i, j){
              var
               _a_ = caml_mod(j + drugiindeks | 0, n),
               _b_ = caml_mod(i + prviindeks | 0, m);
              return caml_check_bound
                       (caml_check_bound(celamatrika, _b_)[1 + _b_], _a_)
                      [1 + _a_];
             });
   }
   function naredimatrikovsot(celamatrika, matrikasosescine){
    var
     m = celamatrika.length - 1,
     n = caml_check_bound(celamatrika, 0)[1].length - 1,
     k = matrikasosescine.length - 1;
    return init_matrix
            (m,
             n,
             function(i, j){
              return dotprod
                      (izlocisosedskomatriko(celamatrika, k, i, j),
                       matrikasosescine);
             });
   }
   var
    Definicije_Izlocisosede =
      [0,
       randomarray,
       randommatrika,
       symbol,
       izpisimatrikoint,
       mapmatrix,
       intofbool,
       boolofint,
       izpisisosedeint,
       izlocisosede,
       dotprod,
       init_matrix,
       izlocisosedskomatriko,
       naredimatrikovsot];
   runtime.caml_register_global
    (6, Definicije_Izlocisosede, "Definicije__Izlocisosede");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiIuZGVmaW5pY2lqZS5vYmpzL2pzb28vZGVmYXVsdC9kZWZpbmljaWplLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJpel9uaXphIiwib3puYWthIiwidl9uaXoiLCJwcmF6ZW5fYXZ0b21hdCIsInphY2V0bm9fc3RhbmplIiwiZG9kYWpfbmVzcHJlamVtbm9fc3RhbmplIiwic3RhbmplIiwiYXZ0b21hdCIsImRvZGFqX3NwcmVqZW1ub19zdGFuamUiLCJkb2Rhal9wcmVob2QiLCJzdGFuamUxIiwiem5hayIsInN0YW5qZTIiLCJwcmVob2RuYV9mdW5rY2lqYSIsInpuYWskMCIsInNlem5hbV9zdGFuaiIsInNlem5hbV9wcmVob2RvdiIsImplX3NwcmVqZW1ub19zdGFuamUiLCJxMCIsInExIiwicTIiLCJlbmtlXzFtb2QzIiwicHJlYmVyaV9uaXoiLCJxIiwibml6IiwiYXV4IiwiYWNjIiwidHJlbnV0bmlfem5hayIsInRyYWsiLCJqZV9uYV9rb25jdSIsInByZW1ha25pX25hcHJlaiIsInByYXplbiIsInByZWJyYW5pIiwibmVwcmVicmFuaSIsInBvemVuaSIsImtvcmFrX25hcHJlaiIsInN0YW5qZSQwIiwic3RhbmplJDEiLCJqZV92X3NwcmVqZW1uZW1fc3Rhbmp1Iiwic2VzdGVqbGlzdCIsInNlem5hbSIsInNlem5hbSQwIiwidGFpbCIsInNlem5hbSQxIiwic3ByZW1lbmlfc3RhbmplIiwic29zZWRpbGlzdCIsInRyZW51dG5vX3N0YW5qZSIsInppdmlzb3NlZGkiLCJzcHJlbWVuaV9zdGFuamVfeml2aSIsIm1hdHJpa2FzZXN0ZWppemxvY2VuaSIsIml6bG9jaSIsIm1hdHJpa2EiLCJtIiwibiIsImkiLCJqIiwia29waXJham1hdHJpa28iLCJrb3JhayIsInphY2V0bmFtYXRyaWthIiwicmFuZG9tYXJyYXkiLCJyYW5kb21tYXRyaWthIiwic3ltYm9sIiwieCIsInkiLCJpenBpc2ltYXRyaWtvaW50IiwidnJzdGljYSIsIm1hcG1hdHJpeCIsImYiLCJtYXQiLCJpbnRvZmJvb2wiLCJib29sb2ZpbnQiLCJpenBpc2lzb3NlZGVpbnQiLCJzb3NlZGkiLCJkZXZldGkiLCJvc21pIiwic2VkbWkiLCJzZXN0aSIsInBldGkiLCJjZXRydGkiLCJ0cmV0amkiLCJkcnVnaSIsInBydmkiLCJpemxvY2lzb3NlZGUiLCJkb3Rwcm9kIiwibWF0cmlrYWEiLCJtYXRyaWthYiIsInZzb3RhIiwiaW5pdF9tYXRyaXgiLCJyb3dzIiwiY29scyIsIml6bG9jaXNvc2Vkc2tvbWF0cmlrbyIsImNlbGFtYXRyaWthIiwiayIsInBydmlpbmRla3MiLCJkcnVnaWluZGVrcyIsIm5hcmVkaW1hdHJpa292c290IiwibWF0cmlrYXNvc2VzY2luZSJdLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZGVmaW5pY2lqZS9zdGFuamUubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2RlZmluaWNpamUvYXZ0b21hdC5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZGVmaW5pY2lqZS90cmFrLm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9kZWZpbmljaWplL3phZ25hbmlBdnRvbWF0Lm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9kZWZpbmljaWplL3ByYXZpbGEubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2RlZmluaWNpamUvaXpsb2Npc29zZWRlLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7WUFFSUEsUUFBUUMsUUFBUyxXQUFUQSxRQUFtQjtZQUMzQkMsaUJBQVFELG1CQUFXLE9BQVhBOytCQURSRCxTQUNBRTs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7OztZQ01BQyxlQUFlQztJQUNqQixlQURpQkEsb0JBQUFBO0dBTWhCO1lBRUNDLHlCQUF5QkMsUUFBT0M7SUFDbEMsZUFEMkJELFFBQU9DLGFBQUFBLFlBQUFBLFlBQUFBO0dBQ2dCO1lBRWhEQyx1QkFBdUJGLFFBQU9DO0lBQ2hDO2dCQUR5QkQsUUFBT0M7WUFBQUE7Z0JBQVBELFFBQU9D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LEdBQUVDO2NBQUssT0F4QnhCNEI7dUJBZUFPLHNCQUtrQkMsYUFHbEJDLEdBQ2lCdEMsR0FBRUM7dUJBSld5QzthQUk4RDtHQUFDOzs7O09BckV6RnJDO09BS0FDO09BS0pDO09BRUFHO09BR0FFO09BR0FHO09BSUFDO09BS0FDO09BS0FXO09BYUFDO09BV0FJO09BSUFHO09BS0FLOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJ0eXBlIHQgPSB7IG96bmFrYSA6IHN0cmluZyB9XG5cbmxldCBpel9uaXphIG96bmFrYSA9IHsgb3puYWthIH1cbmxldCB2X25peiB7IG96bmFrYSB9ID0gb3puYWthXG4iLCJ0eXBlIHN0YW5qZSA9IFN0YW5qZS50XG5cbnR5cGUgdCA9IHtcbiAgc3RhbmphIDogc3RhbmplIGxpc3Q7XG4gIHphY2V0bm9fc3RhbmplIDogc3RhbmplO1xuICBzcHJlamVtbmFfc3RhbmphIDogc3RhbmplIGxpc3Q7XG4gIHByZWhvZGkgOiAoc3RhbmplICogY2hhciAqIHN0YW5qZSkgbGlzdDtcbn1cblxubGV0IHByYXplbl9hdnRvbWF0IHphY2V0bm9fc3RhbmplID1cbiAge1xuICAgIHN0YW5qYSA9IFsgemFjZXRub19zdGFuamUgXTtcbiAgICB6YWNldG5vX3N0YW5qZTtcbiAgICBzcHJlamVtbmFfc3RhbmphID0gW107XG4gICAgcHJlaG9kaSA9IFtdO1xuICB9XG5cbmxldCBkb2Rhal9uZXNwcmVqZW1ub19zdGFuamUgc3RhbmplIGF2dG9tYXQgPVxuICB7IGF2dG9tYXQgd2l0aCBzdGFuamEgPSBzdGFuamUgOjogYXZ0b21hdC5zdGFuamEgfVxuXG5sZXQgZG9kYWpfc3ByZWplbW5vX3N0YW5qZSBzdGFuamUgYXZ0b21hdCA9XG4gIHtcbiAgICBhdnRvbWF0IHdpdGhcbiAgICBzdGFuamEgPSBzdGFuamUgOjogYXZ0b21hdC5zdGFuamE7XG4gICAgc3ByZWplbW5hX3N0YW5qYSA9IHN0YW5qZSA6OiBhdnRvbWF0LnNwcmVqZW1uYV9zdGFuamE7XG4gIH1cblxubGV0IGRvZGFqX3ByZWhvZCBzdGFuamUxIHpuYWsgc3RhbmplMiBhdnRvbWF0ID1cbiAgeyBhdnRvbWF0IHdpdGggcHJlaG9kaSA9IChzdGFuamUxLCB6bmFrLCBzdGFuamUyKSA6OiBhdnRvbWF0LnByZWhvZGkgfVxuXG5sZXQgcHJlaG9kbmFfZnVua2NpamEgYXZ0b21hdCBzdGFuamUgem5hayA9XG4gIG1hdGNoXG4gICAgTGlzdC5maW5kX29wdFxuICAgICAgKGZ1biAoc3RhbmplMSwgem5haycsIF9zdGFuamUyKSAtPiBzdGFuamUxID0gc3RhbmplICYmIHpuYWsgPSB6bmFrJylcbiAgICAgIGF2dG9tYXQucHJlaG9kaVxuICB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAoXywgXywgc3RhbmplMikgLT4gU29tZSBzdGFuamUyXG5cbmxldCB6YWNldG5vX3N0YW5qZSBhdnRvbWF0ID0gYXZ0b21hdC56YWNldG5vX3N0YW5qZVxubGV0IHNlem5hbV9zdGFuaiBhdnRvbWF0ID0gYXZ0b21hdC5zdGFuamFcbmxldCBzZXpuYW1fcHJlaG9kb3YgYXZ0b21hdCA9IGF2dG9tYXQucHJlaG9kaVxuXG5sZXQgamVfc3ByZWplbW5vX3N0YW5qZSBhdnRvbWF0IHN0YW5qZSA9XG4gIExpc3QubWVtIHN0YW5qZSBhdnRvbWF0LnNwcmVqZW1uYV9zdGFuamFcblxubGV0IGVua2VfMW1vZDMgPVxuICBsZXQgcTAgPSBTdGFuamUuaXpfbml6YSBcInEwXCJcbiAgYW5kIHExID0gU3RhbmplLml6X25pemEgXCJxMVwiXG4gIGFuZCBxMiA9IFN0YW5qZS5pel9uaXphIFwicTJcIiBpblxuICBwcmF6ZW5fYXZ0b21hdCBxMCB8PiBkb2Rhal9zcHJlamVtbm9fc3RhbmplIHExXG4gIHw+IGRvZGFqX25lc3ByZWplbW5vX3N0YW5qZSBxMlxuICB8PiBkb2Rhal9wcmVob2QgcTAgJzAnIHEwIHw+IGRvZGFqX3ByZWhvZCBxMSAnMCcgcTEgfD4gZG9kYWpfcHJlaG9kIHEyICcwJyBxMlxuICB8PiBkb2Rhal9wcmVob2QgcTAgJzEnIHExIHw+IGRvZGFqX3ByZWhvZCBxMSAnMScgcTIgfD4gZG9kYWpfcHJlaG9kIHEyICcxJyBxMFxuXG5sZXQgcHJlYmVyaV9uaXogYXZ0b21hdCBxIG5peiA9XG4gIGxldCBhdXggYWNjIHpuYWsgPVxuICAgIG1hdGNoIGFjYyB3aXRoIE5vbmUgLT4gTm9uZSB8IFNvbWUgcSAtPiBwcmVob2RuYV9mdW5rY2lqYSBhdnRvbWF0IHEgem5ha1xuICBpblxuICBuaXogfD4gU3RyaW5nLnRvX3NlcSB8PiBTZXEuZm9sZF9sZWZ0IGF1eCAoU29tZSBxKVxuIiwidHlwZSB0ID0geyBuaXogOiBzdHJpbmc7IGluZGVrc190cmVudXRuZWdhX3puYWthIDogaW50IH1cblxubGV0IHRyZW51dG5pX3puYWsgdHJhayA9IFN0cmluZy5nZXQgdHJhay5uaXogdHJhay5pbmRla3NfdHJlbnV0bmVnYV96bmFrYVxubGV0IGplX25hX2tvbmN1IHRyYWsgPSBTdHJpbmcubGVuZ3RoIHRyYWsubml6ID0gdHJhay5pbmRla3NfdHJlbnV0bmVnYV96bmFrYVxuXG5sZXQgcHJlbWFrbmlfbmFwcmVqIHRyYWsgPVxuICB7IHRyYWsgd2l0aCBpbmRla3NfdHJlbnV0bmVnYV96bmFrYSA9IHN1Y2MgdHJhay5pbmRla3NfdHJlbnV0bmVnYV96bmFrYSB9XG5cbmxldCBpel9uaXphIG5peiA9IHsgbml6OyBpbmRla3NfdHJlbnV0bmVnYV96bmFrYSA9IDAgfVxubGV0IHByYXplbiA9IGl6X25pemEgXCJcIlxubGV0IHZfbml6IHRyYWsgPSB0cmFrLm5pelxuXG5sZXQgcHJlYnJhbmkgdHJhayA9IFN0cmluZy5zdWIgdHJhay5uaXogMCB0cmFrLmluZGVrc190cmVudXRuZWdhX3puYWthXG5cbmFuZCBuZXByZWJyYW5pIHRyYWsgPVxuICBTdHJpbmcuc3ViIHRyYWsubml6IHRyYWsuaW5kZWtzX3RyZW51dG5lZ2Ffem5ha2FcbiAgICAoU3RyaW5nLmxlbmd0aCB0cmFrLm5peiAtIHRyYWsuaW5kZWtzX3RyZW51dG5lZ2Ffem5ha2EpXG4iLCJ0eXBlIHQgPSB7IGF2dG9tYXQgOiBBdnRvbWF0LnQ7IHRyYWsgOiBUcmFrLnQ7IHN0YW5qZSA6IFN0YW5qZS50IH1cblxubGV0IHBvemVuaSBhdnRvbWF0IHRyYWsgPVxuICB7IGF2dG9tYXQ7IHRyYWs7IHN0YW5qZSA9IEF2dG9tYXQuemFjZXRub19zdGFuamUgYXZ0b21hdCB9XG5cbmxldCBhdnRvbWF0IHsgYXZ0b21hdDsgXyB9ID0gYXZ0b21hdFxubGV0IHRyYWsgeyB0cmFrOyBfIH0gPSB0cmFrXG5sZXQgc3RhbmplIHsgc3RhbmplOyBfIH0gPSBzdGFuamVcblxubGV0IGtvcmFrX25hcHJlaiB7IGF2dG9tYXQ7IHRyYWs7IHN0YW5qZSB9ID1cbiAgaWYgVHJhay5qZV9uYV9rb25jdSB0cmFrIHRoZW4gTm9uZVxuICBlbHNlXG4gICAgbGV0IHN0YW5qZScgPVxuICAgICAgQXZ0b21hdC5wcmVob2RuYV9mdW5rY2lqYSBhdnRvbWF0IHN0YW5qZSAoVHJhay50cmVudXRuaV96bmFrIHRyYWspXG4gICAgaW5cbiAgICBtYXRjaCBzdGFuamUnIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBzdGFuamUnIC0+XG4gICAgICAgIFNvbWUgeyBhdnRvbWF0OyB0cmFrID0gVHJhay5wcmVtYWtuaV9uYXByZWogdHJhazsgc3RhbmplID0gc3RhbmplJyB9XG5cbmxldCBqZV92X3NwcmVqZW1uZW1fc3Rhbmp1IHsgYXZ0b21hdDsgc3RhbmplOyBfIH0gPVxuICBBdnRvbWF0LmplX3NwcmVqZW1ub19zdGFuamUgYXZ0b21hdCBzdGFuamVcbiIsIigqIERhdG90ZWthIHMgcHJhdmlsaSB6YSBzcHJlbWVtYm8gc3RhbmogKilcblxuXG5cblxuKCogRnVua2NpamEgc3ByZW1lbmlfc3RhbmplIHNwcmVqbWUgdHVwbGUgc29zZWRvdiBwcmVkdmlkZW5lIGRvbMW+aW5lIChib29sICogYm9vbCAqIGJvb2wgLi4uICogYm9vbCkgaW4gdHJlbnV0bm8gc3RhbmplIDogYm9vbCwgdGVyIHZybmUga29uxI1ubyBzdGFuamUgOiBib29sIFxudHJlbnV0bm8gbmFzdGF2bGplbm8gbmEgb2JsaWtvXG5cdCAgfDF8IHwyfFxuXHR8M3w0fHh8NXw2fFxuXHQgIHw3fCB8OHwgfDl8XG5cbmtqZXIgc28gcG8gdnJzdGkgdiBzb3NlZGl0dXBsZSBrb3Qgc28gbmFwaXNhbmUgxaF0ZXZpbGtlLCB4IGplIHBhIHRyZW51dG5hLiBUZWogb2tvbGljaSBib21vIHpkYWogcHJhdmlsaSBkaW5vemF2ZXIsIHNhaiBuYXMgbGFoa28geiB2ZWxpa28gZG9tacWhbGppamUgc3BvbWluamEgbmEgc3RlZ296YXZyYSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGVnb3NhdXJ1c1xuXG5rYWvFoW5lIHphaHRldmUgxb5lbGltbzpcbi0+IGRhIMSNZSBpbWEgdnNlIG9rb2xpIHNlYmUgcHJhem5vIHJhdGEgdHVkaSBzYW0gcHJhemVuIChuZSBnbGVkZSBuYSBvc25vdm5vIHN0YW5qZSlcbi0+IG9iIG1hbGVtIMWhdGV2aWx1IHNvc2Vkb3YgdiB2ZcSNaW5pIHNpdHVhY2lqIHVtcmVcbi0+IG9iIHNyZWRuamVtIMWhdGV2aWx1IHNvc2Vkb3YgdiB2ZcSNaW5pIHNpdHVhY2lqIG/Fvml2aVxuLT4gb2IgcHJldmVsaWtlbSDFoXRldmlsdSBzb3NlZG92IHVtcmVcblxuXG5yZWNpbW8gZGEgZGFtbyBwcmVwcm9zdG8gdGFrbzpcbi0+IMSNZSBqZSBtcnRldiBpbiBpbWEgMyBhbGkgbWFuaiDFvml2aWggc29zZWRvdiBwb3RlbSBvc3RhbmUgbXJ0ZXZcbi0+IMSNZSBqZSDFvml2IGluIGltYSAyIGFsaSBtYW5qIMW+aXZpaCBzb3NlZG92IHBvdGVtIHVtcmVcbi0+IMSNZSBqZSBtcnRldiBpbiBpbWEgbWVkIDMgaW4gOSBzb3NlZG92IHBvdGVtIG/Fvml2aVxuLT4gxI1lIGplIMW+aXYgaW4gaW1hIG1lZCA0IGluIDggxb5pdmloIHNvc2Vkb3YgcG90ZW0gb3N0YW5lIMW+aXZcbi0+IMW9aXYgaW4gOSBzb3NlZG92IHBvdGVtIHVtcmVcblxuKilcbmxldCByZWMgc2VzdGVqbGlzdCBzZXpuYW0gPVxubWF0Y2ggc2V6bmFtIHdpdGhcbnwgdHJ1ZSA6OnRhaWwgLT4gMSArIChzZXN0ZWpsaXN0IHRhaWwpXG58IGZhbHNlIDo6IHRhaWwgLT4gc2VzdGVqbGlzdCB0YWlsXG58W10gLT4gMFxuXG5cbmxldCBzcHJlbWVuaV9zdGFuamUgc29zZWRpbGlzdCB0cmVudXRub19zdGFuamUgPVxubGV0IHppdmlzb3NlZGkgPSBzZXN0ZWpsaXN0IHNvc2VkaWxpc3QgaW5cbmlmIHppdmlzb3NlZGkgPD00ICYmIChub3QgdHJlbnV0bm9fc3RhbmplKSB0aGVuIGZhbHNlXG5lbHNlIGlmIHppdmlzb3NlZGkgPD0zICYmIHRyZW51dG5vX3N0YW5qZSB0aGVuIGZhbHNlXG5lbHNlIGlmIG5vdCB0cmVudXRub19zdGFuamUgdGhlbiB0cnVlXG5lbHNlIGlmIHppdmlzb3NlZGk8PTggdGhlbiB0cnVlXG5lbHNlIGZhbHNlXG5cbmxldCBzcHJlbWVuaV9zdGFuamVfeml2aSB6aXZpc29zZWRpIHRyZW51dG5vX3N0YW5qZSA9XG5pZiB6aXZpc29zZWRpIDw9MyAmJiAobm90IHRyZW51dG5vX3N0YW5qZSkgdGhlbiBmYWxzZVxuZWxzZSBpZiB6aXZpc29zZWRpIDw9MSAmJiB0cmVudXRub19zdGFuamUgdGhlbiBmYWxzZVxuZWxzZSBpZiBub3QgdHJlbnV0bm9fc3RhbmplIHRoZW4gdHJ1ZVxuZWxzZSBpZiB6aXZpc29zZWRpPD04IHRoZW4gdHJ1ZVxuZWxzZSBmYWxzZVxuXG5cbmxldCBtYXRyaWthc2VzdGVqaXpsb2NlbmkgaXpsb2NpIG1hdHJpa2EgPVxubGV0IG0gPSBBcnJheS5sZW5ndGggbWF0cmlrYSBpblxubGV0IG4gPSBBcnJheS5sZW5ndGggbWF0cmlrYS4oMCkgaW5cbkFycmF5LmluaXQgbSAoZnVuIGkgLT4gQXJyYXkuaW5pdCBuIChmdW4gaiAtPiBzZXN0ZWpsaXN0IEBAIGl6bG9jaSBtYXRyaWthIG0gbiBpIGopKVxuXG5sZXQga29waXJham1hdHJpa28gbWF0cmlrYSA9ICgqemEgc3Byb2JhdmF0IHNlbSByYWJpbCB0byBmdW5rY2lqbywgZGEgbmlzZW0gc3ByZW1pbmphbCBtYXRyaWtlKilcbkFycmF5Lm1hcCBBcnJheS5jb3B5IG1hdHJpa2FcblxubGV0IGtvcmFrIGl6bG9jaSBtYXRyaWthID0gKCpnbGF2bmEgZnVua2NpamEga2kgam8ga2xpxI1lbW8gc2t1cGFqIHMgZnVua2Npam8gaXpsb2Npc29zZWRlIGl6IGl6bG9jaXNvc2VkZS5tbCwgcHJpbWVyOiBsZXQgdHJlbnV0bmEgPSBrb3JhayBpemxvY2lzb3NlZGUgemFjZXRuYW1hdHJpa2EgKilcbmxldCBtID0gQXJyYXkubGVuZ3RoIG1hdHJpa2EgaW5cbmxldCBuID0gQXJyYXkubGVuZ3RoIG1hdHJpa2EuKDApIGluXG5BcnJheS5pbml0IG0gKGZ1biBpIC0+IEFycmF5LmluaXQgbiAoZnVuIGogLT4gc3ByZW1lbmlfc3RhbmplX3ppdmkgKHNlc3Rlamxpc3QgQEAgaXpsb2NpIG1hdHJpa2EgbSBuIGkgaikgbWF0cmlrYS4oaSkuKGopICkpXG5cbmxldCB6YWNldG5hbWF0cmlrYSA9IFt8W3xmYWxzZTsgdHJ1ZTsgdHJ1ZTsgdHJ1ZTsgdHJ1ZTsgdHJ1ZTsgdHJ1ZXxdOyAoKiB6YSB2ZcSNamUgcHJpbWVyZSBzaSBqZSBuYWpib2xqZSBnZW5lcmlyYXRpIG5ha2xqdcSNbm8gbWF0cmlrbyB6IHVrYXpvbTogbGV0IG1hdHJpa2EgPSByYW5kb21tYXRyaWthIG0gbiwga2kgamUgdiBpemxvY2lzb3NlZGUubWwqKVxuICAgIFt8ZmFsc2U7IHRydWU7IHRydWU7IHRydWU7IHRydWU7IHRydWU7IHRydWV8XTtcbiAgICBbfHRydWU7IHRydWU7IHRydWU7IHRydWU7IHRydWU7IHRydWU7IHRydWV8XTtcbiAgICBbfGZhbHNlOyBmYWxzZTsgdHJ1ZTsgdHJ1ZTsgdHJ1ZTsgZmFsc2U7IHRydWV8XTtcbiAgICBbfGZhbHNlOyBmYWxzZTsgZmFsc2U7IHRydWU7IGZhbHNlOyB0cnVlOyBmYWxzZXxdfF1cblxuIiwiKCogdHUgbm90IGJvZG8gZnVua2NpamUsIGtpIG5hbSBpeiBwb2RhbmUgbWF0cmlrZSAobmUgdmVtIMWhZSBrYWvFoW5hIGJvKSBpemxvxI1pam8gc29zZWRlIHYgb2JsaWtpIGtvdCBzZW0gam8gZG9sb8SNaWwgXG50cmViYSBibyBwcnZvIGRvbG/EjWl0aSBtZWplIHNpc3RlbWEgYWxpIHBhxI0gZGEgamUgbmVza29uxI1lbiBpbiBkYSBzZSBibyB0b3JlaiBkb2RhamFsbyBzdHZhcmlcblxubW9nb8SNZSBuYWpwcmVqIHJlxI1lbW8sIGRhIHNvIHBlcmlvZGnEjW5pIGJvdW5kYXJ5IGNvbmRpdGlvbmksIGplIG5hamxhxb5qZVxuXG50cmVudXRubyBuYXN0YXZsamVubyBuYSBvYmxpa29cblxuICAgICBqLTIsai0xLGosaisxLGorMiwgaiszXG5cdCAgfDF8IHwyfFx0aS0xXG5cdHwzfDR8eHw1fDZ8ICAgdnJzdGljYSBpXG5cdCAgfDd8IHw4fCB8OXwgICBpKzFcblx0c3RvbHBlYyBqXG5cbiopXG5sZXQgcmVjIHJhbmRvbWFycmF5IG4gPVxubWF0Y2ggbiB3aXRoXG58IDAgLT4gW3wgfF1cbnwgayAtPiBBcnJheS5hcHBlbmQgW3xSYW5kb20uYm9vbCgpfF0gKHJhbmRvbWFycmF5IChrLTEpKVxuXG5sZXQgcmVjIHJhbmRvbW1hdHJpa2EgbSBuID1cbm1hdGNoIG0gd2l0aCBcbnwgMCAtPiBbfCB8XVxufCBrIC0+IEFycmF5LmFwcGVuZCBbfHJhbmRvbWFycmF5IG58XSAocmFuZG9tbWF0cmlrYSAoay0xKSBuKVxuXG5sZXQgKF5eXikgeCB5ID0geCBeIFwiIFwiIF4geVxuXG5sZXQgaXpwaXNpbWF0cmlrb2ludCBtYXRyaWthID1cbiBBcnJheS5tYXAgKGZ1biB2cnN0aWNhIC0+IHByaW50X3N0cmluZyAoKEFycmF5LmZvbGRfbGVmdCAoXl5eKSBcIlwiIEBAIEFycmF5Lm1hcCBzdHJpbmdfb2ZfaW50IHZyc3RpY2EpIF4gXCJcXG5cIikpIG1hdHJpa2FcblxubGV0IG1hcG1hdHJpeCBmIG1hdCA9XG5BcnJheS5tYXAgKGZ1biB2cnN0aWNhIC0+IEFycmF5Lm1hcCBmIHZyc3RpY2EpIG1hdFxuXG5sZXQgaW50b2Zib29sID0gZnVuY3Rpb25cbnwgdHJ1ZSAtPiAxXG58IGZhbHNlIC0+IDBcblxubGV0IGJvb2xvZmludCA9IGZ1bmN0aW9uXG58IDEgLT4gdHJ1ZVxufCAwIC0+IGZhbHNlXG58IF8gLT4gdHJ1ZVxuXG5sZXQgaXpwaXNpc29zZWRlaW50IHNvc2VkaSA9IFxubWF0Y2ggc29zZWRpIHdpdGggXG58IHBydmk6OmRydWdpOjp0cmV0amk6OmNldHJ0aTo6cGV0aTo6c2VzdGk6OnNlZG1pOjpvc21pOjpkZXZldGk6OltdIC0+IGl6cGlzaW1hdHJpa29pbnQgW3xbfDA7cHJ2aTswO2RydWdpOzA7MHxdOyBbfHRyZXRqaTsgY2V0cnRpOyAwOyBwZXRpOyBzZXN0aTsgMHxdOyBbfDA7IHNlZG1pOyAwOyBvc21pOyAwOyBkZXZldGl8XXxdXG58IF8gLT4gaXpwaXNpbWF0cmlrb2ludCAoQXJyYXkubWFrZV9tYXRyaXggMyA2IDApXG5cbmxldCBpemxvY2lzb3NlZGUgbWF0cmlrYSBtIG4gaSBqID0gKCogbSA9IHN0X3Zyc3RpYywgbj0gc3Rfc3RvbHBjZXYsIGksaiBzdGEga29vcmRpbmF0aSB0cmVudXRuZWdhIHBvbGphICopXG5sZXQgcHJ2aSA9IG1hdHJpa2EuKChpLTErbSkgbW9kIG0pLigoai0xK24pIG1vZCBuKSBpblxubGV0IGRydWdpID0gbWF0cmlrYS4oKGktMSttKSBtb2QgbSkuKChqKzEpICBtb2QgbikgaW5cbmxldCB0cmV0amkgPSBtYXRyaWthLihpIG1vZCBtKS4oKGotMituKSAgbW9kIG4pIGluXG5sZXQgY2V0cnRpID0gbWF0cmlrYS4oaSBtb2QgbSkuKChqLTErbikgIG1vZCBuKSBpblxubGV0IHBldGkgPSBtYXRyaWthLihpIG1vZCBtKS4oKGorMSkgbW9kIG4pIGluXG5sZXQgc2VzdGkgPSBtYXRyaWthLihpIG1vZCBtKS4oKGorMikgbW9kIG4pIGluXG5sZXQgc2VkbWkgPSBtYXRyaWthLigoaSsxKSBtb2QgbSkuKChqLTErbikgbW9kIG4pIGluXG5sZXQgb3NtaSA9IG1hdHJpa2EuKChpKzEpIG1vZCBtKS4oKGorMSkgbW9kIG4pIGluXG5sZXQgZGV2ZXRpID0gbWF0cmlrYS4oKGkrMSkgbW9kIG0pLigoaiszKSBtb2QgbikgaW5cbnBydmk6OmRydWdpOjp0cmV0amk6OmNldHJ0aTo6cGV0aTo6c2VzdGk6OnNlZG1pOjpvc21pOjpkZXZldGk6OltdXG5cblxubGV0IGRvdHByb2QgbWF0cmlrYWEgbWF0cmlrYWIgPSAoKmtvdCBkb3QgcHJvZHVjdCBzYW1vIHogYm9vbGkqKVxuICBsZXQgbSA9IEFycmF5Lmxlbmd0aCBtYXRyaWthYSBpblxuICBsZXQgbiA9IEFycmF5Lmxlbmd0aCBtYXRyaWthYS4oMCkgaW5cbiAgbGV0IHZzb3RhID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIG0gLSAxIGRvXG4gICAgZm9yIGogPSAwIHRvIG4gLSAxIGRvXG4gICAgICB2c290YSA6PSAhdnNvdGEgKyAoaW50b2Zib29sIChtYXRyaWthYS4oaSkuKGopICYmIG1hdHJpa2FiLihpKS4oaikpKVxuICAgIGRvbmVcbiAgZG9uZTtcbiAgIXZzb3RhXG5cbmxldCBpbml0X21hdHJpeCByb3dzIGNvbHMgZiA9ICgqdGEgZnVua2NpamEgYmkgbW9nbGEgYml0IMW+ZSBkZWZpbmlyYW5hIGplIHBpc2FsIG5hIHNwbGV0dT8/PyAqKVxuICBBcnJheS5pbml0IHJvd3MgKGZ1biBpIC0+IEFycmF5LmluaXQgY29scyAoZnVuIGogLT4gZiBpIGopKVxuXG5cbmxldCBpemxvY2lzb3NlZHNrb21hdHJpa28gY2VsYW1hdHJpa2EgayBwcnZpaW5kZWtzIGRydWdpaW5kZWtzID0gKCogZG9iaW1vIG1hdHJpa28gc29zZWRvdiBrdmFkcmF0YSBpIGogKilcbmxldCBtID0gQXJyYXkubGVuZ3RoIGNlbGFtYXRyaWthIGluXG5sZXQgbiA9IEFycmF5Lmxlbmd0aCBjZWxhbWF0cmlrYS4oMCkgaW5cbmluaXRfbWF0cml4IGsgayAoZnVuIGkgaiAtPiBjZWxhbWF0cmlrYS4oKGkgKyBwcnZpaW5kZWtzKSBtb2QgbSkuKChqICsgZHJ1Z2lpbmRla3MgKW1vZCBuKSlcblxubGV0IG5hcmVkaW1hdHJpa292c290IGNlbGFtYXRyaWthIG1hdHJpa2Fzb3Nlc2NpbmUgPVxubGV0IG0gPSBBcnJheS5sZW5ndGggY2VsYW1hdHJpa2EgaW5cbmxldCBuID0gQXJyYXkubGVuZ3RoIGNlbGFtYXRyaWthLigwKSBpbiBcbmxldCBrID0gQXJyYXkubGVuZ3RoIG1hdHJpa2Fzb3Nlc2NpbmUgaW4gXG5pbml0X21hdHJpeCBtIG4gKGZ1biBpIGogLT4gKGRvdHByb2QgKGl6bG9jaXNvc2Vkc2tvbWF0cmlrbyBjZWxhbWF0cmlrYSBrIGkgaikgbWF0cmlrYXNvc2VzY2luZSkpXG4iXX0=
