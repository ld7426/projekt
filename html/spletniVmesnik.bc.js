//# 1 ".spletniVmesnik.eobjs/jsoo/spletniVmesnik.bc.runtime.js"
// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=unknown, use-js-string=true, version=5.8.2
//# 3 ".spletniVmesnik.eobjs/jsoo/spletniVmesnik.bc.runtime.js"

//# 7 ".spletniVmesnik.eobjs/jsoo/spletniVmesnik.bc.runtime.js"
(function
  (Object){
   typeof globalThis !== "object"
   &&
    (this
      ? get()
      : (Object.defineProperty
         (Object.prototype, "_T_", {configurable: true, get: get}),
        _T_));
   function get(){
    var global = this || self;
    global.globalThis = global;
    delete Object.prototype._T_;
   }
  }
  (Object));
(function(globalThis){
   "use strict";
   function caml_subarray_to_jsbytes(a, i, len){
    var f = String.fromCharCode;
    if(i == 0 && len <= 4096 && len == a.length) return f.apply(null, a);
    var s = "";
    for(; 0 < len; i += 1024, len -= 1024)
     s += f.apply(null, a.slice(i, i + Math.min(len, 1024)));
    return s;
   }
   function caml_string_of_jsbytes(x){return x;}
   function caml_string_of_array(a){
    return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a, 0, a.length));
   }
   function caml_ba_get_1(ba, i0){return ba.get(ba.offset(i0));}
   function BigStringReader(bs, i){this.s = bs; this.i = i;}
   BigStringReader.prototype =
    {read8u: function(){return caml_ba_get_1(this.s, this.i++);},
     read8s: function(){return caml_ba_get_1(this.s, this.i++) << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return caml_ba_get_1(s, i) << 8 | caml_ba_get_1(s, i + 1);
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return caml_ba_get_1(s, i) << 24 >> 16 | caml_ba_get_1(s, i + 1);
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (caml_ba_get_1(s, i) << 24 | caml_ba_get_1(s, i + 1) << 16
             | caml_ba_get_1(s, i + 2) << 8
             | caml_ba_get_1(s, i + 3))
             >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return caml_ba_get_1(s, i) << 24 | caml_ba_get_1(s, i + 1) << 16
             | caml_ba_get_1(s, i + 2) << 8
             | caml_ba_get_1(s, i + 3);
     },
     readstr:
     function(len){
      var i = this.i, arr = new Array(len);
      for(var j = 0; j < len; j++) arr[j] = caml_ba_get_1(this.s, i + j);
      this.i = i + len;
      return caml_string_of_array(arr);
     },
     readuint8array:
     function(len){
      var i = this.i, offset = this.offset(i);
      this.i = i + len;
      return this.s.data.subarray(offset, offset + len);
     }};
   function caml_str_repeat(n, s){
    if(n == 0) return "";
    if(s.repeat) return s.repeat(n);
    var r = "", l = 0;
    for(;;){
     if(n & 1) r += s;
     n >>= 1;
     if(n == 0) return r;
     s += s;
     l++;
     if(l == 9) s.slice(0, 1);
    }
   }
   function caml_convert_string_to_bytes(s){
    if(s.t == 2)
     s.c += caml_str_repeat(s.l - s.c.length, "\0");
    else
     s.c = caml_subarray_to_jsbytes(s.c, 0, s.c.length);
    s.t = 0;
   }
   function jsoo_is_ascii(s){
    if(s.length < 24){
     for(var i = 0; i < s.length; i++) if(s.charCodeAt(i) > 127) return false;
     return true;
    }
    else
     return ! /[^\x00-\x7f]/.test(s);
   }
   function caml_utf16_of_utf8(s){
    for(var b = "", t = "", c, c1, c2, v, i = 0, l = s.length; i < l; i++){
     c1 = s.charCodeAt(i);
     if(c1 < 0x80){
      for(var j = i + 1; j < l && (c1 = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.substr(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j == l) break;
      i = j;
     }
     v = 1;
     if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128){
      c = c2 + (c1 << 6);
      if(c1 < 0xe0){
       v = c - 0x3080;
       if(v < 0x80) v = 1;
      }
      else{
       v = 2;
       if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128){
        c = c2 + (c << 6);
        if(c1 < 0xf0){
         v = c - 0xe2080;
         if(v < 0x800 || v >= 0xd7ff && v < 0xe000) v = 2;
        }
        else{
         v = 3;
         if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128 && c1 < 0xf5){
          v = c2 - 0x3c82080 + (c << 6);
          if(v < 0x10000 || v > 0x10ffff) v = 3;
         }
        }
       }
      }
     }
     if(v < 4){
      i -= v;
      t += "\ufffd";
     }
     else if(v > 0xffff)
      t += String.fromCharCode(0xd7c0 + (v >> 10), 0xdc00 + (v & 0x3FF));
     else
      t += String.fromCharCode(v);
     if(t.length > 1024){t.substr(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function MlBytes(tag, contents, length){
    this.t = tag;
    this.c = contents;
    this.l = length;
   }
   MlBytes.prototype.toString =
    function(){
     switch(this.t){
       case 9:
        return this.c;
       default: caml_convert_string_to_bytes(this);
       case 0:
        if(jsoo_is_ascii(this.c)){this.t = 9; return this.c;} this.t = 8;
       case 8:
        return this.c;
     }
    };
   MlBytes.prototype.toUtf16 =
    function(){
     var r = this.toString();
     if(this.t == 9) return r;
     return caml_utf16_of_utf8(r);
    };
   MlBytes.prototype.slice =
    function(){
     var content = this.t == 4 ? this.c.slice() : this.c;
     return new MlBytes(this.t, content, this.l);
    };
   function caml_utf8_of_utf16(s){
    for(var b = "", t = b, c, d, i = 0, l = s.length; i < l; i++){
     c = s.charCodeAt(i);
     if(c < 0x80){
      for(var j = i + 1; j < l && (c = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.substr(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j == l) break;
      i = j;
     }
     if(c < 0x800){
      t += String.fromCharCode(0xc0 | c >> 6);
      t += String.fromCharCode(0x80 | c & 0x3f);
     }
     else if(c < 0xd800 || c >= 0xdfff)
      t +=
       String.fromCharCode
        (0xe0 | c >> 12, 0x80 | c >> 6 & 0x3f, 0x80 | c & 0x3f);
     else if
      (c >= 0xdbff || i + 1 == l || (d = s.charCodeAt(i + 1)) < 0xdc00
       || d > 0xdfff)
      t += "\xef\xbf\xbd";
     else{
      i++;
      c = (c << 10) + d - 0x35fdc00;
      t +=
       String.fromCharCode
        (0xf0 | c >> 18,
         0x80 | c >> 12 & 0x3f,
         0x80 | c >> 6 & 0x3f,
         0x80 | c & 0x3f);
     }
     if(t.length > 1024){t.substr(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function caml_string_of_jsstring(s){
    return jsoo_is_ascii(s)
            ? caml_string_of_jsbytes(s)
            : caml_string_of_jsbytes(caml_utf8_of_utf16(s));
   }
   var
    unix_error =
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
   function make_unix_err_args(code, syscall, path, errno){
    var variant = unix_error.indexOf(code);
    if(variant < 0){if(errno == null) errno = - 9999; variant = [0, errno];}
    var
     args =
       [variant,
        caml_string_of_jsstring(syscall || ""),
        caml_string_of_jsstring(path || "")];
    return args;
   }
   var caml_named_values = {};
   function caml_named_value(nm){return caml_named_values[nm];}
   function jsoo_sys_getenv(n){
    var process = globalThis.process;
    if(process && process.env && process.env[n] != undefined)
     return process.env[n];
    if(globalThis.jsoo_static_env && globalThis.jsoo_static_env[n])
     return globalThis.jsoo_static_env[n];
   }
   var caml_record_backtrace_flag = 0;
   (function(){
      var r = jsoo_sys_getenv("OCAMLRUNPARAM");
      if(r !== undefined){
       var l = r.split(",");
       for(var i = 0; i < l.length; i++)
        if(l[i] == "b"){
         caml_record_backtrace_flag = 1;
         break;
        }
        else if(l[i].startsWith("b="))
         caml_record_backtrace_flag = + l[i].slice(2);
        else
         continue;
      }
     }
     ());
   var caml_global_data = [0];
   function caml_exn_with_js_backtrace(exn, force){
    if(! exn.js_error || force || exn[0] == 248)
     exn.js_error = new globalThis.Error("Js exception containing backtrace");
    return exn;
   }
   function caml_maybe_attach_backtrace(exn, force){
    return caml_record_backtrace_flag
            ? caml_exn_with_js_backtrace(exn, force)
            : exn;
   }
   function caml_raise_with_args(tag, args){
    throw caml_maybe_attach_backtrace([0, tag].concat(args));
   }
   function caml_is_ml_bytes(s){return s instanceof MlBytes;}
   function caml_is_ml_string(s){
    return typeof s === "string" && ! /[^\x00-\xff]/.test(s);
   }
   function caml_bytes_of_array(a){
    if(! (a instanceof Uint8Array)) a = new Uint8Array(a);
    return new MlBytes(4, a, a.length);
   }
   function caml_bytes_of_jsbytes(s){return new MlBytes(0, s, s.length);}
   function caml_jsbytes_of_string(x){return x;}
   function caml_bytes_of_string(s){
    return caml_bytes_of_jsbytes(caml_jsbytes_of_string(s));
   }
   function caml_raise_with_arg(tag, arg){
    throw caml_maybe_attach_backtrace([0, tag, arg]);
   }
   function caml_raise_with_string(tag, msg){
    caml_raise_with_arg(tag, caml_string_of_jsbytes(msg));
   }
   function caml_raise_sys_error(msg){
    caml_raise_with_string(caml_global_data.Sys_error, msg);
   }
   function caml_raise_no_such_file(name){
    caml_raise_sys_error(name + ": No such file or directory");
   }
   function caml_convert_bytes_to_array(s){
    var a = new Uint8Array(s.l), b = s.c, l = b.length, i = 0;
    for(; i < l; i++) a[i] = b.charCodeAt(i);
    for(l = s.l; i < l; i++) a[i] = 0;
    s.c = a;
    s.t = 4;
    return a;
   }
   function caml_uint8_array_of_bytes(s){
    if(s.t != 4) caml_convert_bytes_to_array(s);
    return s.c;
   }
   function caml_invalid_argument(msg){
    caml_raise_with_string(caml_global_data.Invalid_argument, msg);
   }
   function caml_create_bytes(len){
    if(len < 0) caml_invalid_argument("Bytes.create");
    return new MlBytes(len ? 2 : 9, "", len);
   }
   function caml_ml_bytes_length(s){return s.l;}
   function caml_blit_bytes(s1, i1, s2, i2, len){
    if(len == 0) return 0;
    if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length)){
     s2.c =
      s1.t == 4
       ? caml_subarray_to_jsbytes(s1.c, i1, len)
       : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
     s2.t = s2.c.length == s2.l ? 0 : 2;
    }
    else if(s2.t == 2 && i2 == s2.c.length){
     s2.c +=
      s1.t == 4
       ? caml_subarray_to_jsbytes(s1.c, i1, len)
       : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
     s2.t = s2.c.length == s2.l ? 0 : 2;
    }
    else{
     if(s2.t != 4) caml_convert_bytes_to_array(s2);
     var c1 = s1.c, c2 = s2.c;
     if(s1.t == 4)
      if(i2 <= i1)
       for(var i = 0; i < len; i++) c2[i2 + i] = c1[i1 + i];
      else
       for(var i = len - 1; i >= 0; i--) c2[i2 + i] = c1[i1 + i];
     else{
      var l = Math.min(len, c1.length - i1);
      for(var i = 0; i < l; i++) c2[i2 + i] = c1.charCodeAt(i1 + i);
      for(; i < len; i++) c2[i2 + i] = 0;
     }
    }
    return 0;
   }
   function MlFile(){}
   function MlFakeFile(content){this.data = content;}
   MlFakeFile.prototype = new MlFile();
   MlFakeFile.prototype.constructor = MlFakeFile;
   MlFakeFile.prototype.truncate =
    function(len){
     var old = this.data;
     this.data = caml_create_bytes(len | 0);
     caml_blit_bytes(old, 0, this.data, 0, len);
    };
   MlFakeFile.prototype.length =
    function(){return caml_ml_bytes_length(this.data);};
   MlFakeFile.prototype.write =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen){
      var new_str = caml_create_bytes(offset + len), old_data = this.data;
      this.data = new_str;
      caml_blit_bytes(old_data, 0, this.data, 0, clen);
     }
     caml_blit_bytes(caml_bytes_of_array(buf), pos, this.data, offset, len);
     return 0;
    };
   MlFakeFile.prototype.read =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen) len = clen - offset;
     if(len){
      var data = caml_create_bytes(len | 0);
      caml_blit_bytes(this.data, offset, data, 0, len);
      buf.set(caml_uint8_array_of_bytes(data), pos);
     }
     return len;
    };
   function MlFakeFd(name, file, flags){
    this.file = file;
    this.name = name;
    this.flags = flags;
   }
   MlFakeFd.prototype.err_closed =
    function(){
     caml_raise_sys_error(this.name + ": file descriptor already closed");
    };
   MlFakeFd.prototype.length =
    function(){if(this.file) return this.file.length(); this.err_closed();};
   MlFakeFd.prototype.write =
    function(offset, buf, pos, len){
     if(this.file) return this.file.write(offset, buf, pos, len);
     this.err_closed();
    };
   MlFakeFd.prototype.read =
    function(offset, buf, pos, len){
     if(this.file) return this.file.read(offset, buf, pos, len);
     this.err_closed();
    };
   MlFakeFd.prototype.close = function(){this.file = undefined;};
   function MlFakeDevice(root, f){
    this.content = {};
    this.root = root;
    this.lookupFun = f;
   }
   MlFakeDevice.prototype.nm = function(name){return this.root + name;};
   MlFakeDevice.prototype.create_dir_if_needed =
    function(name){
     var comp = name.split("/"), res = "";
     for(var i = 0; i < comp.length - 1; i++){
      res += comp[i] + "/";
      if(this.content[res]) continue;
      this.content[res] = Symbol("directory");
     }
    };
   MlFakeDevice.prototype.slash =
    function(name){return /\/$/.test(name) ? name : name + "/";};
   MlFakeDevice.prototype.lookup =
    function(name){
     if(! this.content[name] && this.lookupFun){
      var
       res =
         this.lookupFun
          (caml_string_of_jsbytes(this.root), caml_string_of_jsbytes(name));
      if(res !== 0){
       this.create_dir_if_needed(name);
       this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]));
      }
     }
    };
   MlFakeDevice.prototype.exists =
    function(name){
     if(name == "") return 1;
     var name_slash = this.slash(name);
     if(this.content[name_slash]) return 1;
     this.lookup(name);
     return this.content[name] ? 1 : 0;
    };
   MlFakeDevice.prototype.isFile =
    function(name){return this.exists(name) && ! this.is_dir(name) ? 1 : 0;};
   MlFakeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     var unix_error = raise_unix && caml_named_value("Unix.Unix_error");
     if(this.exists(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("EEXIST", "mkdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": File exists");
     var parent = /^(.*)\/[^/]+/.exec(name);
     parent = parent && parent[1] || "";
     if(! this.exists(parent))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOENT", "mkdir", this.nm(parent)));
      else
       caml_raise_sys_error(parent + ": No such file or directory");
     if(! this.is_dir(parent))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOTDIR", "mkdir", this.nm(parent)));
      else
       caml_raise_sys_error(parent + ": Not a directory");
     this.create_dir_if_needed(this.slash(name));
    };
   MlFakeDevice.prototype.rmdir =
    function(name, raise_unix){
     var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      name_slash = name == "" ? "" : this.slash(name),
      r = new RegExp("^" + name_slash + "([^/]+)");
     if(! this.exists(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOENT", "rmdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": No such file or directory");
     if(! this.is_dir(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOTDIR", "rmdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": Not a directory");
     for(var n in this.content)
      if(n.match(r))
       if(unix_error)
        caml_raise_with_args
         (unix_error, make_unix_err_args("ENOTEMPTY", "rmdir", this.nm(name)));
       else
        caml_raise_sys_error(this.nm(name) + ": Directory not empty");
     delete this.content[name_slash];
    };
   MlFakeDevice.prototype.readdir =
    function(name){
     var name_slash = name == "" ? "" : this.slash(name);
     if(! this.exists(name))
      caml_raise_sys_error(name + ": No such file or directory");
     if(! this.is_dir(name)) caml_raise_sys_error(name + ": Not a directory");
     var r = new RegExp("^" + name_slash + "([^/]+)"), seen = {}, a = [];
     for(var n in this.content){
      var m = n.match(r);
      if(m && ! seen[m[1]]){seen[m[1]] = true; a.push(m[1]);}
     }
     return a;
    };
   MlFakeDevice.prototype.opendir =
    function(name, raise_unix){
     var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      a = this.readdir(name),
      c = false,
      i = 0;
     return {readSync:
             function(){
              if(c)
               if(unix_error)
                caml_raise_with_args
                 (unix_error,
                  make_unix_err_args("EBADF", "closedir", this.nm(name)));
               else
                caml_raise_sys_error(name + ": closedir failed");
              if(i == a.length) return null;
              var entry = a[i];
              i++;
              return {name: entry};
             },
             closeSync:
             function(){
              if(c)
               if(unix_error)
                caml_raise_with_args
                 (unix_error,
                  make_unix_err_args("EBADF", "closedir", this.nm(name)));
               else
                caml_raise_sys_error(name + ": closedir failed");
              c = true;
              a = [];
             }};
    };
   MlFakeDevice.prototype.is_dir =
    function(name){
     if(name == "") return true;
     var name_slash = this.slash(name);
     return this.content[name_slash] ? 1 : 0;
    };
   MlFakeDevice.prototype.unlink =
    function(name){
     var ok = this.content[name] ? true : false;
     delete this.content[name];
     return ok;
    };
   MlFakeDevice.prototype.open =
    function(name, f){
     var file;
     if(f.rdonly && f.wronly)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_rdonly and Open_wronly are not compatible");
     if(f.text && f.binary)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_text and Open_binary are not compatible");
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_sys_error(this.nm(name) + " : is a directory");
      if(f.create && f.excl)
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      file = this.content[name];
      if(f.truncate) file.truncate();
     }
     else if(f.create){
      this.create_dir_if_needed(name);
      this.content[name] = new MlFakeFile(caml_create_bytes(0));
      file = this.content[name];
     }
     else
      caml_raise_no_such_file(this.nm(name));
     return new MlFakeFd(this.nm(name), file, f);
    };
   MlFakeDevice.prototype.open =
    function(name, f){
     var file;
     if(f.rdonly && f.wronly)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_rdonly and Open_wronly are not compatible");
     if(f.text && f.binary)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_text and Open_binary are not compatible");
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_sys_error(this.nm(name) + " : is a directory");
      if(f.create && f.excl)
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      file = this.content[name];
      if(f.truncate) file.truncate();
     }
     else if(f.create){
      this.create_dir_if_needed(name);
      this.content[name] = new MlFakeFile(caml_create_bytes(0));
      file = this.content[name];
     }
     else
      caml_raise_no_such_file(this.nm(name));
     return new MlFakeFd(this.nm(name), file, f);
    };
   MlFakeDevice.prototype.register =
    function(name, content){
     var file;
     if(this.content[name])
      caml_raise_sys_error(this.nm(name) + " : file already exists");
     if(caml_is_ml_bytes(content)) file = new MlFakeFile(content);
     if(caml_is_ml_string(content))
      file = new MlFakeFile(caml_bytes_of_string(content));
     else if(content instanceof Array)
      file = new MlFakeFile(caml_bytes_of_array(content));
     else if(typeof content === "string")
      file = new MlFakeFile(caml_bytes_of_jsbytes(content));
     else if(content.toString){
      var
       bytes =
         caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
      file = new MlFakeFile(bytes);
     }
     if(file){
      this.create_dir_if_needed(name);
      this.content[name] = file;
     }
     else
      caml_raise_sys_error
       (this.nm(name) + " : registering file with invalid content type");
    };
   MlFakeDevice.prototype.constructor = MlFakeDevice;
   function MlFakeFd_out(fd, flags){
    MlFakeFile.call(this, caml_create_bytes(0));
    this.log = function(s){return 0;};
    if(fd == 1 && typeof console.log == "function")
     this.log = console.log;
    else if(fd == 2 && typeof console.error == "function")
     this.log = console.error;
    else if(typeof console.log == "function") this.log = console.log;
    this.flags = flags;
   }
   MlFakeFd_out.prototype.length = function(){return 0;};
   MlFakeFd_out.prototype.write =
    function(offset, buf, pos, len){
     if(this.log){
      if
       (len > 0 && pos >= 0 && pos + len <= buf.length
        && buf[pos + len - 1] == 10)
       len--;
      var src = caml_create_bytes(len);
      caml_blit_bytes(caml_bytes_of_array(buf), pos, src, 0, len);
      this.log(src.toUtf16());
      return 0;
     }
     caml_raise_sys_error(this.fd + ": file descriptor already closed");
    };
   MlFakeFd_out.prototype.read =
    function(offset, buf, pos, len){
     caml_raise_sys_error(this.fd + ": file descriptor is write only");
    };
   MlFakeFd_out.prototype.close = function(){this.log = undefined;};
   var caml_int64_offset = Math.pow(2, - 24);
   function caml_raise_constant(tag){throw tag;}
   function caml_raise_zero_divide(){
    caml_raise_constant(caml_global_data.Division_by_zero);
   }
   function MlInt64(lo, mi, hi){
    this.lo = lo & 0xffffff;
    this.mi = mi & 0xffffff;
    this.hi = hi & 0xffff;
   }
   MlInt64.prototype.caml_custom = "_j";
   MlInt64.prototype.copy =
    function(){return new MlInt64(this.lo, this.mi, this.hi);};
   MlInt64.prototype.ucompare =
    function(x){
     if(this.hi > x.hi) return 1;
     if(this.hi < x.hi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.compare =
    function(x){
     var hi = this.hi << 16, xhi = x.hi << 16;
     if(hi > xhi) return 1;
     if(hi < xhi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.neg =
    function(){
     var
      lo = - this.lo,
      mi = - this.mi + (lo >> 24),
      hi = - this.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.add =
    function(x){
     var
      lo = this.lo + x.lo,
      mi = this.mi + x.mi + (lo >> 24),
      hi = this.hi + x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.sub =
    function(x){
     var
      lo = this.lo - x.lo,
      mi = this.mi - x.mi + (lo >> 24),
      hi = this.hi - x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.mul =
    function(x){
     var
      lo = this.lo * x.lo,
      mi = (lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
      hi =
        (mi * caml_int64_offset | 0) + this.hi * x.lo + this.mi * x.mi
        + this.lo * x.hi;
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.isZero =
    function(){return (this.lo | this.mi | this.hi) == 0;};
   MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0;};
   MlInt64.prototype.and =
    function(x){
     return new MlInt64(this.lo & x.lo, this.mi & x.mi, this.hi & x.hi);
    };
   MlInt64.prototype.or =
    function(x){
     return new MlInt64(this.lo | x.lo, this.mi | x.mi, this.hi | x.hi);
    };
   MlInt64.prototype.xor =
    function(x){
     return new MlInt64(this.lo ^ x.lo, this.mi ^ x.mi, this.hi ^ x.hi);
    };
   MlInt64.prototype.shift_left =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo << s,
               this.mi << s | this.lo >> 24 - s,
               this.hi << s | this.mi >> 24 - s);
     if(s < 48)
      return new
              MlInt64
              (0, this.lo << s - 24, this.mi << s - 24 | this.lo >> 48 - s);
     return new MlInt64(0, 0, this.lo << s - 48);
    };
   MlInt64.prototype.shift_right_unsigned =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | this.hi << 24 - s,
               this.hi >> s);
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s, this.hi >> s - 24, 0);
     return new MlInt64(this.hi >> s - 48, 0, 0);
    };
   MlInt64.prototype.shift_right =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     var h = this.hi << 16 >> 16;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | h << 24 - s,
               this.hi << 16 >> s >>> 16);
     var sign = this.hi << 16 >> 31;
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s,
               this.hi << 16 >> s - 24 >> 16,
               sign & 0xffff);
     return new MlInt64(this.hi << 16 >> s - 32, sign, sign);
    };
   MlInt64.prototype.lsl1 =
    function(){
     this.hi = this.hi << 1 | this.mi >> 23;
     this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
     this.lo = this.lo << 1 & 0xffffff;
    };
   MlInt64.prototype.lsr1 =
    function(){
     this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
     this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
     this.hi = this.hi >>> 1;
    };
   MlInt64.prototype.udivmod =
    function(x){
     var
      offset = 0,
      modulus = this.copy(),
      divisor = x.copy(),
      quotient = new MlInt64(0, 0, 0);
     while(modulus.ucompare(divisor) > 0){offset++; divisor.lsl1();}
     while(offset >= 0){
      offset--;
      quotient.lsl1();
      if(modulus.ucompare(divisor) >= 0){
       quotient.lo++;
       modulus = modulus.sub(divisor);
      }
      divisor.lsr1();
     }
     return {quotient: quotient, modulus: modulus};
    };
   MlInt64.prototype.div =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi ^ y.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var q = x.udivmod(y).quotient;
     if(sign & 0x8000) q = q.neg();
     return q;
    };
   MlInt64.prototype.mod =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var r = x.udivmod(y).modulus;
     if(sign & 0x8000) r = r.neg();
     return r;
    };
   MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24;};
   MlInt64.prototype.toFloat =
    function(){
     return (this.hi << 16) * Math.pow(2, 32) + this.mi * Math.pow(2, 24)
            + this.lo;
    };
   MlInt64.prototype.toArray =
    function(){
     return [this.hi >> 8,
             this.hi & 0xff,
             this.mi >> 16,
             this.mi >> 8 & 0xff,
             this.mi & 0xff,
             this.lo >> 16,
             this.lo >> 8 & 0xff,
             this.lo & 0xff];
    };
   MlInt64.prototype.lo32 =
    function(){return this.lo | (this.mi & 0xff) << 24;};
   MlInt64.prototype.hi32 =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16;};
   function MlMutex(){this.locked = false;}
   function MlNat(x){
    this.data = new Int32Array(x);
    this.length = this.data.length + 2;
   }
   MlNat.prototype.caml_custom = "_nat";
   function caml_ml_string_length(s){return s.length;}
   function caml_string_unsafe_get(s, i){return s.charCodeAt(i);}
   function caml_uint8_array_of_string(s){
    var l = caml_ml_string_length(s), a = new Uint8Array(l), i = 0;
    for(; i < l; i++) a[i] = caml_string_unsafe_get(s, i);
    return a;
   }
   function caml_bytes_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_bytes_unsafe_set(s, i, c){
    c &= 0xff;
    if(s.t != 4){
     if(i == s.c.length){
      s.c += String.fromCharCode(c);
      if(i + 1 == s.l) s.t = 0;
      return 0;
     }
     caml_convert_bytes_to_array(s);
    }
    s.c[i] = c;
    return 0;
   }
   function caml_bytes_set(s, i, c){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_set(s, i, c);
   }
   function MlNodeFd(fd, flags){
    this.fs = require("fs");
    this.fd = fd;
    this.flags = flags;
   }
   MlNodeFd.prototype = new MlFile();
   MlNodeFd.prototype.constructor = MlNodeFd;
   MlNodeFd.prototype.truncate =
    function(len){
     try{this.fs.ftruncateSync(this.fd, len | 0);}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.length =
    function(){
     try{return this.fs.fstatSync(this.fd).size;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.write =
    function(offset, buf, buf_offset, len){
     try{
      if(this.flags.isCharacterDevice)
       this.fs.writeSync(this.fd, buf, buf_offset, len);
      else
       this.fs.writeSync(this.fd, buf, buf_offset, len, offset);
     }
     catch(err){caml_raise_sys_error(err.toString());}
     return 0;
    };
   MlNodeFd.prototype.read =
    function(offset, a, buf_offset, len){
     try{
      if(this.flags.isCharacterDevice)
       var read = this.fs.readSync(this.fd, a, buf_offset, len);
      else
       var read = this.fs.readSync(this.fd, a, buf_offset, len, offset);
      return read;
     }
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.close =
    function(){
     try{this.fs.closeSync(this.fd); return 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   function MlNodeDevice(root){this.fs = require("fs"); this.root = root;}
   MlNodeDevice.prototype.nm = function(name){return this.root + name;};
   MlNodeDevice.prototype.exists =
    function(name){
     try{return this.fs.existsSync(this.nm(name)) ? 1 : 0;}
     catch(err){return 0;}
    };
   MlNodeDevice.prototype.isFile =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isFile() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     try{this.fs.mkdirSync(this.nm(name), {mode: mode}); return 0;}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.rmdir =
    function(name, raise_unix){
     try{this.fs.rmdirSync(this.nm(name)); return 0;}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readdir =
    function(name, raise_unix){
     try{return this.fs.readdirSync(this.nm(name));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.is_dir =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isDirectory() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.unlink =
    function(name, raise_unix){
     try{
      var b = this.fs.existsSync(this.nm(name)) ? 1 : 0;
      this.fs.unlinkSync(this.nm(name));
      return b;
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.open =
    function(name, f, raise_unix){
     var consts = require("constants"), res = 0;
     for(var key in f)
      switch(key){
        case "rdonly":
         res |= consts.O_RDONLY; break;
        case "wronly":
         res |= consts.O_WRONLY; break;
        case "append":
         res |= consts.O_WRONLY | consts.O_APPEND; break;
        case "create":
         res |= consts.O_CREAT; break;
        case "truncate":
         res |= consts.O_TRUNC; break;
        case "excl":
         res |= consts.O_EXCL; break;
        case "binary":
         res |= consts.O_BINARY; break;
        case "text":
         res |= consts.O_TEXT; break;
        case "nonblock":
         res |= consts.O_NONBLOCK; break;
      }
     try{
      var
       fd = this.fs.openSync(this.nm(name), res),
       isCharacterDevice =
         this.fs.lstatSync(this.nm(name)).isCharacterDevice();
      f.isCharacterDevice = isCharacterDevice;
      return new MlNodeFd(fd, f);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.rename =
    function(o, n, raise_unix){
     try{this.fs.renameSync(this.nm(o), this.nm(n));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.stat =
    function(name, raise_unix){
     try{
      var js_stats = this.fs.statSync(this.nm(name));
      return this.stats_from_js(js_stats);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.lstat =
    function(name, raise_unix){
     try{
      var js_stats = this.fs.lstatSync(this.nm(name));
      return this.stats_from_js(js_stats);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.symlink =
    function(to_dir, target, path, raise_unix){
     try{
      this.fs.symlinkSync
       (this.nm(target), this.nm(path), to_dir ? "dir" : "file");
      return 0;
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readlink =
    function(name, raise_unix){
     try{
      var link = this.fs.readlinkSync(this.nm(name), "utf8");
      return caml_string_of_jsstring(link);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.opendir =
    function(name, raise_unix){
     try{return this.fs.opendirSync(this.nm(name));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.raise_nodejs_error =
    function(err, raise_unix){
     var unix_error = caml_named_value("Unix.Unix_error");
     if(raise_unix && unix_error){
      var
       args = make_unix_err_args(err.code, err.syscall, err.path, err.errno);
      caml_raise_with_args(unix_error, args);
     }
     else
      caml_raise_sys_error(err.toString());
    };
   MlNodeDevice.prototype.stats_from_js =
    function(js_stats){
     var file_kind;
     if(js_stats.isFile())
      file_kind = 0;
     else if(js_stats.isDirectory())
      file_kind = 1;
     else if(js_stats.isCharacterDevice())
      file_kind = 2;
     else if(js_stats.isBlockDevice())
      file_kind = 3;
     else if(js_stats.isSymbolicLink())
      file_kind = 4;
     else if(js_stats.isFIFO())
      file_kind = 5;
     else if(js_stats.isSocket()) file_kind = 6;
     return [0,
             js_stats.dev,
             js_stats.ino,
             file_kind,
             js_stats.mode,
             js_stats.nlink,
             js_stats.uid,
             js_stats.gid,
             js_stats.rdev,
             js_stats.size,
             js_stats.atimeMs,
             js_stats.mtimeMs,
             js_stats.ctimeMs];
    };
   MlNodeDevice.prototype.constructor = MlNodeDevice;
   var MlObjectTable;
   if(typeof globalThis.Map === "undefined")
    MlObjectTable =
     function(){
       function NaiveLookup(objs){this.objs = objs;}
       NaiveLookup.prototype.get =
        function(v){
         for(var i = 0; i < this.objs.length; i++)
          if(this.objs[i] === v) return i;
        };
       NaiveLookup.prototype.set = function(){};
       return function(){
        this.objs = [];
        this.lookup = new NaiveLookup(this.objs);};
      }
      ();
   else
    MlObjectTable =
     function(){this.objs = []; this.lookup = new globalThis.Map();};
   MlObjectTable.prototype.store =
    function(v){this.lookup.set(v, this.objs.length); this.objs.push(v);};
   MlObjectTable.prototype.recall =
    function(v){
     var i = this.lookup.get(v);
     return i === undefined ? undefined : this.objs.length - i;
    };
   function MlStringReader(s, i){
    this.s = caml_jsbytes_of_string(s);
    this.i = i;
   }
   MlStringReader.prototype =
    {read8u: function(){return this.s.charCodeAt(this.i++);},
     read8s: function(){return this.s.charCodeAt(this.i++) << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1);
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1);
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
             | s.charCodeAt(i + 2) << 8
             | s.charCodeAt(i + 3))
             >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
             | s.charCodeAt(i + 2) << 8
             | s.charCodeAt(i + 3);
     },
     readstr:
     function(len){
      var i = this.i;
      this.i = i + len;
      return caml_string_of_jsbytes(this.s.substring(i, i + len));
     },
     readuint8array:
     function(len){
      var b = new Uint8Array(len), s = this.s, i = this.i;
      for(var j = 0; j < len; j++) b[j] = s.charCodeAt(i + j);
      this.i = i + len;
      return b;
     }};
   function caml_int64_create_lo_hi(lo, hi){
    return new
            MlInt64
            (lo & 0xffffff,
             lo >>> 24 & 0xff | (hi & 0xffff) << 8,
             hi >>> 16 & 0xffff);
   }
   function caml_int64_hi32(v){return v.hi32();}
   function caml_int64_lo32(v){return v.lo32();}
   function caml_array_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   var caml_ba_custom_name = "_bigarr02";
   function Ml_Bigarray(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
   Ml_Bigarray.prototype.offset =
    function(arg){
     var ofs = 0;
     if(typeof arg === "number") arg = [arg];
     if(! (arg instanceof Array))
      caml_invalid_argument("bigarray.js: invalid offset");
     if(this.dims.length != arg.length)
      caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
     if(this.layout == 0)
      for(var i = 0; i < this.dims.length; i++){
       if(arg[i] < 0 || arg[i] >= this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + arg[i];
      }
     else
      for(var i = this.dims.length - 1; i >= 0; i--){
       if(arg[i] < 1 || arg[i] > this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + (arg[i] - 1);
      }
     return ofs;
    };
   Ml_Bigarray.prototype.get =
    function(ofs){
     switch(this.kind){
       case 7:
        var l = this.data[ofs * 2 + 0], h = this.data[ofs * 2 + 1];
        return caml_int64_create_lo_hi(l, h);
       case 10:
       case 11:
        var r = this.data[ofs * 2 + 0], i = this.data[ofs * 2 + 1];
        return [254, r, i];
       default: return this.data[ofs];
     }
    };
   Ml_Bigarray.prototype.set =
    function(ofs, v){
     switch(this.kind){
       case 7:
        this.data[ofs * 2 + 0] = caml_int64_lo32(v);
        this.data[ofs * 2 + 1] = caml_int64_hi32(v);
        break;
       case 10:
       case 11:
        this.data[ofs * 2 + 0] = v[1]; this.data[ofs * 2 + 1] = v[2]; break;
       default: this.data[ofs] = v; break;
     }
     return 0;
    };
   Ml_Bigarray.prototype.fill =
    function(v){
     switch(this.kind){
       case 7:
        var a = caml_int64_lo32(v), b = caml_int64_hi32(v);
        if(a == b)
         this.data.fill(a);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 == 0 ? a : b;
        break;
       case 10:
       case 11:
        var im = v[1], re = v[2];
        if(im == re)
         this.data.fill(im);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 == 0 ? im : re;
        break;
       default: this.data.fill(v); break;
     }
    };
   Ml_Bigarray.prototype.compare =
    function(b, total){
     if(this.layout != b.layout || this.kind != b.kind){
      var k1 = this.kind | this.layout << 8, k2 = b.kind | b.layout << 8;
      return k2 - k1;
     }
     if(this.dims.length != b.dims.length)
      return b.dims.length - this.dims.length;
     for(var i = 0; i < this.dims.length; i++)
      if(this.dims[i] != b.dims[i]) return this.dims[i] < b.dims[i] ? - 1 : 1;
     switch(this.kind){
       case 0:
       case 1:
       case 10:
       case 11:
        var x, y;
        for(var i = 0; i < this.data.length; i++){
         x = this.data[i];
         y = b.data[i];
         if(x < y) return - 1;
         if(x > y) return 1;
         if(x != y){
          if(! total) return NaN;
          if(x == x) return 1;
          if(y == y) return - 1;
         }
        }
        break;
       case 7:
        for(var i = 0; i < this.data.length; i += 2){
         if(this.data[i + 1] < b.data[i + 1]) return - 1;
         if(this.data[i + 1] > b.data[i + 1]) return 1;
         if(this.data[i] >>> 0 < b.data[i] >>> 0) return - 1;
         if(this.data[i] >>> 0 > b.data[i] >>> 0) return 1;
        }
        break;
       case 2:
       case 3:
       case 4:
       case 5:
       case 6:
       case 8:
       case 9:
       case 12:
        for(var i = 0; i < this.data.length; i++){
         if(this.data[i] < b.data[i]) return - 1;
         if(this.data[i] > b.data[i]) return 1;
        }
        break;
     }
     return 0;
    };
   function Ml_Bigarray_c_1_1(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
   Ml_Bigarray_c_1_1.prototype.offset =
    function(arg){
     if(typeof arg !== "number")
      if(arg instanceof Array && arg.length == 1)
       arg = arg[0];
      else
       caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
     if(arg < 0 || arg >= this.dims[0]) caml_array_bound_error();
     return arg;
    };
   Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs];};
   Ml_Bigarray_c_1_1.prototype.set =
    function(ofs, v){this.data[ofs] = v; return 0;};
   Ml_Bigarray_c_1_1.prototype.fill =
    function(v){this.data.fill(v); return 0;};
   function UInt8ArrayReader(s, i){this.s = s; this.i = i;}
   UInt8ArrayReader.prototype =
    {read8u: function(){return this.s[this.i++];},
     read8s: function(){return this.s[this.i++] << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s[i] << 8 | s[i + 1];
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s[i] << 24 >> 16 | s[i + 1];
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3]) >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3];
     },
     readstr:
     function(len){
      var i = this.i;
      this.i = i + len;
      return caml_string_of_array(this.s.subarray(i, i + len));
     },
     readuint8array:
     function(len){
      var i = this.i;
      this.i = i + len;
      return this.s.subarray(i, i + len);
     }};
   function incr_nat(nat, ofs, len, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) + carry;
     nat.data[ofs + i] = x | 0;
     if(x == x >>> 0){carry = 0; break;} else carry = 1;
    }
    return carry;
   }
   function add_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
     nat1.data[ofs1 + i] = x;
     if(x == x >>> 0) carry = 0; else carry = 1;
    }
    return incr_nat(nat1, ofs1 + len2, len1 - len2, carry);
   }
   function caml_ba_get_size(dims){
    var n_dims = dims.length, size = 1;
    for(var i = 0; i < n_dims; i++){
     if(dims[i] < 0)
      caml_invalid_argument("Bigarray.create: negative dimension");
     size = size * dims[i];
    }
    return size;
   }
   function caml_ba_get_size_per_element(kind){
    switch(kind){case 7:case 10:case 11: return 2;default: return 1;
    }
   }
   function caml_ba_create_unsafe(kind, layout, dims, data){
    var size_per_element = caml_ba_get_size_per_element(kind);
    if(caml_ba_get_size(dims) * size_per_element != data.length)
     caml_invalid_argument("length doesn't match dims");
    if(layout == 0 && dims.length == 1 && size_per_element == 1)
     return new Ml_Bigarray_c_1_1(kind, layout, dims, data);
    return new Ml_Bigarray(kind, layout, dims, data);
   }
   function bigstring_of_array_buffer(ab){
    var ta = new Uint8Array(ab);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function bigstring_of_typed_array(ba){
    var
     ta =
       new
        Uint8Array
        (ba.buffer, ba.byteOffset, ba.length * ba.BYTES_PER_ELEMENT);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function bigstring_to_array_buffer(bs){return bs.data.buffer;}
   function bigstring_to_typed_array(bs){return bs.data;}
   function blit_nat(nat1, ofs1, nat2, ofs2, len){
    for(var i = 0; i < len; i++) nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
    return 0;
   }
   var
    caml_MD5Transform =
      function(){
        function add(x, y){return x + y | 0;}
        function xx(q, a, b, x, s, t){
         a = add(add(a, q), add(x, t));
         return add(a << s | a >>> 32 - s, b);
        }
        function ff(a, b, c, d, x, s, t){
         return xx(b & c | ~ b & d, a, b, x, s, t);
        }
        function gg(a, b, c, d, x, s, t){
         return xx(b & d | c & ~ d, a, b, x, s, t);
        }
        function hh(a, b, c, d, x, s, t){return xx(b ^ c ^ d, a, b, x, s, t);}
        function ii(a, b, c, d, x, s, t){
         return xx(c ^ (b | ~ d), a, b, x, s, t);
        }
        return function(w, buffer){
         var a = w[0], b = w[1], c = w[2], d = w[3];
         a = ff(a, b, c, d, buffer[0], 7, 0xD76AA478);
         d = ff(d, a, b, c, buffer[1], 12, 0xE8C7B756);
         c = ff(c, d, a, b, buffer[2], 17, 0x242070DB);
         b = ff(b, c, d, a, buffer[3], 22, 0xC1BDCEEE);
         a = ff(a, b, c, d, buffer[4], 7, 0xF57C0FAF);
         d = ff(d, a, b, c, buffer[5], 12, 0x4787C62A);
         c = ff(c, d, a, b, buffer[6], 17, 0xA8304613);
         b = ff(b, c, d, a, buffer[7], 22, 0xFD469501);
         a = ff(a, b, c, d, buffer[8], 7, 0x698098D8);
         d = ff(d, a, b, c, buffer[9], 12, 0x8B44F7AF);
         c = ff(c, d, a, b, buffer[10], 17, 0xFFFF5BB1);
         b = ff(b, c, d, a, buffer[11], 22, 0x895CD7BE);
         a = ff(a, b, c, d, buffer[12], 7, 0x6B901122);
         d = ff(d, a, b, c, buffer[13], 12, 0xFD987193);
         c = ff(c, d, a, b, buffer[14], 17, 0xA679438E);
         b = ff(b, c, d, a, buffer[15], 22, 0x49B40821);
         a = gg(a, b, c, d, buffer[1], 5, 0xF61E2562);
         d = gg(d, a, b, c, buffer[6], 9, 0xC040B340);
         c = gg(c, d, a, b, buffer[11], 14, 0x265E5A51);
         b = gg(b, c, d, a, buffer[0], 20, 0xE9B6C7AA);
         a = gg(a, b, c, d, buffer[5], 5, 0xD62F105D);
         d = gg(d, a, b, c, buffer[10], 9, 0x02441453);
         c = gg(c, d, a, b, buffer[15], 14, 0xD8A1E681);
         b = gg(b, c, d, a, buffer[4], 20, 0xE7D3FBC8);
         a = gg(a, b, c, d, buffer[9], 5, 0x21E1CDE6);
         d = gg(d, a, b, c, buffer[14], 9, 0xC33707D6);
         c = gg(c, d, a, b, buffer[3], 14, 0xF4D50D87);
         b = gg(b, c, d, a, buffer[8], 20, 0x455A14ED);
         a = gg(a, b, c, d, buffer[13], 5, 0xA9E3E905);
         d = gg(d, a, b, c, buffer[2], 9, 0xFCEFA3F8);
         c = gg(c, d, a, b, buffer[7], 14, 0x676F02D9);
         b = gg(b, c, d, a, buffer[12], 20, 0x8D2A4C8A);
         a = hh(a, b, c, d, buffer[5], 4, 0xFFFA3942);
         d = hh(d, a, b, c, buffer[8], 11, 0x8771F681);
         c = hh(c, d, a, b, buffer[11], 16, 0x6D9D6122);
         b = hh(b, c, d, a, buffer[14], 23, 0xFDE5380C);
         a = hh(a, b, c, d, buffer[1], 4, 0xA4BEEA44);
         d = hh(d, a, b, c, buffer[4], 11, 0x4BDECFA9);
         c = hh(c, d, a, b, buffer[7], 16, 0xF6BB4B60);
         b = hh(b, c, d, a, buffer[10], 23, 0xBEBFBC70);
         a = hh(a, b, c, d, buffer[13], 4, 0x289B7EC6);
         d = hh(d, a, b, c, buffer[0], 11, 0xEAA127FA);
         c = hh(c, d, a, b, buffer[3], 16, 0xD4EF3085);
         b = hh(b, c, d, a, buffer[6], 23, 0x04881D05);
         a = hh(a, b, c, d, buffer[9], 4, 0xD9D4D039);
         d = hh(d, a, b, c, buffer[12], 11, 0xE6DB99E5);
         c = hh(c, d, a, b, buffer[15], 16, 0x1FA27CF8);
         b = hh(b, c, d, a, buffer[2], 23, 0xC4AC5665);
         a = ii(a, b, c, d, buffer[0], 6, 0xF4292244);
         d = ii(d, a, b, c, buffer[7], 10, 0x432AFF97);
         c = ii(c, d, a, b, buffer[14], 15, 0xAB9423A7);
         b = ii(b, c, d, a, buffer[5], 21, 0xFC93A039);
         a = ii(a, b, c, d, buffer[12], 6, 0x655B59C3);
         d = ii(d, a, b, c, buffer[3], 10, 0x8F0CCC92);
         c = ii(c, d, a, b, buffer[10], 15, 0xFFEFF47D);
         b = ii(b, c, d, a, buffer[1], 21, 0x85845DD1);
         a = ii(a, b, c, d, buffer[8], 6, 0x6FA87E4F);
         d = ii(d, a, b, c, buffer[15], 10, 0xFE2CE6E0);
         c = ii(c, d, a, b, buffer[6], 15, 0xA3014314);
         b = ii(b, c, d, a, buffer[13], 21, 0x4E0811A1);
         a = ii(a, b, c, d, buffer[4], 6, 0xF7537E82);
         d = ii(d, a, b, c, buffer[11], 10, 0xBD3AF235);
         c = ii(c, d, a, b, buffer[2], 15, 0x2AD7D2BB);
         b = ii(b, c, d, a, buffer[9], 21, 0xEB86D391);
         w[0] = add(a, w[0]);
         w[1] = add(b, w[1]);
         w[2] = add(c, w[2]);
         w[3] = add(d, w[3]);};
       }
       ();
   function caml_MD5Final(ctx){
    var in_buf = ctx.len & 0x3f;
    ctx.b8[in_buf] = 0x80;
    in_buf++;
    if(in_buf > 56){
     for(var j = in_buf; j < 64; j++) ctx.b8[j] = 0;
     caml_MD5Transform(ctx.w, ctx.b32);
     for(var j = 0; j < 56; j++) ctx.b8[j] = 0;
    }
    else
     for(var j = in_buf; j < 56; j++) ctx.b8[j] = 0;
    ctx.b32[14] = ctx.len << 3;
    ctx.b32[15] = ctx.len >> 29 & 0x1FFFFFFF;
    caml_MD5Transform(ctx.w, ctx.b32);
    var t = new Uint8Array(16);
    for(var i = 0; i < 4; i++)
     for(var j = 0; j < 4; j++) t[i * 4 + j] = ctx.w[i] >> 8 * j & 0xFF;
    return t;
   }
   function caml_MD5Init(){
    var
     buffer = new ArrayBuffer(64),
     b32 = new Uint32Array(buffer),
     b8 = new Uint8Array(buffer);
    return {len: 0,
            w:
            new Uint32Array([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476]),
            b32: b32,
            b8: b8};
   }
   function caml_MD5Update(ctx, input, input_len){
    var in_buf = ctx.len & 0x3f, input_pos = 0;
    ctx.len += input_len;
    if(in_buf){
     var missing = 64 - in_buf;
     if(input_len < missing){
      ctx.b8.set(input.subarray(0, input_len), in_buf);
      return;
     }
     ctx.b8.set(input.subarray(0, missing), in_buf);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= missing;
     input_pos += missing;
    }
    while(input_len >= 64){
     ctx.b8.set(input.subarray(input_pos, input_pos + 64), 0);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= 64;
     input_pos += 64;
    }
    if(input_len)
     ctx.b8.set(input.subarray(input_pos, input_pos + input_len), 0);
   }
   function caml_acosh_float(x){return Math.acosh(x);}
   function caml_call_gen(f, args){
    var
     n = f.l >= 0 ? f.l : f.l = f.length,
     argsLen = args.length,
     d = n - argsLen;
    if(d == 0)
     return f.apply(null, args);
    else if(d < 0){
     var g = f.apply(null, args.slice(0, n));
     if(typeof g !== "function") return g;
     return caml_call_gen(g, args.slice(n));
    }
    else{
     switch(d){
       case 1:
        {
         var
          g =
            function(x){
             var nargs = new Array(argsLen + 1);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             return f.apply(null, nargs);
            };
         break;
        }
       case 2:
        {
         var
          g =
            function(x, y){
             var nargs = new Array(argsLen + 2);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             nargs[argsLen + 1] = y;
             return f.apply(null, nargs);
            };
         break;
        }
       default:
        var
         g =
           function(){
            var
             extra_args = arguments.length == 0 ? 1 : arguments.length,
             nargs = new Array(args.length + extra_args);
            for(var i = 0; i < args.length; i++) nargs[i] = args[i];
            for(var i = 0; i < arguments.length; i++)
             nargs[args.length + i] = arguments[i];
            return caml_call_gen(f, nargs);
           };
     }
     g.l = d;
     return g;
    }
   }
   function caml_alloc_dummy_infix(){
    return function f(x){return caml_call_gen(f.fun, [x]);};
   }
   function caml_alloc_stack(hv, hx, hf){return 0;}
   var
    caml_argv =
      function(){
        var process = globalThis.process, main = "a.out", args = [];
        if(process && process.argv && process.argv.length > 1){
         var argv = process.argv;
         main = argv[1];
         args = argv.slice(2);
        }
        var p = caml_string_of_jsstring(main), args2 = [0, p];
        for(var i = 0; i < args.length; i++)
         args2.push(caml_string_of_jsstring(args[i]));
        return args2;
       }
       ();
   function caml_array_append(a1, a2){
    var l1 = a1.length, l2 = a2.length, l = l1 + l2 - 1, a = new Array(l);
    a[0] = 0;
    var i = 1, j = 1;
    for(; i < l1; i++) a[i] = a1[i];
    for(; i < l; i++, j++) a[i] = a2[j];
    return a;
   }
   function caml_array_blit(a1, i1, a2, i2, len){
    if(i2 <= i1)
     for(var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];
    else
     for(var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];
    return 0;
   }
   function caml_array_concat(l){
    var a = [0];
    while(l !== 0){
     var b = l[1];
     for(var i = 1; i < b.length; i++) a.push(b[i]);
     l = l[2];
    }
    return a;
   }
   function caml_array_fill(array, ofs, len, v){
    for(var i = 0; i < len; i++) array[ofs + i + 1] = v;
    return 0;
   }
   function caml_array_get(array, index){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    return array[index + 1];
   }
   function caml_array_of_bytes(x){return caml_uint8_array_of_bytes(x);}
   function caml_array_of_string(x){return caml_uint8_array_of_string(x);}
   function caml_array_set(array, index, newval){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    array[index + 1] = newval;
    return 0;
   }
   function caml_array_sub(a, i, len){
    var a2 = new Array(len + 1);
    a2[0] = 0;
    for(var i2 = 1, i1 = i + 1; i2 <= len; i2++, i1++) a2[i2] = a[i1];
    return a2;
   }
   function caml_asinh_float(x){return Math.asinh(x);}
   function caml_atanh_float(x){return Math.atanh(x);}
   function caml_atomic_cas(ref, o, n){
    if(ref[1] === o){ref[1] = n; return 1;}
    return 0;
   }
   function caml_atomic_exchange(ref, v){
    var r = ref[1];
    ref[1] = v;
    return r;
   }
   function caml_atomic_fetch_add(ref, i){
    var old = ref[1];
    ref[1] += i;
    return old;
   }
   function caml_atomic_load(ref){return ref[1];}
   function caml_atomic_make_contended(a){return [0, a];}
   function caml_ba_blit(src, dst){
    if(dst.dims.length != src.dims.length)
     caml_invalid_argument("Bigarray.blit: dimension mismatch");
    for(var i = 0; i < dst.dims.length; i++)
     if(dst.dims[i] != src.dims[i])
      caml_invalid_argument("Bigarray.blit: dimension mismatch");
    dst.data.set(src.data);
    return 0;
   }
   function caml_ba_change_layout(ba, layout){
    if(ba.layout == layout) return ba;
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++)
     new_dims[i] = ba.dims[ba.dims.length - i - 1];
    return caml_ba_create_unsafe(ba.kind, layout, new_dims, ba.data);
   }
   function caml_ba_compare(a, b, total){return a.compare(b, total);}
   function caml_ba_create_buffer(kind, size){
    var view;
    switch(kind){
      case 0:
       view = Float32Array; break;
      case 1:
       view = Float64Array; break;
      case 2:
       view = Int8Array; break;
      case 3:
       view = Uint8Array; break;
      case 4:
       view = Int16Array; break;
      case 5:
       view = Uint16Array; break;
      case 6:
       view = Int32Array; break;
      case 7:
       view = Int32Array; break;
      case 8:
       view = Int32Array; break;
      case 9:
       view = Int32Array; break;
      case 10:
       view = Float32Array; break;
      case 11:
       view = Float64Array; break;
      case 12:
       view = Uint8Array; break;
    }
    if(! view) caml_invalid_argument("Bigarray.create: unsupported kind");
    var data = new view(size * caml_ba_get_size_per_element(kind));
    return data;
   }
   function caml_js_from_array(a){return a.slice(1);}
   function caml_ba_create(kind, layout, dims_ml){
    var
     dims = caml_js_from_array(dims_ml),
     data = caml_ba_create_buffer(kind, caml_ba_get_size(dims));
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_ba_create_from(data1, data2, jstyp, kind, layout, dims){
    if(data2 || caml_ba_get_size_per_element(kind) == 2)
     caml_invalid_argument
      ("caml_ba_create_from: use return caml_ba_create_unsafe");
    return caml_ba_create_unsafe(kind, layout, dims, data1);
   }
   function caml_int32_float_of_bits(x){
    var int32a = new Int32Array(1);
    int32a[0] = x;
    var float32a = new Float32Array(int32a.buffer);
    return float32a[0];
   }
   function caml_int64_of_bytes(a){
    return new
            MlInt64
            (a[7] << 0 | a[6] << 8 | a[5] << 16,
             a[4] << 0 | a[3] << 8 | a[2] << 16,
             a[1] << 0 | a[0] << 8);
   }
   function caml_int64_float_of_bits(x){
    var lo = x.lo, mi = x.mi, hi = x.hi, exp = (hi & 0x7fff) >> 4;
    if(exp == 2047)
     return (lo | mi | hi & 0xf) == 0
             ? hi & 0x8000 ? - Infinity : Infinity
             : NaN;
    var k = Math.pow(2, - 24), res = (lo * k + mi) * k + (hi & 0xf);
    if(exp > 0){
     res += 16;
     res *= Math.pow(2, exp - 1027);
    }
    else
     res *= Math.pow(2, - 1026);
    if(hi & 0x8000) res = - res;
    return res;
   }
   function caml_failwith(msg){
    if(! caml_global_data.Failure)
     caml_global_data.Failure = [248, caml_string_of_jsbytes("Failure"), - 3];
    caml_raise_with_string(caml_global_data.Failure, msg);
   }
   function caml_ba_deserialize(reader, sz, name){
    var num_dims = reader.read32s();
    if(num_dims < 0 || num_dims > 16)
     caml_failwith("input_value: wrong number of bigarray dimensions");
    var
     tag = reader.read32s(),
     kind = tag & 0xff,
     layout = tag >> 8 & 1,
     dims = [];
    if(name == "_bigarr02")
     for(var i = 0; i < num_dims; i++){
      var size_dim = reader.read16u();
      if(size_dim == 0xffff){
       var size_dim_hi = reader.read32u(), size_dim_lo = reader.read32u();
       if(size_dim_hi != 0)
        caml_failwith("input_value: bigarray dimension overflow in 32bit");
       size_dim = size_dim_lo;
      }
      dims.push(size_dim);
     }
    else
     for(var i = 0; i < num_dims; i++) dims.push(reader.read32u());
    var
     size = caml_ba_get_size(dims),
     data = caml_ba_create_buffer(kind, size),
     ba = caml_ba_create_unsafe(kind, layout, dims, data);
    switch(kind){
      case 2:
       for(var i = 0; i < size; i++) data[i] = reader.read8s(); break;
      case 3:
      case 12:
       for(var i = 0; i < size; i++) data[i] = reader.read8u(); break;
      case 4:
       for(var i = 0; i < size; i++) data[i] = reader.read16s(); break;
      case 5:
       for(var i = 0; i < size; i++) data[i] = reader.read16u(); break;
      case 6:
       for(var i = 0; i < size; i++) data[i] = reader.read32s(); break;
      case 8:
      case 9:
       var sixty = reader.read8u();
       if(sixty)
        caml_failwith
         ("input_value: cannot read bigarray with 64-bit OCaml ints");
       for(var i = 0; i < size; i++) data[i] = reader.read32s();
       break;
      case 7:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var int64 = caml_int64_of_bytes(t);
        ba.set(i, int64);
       }
       break;
      case 1:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var f = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, f);
       }
       break;
      case 0:
       for(var i = 0; i < size; i++){
        var f = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, f);
       }
       break;
      case 10:
       for(var i = 0; i < size; i++){
        var
         re = caml_int32_float_of_bits(reader.read32s()),
         im = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, [254, re, im]);
       }
       break;
      case 11:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var re = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var im = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, [254, re, im]);
       }
       break;
    }
    sz[0] = (4 + num_dims) * 4;
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_ba_dim(ba, i){
    if(i < 0 || i >= ba.dims.length) caml_invalid_argument("Bigarray.dim");
    return ba.dims[i];
   }
   function caml_ba_dim_1(ba){return caml_ba_dim(ba, 0);}
   function caml_ba_dim_2(ba){return caml_ba_dim(ba, 1);}
   function caml_ba_dim_3(ba){return caml_ba_dim(ba, 2);}
   function caml_ba_fill(ba, v){ba.fill(v); return 0;}
   function caml_ba_kind_of_typed_array(ta){
    var kind;
    if(ta instanceof Float32Array)
     kind = 0;
    else if(ta instanceof Float64Array)
     kind = 1;
    else if(ta instanceof Int8Array)
     kind = 2;
    else if(ta instanceof Uint8Array)
     kind = 3;
    else if(ta instanceof Uint8ClampedArray)
     kind = 3;
    else if(ta instanceof Int16Array)
     kind = 4;
    else if(ta instanceof Uint16Array)
     kind = 5;
    else if(ta instanceof Int32Array)
     kind = 6;
    else if(ta instanceof Uint32Array)
     kind = 6;
    else
     caml_invalid_argument("caml_ba_kind_of_typed_array: unsupported kind");
    return kind;
   }
   function caml_ba_from_typed_array(ta){
    var
     kind = caml_ba_kind_of_typed_array(ta),
     ta =
       ta instanceof Uint32Array
        ? new Int32Array(ta.buffer, ta.byteOffset, ta.length)
        : ta;
    return caml_ba_create_unsafe(kind, 0, [ta.length], ta);
   }
   function caml_ba_get_2(ba, i0, i1){return ba.get(ba.offset([i0, i1]));}
   function caml_ba_get_3(ba, i0, i1, i2){
    return ba.get(ba.offset([i0, i1, i2]));
   }
   function caml_ba_get_generic(ba, i){
    var ofs = ba.offset(caml_js_from_array(i));
    return ba.get(ofs);
   }
   function caml_mul(a, b){return Math.imul(a, b);}
   function caml_hash_mix_int(h, d){
    d = caml_mul(d, 0xcc9e2d51 | 0);
    d = d << 15 | d >>> 32 - 15;
    d = caml_mul(d, 0x1b873593);
    h ^= d;
    h = h << 13 | h >>> 32 - 13;
    return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0;
   }
   var log2_ok = Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
   function jsoo_floor_log2(x){
    if(log2_ok) return Math.floor(Math.log2(x));
    var i = 0;
    if(x == 0) return - Infinity;
    if(x >= 1) while(x >= 2){x /= 2; i++;} else while(x < 1){x *= 2; i--;}
    return i;
   }
   function caml_int64_create_lo_mi_hi(lo, mi, hi){return new MlInt64(lo, mi, hi);
   }
   function caml_int64_bits_of_float(x){
    if(! isFinite(x)){
     if(isNaN(x)) return caml_int64_create_lo_mi_hi(1, 0, 0x7ff0);
     return x > 0
             ? caml_int64_create_lo_mi_hi(0, 0, 0x7ff0)
             : caml_int64_create_lo_mi_hi(0, 0, 0xfff0);
    }
    var sign = x == 0 && 1 / x == - Infinity ? 0x8000 : x >= 0 ? 0 : 0x8000;
    if(sign) x = - x;
    var exp = jsoo_floor_log2(x) + 1023;
    if(exp <= 0){
     exp = 0;
     x /= Math.pow(2, - 1026);
    }
    else{
     x /= Math.pow(2, exp - 1027);
     if(x < 16){x *= 2; exp -= 1;}
     if(exp == 0) x /= 2;
    }
    var k = Math.pow(2, 24), r3 = x | 0;
    x = (x - r3) * k;
    var r2 = x | 0;
    x = (x - r2) * k;
    var r1 = x | 0;
    r3 = r3 & 0xf | sign | exp << 4;
    return caml_int64_create_lo_mi_hi(r1, r2, r3);
   }
   function caml_hash_mix_int64(h, v){
    h = caml_hash_mix_int(h, caml_int64_lo32(v));
    h = caml_hash_mix_int(h, caml_int64_hi32(v));
    return h;
   }
   function caml_hash_mix_float(h, v0){
    return caml_hash_mix_int64(h, caml_int64_bits_of_float(v0));
   }
   function caml_ba_hash(ba){
    var num_elts = caml_ba_get_size(ba.dims), h = 0;
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       if(num_elts > 256) num_elts = 256;
       var w = 0, i = 0;
       for(i = 0; i + 4 <= ba.data.length; i += 4){
        w =
         ba.data[i + 0] | ba.data[i + 1] << 8 | ba.data[i + 2] << 16
         | ba.data[i + 3] << 24;
        h = caml_hash_mix_int(h, w);
       }
       w = 0;
       switch(num_elts & 3){
         case 3:
          w = ba.data[i + 2] << 16;
         case 2:
          w |= ba.data[i + 1] << 8;
         case 1:
          w |= ba.data[i + 0]; h = caml_hash_mix_int(h, w);
       }
       break;
      case 4:
      case 5:
       if(num_elts > 128) num_elts = 128;
       var w = 0, i = 0;
       for(i = 0; i + 2 <= ba.data.length; i += 2){
        w = ba.data[i + 0] | ba.data[i + 1] << 16;
        h = caml_hash_mix_int(h, w);
       }
       if((num_elts & 1) != 0) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 6:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 8:
      case 9:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 7:
       if(num_elts > 32) num_elts = 32;
       num_elts *= 2;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 10:
       num_elts *= 2;
      case 0:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
      case 11:
       num_elts *= 2;
      case 1:
       if(num_elts > 32) num_elts = 32;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
    }
    return h;
   }
   function caml_ba_init(){return 0;}
   function caml_ba_kind(ba){return ba.kind;}
   function caml_ba_layout(ba){return ba.layout;}
   function caml_ba_map_file(vfd, kind, layout, shared, dims, pos){caml_failwith("caml_ba_map_file not implemented");
   }
   function caml_ba_map_file_bytecode(argv, argn){
    return caml_ba_map_file
            (argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
   }
   function caml_ba_num_dims(ba){return ba.dims.length;}
   function caml_ba_reshape(ba, vind){
    vind = caml_js_from_array(vind);
    var new_dim = [], num_dims = vind.length;
    if(num_dims < 0 || num_dims > 16)
     caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
    var num_elts = 1;
    for(var i = 0; i < num_dims; i++){
     new_dim[i] = vind[i];
     if(new_dim[i] < 0)
      caml_invalid_argument("Bigarray.reshape: negative dimension");
     num_elts = num_elts * new_dim[i];
    }
    var size = caml_ba_get_size(ba.dims);
    if(num_elts != size)
     caml_invalid_argument("Bigarray.reshape: size mismatch");
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dim, ba.data);
   }
   function caml_int32_bits_of_float(x){
    var float32a = new Float32Array(1);
    float32a[0] = x;
    var int32a = new Int32Array(float32a.buffer);
    return int32a[0] | 0;
   }
   function caml_int64_to_bytes(x){return x.toArray();}
   function caml_ba_serialize(writer, ba, sz){
    writer.write(32, ba.dims.length);
    writer.write(32, ba.kind | ba.layout << 8);
    if(ba.caml_custom == "_bigarr02")
     for(var i = 0; i < ba.dims.length; i++)
      if(ba.dims[i] < 0xffff)
       writer.write(16, ba.dims[i]);
      else{
       writer.write(16, 0xffff);
       writer.write(32, 0);
       writer.write(32, ba.dims[i]);
      }
    else
     for(var i = 0; i < ba.dims.length; i++) writer.write(32, ba.dims[i]);
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       for(var i = 0; i < ba.data.length; i++) writer.write(8, ba.data[i]);
       break;
      case 4:
      case 5:
       for(var i = 0; i < ba.data.length; i++) writer.write(16, ba.data[i]);
       break;
      case 6:
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 8:
      case 9:
       writer.write(8, 0);
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 7:
       for(var i = 0; i < ba.data.length / 2; i++){
        var b = caml_int64_to_bytes(ba.get(i));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 1:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 0:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int32_bits_of_float(ba.get(i));
        writer.write(32, b);
       }
       break;
      case 10:
       for(var i = 0; i < ba.data.length / 2; i++){
        var j = ba.get(i);
        writer.write(32, caml_int32_bits_of_float(j[1]));
        writer.write(32, caml_int32_bits_of_float(j[2]));
       }
       break;
      case 11:
       for(var i = 0; i < ba.data.length / 2; i++){
        var
         complex = ba.get(i),
         b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
    }
    sz[0] = (4 + ba.dims.length) * 4;
    sz[1] = (4 + ba.dims.length) * 8;
   }
   function caml_ba_set_1(ba, i0, v){ba.set(ba.offset(i0), v); return 0;}
   function caml_ba_set_2(ba, i0, i1, v){
    ba.set(ba.offset([i0, i1]), v);
    return 0;
   }
   function caml_ba_set_3(ba, i0, i1, i2, v){
    ba.set(ba.offset([i0, i1, i2]), v);
    return 0;
   }
   function caml_ba_set_generic(ba, i, v){
    ba.set(ba.offset(caml_js_from_array(i)), v);
    return 0;
   }
   function caml_ba_slice(ba, vind){
    vind = caml_js_from_array(vind);
    var num_inds = vind.length, index = [], sub_dims = [], ofs;
    if(num_inds > ba.dims.length)
     caml_invalid_argument("Bigarray.slice: too many indices");
    if(ba.layout == 0){
     for(var i = 0; i < num_inds; i++) index[i] = vind[i];
     for(; i < ba.dims.length; i++) index[i] = 0;
     sub_dims = ba.dims.slice(num_inds);
    }
    else{
     for(var i = 0; i < num_inds; i++)
      index[ba.dims.length - num_inds + i] = vind[i];
     for(var i = 0; i < ba.dims.length - num_inds; i++) index[i] = 1;
     sub_dims = ba.dims.slice(0, ba.dims.length - num_inds);
    }
    ofs = ba.offset(index);
    var
     size = caml_ba_get_size(sub_dims),
     size_per_element = caml_ba_get_size_per_element(ba.kind),
     new_data =
       ba.data.subarray
        (ofs * size_per_element, (ofs + size) * size_per_element);
    return caml_ba_create_unsafe(ba.kind, ba.layout, sub_dims, new_data);
   }
   function caml_ba_sub(ba, ofs, len){
    var changed_dim, mul = 1;
    if(ba.layout == 0){
     for(var i = 1; i < ba.dims.length; i++) mul = mul * ba.dims[i];
     changed_dim = 0;
    }
    else{
     for(var i = 0; i < ba.dims.length - 1; i++) mul = mul * ba.dims[i];
     changed_dim = ba.dims.length - 1;
     ofs = ofs - 1;
    }
    if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
     caml_invalid_argument("Bigarray.sub: bad sub-array");
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++) new_dims[i] = ba.dims[i];
    new_dims[changed_dim] = len;
    mul *= caml_ba_get_size_per_element(ba.kind);
    var new_data = ba.data.subarray(ofs * mul, (ofs + len) * mul);
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dims, new_data);
   }
   function caml_ba_to_typed_array(ba){return ba.data;}
   function caml_ba_uint8_get16(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    var b1 = ba.get(ofs), b2 = ba.get(ofs + 1);
    return b1 | b2 << 8;
   }
   function caml_ba_uint8_get32(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3);
    return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24;
   }
   function caml_ba_uint8_get64(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3),
     b5 = ba.get(ofs + 4),
     b6 = ba.get(ofs + 5),
     b7 = ba.get(ofs + 6),
     b8 = ba.get(ofs + 7);
    return caml_int64_of_bytes([b8, b7, b6, b5, b4, b3, b2, b1]);
   }
   function caml_ba_uint8_set16(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    return 0;
   }
   function caml_ba_uint8_set32(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    ba.set(ofs + 2, v >>> 16 & 0xff);
    ba.set(ofs + 3, v >>> 24 & 0xff);
    return 0;
   }
   function caml_ba_uint8_set64(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var v = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) ba.set(ofs + i, v[7 - i]);
    return 0;
   }
   function caml_backtrace_status(_unit){
    return caml_record_backtrace_flag ? 1 : 0;
   }
   function caml_bigstring_blit_ba_to_ba(ba1, pos1, ba2, pos2, len){
    if(12 != ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs1 = ba1.offset(pos1), ofs2 = ba2.offset(pos2);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = ba1.data.subarray(ofs1, ofs1 + len);
    ba2.data.set(slice, pos2);
    return 0;
   }
   function caml_bigstring_blit_ba_to_bytes(ba1, pos1, bytes2, pos2, len){
    if(12 != ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs1 = ba1.offset(pos1);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(pos2 + len > caml_ml_bytes_length(bytes2)) caml_array_bound_error();
    var slice = ba1.data.slice(ofs1, ofs1 + len);
    caml_blit_bytes(caml_bytes_of_array(slice), 0, bytes2, pos2, len);
    return 0;
   }
   function caml_bigstring_blit_bytes_to_ba(str1, pos1, ba2, pos2, len){
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_bytes_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_bytes(str1).slice(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   function caml_bigstring_blit_string_to_ba(str1, pos1, ba2, pos2, len){
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_string_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_string(str1).slice(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   function caml_bigstring_memcmp(s1, pos1, s2, pos2, len){
    for(var i = 0; i < len; i++){
     var a = caml_ba_get_1(s1, pos1 + i), b = caml_ba_get_1(s2, pos2 + i);
     if(a < b) return - 1;
     if(a > b) return 1;
    }
    return 0;
   }
   function caml_blit_string(a, b, c, d, e){
    caml_blit_bytes(caml_bytes_of_string(a), b, c, d, e);
    return 0;
   }
   function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8;}
   function caml_jsstring_of_string(s){
    if(jsoo_is_ascii(s)) return s;
    return caml_utf16_of_utf8(s);
   }
   function caml_build_symbols(symb){
    var r = {};
    if(symb)
     for(var i = 1; i < symb.length; i++)
      r[caml_jsstring_of_string(symb[i][1])] = symb[i][2];
    return r;
   }
   function caml_bytes_compare(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? - 1 : s1.c > s2.c ? 1 : 0;
   }
   function caml_bytes_equal(s1, s2){
    if(s1 === s2) return 1;
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c == s2.c ? 1 : 0;
   }
   function caml_bytes_unsafe_get(s, i){
    switch(s.t & 6){
      default: if(i >= s.c.length) return 0;
      case 0:
       return s.c.charCodeAt(i);
      case 4:
       return s.c[i];
    }
   }
   function caml_bytes_get(s, i){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_get(s, i);
   }
   function caml_bytes_get16(s, i){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function caml_bytes_get32(s, i){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1),
     b3 = caml_bytes_unsafe_get(s, i + 2),
     b4 = caml_bytes_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_bytes_get64(s, i){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_bytes_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   function caml_bytes_lessequal(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c <= s2.c ? 1 : 0;
   }
   function caml_bytes_greaterequal(s1, s2){return caml_bytes_lessequal(s2, s1);
   }
   function caml_bytes_lessthan(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? 1 : 0;
   }
   function caml_bytes_greaterthan(s1, s2){return caml_bytes_lessthan(s2, s1);
   }
   function caml_bytes_notequal(s1, s2){return 1 - caml_bytes_equal(s1, s2);}
   function caml_bytes_of_utf16_jsstring(s){
    var tag = 9;
    if(! jsoo_is_ascii(s)) tag = 8, s = caml_utf8_of_utf16(s);
    return new MlBytes(tag, s, s.length);
   }
   function caml_bytes_set16(s, i, i16){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var b2 = 0xFF & i16 >> 8, b1 = 0xFF & i16;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    return 0;
   }
   function caml_bytes_set32(s, i, i32){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b4 = 0xFF & i32 >> 24,
     b3 = 0xFF & i32 >> 16,
     b2 = 0xFF & i32 >> 8,
     b1 = 0xFF & i32;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    caml_bytes_unsafe_set(s, i + 2, b3);
    caml_bytes_unsafe_set(s, i + 3, b4);
    return 0;
   }
   function caml_bytes_set64(s, i, i64){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = caml_int64_to_bytes(i64);
    for(var j = 0; j < 8; j++) caml_bytes_unsafe_set(s, i + 7 - j, a[j]);
    return 0;
   }
   var caml_callback = caml_call_gen;
   function caml_cbrt_float(x){return Math.cbrt(x);}
   var caml_ml_channels = new Array();
   function caml_ml_channel_get(id){return caml_ml_channels[id];}
   function caml_channel_descriptor(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.fd;
   }
   function caml_check_bound(array, index){
    if(index >>> 0 >= array.length - 1) caml_array_bound_error();
    return array;
   }
   function caml_classify_float(x){
    if(isFinite(x)){
     if(Math.abs(x) >= 2.2250738585072014e-308) return 0;
     if(x != 0) return 1;
     return 2;
    }
    return isNaN(x) ? 4 : 3;
   }
   function caml_is_continuation_tag(t){return 0;}
   function caml_int32_unmarshal(reader, size){size[0] = 4; return reader.read32s();
   }
   function caml_nativeint_unmarshal(reader, size){
    switch(reader.read8u()){
      case 1:
       size[0] = 4; return reader.read32s();
      case 2:
       caml_failwith("input_value: native integer value too large");
      default: caml_failwith("input_value: ill-formed native integer");
    }
   }
   function caml_int64_unmarshal(reader, size){
    var t = new Array(8);
    for(var j = 0; j < 8; j++) t[j] = reader.read8u();
    size[0] = 8;
    return caml_int64_of_bytes(t);
   }
   function caml_int64_marshal(writer, v, sizes){
    var b = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) writer.write(8, b[i]);
    sizes[0] = 8;
    sizes[1] = 8;
   }
   function caml_int64_compare(x, y, total){return x.compare(y);}
   function caml_int64_hash(v){return v.lo32() ^ v.hi32();}
   var
    caml_custom_ops =
      {"_j":
       {deserialize: caml_int64_unmarshal,
        serialize: caml_int64_marshal,
        fixed_length: 8,
        compare: caml_int64_compare,
        hash: caml_int64_hash},
       "_i": {deserialize: caml_int32_unmarshal, fixed_length: 4},
       "_n": {deserialize: caml_nativeint_unmarshal, fixed_length: 4},
       "_bigarray":
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarray");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarr02");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash}};
   function caml_compare_val_get_custom(a){
    return caml_custom_ops[a.caml_custom]
           && caml_custom_ops[a.caml_custom].compare;
   }
   function caml_compare_val_number_custom(num, custom, swap, total){
    var comp = caml_compare_val_get_custom(custom);
    if(comp){
     var x = swap > 0 ? comp(custom, num, total) : comp(num, custom, total);
     if(total && x != x) return swap;
     if(+ x != + x) return + x;
     if((x | 0) != 0) return x | 0;
    }
    return swap;
   }
   function caml_compare_val_tag(a){
    if(typeof a === "number")
     return 1000;
    else if(caml_is_ml_bytes(a))
     return 252;
    else if(caml_is_ml_string(a))
     return 1252;
    else if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255){var tag = a[0] | 0; return tag == 254 ? 0 : tag;}
    else if(a instanceof String)
     return 12520;
    else if(typeof a == "string")
     return 12520;
    else if(a instanceof Number)
     return 1000;
    else if(a && a.caml_custom)
     return 1255;
    else if(a && a.compare)
     return 1256;
    else if(typeof a == "function")
     return 1247;
    else if(typeof a == "symbol") return 1251;
    return 1001;
   }
   function caml_int_compare(a, b){
    if(a < b) return - 1;
    if(a == b) return 0;
    return 1;
   }
   function caml_string_compare(s1, s2){
    return s1 < s2 ? - 1 : s1 > s2 ? 1 : 0;
   }
   function caml_compare_val(a, b, total){
    var stack = [];
    for(;;){
     if(! (total && a === b)){
      var tag_a = caml_compare_val_tag(a);
      if(tag_a == 250){a = a[1]; continue;}
      var tag_b = caml_compare_val_tag(b);
      if(tag_b == 250){b = b[1]; continue;}
      if(tag_a !== tag_b){
       if(tag_a == 1000){
        if(tag_b == 1255)
         return caml_compare_val_number_custom(a, b, - 1, total);
        return - 1;
       }
       if(tag_b == 1000){
        if(tag_a == 1255)
         return caml_compare_val_number_custom(b, a, 1, total);
        return 1;
       }
       return tag_a < tag_b ? - 1 : 1;
      }
      switch(tag_a){
        case 247:
         caml_invalid_argument("compare: functional value"); break;
        case 248:
         var x = caml_int_compare(a[2], b[2]); if(x != 0) return x | 0; break;
        case 249:
         caml_invalid_argument("compare: functional value"); break;
        case 250:
         caml_invalid_argument("equal: got Forward_tag, should not happen");
         break;
        case 251:
         caml_invalid_argument("equal: abstract value"); break;
        case 252:
         if(a !== b){
          var x = caml_bytes_compare(a, b);
          if(x != 0) return x | 0;
         }
         break;
        case 253:
         caml_invalid_argument("equal: got Double_tag, should not happen");
         break;
        case 254:
         caml_invalid_argument
          ("equal: got Double_array_tag, should not happen");
         break;
        case 255:
         caml_invalid_argument("equal: got Custom_tag, should not happen");
         break;
        case 1247:
         caml_invalid_argument("compare: functional value"); break;
        case 1255:
         var comp = caml_compare_val_get_custom(a);
         if(comp != caml_compare_val_get_custom(b))
          return a.caml_custom < b.caml_custom ? - 1 : 1;
         if(! comp) caml_invalid_argument("compare: abstract value");
         var x = comp(a, b, total);
         if(x != x) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x != 0) return x | 0;
         break;
        case 1256:
         var x = a.compare(b, total);
         if(x != x) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x != 0) return x | 0;
         break;
        case 1000:
         a = + a;
         b = + b;
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a != b){
          if(! total) return NaN;
          if(a == a) return 1;
          if(b == b) return - 1;
         }
         break;
        case 1001:
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a != b){
          if(! total) return NaN;
          if(a == a) return 1;
          if(b == b) return - 1;
         }
         break;
        case 1251:
         if(a !== b){if(! total) return NaN; return 1;} break;
        case 1252:
         var a = caml_jsbytes_of_string(a), b = caml_jsbytes_of_string(b);
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        case 12520:
         var a = a.toString(), b = b.toString();
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        case 246:
        case 254:
        default:
         if(caml_is_continuation_tag(tag_a)){
          caml_invalid_argument("compare: continuation value");
          break;
         }
         if(a.length != b.length) return a.length < b.length ? - 1 : 1;
         if(a.length > 1) stack.push(a, b, 1);
         break;
      }
     }
     if(stack.length == 0) return 0;
     var i = stack.pop();
     b = stack.pop();
     a = stack.pop();
     if(i + 1 < a.length) stack.push(a, b, i + 1);
     a = a[i];
     b = b[i];
    }
   }
   function caml_compare(a, b){return caml_compare_val(a, b, true);}
   function caml_continuation_use_noexc(cont){
    var stack = cont[1];
    cont[1] = 0;
    return stack;
   }
   function caml_continuation_use_and_update_handler_noexc
   (cont, hval, hexn, heff){
    var stack = caml_continuation_use_noexc(cont);
    stack[3] = [0, hval, hexn, heff];
    return stack;
   }
   function caml_convert_raw_backtrace(){return [0];}
   function caml_convert_raw_backtrace_slot(){
    caml_failwith("caml_convert_raw_backtrace_slot");
   }
   function caml_copysign_float(x, y){
    if(y == 0) y = 1 / y;
    x = Math.abs(x);
    return y < 0 ? - x : x;
   }
   function caml_cosh_float(x){return Math.cosh(x);}
   function fs_node_supported(){
    return typeof globalThis.process !== "undefined"
           && typeof globalThis.process.versions !== "undefined"
           && typeof globalThis.process.versions.node !== "undefined";
   }
   function make_path_is_absolute(){
    function posix(path){
     if(path.charAt(0) === "/") return ["", path.substring(1)];
     return;
    }
    function win32(path){
     var
      splitDeviceRe =
        /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
      result = splitDeviceRe.exec(path),
      device = result[1] || "",
      isUnc = Boolean(device && device.charAt(1) !== ":");
     if(Boolean(result[2] || isUnc)){
      var root = result[1] || "", sep = result[2] || "";
      return [root, path.substring(root.length + sep.length)];
     }
     return;
    }
    return fs_node_supported() && globalThis.process
            && globalThis.process.platform
            ? globalThis.process.platform === "win32" ? win32 : posix
            : posix;
   }
   var path_is_absolute = make_path_is_absolute();
   function caml_trailing_slash(name){
    return name.slice(- 1) !== "/" ? name + "/" : name;
   }
   if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
    var caml_current_dir = globalThis.process.cwd().replace(/\\/g, "/");
   else
    var caml_current_dir = "/static";
   caml_current_dir = caml_trailing_slash(caml_current_dir);
   function caml_make_path(name){
    name = caml_jsstring_of_string(name);
    if(! path_is_absolute(name)) name = caml_current_dir + name;
    var
     comp0 = path_is_absolute(name),
     comp = comp0[1].split("/"),
     ncomp = [];
    for(var i = 0; i < comp.length; i++)
     switch(comp[i]){
       case "..":
        if(ncomp.length > 1) ncomp.pop(); break;
       case ".": break;
       case "": break;
       default: ncomp.push(comp[i]); break;
     }
    ncomp.unshift(comp0[0]);
    ncomp.orig = name;
    return ncomp;
   }
   function caml_get_root(path){
    var x = path_is_absolute(path);
    if(! x) return;
    return x[0] + "/";
   }
   var
    caml_root =
      caml_get_root(caml_current_dir)
      || caml_failwith("unable to compute caml_root"),
    jsoo_mount_point = [];
   if(fs_node_supported())
    jsoo_mount_point.push
     ({path: caml_root, device: new MlNodeDevice(caml_root)});
   else
    jsoo_mount_point.push
     ({path: caml_root, device: new MlFakeDevice(caml_root)});
   jsoo_mount_point.push
    ({path: "/static/", device: new MlFakeDevice("/static/")});
   function resolve_fs_device(name){
    var
     path = caml_make_path(name),
     name = path.join("/"),
     name_slash = caml_trailing_slash(name),
     res;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var m = jsoo_mount_point[i];
     if
      (name_slash.search(m.path) == 0
       && (! res || res.path.length < m.path.length))
      res =
       {path: m.path,
        device: m.device,
        rest: name.substring(m.path.length, name.length)};
    }
    if(! res && fs_node_supported()){
     var root = caml_get_root(name);
     if(root && root.match(/^[a-zA-Z]:\/$/)){
      var m = {path: root, device: new MlNodeDevice(root)};
      jsoo_mount_point.push(m);
      res =
       {path: m.path,
        device: m.device,
        rest: name.substring(m.path.length, name.length)};
     }
    }
    if(res) return res;
    caml_raise_sys_error("no device found for " + name_slash);
   }
   function caml_create_file(name, content){
    var root = resolve_fs_device(name);
    if(! root.device.register) caml_failwith("cannot register file");
    root.device.register(root.rest, content);
    return 0;
   }
   function caml_create_string(len){caml_invalid_argument("String.create");}
   var caml_custom_event_index = 0, caml_decompress_input = null;
   function caml_div(x, y){
    if(y == 0) caml_raise_zero_divide();
    return x / y | 0;
   }
   var caml_domain_dls = [0];
   function caml_domain_dls_get(unit){return caml_domain_dls;}
   function caml_domain_dls_set(a){caml_domain_dls = a;}
   var caml_domain_id = 0;
   function caml_ml_mutex_unlock(t){t.locked = false; return 0;}
   var caml_domain_latest_idx = 1;
   function caml_domain_spawn(f, mutex){
    var id = caml_domain_latest_idx++, old = caml_domain_id;
    caml_domain_id = id;
    var res = caml_callback(f, [0]);
    caml_domain_id = old;
    caml_ml_mutex_unlock(mutex);
    return id;
   }
   var caml_ephe_data_offset = 2, caml_ephe_key_offset = 3;
   function caml_ephe_unset_data(x){
    if(globalThis.FinalizationRegistry && globalThis.WeakRef)
     if(x[1] instanceof globalThis.FinalizationRegistry)
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key) x[1].unregister(key);
       }
      }
    x[caml_ephe_data_offset] = undefined;
    return 0;
   }
   function caml_ephe_set_data(x, data){
    if(globalThis.FinalizationRegistry && globalThis.WeakRef)
     if(! (x[1] instanceof globalThis.FinalizationRegistry)){
      x[1] =
       new
        globalThis.FinalizationRegistry
        (function(){caml_ephe_unset_data(x);});
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key) x[1].register(key, undefined, key);
       }
      }
     }
    x[caml_ephe_data_offset] = data;
    return 0;
   }
   function caml_ephe_blit_data(src, dst){
    var n = src[caml_ephe_data_offset];
    if(n === undefined)
     caml_ephe_unset_data(dst);
    else
     caml_ephe_set_data(dst, n);
    return 0;
   }
   function caml_ephe_blit_key(a1, i1, a2, i2, len){
    caml_array_blit
     (a1,
      caml_ephe_key_offset + i1 - 1,
      a2,
      caml_ephe_key_offset + i2 - 1,
      len);
    return 0;
   }
   function caml_ephe_check_data(x){
    return x[caml_ephe_data_offset] === undefined ? 0 : 1;
   }
   function caml_ephe_check_key(x, i){
    var weak = x[caml_ephe_key_offset + i];
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
     weak = weak.deref();
    return weak === undefined ? 0 : 1;
   }
   function caml_weak_create(n){
    if(n < 0) caml_invalid_argument("Weak.create");
    var x = [251, "caml_ephe_list_head"];
    x.length = caml_ephe_key_offset + n;
    return x;
   }
   function caml_ephe_create(n){var x = caml_weak_create(n); return x;}
   function caml_ephe_get_data(x){
    return x[caml_ephe_data_offset] === undefined
            ? 0
            : [0, x[caml_ephe_data_offset]];
   }
   function caml_obj_dup(x){
    var l = x.length, a = new Array(l);
    for(var i = 0; i < l; i++) a[i] = x[i];
    return a;
   }
   function caml_ephe_get_data_copy(x){
    return x[caml_ephe_data_offset] === undefined
            ? 0
            : [0, caml_obj_dup(x[caml_ephe_data_offset])];
   }
   function caml_ephe_get_key(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.get_key");
    var weak = x[caml_ephe_key_offset + i];
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
     weak = weak.deref();
    return weak === undefined ? 0 : [0, weak];
   }
   function caml_ephe_get_key_copy(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.get_copy");
    var y = caml_ephe_get_key(x, i);
    if(y === 0) return y;
    var z = y[1];
    if(z instanceof Array) return [0, caml_obj_dup(z)];
    return y;
   }
   function caml_ephe_set_key(x, i, v){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.set");
    if(v instanceof Object && globalThis.WeakRef){
     if(x[1].register) x[1].register(v, undefined, v);
     x[caml_ephe_key_offset + i] = new globalThis.WeakRef(v);
    }
    else
     x[caml_ephe_key_offset + i] = v;
    return 0;
   }
   function caml_ephe_unset_key(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.set");
    if
     (globalThis.WeakRef
      && x[caml_ephe_key_offset + i] instanceof globalThis.WeakRef
      && x[1].unregister){
     var old = x[caml_ephe_key_offset + i].deref();
     if(old !== undefined){
      var count = 0;
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key === old) count++;
       }
      }
      if(count == 1) x[1].unregister(old);
     }
    }
    x[caml_ephe_key_offset + i] = undefined;
    return 0;
   }
   function caml_equal(x, y){return + (caml_compare_val(x, y, false) == 0);}
   function caml_erf_float(x){
    var
     a1 = 0.254829592,
     a2 = - 0.284496736,
     a3 = 1.421413741,
     a4 = - 1.453152027,
     a5 = 1.061405429,
     p = 0.3275911,
     sign = 1;
    if(x < 0) sign = - 1;
    x = Math.abs(x);
    var
     t = 1.0 / (1.0 + p * x),
     y =
       1.0
       -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t
        * Math.exp(- (x * x));
    return sign * y;
   }
   function caml_erfc_float(x){return 1 - caml_erf_float(x);}
   function caml_eventlog_pause(unit){return 0;}
   function caml_eventlog_resume(unit){return 0;}
   var caml_executable_name = caml_argv[1];
   function caml_exp2_float(x){return Math.pow(2, x);}
   function caml_expm1_float(x){return Math.expm1(x);}
   function caml_is_special_exception(exn){
    switch(exn[2]){case - 8:case - 11:case - 12: return 1;default: return 0;
    }
   }
   function caml_format_exception(exn){
    var r = "";
    if(exn[0] == 0){
     r += exn[1][1];
     if
      (exn.length == 3 && exn[2][0] == 0 && caml_is_special_exception(exn[1]))
      var bucket = exn[2], start = 1;
     else
      var start = 2, bucket = exn;
     r += "(";
     for(var i = start; i < bucket.length; i++){
      if(i > start) r += ", ";
      var v = bucket[i];
      if(typeof v == "number")
       r += v.toString();
      else if(v instanceof MlBytes)
       r += '"' + v.toString() + '"';
      else if(typeof v == "string")
       r += '"' + v.toString() + '"';
      else
       r += "_";
     }
     r += ")";
    }
    else if(exn[0] == 248) r += exn[1];
    return r;
   }
   function caml_fatal_uncaught_exception(err){
    if(err instanceof Array && (err[0] == 0 || err[0] == 248)){
     var handler = caml_named_value("Printexc.handle_uncaught_exception");
     if(handler)
      caml_callback(handler, [err, false]);
     else{
      var
       msg = caml_format_exception(err),
       at_exit = caml_named_value("Pervasives.do_at_exit");
      if(at_exit) caml_callback(at_exit, [0]);
      console.error("Fatal error: exception " + msg);
      if(err.js_error) throw err.js_error;
     }
    }
    else
     throw err;
   }
   function caml_fill_bytes(s, i, l, c){
    if(l > 0)
     if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
      if(c == 0){
       s.c = "";
       s.t = 2;
      }
      else{
       s.c = caml_str_repeat(l, String.fromCharCode(c));
       s.t = l == s.l ? 0 : 2;
      }
     else{
      if(s.t != 4) caml_convert_bytes_to_array(s);
      for(l += i; i < l; i++) s.c[i] = c;
     }
    return 0;
   }
   function caml_final_register(){return 0;}
   var all_finalizers = new globalThis.Set();
   function caml_final_register_called_without_value(cb, a){
    if(globalThis.FinalizationRegistry && a instanceof Object){
     var
      x =
        new
         globalThis.FinalizationRegistry
         (function(x){all_finalizers.delete(x); cb(0); return;});
     x.register(a, x);
     all_finalizers.add(x);
    }
    return 0;
   }
   function caml_final_release(){return 0;}
   function caml_finish_formatting(f, rawbuffer){
    if(f.uppercase) rawbuffer = rawbuffer.toUpperCase();
    var len = rawbuffer.length;
    if(f.signedconv && (f.sign < 0 || f.signstyle != "-")) len++;
    if(f.alternate){if(f.base == 8) len += 1; if(f.base == 16) len += 2;}
    var buffer = "";
    if(f.justify == "+" && f.filler == " ")
     for(var i = len; i < f.width; i++) buffer += " ";
    if(f.signedconv)
     if(f.sign < 0)
      buffer += "-";
     else if(f.signstyle != "-") buffer += f.signstyle;
    if(f.alternate && f.base == 8) buffer += "0";
    if(f.alternate && f.base == 16) buffer += f.uppercase ? "0X" : "0x";
    if(f.justify == "+" && f.filler == "0")
     for(var i = len; i < f.width; i++) buffer += "0";
    buffer += rawbuffer;
    if(f.justify == "-") for(var i = len; i < f.width; i++) buffer += " ";
    return caml_string_of_jsbytes(buffer);
   }
   function caml_float_compare(x, y){
    if(x === y) return 0;
    if(x < y) return - 1;
    if(x > y) return 1;
    if(x === x) return 1;
    if(y === y) return - 1;
    return 0;
   }
   function caml_float_of_bytes(a){
    return caml_int64_float_of_bits(caml_int64_of_bytes(a));
   }
   function caml_float_of_string(s){
    var res;
    s = caml_jsbytes_of_string(s);
    res = + s;
    if(s.length > 0 && res === res) return res;
    s = s.replace(/_/g, "");
    res = + s;
    if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s)) return res;
    var m = /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s);
    if(m){
     var
      m3 = m[3].replace(/0+$/, ""),
      mantissa = parseInt(m[1] + m[2] + m3, 16),
      exponent = (m[5] | 0) - 4 * m3.length;
     res = mantissa * Math.pow(2, exponent);
     return res;
    }
    if(/^\+?inf(inity)?$/i.test(s)) return Infinity;
    if(/^-inf(inity)?$/i.test(s)) return - Infinity;
    caml_failwith("float_of_string");
   }
   function caml_floatarray_blit(a1, i1, a2, i2, len){
    if(i2 <= i1)
     for(var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];
    else
     for(var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];
    return 0;
   }
   function caml_floatarray_create(len){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_fma_float(x, y, z){
    var
     SPLIT = Math.pow(2, 27) + 1,
     MIN_VALUE = Math.pow(2, - 1022),
     EPSILON = Math.pow(2, - 52),
     C = 416,
     A = Math.pow(2, + C),
     B = Math.pow(2, - C);
    function multiply(a, b){
     var
      at = SPLIT * a,
      ahi = at - (at - a),
      alo = a - ahi,
      bt = SPLIT * b,
      bhi = bt - (bt - b),
      blo = b - bhi,
      p = a * b,
      e = ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
     return {p: p, e: e};
    }
    function add(a, b){
     var s = a + b, v = s - a, e = a - (s - v) + (b - v);
     return {s: s, e: e};
    }
    function adjust(x, y){
     return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
             ? x * (1 + (x < 0 ? - 1 : + 1) * (y < 0 ? - 1 : + 1) * EPSILON)
             : x;
    }
    if
     (x === 0 || x !== x || x === + (1 / 0) || x === - (1 / 0) || y === 0
      || y !== y
      || y === + (1 / 0)
      || y === - (1 / 0))
     return x * y + z;
    if(z === 0) return x * y;
    if(z !== z || z === + (1 / 0) || z === - (1 / 0)) return z;
    var scale = 1;
    while(Math.abs(x) > A){scale *= A; x *= B;}
    while(Math.abs(y) > A){scale *= A; y *= B;}
    if(scale === 1 / 0) return x * y * scale;
    while(Math.abs(x) < B){scale *= B; x *= A;}
    while(Math.abs(y) < B){scale *= B; y *= A;}
    if(scale === 0) return z;
    var xs = x, ys = y, zs = z / scale;
    if(Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON) return z;
    if(Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
     zs = (z < 0 ? - 1 : + 1) * MIN_VALUE;
    var
     xy = multiply(xs, ys),
     s = add(xy.p, zs),
     u = add(xy.e, s.e),
     i = add(s.s, u.s),
     f = i.s + adjust(i.e, u.e);
    if(f === 0) return f;
    var fs = f * scale;
    if(Math.abs(fs) > MIN_VALUE) return fs;
    return fs + adjust(f - fs / scale, i.e) * scale;
   }
   function caml_parse_format(fmt){
    fmt = caml_jsbytes_of_string(fmt);
    var len = fmt.length;
    if(len > 31) caml_invalid_argument("format_int: format too long");
    var
     f =
       {justify: "+",
        signstyle: "-",
        filler: " ",
        alternate: false,
        base: 0,
        signedconv: false,
        width: 0,
        uppercase: false,
        sign: 1,
        prec: - 1,
        conv: "f"};
    for(var i = 0; i < len; i++){
     var c = fmt.charAt(i);
     switch(c){
       case "-":
        f.justify = "-"; break;
       case "+":
       case " ":
        f.signstyle = c; break;
       case "0":
        f.filler = "0"; break;
       case "#":
        f.alternate = true; break;
       case "1":
       case "2":
       case "3":
       case "4":
       case "5":
       case "6":
       case "7":
       case "8":
       case "9":
        f.width = 0;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.width = f.width * 10 + c; i++;}
        i--;
        break;
       case ".":
        f.prec = 0;
        i++;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.prec = f.prec * 10 + c; i++;}
        i--;
       case "d":
       case "i":
        f.signedconv = true;
       case "u":
        f.base = 10; break;
       case "x":
        f.base = 16; break;
       case "X":
        f.base = 16; f.uppercase = true; break;
       case "o":
        f.base = 8; break;
       case "e":
       case "f":
       case "g":
        f.signedconv = true; f.conv = c; break;
       case "E":
       case "F":
       case "G":
        f.signedconv = true;
        f.uppercase = true;
        f.conv = c.toLowerCase();
        break;
     }
    }
    return f;
   }
   function caml_format_float(fmt, x){
    function toFixed(x, dp){
     if(Math.abs(x) < 1.0)
      return x.toFixed(dp);
     else{
      var e = parseInt(x.toString().split("+")[1]);
      if(e > 20){
       e -= 20;
       x /= Math.pow(10, e);
       x += new Array(e + 1).join("0");
       if(dp > 0) x = x + "." + new Array(dp + 1).join("0");
       return x;
      }
      else
       return x.toFixed(dp);
     }
    }
    var s, f = caml_parse_format(fmt), prec = f.prec < 0 ? 6 : f.prec;
    if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1; x = - x;}
    if(isNaN(x)){
     s = "nan";
     f.filler = " ";
    }
    else if(! isFinite(x)){
     s = "inf";
     f.filler = " ";
    }
    else
     switch(f.conv){
       case "e":
        var s = x.toExponential(prec), i = s.length;
        if(s.charAt(i - 3) == "e")
         s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
        break;
       case "f":
        s = toFixed(x, prec); break;
       case "g":
        prec = prec ? prec : 1;
        s = x.toExponential(prec - 1);
        var j = s.indexOf("e"), exp = + s.slice(j + 1);
        if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec){
         var i = j - 1;
         while(s.charAt(i) == "0") i--;
         if(s.charAt(i) == ".") i--;
         s = s.slice(0, i + 1) + s.slice(j);
         i = s.length;
         if(s.charAt(i - 3) == "e")
          s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
         break;
        }
        else{
         var p = prec;
         if(exp < 0){
          p -= exp + 1;
          s = x.toFixed(p);
         }
         else
          while(s = x.toFixed(p), s.length > prec + 1) p--;
         if(p){
          var i = s.length - 1;
          while(s.charAt(i) == "0") i--;
          if(s.charAt(i) == ".") i--;
          s = s.slice(0, i + 1);
         }
        }
        break;
     }
    return caml_finish_formatting(f, s);
   }
   function caml_format_int(fmt, i){
    if(caml_jsbytes_of_string(fmt) == "%d")
     return caml_string_of_jsbytes("" + i);
    var f = caml_parse_format(fmt);
    if(i < 0) if(f.signedconv){f.sign = - 1; i = - i;} else i >>>= 0;
    var s = i.toString(f.base);
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - s.length;
     if(n > 0) s = caml_str_repeat(n, "0") + s;
    }
    return caml_finish_formatting(f, s);
   }
   var caml_oo_last_id = 0;
   function caml_fresh_oo_id(){return caml_oo_last_id++;}
   function caml_frexp_float(x){
    if(x == 0 || ! isFinite(x)) return [0, x, 0];
    var neg = x < 0;
    if(neg) x = - x;
    var exp = Math.max(- 1023, jsoo_floor_log2(x) + 1);
    x *= Math.pow(2, - exp);
    while(x < 0.5){x *= 2; exp--;}
    while(x >= 1){x *= 0.5; exp++;}
    if(neg) x = - x;
    return [0, x, exp];
   }
   function jsoo_create_file(name, content){
    var
     name = caml_string_of_jsbytes(name),
     content = caml_string_of_jsbytes(content);
    return caml_create_file(name, content);
   }
   function caml_fs_init(){
    var tmp = globalThis.caml_fs_tmp;
    if(tmp)
     for(var i = 0; i < tmp.length; i++)
      jsoo_create_file(tmp[i].name, tmp[i].content);
    globalThis.jsoo_create_file = jsoo_create_file;
    globalThis.caml_fs_tmp = [];
    return 0;
   }
   function caml_gc_compaction(){return 0;}
   function caml_gc_counters(){return [254, 0, 0, 0];}
   function caml_gc_full_major(unit){
    if(typeof globalThis.gc == "function") globalThis.gc();
    return 0;
   }
   function caml_gc_get(){return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];}
   function caml_gc_huge_fallback_count(unit){return 0;}
   function caml_gc_major(unit){
    if(typeof globalThis.gc == "function") globalThis.gc();
    return 0;
   }
   function caml_gc_major_slice(work){return 0;}
   function caml_gc_minor(unit){
    if(typeof globalThis.gc == "function") globalThis.gc(true);
    return 0;
   }
   function caml_gc_minor_words(unit){return 0;}
   function caml_gc_quick_stat(){
    return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
   }
   function caml_gc_set(_control){return 0;}
   function caml_gc_stat(){return caml_gc_quick_stat();}
   function caml_get_continuation_callstack(){return [0];}
   function caml_get_current_callstack(){return [0];}
   function caml_get_exception_backtrace(){return 0;}
   function caml_get_exception_raw_backtrace(){return [0];}
   function caml_get_global_data(){return caml_global_data;}
   function caml_get_major_bucket(n){return 0;}
   function caml_get_major_credit(n){return 0;}
   function caml_get_minor_free(unit){return 0;}
   var caml_method_cache = [];
   function caml_get_public_method(obj, tag, cacheid){
    var meths = obj[1], ofs = caml_method_cache[cacheid];
    if(ofs === undefined)
     for(var i = caml_method_cache.length; i < cacheid; i++)
      caml_method_cache[i] = 0;
    else if(meths[ofs] === tag) return meths[ofs - 1];
    var li = 3, hi = meths[1] * 2 + 1, mi;
    while(li < hi){
     mi = li + hi >> 1 | 1;
     if(tag < meths[mi + 1]) hi = mi - 2; else li = mi;
    }
    caml_method_cache[cacheid] = li + 1;
    return tag == meths[li + 1] ? meths[li] : 0;
   }
   function caml_gr_arc_aux(ctx, cx, cy, ry, rx, a1, a2){
    while(a1 > a2) a2 += 360;
    a1 /= 180;
    a2 /= 180;
    var
     rot = 0,
     xPos,
     yPos,
     xPos_prev,
     yPos_prev,
     space = 2,
     num = (a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
     delta = (a2 - a1) * Math.PI / num,
     i = a1 * Math.PI;
    for(var j = 0; j <= num; j++){
     xPos =
      cx - rx * Math.sin(i) * Math.sin(rot * Math.PI)
      + ry * Math.cos(i) * Math.cos(rot * Math.PI);
     xPos = xPos.toFixed(2);
     yPos =
      cy + ry * Math.cos(i) * Math.sin(rot * Math.PI)
      + rx * Math.sin(i) * Math.cos(rot * Math.PI);
     yPos = yPos.toFixed(2);
     if(j == 0)
      ctx.moveTo(xPos, yPos);
     else if(xPos_prev != xPos || yPos_prev != yPos) ctx.lineTo(xPos, yPos);
     xPos_prev = xPos;
     yPos_prev = yPos;
     i -= delta;
    }
    return 0;
   }
   var caml_gr_state;
   function caml_gr_state_get(){
    if(caml_gr_state) return caml_gr_state;
    throw caml_maybe_attach_backtrace
           ([0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]);
   }
   function caml_gr_blit_image(im, x, y){
    var
     s = caml_gr_state_get(),
     im2 =
       s.context.getImageData
        (x, s.height - im.height - y, im.width, im.height);
    for(var i = 0; i < im2.data.length; i += 4){
     im.data[i] = im2.data[i];
     im.data[i + 1] = im2.data[i + 1];
     im.data[i + 2] = im2.data[i + 2];
     im.data[i + 3] = im2.data[i + 3];
    }
    return 0;
   }
   function caml_gr_clear_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = s.width;
    s.canvas.height = s.height;
    return 0;
   }
   function caml_gr_close_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = 0;
    s.canvas.height = 0;
    return 0;
   }
   function caml_gr_close_subwindow(a){
    caml_failwith("caml_gr_close_subwindow not Implemented");
   }
   function caml_gr_create_image(x, y){
    var s = caml_gr_state_get();
    return s.context.createImageData(x, y);
   }
   function caml_gr_current_x(){var s = caml_gr_state_get(); return s.x;}
   function caml_gr_current_y(){var s = caml_gr_state_get(); return s.y;}
   function caml_gr_display_mode(){
    caml_failwith("caml_gr_display_mode not Implemented");
   }
   function caml_gr_doc_of_state(state){
    if(state.canvas.ownerDocument) return state.canvas.ownerDocument;
   }
   function caml_gr_draw_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.stroke();
    return 0;
   }
   function caml_gr_draw_str(str){
    var s = caml_gr_state_get(), m = s.context.measureText(str), dx = m.width;
    s.context.fillText(str, s.x, s.height - s.y);
    s.x += dx | 0;
    return 0;
   }
   function caml_gr_draw_char(c){
    caml_gr_draw_str(String.fromCharCode(c));
    return 0;
   }
   function caml_gr_draw_image(im, x, y){
    var s = caml_gr_state_get();
    if(! im.image){
     var canvas = document.createElement("canvas");
     canvas.width = s.width;
     canvas.height = s.height;
     canvas.getContext("2d").putImageData(im, 0, 0);
     var image = new globalThis.Image();
     image.onload =
      function(){
       s.context.drawImage(image, x, s.height - im.height - y);
       im.image = image;
      };
     image.src = canvas.toDataURL("image/png");
    }
    else
     s.context.drawImage(im.image, x, s.height - im.height - y);
    return 0;
   }
   function caml_gr_draw_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.strokeRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_gr_draw_string(str){
    caml_gr_draw_str(caml_jsstring_of_string(str));
    return 0;
   }
   function caml_gr_dump_image(im){
    var data = [0];
    for(var i = 0; i < im.height; i++){
     data[i + 1] = [0];
     for(var j = 0; j < im.width; j++){
      var
       o = i * (im.width * 4) + j * 4,
       r = im.data[o + 0],
       g = im.data[o + 1],
       b = im.data[o + 2];
      data[i + 1][j + 1] = (r << 16) + (g << 8) + b;
     }
    }
    return data;
   }
   function caml_gr_fill_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.fill();
    return 0;
   }
   function caml_gr_fill_poly(ar){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(ar[1][1], s.height - ar[1][2]);
    for(var i = 2; i < ar.length; i++)
     s.context.lineTo(ar[i][1], s.height - ar[i][2]);
    s.context.lineTo(ar[1][1], s.height - ar[1][2]);
    s.context.fill();
    return 0;
   }
   function caml_gr_fill_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.fillRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_gr_lineto(x, y){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(s.x, s.height - s.y);
    s.context.lineTo(x, s.height - y);
    s.context.stroke();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_gr_make_image(arr){
    var
     s = caml_gr_state_get(),
     h = arr.length - 1,
     w = arr[1].length - 1,
     im = s.context.createImageData(w, h);
    for(var i = 0; i < h; i++)
     for(var j = 0; j < w; j++){
      var c = arr[i + 1][j + 1], o = i * (w * 4) + j * 4;
      if(c == - 1){
       im.data[o + 0] = 0;
       im.data[o + 1] = 0;
       im.data[o + 2] = 0;
       im.data[o + 3] = 0;
      }
      else{
       im.data[o + 0] = c >> 16 & 0xff;
       im.data[o + 1] = c >> 8 & 0xff;
       im.data[o + 2] = c >> 0 & 0Xff;
       im.data[o + 3] = 0xff;
      }
     }
    return im;
   }
   function caml_gr_moveto(x, y){
    var s = caml_gr_state_get();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_gr_set_window_title(name){
    var s = caml_gr_state_get();
    s.title = name;
    var jsname = caml_jsstring_of_string(name);
    if(s.set_title) s.set_title(jsname);
    return 0;
   }
   function caml_gr_set_line_width(w){
    var s = caml_gr_state_get();
    s.line_width = w;
    s.context.lineWidth = w;
    return 0;
   }
   function caml_gr_set_text_size(size){
    var s = caml_gr_state_get();
    s.text_size = size;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_gr_set_font(f){
    var s = caml_gr_state_get();
    s.font = f;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_gr_set_color(color){
    var s = caml_gr_state_get();
    function convert(number){
     var str = "" + number.toString(16);
     while(str.length < 2) str = "0" + str;
     return str;
    }
    var r = color >> 16 & 0xff, g = color >> 8 & 0xff, b = color >> 0 & 0xff;
    s.color = color;
    var c_str = "#" + convert(r) + convert(g) + convert(b);
    s.context.fillStyle = c_str;
    s.context.strokeStyle = c_str;
    return 0;
   }
   function caml_gr_resize_window(w, h){
    var s = caml_gr_state_get();
    s.width = w;
    s.height = h;
    s.canvas.width = w;
    s.canvas.height = h;
    return 0;
   }
   function caml_gr_state_init(){
    caml_gr_moveto(caml_gr_state.x, caml_gr_state.y);
    caml_gr_resize_window(caml_gr_state.width, caml_gr_state.height);
    caml_gr_set_line_width(caml_gr_state.line_width);
    caml_gr_set_text_size(caml_gr_state.text_size);
    caml_gr_set_font(caml_gr_state.font);
    caml_gr_set_color(caml_gr_state.color);
    caml_gr_set_window_title(caml_gr_state.title);
    caml_gr_state.context.textBaseline = "bottom";
   }
   function caml_gr_state_set(ctx){
    caml_gr_state = ctx;
    caml_gr_state_init();
    return 0;
   }
   function caml_gr_state_create(canvas, w, h){
    var context = canvas.getContext("2d");
    return {context: context,
            canvas: canvas,
            x: 0,
            y: 0,
            width: w,
            height: h,
            line_width: 1,
            font: caml_string_of_jsbytes("fixed"),
            text_size: 26,
            color: 0x000000,
            title: caml_string_of_jsbytes("")};
   }
   function caml_gr_open_graph(info){
    var info = caml_jsstring_of_string(info);
    function get(name){
     var res = info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
     if(res) return res[2];
    }
    var specs = [];
    if(! (info == "")) specs.push(info);
    var target = get("target");
    if(! target) target = "";
    var status = get("status");
    if(! status) specs.push("status=1");
    var w = get("width");
    w = w ? parseInt(w) : 200;
    specs.push("width=" + w);
    var h = get("height");
    h = h ? parseInt(h) : 200;
    specs.push("height=" + h);
    var win = globalThis.open("about:blank", target, specs.join(","));
    if(! win) caml_failwith("Graphics.open_graph: cannot open the window");
    var doc = win.document, canvas = doc.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    var ctx = caml_gr_state_create(canvas, w, h);
    ctx.set_title = function(title){doc.title = title;};
    caml_gr_state_set(ctx);
    var body = doc.body;
    body.style.margin = "0px";
    body.appendChild(canvas);
    return 0;
   }
   function caml_gr_open_subwindow(a, b, c, d){
    caml_failwith("caml_gr_open_subwindow not Implemented");
   }
   function caml_gr_plot(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.createImageData(1, 1),
     d = im.data,
     color = s.color;
    d[0] = color >> 16 & 0xff;
    d[1] = color >> 8 & 0xff, d[2] = color >> 0 & 0xff;
    d[3] = 0xFF;
    s.x = x;
    s.y = y;
    s.context.putImageData(im, x, s.height - y);
    return 0;
   }
   function caml_gr_point_color(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.getImageData(x, s.height - y, 1, 1),
     d = im.data;
    return (d[0] << 16) + (d[1] << 8) + d[2];
   }
   function caml_gr_remember_mode(){
    caml_failwith("caml_gr_remember_mode not Implemented");
   }
   function caml_gr_sigio_handler(){return 0;}
   function caml_gr_sigio_signal(){return 0;}
   function caml_gr_size_x(){var s = caml_gr_state_get(); return s.width;}
   function caml_gr_size_y(){var s = caml_gr_state_get(); return s.height;}
   function caml_gr_synchronize(){
    caml_failwith("caml_gr_synchronize not Implemented");
   }
   function caml_gr_text_size(txt){
    var
     s = caml_gr_state_get(),
     w = s.context.measureText(caml_jsstring_of_string(txt)).width;
    return [0, w, s.text_size];
   }
   function caml_gr_wait_event(_evl){
    caml_failwith
     ("caml_gr_wait_event not Implemented: use Graphics_js instead");
   }
   function caml_gr_window_id(a){
    caml_failwith("caml_gr_window_id not Implemented");
   }
   function caml_greaterequal(x, y){
    return + (caml_compare_val(x, y, false) >= 0);
   }
   function caml_greaterthan(x, y){
    return + (caml_compare_val(x, y, false) > 0);
   }
   function caml_hash_mix_jsbytes(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w =
      s.charCodeAt(i) | s.charCodeAt(i + 1) << 8 | s.charCodeAt(i + 2) << 16
      | s.charCodeAt(i + 3) << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s.charCodeAt(i + 2) << 16;
      case 2:
       w |= s.charCodeAt(i + 1) << 8;
      case 1:
       w |= s.charCodeAt(i); h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_hash_mix_string(h, v){
    return caml_hash_mix_jsbytes(h, caml_jsbytes_of_string(v));
   }
   function caml_hash_mix_bytes_arr(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s[i + 2] << 16;
      case 2:
       w |= s[i + 1] << 8;
      case 1:
       w |= s[i]; h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_ml_bytes_content(s){
    switch(s.t & 6){
      default: caml_convert_string_to_bytes(s);
      case 0:
       return s.c;
      case 4:
       return s.c;
    }
   }
   function caml_hash_mix_bytes(h, v){
    var content = caml_ml_bytes_content(v);
    return typeof content === "string"
            ? caml_hash_mix_jsbytes(h, content)
            : caml_hash_mix_bytes_arr(h, content);
   }
   function caml_hash_mix_final(h){
    h ^= h >>> 16;
    h = caml_mul(h, 0x85ebca6b | 0);
    h ^= h >>> 13;
    h = caml_mul(h, 0xc2b2ae35 | 0);
    h ^= h >>> 16;
    return h;
   }
   function caml_hash(count, limit, seed, obj){
    var queue, rd, wr, sz, num, h, v, i, len;
    sz = limit;
    if(sz < 0 || sz > 256) sz = 256;
    num = count;
    h = seed;
    queue = [obj];
    rd = 0;
    wr = 1;
    while(rd < wr && num > 0){
     v = queue[rd++];
     if(v && v.caml_custom){
      if
       (caml_custom_ops[v.caml_custom] && caml_custom_ops[v.caml_custom].hash){
       var hh = caml_custom_ops[v.caml_custom].hash(v);
       h = caml_hash_mix_int(h, hh);
       num--;
      }
     }
     else if(v instanceof Array && v[0] === (v[0] | 0))
      switch(v[0]){
        case 248:
         h = caml_hash_mix_int(h, v[2]); num--; break;
        case 250:
         queue[--rd] = v[1]; break;
        default:
         if(caml_is_continuation_tag(v[0])) break;
         var tag = v.length - 1 << 10 | v[0];
         h = caml_hash_mix_int(h, tag);
         for(i = 1, len = v.length; i < len; i++){if(wr >= sz) break; queue[wr++] = v[i];
         }
         break;
      }
     else if(caml_is_ml_bytes(v)){
      h = caml_hash_mix_bytes(h, v);
      num--;
     }
     else if(caml_is_ml_string(v)){
      h = caml_hash_mix_string(h, v);
      num--;
     }
     else if(typeof v === "string"){
      h = caml_hash_mix_jsbytes(h, v);
      num--;
     }
     else if(v === (v | 0)){
      h = caml_hash_mix_int(h, v + v + 1);
      num--;
     }
     else if(typeof v === "number"){h = caml_hash_mix_float(h, v); num--;}
    }
    h = caml_hash_mix_final(h);
    return h & 0x3FFFFFFF;
   }
   function caml_hash_mix_bigstring(h, bs){
    return caml_hash_mix_bytes_arr(h, bs.data);
   }
   function num_digits_nat(nat, ofs, len){
    for(var i = len - 1; i >= 0; i--) if(nat.data[ofs + i] != 0) return i + 1;
    return 1;
   }
   function caml_hash_nat(x){
    var len = num_digits_nat(x, 0, x.data.length), h = 0;
    for(var i = 0; i < len; i++) h = caml_hash_mix_int(h, x.data[i]);
    return h;
   }
   function caml_hexstring_of_float(x, prec, style){
    if(! isFinite(x)){
     if(isNaN(x)) return caml_string_of_jsstring("nan");
     return caml_string_of_jsstring(x > 0 ? "infinity" : "-infinity");
    }
    var sign = x == 0 && 1 / x == - Infinity ? 1 : x >= 0 ? 0 : 1;
    if(sign) x = - x;
    var exp = 0;
    if(x == 0)
     ;
    else if(x < 1)
     while(x < 1 && exp > - 1022){x *= 2; exp--;}
    else
     while(x >= 2){x /= 2; exp++;}
    var exp_sign = exp < 0 ? "" : "+", sign_str = "";
    if(sign)
     sign_str = "-";
    else
     switch(style){
       case 43:
        sign_str = "+"; break;
       case 32:
        sign_str = " "; break;
       default: break;
     }
    if(prec >= 0 && prec < 13){
     var cst = Math.pow(2, prec * 4);
     x = Math.round(x * cst) / cst;
    }
    var x_str = x.toString(16);
    if(prec >= 0){
     var idx = x_str.indexOf(".");
     if(idx < 0)
      x_str += "." + caml_str_repeat(prec, "0");
     else{
      var size = idx + 1 + prec;
      if(x_str.length < size)
       x_str += caml_str_repeat(size - x_str.length, "0");
      else
       x_str = x_str.substr(0, size);
     }
    }
    return caml_string_of_jsstring
            (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10));
   }
   function caml_hypot_float(x, y){return Math.hypot(x, y);}
   var caml_marshal_header_size = 20;
   function caml_refill(chan){
    if(chan.refill != null){
     var str = chan.refill(), str_a = caml_uint8_array_of_string(str);
     if(str_a.length == 0)
      chan.refill = null;
     else{
      if(chan.buffer.length < chan.buffer_max + str_a.length){
       var b = new Uint8Array(chan.buffer_max + str_a.length);
       b.set(chan.buffer);
       chan.buffer = b;
      }
      chan.buffer.set(str_a, chan.buffer_max);
      chan.offset += str_a.length;
      chan.buffer_max += str_a.length;
     }
    }
    else{
     var
      nread =
        chan.file.read
         (chan.offset,
          chan.buffer,
          chan.buffer_max,
          chan.buffer.length - chan.buffer_max);
     chan.offset += nread;
     chan.buffer_max += nread;
    }
   }
   function caml_raise_end_of_file(){
    caml_raise_constant(caml_global_data.End_of_file);
   }
   function caml_marshal_data_size(s, ofs){
    var r = new UInt8ArrayReader(caml_uint8_array_of_bytes(s), ofs);
    function readvlq(overflow){
     var c = r.read8u(), n = c & 0x7F;
     while((c & 0x80) != 0){
      c = r.read8u();
      var n7 = n << 7;
      if(n != n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7F;
     }
     return n;
    }
    switch(r.read32u()){
      case 0x8495A6BE:
       var header_len = 20, data_len = r.read32u(); break;
      case 0x8495A6BD:
       var
        header_len = r.read8u() & 0x3F,
        overflow = [false],
        data_len = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("Marshal.data_size: object too large to be read back on this platform");
       break;
      case 0x8495A6BF:
      default: caml_failwith("Marshal.data_size: bad object"); break;
    }
    return header_len - caml_marshal_header_size + data_len;
   }
   function caml_input_value_from_reader(reader, ofs){
    function readvlq(overflow){
     var c = reader.read8u(), n = c & 0x7F;
     while((c & 0x80) != 0){
      c = reader.read8u();
      var n7 = n << 7;
      if(n != n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7F;
     }
     return n;
    }
    var magic = reader.read32u();
    switch(magic){
      case 0x8495A6BE:
       var
        header_len = 20,
        compressed = 0,
        data_len = reader.read32u(),
        uncompressed_data_len = data_len,
        num_objects = reader.read32u(),
        _size_32 = reader.read32u(),
        _size_64 = reader.read32u();
       break;
      case 0x8495A6BD:
       var
        header_len = reader.read8u() & 0x3F,
        compressed = 1,
        overflow = [false],
        data_len = readvlq(overflow),
        uncompressed_data_len = readvlq(overflow),
        num_objects = readvlq(overflow),
        _size_32 = readvlq(overflow),
        _size_64 = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("caml_input_value_from_reader: object too large to be read back on this platform");
       break;
      case 0x8495A6BF:
       caml_failwith
        ("caml_input_value_from_reader: object too large to be read back on a 32-bit platform");
       break;
      default:
       caml_failwith("caml_input_value_from_reader: bad object"); break;
    }
    var
     stack = [],
     intern_obj_table = num_objects > 0 ? [] : null,
     obj_counter = 0;
    function intern_rec(reader){
     var code = reader.read8u();
     if(code >= 0x40)
      if(code >= 0x80){
       var tag = code & 0xF, size = code >> 4 & 0x7, v = [tag];
       if(size == 0) return v;
       if(intern_obj_table) intern_obj_table[obj_counter++] = v;
       stack.push(v, size);
       return v;
      }
      else
       return code & 0x3F;
     else if(code >= 0x20){
      var len = code & 0x1F, v = reader.readstr(len);
      if(intern_obj_table) intern_obj_table[obj_counter++] = v;
      return v;
     }
     else
      switch(code){
        case 0x00:
         return reader.read8s();
        case 0x01:
         return reader.read16s();
        case 0x02:
         return reader.read32s();
        case 0x03:
         caml_failwith("input_value: integer too large"); break;
        case 0x04:
         var offset = reader.read8u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x05:
         var offset = reader.read16u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x06:
         var offset = reader.read32u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x08:
         var
          header = reader.read32u(),
          tag = header & 0xFF,
          size = header >> 10,
          v = [tag];
         if(size == 0) return v;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         stack.push(v, size);
         return v;
        case 0x13:
         caml_failwith("input_value: data block too large"); break;
        case 0x09:
         var len = reader.read8u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0A:
         var len = reader.read32u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0C:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[7 - i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0B:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0E:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0D:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x07:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0F:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x10:
        case 0x11:
         caml_failwith("input_value: code pointer"); break;
        case 0x12:
        case 0x18:
        case 0x19:
         var c, s = "";
         while((c = reader.read8u()) != 0) s += String.fromCharCode(c);
         var ops = caml_custom_ops[s], expected_size;
         if(! ops)
          caml_failwith("input_value: unknown custom block identifier");
         switch(code){
           case 0x12: break;
           case 0x19:
            if(! ops.fixed_length)
             caml_failwith("input_value: expected a fixed-size custom block");
            expected_size = ops.fixed_length;
            break;
           case 0x18:
            expected_size = reader.read32u();
            reader.read32s();
            reader.read32s();
            break;
         }
         var
          old_pos = reader.i,
          size = [0],
          v = ops.deserialize(reader, size);
         if(expected_size != undefined)
          if(expected_size != size[0])
           caml_failwith
            ("input_value: incorrect length of serialized custom block");
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        default: caml_failwith("input_value: ill-formed message");
      }
    }
    if(compressed)
     if(caml_decompress_input)
      var
       data = reader.readuint8array(data_len),
       res = new Uint8Array(uncompressed_data_len),
       res = caml_decompress_input(data, res),
       reader = new UInt8ArrayReader(res, 0);
     else
      caml_failwith("input_value: compressed object, cannot decompress");
    var res = intern_rec(reader);
    while(stack.length > 0){
     var size = stack.pop(), v = stack.pop(), d = v.length;
     if(d < size) stack.push(v, size);
     v[d] = intern_rec(reader);
    }
    if(typeof ofs != "number") ofs[0] = reader.i;
    return res;
   }
   function caml_string_of_bytes(s){
    s.t & 6 && caml_convert_string_to_bytes(s);
    return caml_string_of_jsbytes(s.c);
   }
   function caml_input_value_from_bytes(s, ofs){
    var
     reader =
       new
        MlStringReader
        (caml_string_of_bytes(s), typeof ofs == "number" ? ofs : ofs[0]);
    return caml_input_value_from_reader(reader, ofs);
   }
   function caml_input_value(chanid){
    var
     chan = caml_ml_channel_get(chanid),
     header = new Uint8Array(caml_marshal_header_size);
    function block(buffer, offset, n){
     var r = 0;
     while(r < n){
      if(chan.buffer_curr >= chan.buffer_max){
       chan.buffer_curr = 0;
       chan.buffer_max = 0;
       caml_refill(chan);
      }
      if(chan.buffer_curr >= chan.buffer_max) break;
      buffer[offset + r] = chan.buffer[chan.buffer_curr];
      chan.buffer_curr++;
      r++;
     }
     return r;
    }
    var r = block(header, 0, caml_marshal_header_size);
    if(r == 0)
     caml_raise_end_of_file();
    else if(r < caml_marshal_header_size)
     caml_failwith("input_value: truncated object");
    var
     len = caml_marshal_data_size(caml_bytes_of_array(header), 0),
     buf = new Uint8Array(len + caml_marshal_header_size);
    buf.set(header, 0);
    var r = block(buf, caml_marshal_header_size, len);
    if(r < len)
     caml_failwith("input_value: truncated object " + r + "  " + len);
    var
     offset = [0],
     res = caml_input_value_from_bytes(caml_bytes_of_array(buf), offset);
    chan.offset = chan.offset + offset[0];
    return res;
   }
   function caml_input_value_from_string(s, ofs){
    var reader = new MlStringReader(s, typeof ofs == "number" ? ofs : ofs[0]);
    return caml_input_value_from_reader(reader, ofs);
   }
   function caml_input_value_to_outside_heap(c){return caml_input_value(c);}
   function caml_install_signal_handler(){return 0;}
   function caml_int32_bswap(x){
    return (x & 0x000000FF) << 24 | (x & 0x0000FF00) << 8
           | (x & 0x00FF0000) >>> 8
           | (x & 0xFF000000) >>> 24;
   }
   function caml_int64_add(x, y){return x.add(y);}
   function caml_int64_and(x, y){return x.and(y);}
   function caml_int64_bswap(x){
    var y = caml_int64_to_bytes(x);
    return caml_int64_of_bytes
            ([y[7], y[6], y[5], y[4], y[3], y[2], y[1], y[0]]);
   }
   function caml_int64_div(x, y){return x.div(y);}
   function caml_int64_is_zero(x){return + x.isZero();}
   function caml_int64_of_int32(x){
    return new MlInt64(x & 0xffffff, x >> 24 & 0xffffff, x >> 31 & 0xffff);
   }
   function caml_int64_to_int32(x){return x.toInt();}
   function caml_int64_is_negative(x){return + x.isNeg();}
   function caml_int64_neg(x){return x.neg();}
   function caml_int64_format(fmt, x){
    var f = caml_parse_format(fmt);
    if(f.signedconv && caml_int64_is_negative(x)){f.sign = - 1; x = caml_int64_neg(x);}
    var
     buffer = "",
     wbase = caml_int64_of_int32(f.base),
     cvtbl = "0123456789abcdef";
    do{
     var p = x.udivmod(wbase);
     x = p.quotient;
     buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer;
    }
    while
     (! caml_int64_is_zero(x));
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - buffer.length;
     if(n > 0) buffer = caml_str_repeat(n, "0") + buffer;
    }
    return caml_finish_formatting(f, buffer);
   }
   function caml_int64_mod(x, y){return x.mod(y);}
   function caml_int64_mul(x, y){return x.mul(y);}
   function caml_int64_of_float(x){
    if(x < 0) x = Math.ceil(x);
    return new
            MlInt64
            (x & 0xffffff,
             Math.floor(x * caml_int64_offset) & 0xffffff,
             Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff);
   }
   function caml_int64_ult(x, y){return x.ucompare(y) < 0;}
   function caml_parse_sign_and_base(s){
    var i = 0, len = caml_ml_string_length(s), base = 10, sign = 1;
    if(len > 0)
     switch(caml_string_unsafe_get(s, i)){
       case 45:
        i++; sign = - 1; break;
       case 43:
        i++; sign = 1; break;
     }
    if(i + 1 < len && caml_string_unsafe_get(s, i) == 48)
     switch(caml_string_unsafe_get(s, i + 1)){
       case 120:
       case 88:
        base = 16; i += 2; break;
       case 111:
       case 79:
        base = 8; i += 2; break;
       case 98:
       case 66:
        base = 2; i += 2; break;
       case 117:
       case 85:
        i += 2; break;
     }
    return [i, sign, base];
   }
   function caml_parse_digit(c){
    if(c >= 48 && c <= 57) return c - 48;
    if(c >= 65 && c <= 90) return c - 55;
    if(c >= 97 && c <= 122) return c - 87;
    return - 1;
   }
   function caml_int64_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     base64 = caml_int64_of_int32(base),
     threshold =
       new MlInt64(0xffffff, 0xfffffff, 0xffff).udivmod(base64).quotient,
     c = caml_string_unsafe_get(s, i),
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = caml_int64_of_int32(d);
    for(;;){
     i++;
     c = caml_string_unsafe_get(s, i);
     if(c == 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     if(caml_int64_ult(threshold, res)) caml_failwith("int_of_string");
     d = caml_int64_of_int32(d);
     res = caml_int64_add(caml_int64_mul(base64, res), d);
     if(caml_int64_ult(res, d)) caml_failwith("int_of_string");
    }
    if(i != caml_ml_string_length(s)) caml_failwith("int_of_string");
    if(base == 10 && caml_int64_ult(new MlInt64(0, 0, 0x8000), res))
     caml_failwith("int_of_string");
    if(sign < 0) res = caml_int64_neg(res);
    return res;
   }
   function caml_int64_or(x, y){return x.or(y);}
   function caml_int64_shift_left(x, s){return x.shift_left(s);}
   function caml_int64_shift_right(x, s){return x.shift_right(s);}
   function caml_int64_shift_right_unsigned(x, s){return x.shift_right_unsigned(s);
   }
   function caml_int64_sub(x, y){return x.sub(y);}
   function caml_int64_to_float(x){return x.toFloat();}
   function caml_int64_xor(x, y){return x.xor(y);}
   function caml_int_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     len = caml_ml_string_length(s),
     threshold = - 1 >>> 0,
     c = i < len ? caml_string_unsafe_get(s, i) : 0,
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = d;
    for(i++; i < len; i++){
     c = caml_string_unsafe_get(s, i);
     if(c == 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     res = base * res + d;
     if(res > threshold) caml_failwith("int_of_string");
    }
    if(i != len) caml_failwith("int_of_string");
    res = sign * res;
    if(base == 10 && (res | 0) != res) caml_failwith("int_of_string");
    return res | 0;
   }
   function caml_is_js(){return 1;}
   function caml_is_printable(c){return + (c > 31 && c < 127);}
   function caml_js_call(f, o, args){
    return f.apply(o, caml_js_from_array(args));
   }
   function caml_js_delete(o, f){delete o[f]; return 0;}
   function caml_js_equals(x, y){return + (x == y);}
   function caml_js_error_of_exception(exn){
    if(exn.js_error) return exn.js_error;
    return null;
   }
   function caml_js_error_option_of_exception(exn){
    if(exn.js_error) return [0, exn.js_error];
    return 0;
   }
   function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s));}
   function caml_js_expr(s){
    console.error("caml_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_js_from_bool(x){return ! ! x;}
   function caml_js_from_float(x){return x;}
   function caml_js_from_string(s){return caml_jsstring_of_string(s);}
   function caml_js_fun_call(f, a){
    switch(a.length){
      case 1:
       return f();
      case 2:
       return f(a[1]);
      case 3:
       return f(a[1], a[2]);
      case 4:
       return f(a[1], a[2], a[3]);
      case 5:
       return f(a[1], a[2], a[3], a[4]);
      case 6:
       return f(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return f(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return f(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    return f.apply(null, caml_js_from_array(a));
   }
   function caml_js_function_arity(f){return f.l >= 0 ? f.l : f.l = f.length;}
   function caml_js_get(o, f){return o[f];}
   function caml_js_get_console(){
    var
     c = console,
     m =
       ["log",
        "debug",
        "info",
        "warn",
        "error",
        "assert",
        "dir",
        "dirxml",
        "trace",
        "group",
        "groupCollapsed",
        "groupEnd",
        "time",
        "timeEnd"];
    function f(){}
    for(var i = 0; i < m.length; i++) if(! c[m[i]]) c[m[i]] = f;
    return c;
   }
   function caml_js_html_entities(s){
    var entity = /^&#?[0-9a-zA-Z]+;$/;
    if(s.match(entity)){
     var str, temp = document.createElement("p");
     temp.innerHTML = s;
     str = temp.textContent || temp.innerText;
     temp = null;
     return str;
    }
    else
     caml_failwith("Invalid entity " + s);
   }
   var caml_js_regexps = {amp: /&/g, lt: /</g, quot: /\"/g, all: /[&<\"]/};
   function caml_js_html_escape(s){
    if(! caml_js_regexps.all.test(s)) return s;
    return s.replace(caml_js_regexps.amp, "&amp;").replace
             (caml_js_regexps.lt, "&lt;").replace
            (caml_js_regexps.quot, "&quot;");
   }
   function caml_js_instanceof(o, c){return o instanceof c ? 1 : 0;}
   function caml_js_meth_call(o, f, args){
    return o[caml_jsstring_of_string(f)].apply(o, caml_js_from_array(args));
   }
   function caml_js_new(c, a){
    switch(a.length){
      case 1:
       return new c;
      case 2:
       return new c(a[1]);
      case 3:
       return new c(a[1], a[2]);
      case 4:
       return new c(a[1], a[2], a[3]);
      case 5:
       return new c(a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    function F(){return c.apply(this, caml_js_from_array(a));}
    F.prototype = c.prototype;
    return new F;
   }
   function caml_js_object(a){
    var o = {};
    for(var i = 1; i < a.length; i++){
     var p = a[i];
     o[caml_jsstring_of_string(p[1])] = p[2];
    }
    return o;
   }
   function caml_js_on_ie(){
    var
     ua =
       globalThis.navigator && globalThis.navigator.userAgent
        ? globalThis.navigator.userAgent
        : "";
    return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0;
   }
   function caml_js_pure_expr(f){return caml_callback(f, [0]);}
   function caml_js_set(o, f, v){o[f] = v; return 0;}
   function caml_js_strict_equals(x, y){return + (x === y);}
   function caml_js_to_array(a){
    var len = a.length, b = new Array(len + 1);
    b[0] = 0;
    for(var i = 0; i < len; i++) b[i + 1] = a[i];
    return b;
   }
   function caml_js_to_bool(x){return + x;}
   function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s);}
   function caml_js_to_float(x){return x;}
   function caml_js_to_int32(x){return x | 0;}
   function caml_js_to_string(s){return caml_string_of_jsstring(s);}
   function caml_js_typeof(o){return typeof o;}
   function caml_js_var(x){
    var x = caml_jsstring_of_string(x);
    if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
     console.error
      ('caml_js_var: "' + x
       + '" is not a valid JavaScript variable. continuing ..');
    return eval(x);
   }
   function caml_js_wrap_callback(f){
    return function(){
     var len = arguments.length;
     if(len > 0){
      var args = new Array(len);
      for(var i = 0; i < len; i++) args[i] = arguments[i];
     }
     else
      args = [undefined];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_js_wrap_callback_arguments(f){
    return function(){
     var len = arguments.length, args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, [args]);};
   }
   function caml_js_wrap_callback_strict(arity, f){
    return function(){
     var
      n = arguments.length,
      args = new Array(arity),
      len = Math.min(arguments.length, arity);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_js_wrap_callback_unsafe(f){
    return function(){
     var len = caml_js_function_arity(f), args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_js_wrap_meth_callback(f){
    return function(){
     var len = arguments.length, args = new Array(len + 1);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_js_wrap_meth_callback_arguments(f){
    return function(){
     var len = arguments.length, args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, [this, args]);};
   }
   function caml_js_wrap_meth_callback_strict(arity, f){
    return function(){
     var args = new Array(arity + 1), len = Math.min(arguments.length, arity);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_js_wrap_meth_callback_unsafe(f){
    return function(){
     var len = caml_js_function_arity(f) - 1, args = new Array(len + 1);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_jsoo_flags_effects(unit){return 0;}
   function caml_jsoo_flags_use_js_string(unit){return 1;}
   function caml_lazy_make_forward(v){return [250, v];}
   function caml_obj_tag(x){
    if(x instanceof Array && x[0] == x[0] >>> 0)
     return x[0];
    else if(caml_is_ml_bytes(x))
     return 252;
    else if(caml_is_ml_string(x))
     return 252;
    else if(x instanceof Function || typeof x == "function")
     return 247;
    else if(x && x.caml_custom) return 255; else return 1000;
   }
   function caml_lazy_read_result(o){
    return caml_obj_tag(o) == 250 ? o[1] : o;
   }
   function caml_obj_update_tag(b, o, n){
    if(b[0] == o){b[0] = n; return 1;}
    return 0;
   }
   function caml_lazy_reset_to_lazy(o){
    caml_obj_update_tag(o, 244, 246);
    return 0;
   }
   function caml_lazy_update_to_forcing(o){
    return o instanceof Array && o[0] == o[0] >>> 0
            && caml_obj_update_tag(o, 246, 244)
            ? 0
            : 1;
   }
   function caml_lazy_update_to_forward(o){
    caml_obj_update_tag(o, 244, 250);
    return 0;
   }
   function caml_ldexp_float(x, exp){
    exp |= 0;
    if(exp > 1023){
     exp -= 1023;
     x *= Math.pow(2, 1023);
     if(exp > 1023){exp -= 1023; x *= Math.pow(2, 1023);}
    }
    if(exp < - 1023){exp += 1023; x *= Math.pow(2, - 1023);}
    x *= Math.pow(2, exp);
    return x;
   }
   function caml_lessequal(x, y){
    return + (caml_compare_val(x, y, false) <= 0);
   }
   function caml_lessthan(x, y){return + (caml_compare_val(x, y, false) < 0);}
   function caml_lex_array(s){
    s = caml_jsbytes_of_string(s);
    var l = s.length / 2, a = new Array(l);
    for(var i = 0; i < l; i++)
     a[i] = (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8) << 16 >> 16;
    return a;
   }
   function caml_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    var
     c,
     state = start_state,
     buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0) return - base - 1;
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] == 0) return - state - 1; else c = 256;
     else{c = buffer[lexbuf[lex_curr_pos]]; lexbuf[lex_curr_pos]++;}
     if(tbl.lex_check[base + c] == state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] == - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else if(c == 256) lexbuf[lex_eof_reached] = 0;
    }
   }
   function caml_list_mount_point(){
    var prev = 0;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var old = prev;
     prev = [0, caml_string_of_jsbytes(jsoo_mount_point[i].path), old];
    }
    return prev;
   }
   function caml_list_of_js_array(a){
    var l = 0;
    for(var i = a.length - 1; i >= 0; i--){var e = a[i]; l = [0, e, l];}
    return l;
   }
   function caml_list_to_js_array(l){
    var a = [];
    for(; l !== 0; l = l[2]) a.push(l[1]);
    return a;
   }
   function caml_log10_float(x){return Math.log10(x);}
   function caml_log1p_float(x){return Math.log1p(x);}
   function caml_log2_float(x){return Math.log2(x);}
   function caml_new_string(s){return caml_string_of_jsbytes(s);}
   function caml_lxm_next(v){
    function shift_l(x, k){return caml_int64_shift_left(x, k);}
    function shift_r(x, k){return caml_int64_shift_right_unsigned(x, k);}
    function or(a, b){return caml_int64_or(a, b);}
    function xor(a, b){return caml_int64_xor(a, b);}
    function add(a, b){return caml_int64_add(a, b);}
    function mul(a, b){return caml_int64_mul(a, b);}
    function rotl(x, k){return or(shift_l(x, k), shift_r(x, 64 - k));}
    function get(a, i){return caml_ba_get_1(a, i);}
    function set(a, i, x){return caml_ba_set_1(a, i, x);}
    var
     M = caml_int64_of_string(caml_new_string("0xd1342543de82ef95")),
     daba = caml_int64_of_string(caml_new_string("0xdaba0b6eb09322e3")),
     z,
     q0,
     q1,
     st = v,
     a = get(st, 0),
     s = get(st, 1),
     x0 = get(st, 2),
     x1 = get(st, 3);
    z = add(s, x0);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = xor(z, shift_r(z, 32));
    set(st, 1, add(mul(s, M), a));
    var q0 = x0, q1 = x1;
    q1 = xor(q1, q0);
    q0 = rotl(q0, 24);
    q0 = xor(xor(q0, q1), shift_l(q1, 16));
    q1 = rotl(q1, 37);
    set(st, 2, q0);
    set(st, 3, q1);
    return z;
   }
   function caml_make_float_vect(len){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_make_vect(len, init){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 0;
    for(var i = 1; i < len; i++) b[i] = init;
    return b;
   }
   var
    caml_marshal_constants =
      {PREFIX_SMALL_BLOCK: 0x80,
       PREFIX_SMALL_INT: 0x40,
       PREFIX_SMALL_STRING: 0x20,
       CODE_INT8: 0x00,
       CODE_INT16: 0x01,
       CODE_INT32: 0x02,
       CODE_INT64: 0x03,
       CODE_SHARED8: 0x04,
       CODE_SHARED16: 0x05,
       CODE_SHARED32: 0x06,
       CODE_BLOCK32: 0x08,
       CODE_BLOCK64: 0x13,
       CODE_STRING8: 0x09,
       CODE_STRING32: 0x0A,
       CODE_DOUBLE_BIG: 0x0B,
       CODE_DOUBLE_LITTLE: 0x0C,
       CODE_DOUBLE_ARRAY8_BIG: 0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE: 0x0E,
       CODE_DOUBLE_ARRAY32_BIG: 0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE: 0x07,
       CODE_CODEPOINTER: 0x10,
       CODE_INFIXPOINTER: 0x11,
       CODE_CUSTOM: 0x12,
       CODE_CUSTOM_LEN: 0x18,
       CODE_CUSTOM_FIXED: 0x19};
   function caml_maybe_print_stats(unit){return 0;}
   function caml_md5_bytes(s, ofs, len){
    var ctx = caml_MD5Init(), a = caml_uint8_array_of_bytes(s);
    caml_MD5Update(ctx, a.subarray(ofs, ofs + len), len);
    return caml_string_of_array(caml_MD5Final(ctx));
   }
   function caml_ml_input_block(chanid, ba, i, l){
    var
     chan = caml_ml_channel_get(chanid),
     n = l,
     avail = chan.buffer_max - chan.buffer_curr;
    if(l <= avail){
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + l), i);
     chan.buffer_curr += l;
    }
    else if(avail > 0){
     ba.set
      (chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + avail), i);
     chan.buffer_curr += avail;
     n = avail;
    }
    else{
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
     var avail = chan.buffer_max - chan.buffer_curr;
     if(n > avail) n = avail;
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + n), i);
     chan.buffer_curr += n;
    }
    return n | 0;
   }
   function caml_md5_chan(chanid, toread){
    var ctx = caml_MD5Init(), buffer = new Uint8Array(4096);
    if(toread < 0)
     while(true){
      var read = caml_ml_input_block(chanid, buffer, 0, buffer.length);
      if(read == 0) break;
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
     }
    else
     while(toread > 0){
      var
       read =
         caml_ml_input_block
          (chanid, buffer, 0, toread > buffer.length ? buffer.length : toread);
      if(read == 0) caml_raise_end_of_file();
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
      toread -= read;
     }
    return caml_string_of_array(caml_MD5Final(ctx));
   }
   function caml_md5_string(s, ofs, len){
    return caml_md5_bytes(caml_bytes_of_string(s), ofs, len);
   }
   function caml_memprof_discard(t){return 0;}
   function caml_memprof_set(_control){return 0;}
   function caml_memprof_start(rate, stack_size, tracker){return 0;}
   function caml_memprof_stop(unit){return 0;}
   function caml_ml_channel_redirect(captured, into){
    var
     to_restore = caml_ml_channel_get(captured),
     new_ = caml_ml_channel_get(into);
    caml_ml_channels[captured] = new_;
    return to_restore;
   }
   function caml_ml_channel_restore(captured, to_restore){caml_ml_channels[captured] = to_restore; return 0;
   }
   function caml_ml_channel_size(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.file.length();
   }
   function caml_ml_channel_size_64(chanid){
    var chan = caml_ml_channel_get(chanid);
    return caml_int64_of_float(chan.file.length());
   }
   var caml_sys_fds = new Array(3);
   function caml_sys_close(fd){
    var file = caml_sys_fds[fd];
    if(file) file.close();
    delete caml_sys_fds[fd];
    return 0;
   }
   function caml_ml_flush(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(! chan.opened) caml_raise_sys_error("Cannot flush a closed channel");
    if(! chan.buffer || chan.buffer_curr == 0) return 0;
    if(chan.output)
     chan.output(caml_subarray_to_jsbytes(chan.buffer, 0, chan.buffer_curr));
    else
     chan.file.write(chan.offset, chan.buffer, 0, chan.buffer_curr);
    chan.offset += chan.buffer_curr;
    chan.buffer_curr = 0;
    return 0;
   }
   function caml_ml_close_channel(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(chan.opened){
     chan.opened = false;
     caml_sys_close(chan.fd);
     chan.fd = - 1;
     chan.buffer = new Uint8Array(0);
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
    }
    return 0;
   }
   function caml_ml_condition_broadcast(t){return 0;}
   function caml_ml_condition_new(unit){return {condition: 1};}
   function caml_ml_condition_signal(t){return 0;}
   function caml_ml_condition_wait(t, mutext){return 0;}
   function caml_ml_debug_info_status(){return 0;}
   function caml_ml_domain_cpu_relax(unit){return 0;}
   function caml_ml_domain_id(unit){return caml_domain_id;}
   function caml_ml_domain_set_name(_name){return 0;}
   var caml_ml_domain_unique_token_ = [0];
   function caml_ml_domain_unique_token(unit){return caml_ml_domain_unique_token_;
   }
   var caml_runtime_warnings = 0;
   function caml_ml_enable_runtime_warnings(bool){caml_runtime_warnings = bool; return 0;
   }
   function caml_ml_input(chanid, b, i, l){
    var ba = caml_uint8_array_of_bytes(b);
    return caml_ml_input_block(chanid, ba, i, l);
   }
   function caml_ml_input_bigarray(chanid, b, i, l){
    var ba = caml_ba_to_typed_array(b);
    return caml_ml_input_block(chanid, ba, i, l);
   }
   function caml_ml_input_char(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(chan.buffer_curr >= chan.buffer_max){
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
    }
    if(chan.buffer_curr >= chan.buffer_max) caml_raise_end_of_file();
    var res = chan.buffer[chan.buffer_curr];
    chan.buffer_curr++;
    return res;
   }
   function caml_ml_input_int(chanid){
    var chan = caml_ml_channel_get(chanid), res = 0;
    for(var i = 0; i < 4; i++)
     res = (res << 8) + caml_ml_input_char(chanid) | 0;
    return res | 0;
   }
   function caml_ml_input_scan_line(chanid){
    var chan = caml_ml_channel_get(chanid), p = chan.buffer_curr;
    do
     if(p >= chan.buffer_max){
      if(chan.buffer_curr > 0){
       chan.buffer.set(chan.buffer.subarray(chan.buffer_curr), 0);
       p -= chan.buffer_curr;
       chan.buffer_max -= chan.buffer_curr;
       chan.buffer_curr = 0;
      }
      if(chan.buffer_max >= chan.buffer.length) return - chan.buffer_max | 0;
      var prev_max = chan.buffer_max;
      caml_refill(chan);
      if(prev_max == chan.buffer_max) return - chan.buffer_max | 0;
     }
    while
     (chan.buffer[p++] != 10);
    return p - chan.buffer_curr | 0;
   }
   function caml_ml_is_buffered(chanid){
    return caml_ml_channel_get(chanid).buffered ? 1 : 0;
   }
   function caml_ml_mutex_lock(t){
    if(t.locked)
     caml_failwith("Mutex.lock: mutex already locked. Cannot wait.");
    else
     t.locked = true;
    return 0;
   }
   function caml_ml_mutex_new(unit){return new MlMutex();}
   function caml_ml_mutex_try_lock(t){
    if(! t.locked){t.locked = true; return 1;}
    return 0;
   }
   function caml_sys_open_for_node(fd, flags){
    if(flags.name)
     try{
      var fs = require("fs"), fd2 = fs.openSync(flags.name, "rs");
      return new MlNodeFd(fd2, flags);
     }
     catch(e){}
    return new MlNodeFd(fd, flags);
   }
   function caml_sys_open_internal(file, idx){
    if(idx == undefined) idx = caml_sys_fds.length;
    caml_sys_fds[idx] = file;
    return idx | 0;
   }
   function caml_sys_open(name, flags, _perms){
    var f = {};
    while(flags){
     switch(flags[1]){
       case 0:
        f.rdonly = 1; break;
       case 1:
        f.wronly = 1; break;
       case 2:
        f.append = 1; break;
       case 3:
        f.create = 1; break;
       case 4:
        f.truncate = 1; break;
       case 5:
        f.excl = 1; break;
       case 6:
        f.binary = 1; break;
       case 7:
        f.text = 1; break;
       case 8:
        f.nonblock = 1; break;
     }
     flags = flags[2];
    }
    if(f.rdonly && f.wronly)
     caml_raise_sys_error
      (caml_jsbytes_of_string(name)
       + " : flags Open_rdonly and Open_wronly are not compatible");
    if(f.text && f.binary)
     caml_raise_sys_error
      (caml_jsbytes_of_string(name)
       + " : flags Open_text and Open_binary are not compatible");
    var root = resolve_fs_device(name), file = root.device.open(root.rest, f);
    return caml_sys_open_internal(file, undefined);
   }
   (function(){
      function file(fd, flags){
       return fs_node_supported()
               ? caml_sys_open_for_node(fd, flags)
               : new MlFakeFd_out(fd, flags);
      }
      caml_sys_open_internal
       (file(0, {rdonly: 1, altname: "/dev/stdin", isCharacterDevice: true}),
        0);
      caml_sys_open_internal
       (file(1, {buffered: 2, wronly: 1, isCharacterDevice: true}), 1);
      caml_sys_open_internal
       (file(2, {buffered: 2, wronly: 1, isCharacterDevice: true}), 2);
     }
     ());
   function caml_ml_open_descriptor_in(fd){
    var file = caml_sys_fds[fd];
    if(file.flags.wronly) caml_raise_sys_error("fd " + fd + " is writeonly");
    var
     refill = null,
     channel =
       {file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: false,
        buffer_curr: 0,
        buffer_max: 0,
        buffer: new Uint8Array(65536),
        refill: refill};
    caml_ml_channels[channel.fd] = channel;
    return channel.fd;
   }
   function caml_ml_open_descriptor_out(fd){
    var file = caml_sys_fds[fd];
    if(file.flags.rdonly) caml_raise_sys_error("fd " + fd + " is readonly");
    var
     buffered = file.flags.buffered !== undefined ? file.flags.buffered : 1,
     channel =
       {file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: true,
        buffer_curr: 0,
        buffer: new Uint8Array(65536),
        buffered: buffered};
    caml_ml_channels[channel.fd] = channel;
    return channel.fd;
   }
   function caml_ml_out_channels_list(){
    var l = 0;
    for(var c = 0; c < caml_ml_channels.length; c++)
     if
      (caml_ml_channels[c] && caml_ml_channels[c].opened
       && caml_ml_channels[c].out)
      l = [0, caml_ml_channels[c].fd, l];
    return l;
   }
   function caml_ml_output_ta(chanid, buffer, offset, len){
    var chan = caml_ml_channel_get(chanid);
    if(! chan.opened)
     caml_raise_sys_error("Cannot output to a closed channel");
    buffer = buffer.subarray(offset, offset + len);
    if(chan.buffer_curr + buffer.length > chan.buffer.length){
     var b = new Uint8Array(chan.buffer_curr + buffer.length);
     b.set(chan.buffer);
     chan.buffer = b;
    }
    switch(chan.buffered){
      case 0:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       caml_ml_flush(chanid);
       break;
      case 1:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       break;
      case 2:
       var id = buffer.lastIndexOf(10);
       if(id < 0){
        chan.buffer.set(buffer, chan.buffer_curr);
        chan.buffer_curr += buffer.length;
        if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       }
       else{
        chan.buffer.set(buffer.subarray(0, id + 1), chan.buffer_curr);
        chan.buffer_curr += id + 1;
        caml_ml_flush(chanid);
        chan.buffer.set(buffer.subarray(id + 1), chan.buffer_curr);
        chan.buffer_curr += buffer.length - id - 1;
       }
       break;
    }
    return 0;
   }
   function caml_ml_output_bytes(chanid, buffer, offset, len){
    var buffer = caml_uint8_array_of_bytes(buffer);
    return caml_ml_output_ta(chanid, buffer, offset, len);
   }
   function caml_ml_output(chanid, buffer, offset, len){
    return caml_ml_output_bytes
            (chanid, caml_bytes_of_string(buffer), offset, len);
   }
   function caml_ml_output_bigarray(chanid, buffer, offset, len){
    var buffer = caml_ba_to_typed_array(buffer);
    return caml_ml_output_ta(chanid, buffer, offset, len);
   }
   function caml_ml_output_char(chanid, c){
    var s = caml_string_of_jsbytes(String.fromCharCode(c));
    caml_ml_output(chanid, s, 0, 1);
    return 0;
   }
   function caml_ml_output_int(chanid, i){
    var
     arr = [i >> 24 & 0xFF, i >> 16 & 0xFF, i >> 8 & 0xFF, i & 0xFF],
     s = caml_string_of_array(arr);
    caml_ml_output(chanid, s, 0, 4);
    return 0;
   }
   function caml_pos_in(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.offset - (chan.buffer_max - chan.buffer_curr) | 0;
   }
   function caml_ml_pos_in(chanid){return caml_pos_in(chanid);}
   function caml_ml_pos_in_64(chanid){
    return caml_int64_of_float(caml_pos_in(chanid));
   }
   function caml_pos_out(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.offset + chan.buffer_curr;
   }
   function caml_ml_pos_out(chanid){return caml_pos_out(chanid);}
   function caml_ml_pos_out_64(chanid){
    return caml_int64_of_float(caml_pos_out(chanid));
   }
   function caml_ml_runtime_events_pause(){return 0;}
   function caml_ml_runtime_events_resume(){return 0;}
   function caml_ml_runtime_events_start(){return 0;}
   function caml_ml_runtime_warnings_enabled(_unit){return caml_runtime_warnings;
   }
   function caml_seek_in(chanid, pos){
    var chan = caml_ml_channel_get(chanid);
    if(chan.refill != null) caml_raise_sys_error("Illegal seek");
    if
     (pos >= chan.offset - chan.buffer_max && pos <= chan.offset
      && chan.file.flags.binary)
     chan.buffer_curr = chan.buffer_max - (chan.offset - pos);
    else{chan.offset = pos; chan.buffer_curr = 0; chan.buffer_max = 0;}
    return 0;
   }
   function caml_ml_seek_in(chanid, pos){return caml_seek_in(chanid, pos);}
   function caml_ml_seek_in_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_in(chanid, pos);
   }
   function caml_seek_out(chanid, pos){
    caml_ml_flush(chanid);
    var chan = caml_ml_channel_get(chanid);
    chan.offset = pos;
    return 0;
   }
   function caml_ml_seek_out(chanid, pos){return caml_seek_out(chanid, pos);}
   function caml_ml_seek_out_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_out(chanid, pos);
   }
   function caml_ml_set_binary_mode(chanid, mode){
    var chan = caml_ml_channel_get(chanid);
    chan.file.flags.text = ! mode;
    chan.file.flags.binary = mode;
    return 0;
   }
   function caml_ml_set_buffered(chanid, v){
    caml_ml_channel_get(chanid).buffered = v;
    if(! v) caml_ml_flush(chanid);
    return 0;
   }
   function caml_ml_set_channel_name(chanid, name){
    var chan = caml_ml_channel_get(chanid);
    chan.name = name;
    return 0;
   }
   function caml_ml_set_channel_output(chanid, f){
    var chan = caml_ml_channel_get(chanid);
    chan.output = function(s){f(s);};
    return 0;
   }
   function caml_ml_set_channel_refill(chanid, f){
    caml_ml_channel_get(chanid).refill = f;
    return 0;
   }
   function caml_mod(x, y){if(y == 0) caml_raise_zero_divide(); return x % y;}
   function caml_modf_float(x){
    if(isFinite(x)){
     var neg = 1 / x < 0;
     x = Math.abs(x);
     var i = Math.floor(x), f = x - i;
     if(neg){i = - i; f = - f;}
     return [0, f, i];
    }
    if(isNaN(x)) return [0, NaN, NaN];
    return [0, 1 / x, x];
   }
   function caml_mount_autoload(name, f){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/"));
    jsoo_mount_point.push({path: name, device: new MlFakeDevice(name, f)});
    return 0;
   }
   function caml_lex_run_mem(s, i, mem, curr_pos){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst == 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src == 0xff)
      mem[dst + 1] = curr_pos;
     else
      mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_lex_run_tag(s, i, mem){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst == 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src == 0xff) mem[dst + 1] = - 1; else mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_new_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_mem = 10,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5,
     lex_base_code = 6,
     lex_backtrk_code = 7,
     lex_default_code = 8,
     lex_trans_code = 9,
     lex_check_code = 10,
     lex_code = 11;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    if(! tbl.lex_default_code){
     tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
     tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
     tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
     tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
     tbl.lex_default_code = caml_lex_array(tbl[lex_default_code]);
    }
    if(tbl.lex_code == null)
     tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
    var
     c,
     state = start_state,
     buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0){
      var pc_off = tbl.lex_base_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      return - base - 1;
     }
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      var pc_off = tbl.lex_backtrk_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] == 0) return - state - 1; else c = 256;
     else{c = buffer[lexbuf[lex_curr_pos]]; lexbuf[lex_curr_pos]++;}
     var pstate = state;
     if(tbl.lex_check[base + c] == state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] == - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else{
      var base_code = tbl.lex_base_code[pstate], pc_off;
      if(tbl.lex_check_code[base_code + c] == pstate)
       pc_off = tbl.lex_trans_code[base_code + c];
      else
       pc_off = tbl.lex_default_code[pstate];
      if(pc_off > 0)
       caml_lex_run_mem
        (tbl.lex_code, pc_off, lexbuf[lex_mem], lexbuf[lex_curr_pos]);
      if(c == 256) lexbuf[lex_eof_reached] = 0;
     }
    }
   }
   function caml_nextafter_float(x, y){
    if(isNaN(x) || isNaN(y)) return NaN;
    if(x == y) return y;
    if(x == 0) return y < 0 ? - Math.pow(2, - 1074) : Math.pow(2, - 1074);
    var bits = caml_int64_bits_of_float(x), one = caml_int64_of_int32(1);
    if(x < y == x > 0)
     bits = caml_int64_add(bits, one);
    else
     bits = caml_int64_sub(bits, one);
    return caml_int64_float_of_bits(bits);
   }
   function caml_notequal(x, y){
    return + (caml_compare_val(x, y, false) != 0);
   }
   function caml_obj_add_offset(v, offset){
    caml_failwith("Obj.add_offset is not supported");
   }
   function caml_obj_block(tag, size){
    var o = new Array(size + 1);
    o[0] = tag;
    for(var i = 1; i <= size; i++) o[i] = 0;
    return o;
   }
   function caml_obj_compare_and_swap(x, i, old, n){
    if(x[i + 1] == old){x[i + 1] = n; return 1;}
    return 0;
   }
   function caml_obj_is_block(x){return + (x instanceof Array);}
   function caml_obj_is_shared(x){return 1;}
   function caml_obj_make_forward(b, v){b[0] = 250; b[1] = v; return 0;}
   function caml_obj_raw_field(o, i){return o[i + 1];}
   function caml_obj_reachable_words(o){return 0;}
   function caml_obj_set_raw_field(o, i, v){return o[i + 1] = v;}
   function caml_obj_set_tag(x, tag){x[0] = tag; return 0;}
   function caml_obj_truncate(x, s){
    if(s <= 0 || s + 1 > x.length) caml_invalid_argument("Obj.truncate");
    if(x.length != s + 1) x.length = s + 1;
    return 0;
   }
   function caml_obj_with_tag(tag, x){
    var l = x.length, a = new Array(l);
    a[0] = tag;
    for(var i = 1; i < l; i++) a[i] = x[i];
    return a;
   }
   function caml_ojs_iterate_properties(o, f){
    var name;
    for(name in o) if(o.hasOwnProperty(name)) f(name);
   }
   function caml_ojs_new_arr(c, a){
    switch(a.length){
      case 0:
       return new c;
      case 1:
       return new c(a[0]);
      case 2:
       return new c(a[0], a[1]);
      case 3:
       return new c(a[0], a[1], a[2]);
      case 4:
       return new c(a[0], a[1], a[2], a[3]);
      case 5:
       return new c(a[0], a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);
    }
    function F(){return c.apply(this, a);}
    F.prototype = c.prototype;
    return new F;
   }
   function caml_ojs_wrap_fun_arguments(f){
    return function(){return caml_js_wrap_callback(f)(arguments);};
   }
   var
    caml_output_val =
      function(){
        function Writer(){this.chunk = [];}
        Writer.prototype =
         {chunk_idx: 20,
          block_len: 0,
          obj_counter: 0,
          size_32: 0,
          size_64: 0,
          write:
          function(size, value){
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[this.chunk_idx++] = value >> i & 0xFF;
          },
          write_at:
          function(pos, size, value){
           var pos = pos;
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[pos++] = value >> i & 0xFF;
          },
          write_code:
          function(size, code, value){
           this.chunk[this.chunk_idx++] = code;
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[this.chunk_idx++] = value >> i & 0xFF;
          },
          write_shared:
          function(offset){
           if(offset < 1 << 8)
            this.write_code(8, 0x04, offset);
           else if(offset < 1 << 16)
            this.write_code(16, 0x05, offset);
           else
            this.write_code(32, 0x06, offset);
          },
          pos: function(){return this.chunk_idx;},
          finalize:
          function(){
           this.block_len = this.chunk_idx - 20;
           this.chunk_idx = 0;
           this.write(32, 0x8495A6BE);
           this.write(32, this.block_len);
           this.write(32, this.obj_counter);
           this.write(32, this.size_32);
           this.write(32, this.size_64);
           return this.chunk;
          }};
        return function(v, flags){
         flags = caml_list_to_js_array(flags);
         var
          no_sharing = flags.indexOf(0) !== - 1,
          closures = flags.indexOf(1) !== - 1;
         if(closures)
          console.warn
           ("in caml_output_val: flag Marshal.Closures is not supported.");
         var
          writer = new Writer(),
          stack = [],
          intern_obj_table = no_sharing ? null : new MlObjectTable();
         function memo(v){
          if(no_sharing) return false;
          var existing_offset = intern_obj_table.recall(v);
          if(existing_offset){
           writer.write_shared(existing_offset);
           return true;
          }
          else{intern_obj_table.store(v); return false;}
         }
         function extern_rec(v){
          if(v.caml_custom){
           if(memo(v)) return;
           var
            name = v.caml_custom,
            ops = caml_custom_ops[name],
            sz_32_64 = [0, 0];
           if(! ops.serialize)
            caml_invalid_argument("output_value: abstract value (Custom)");
           if(ops.fixed_length == undefined){
            writer.write(8, 0x18);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            var header_pos = writer.pos();
            for(var i = 0; i < 12; i++) writer.write(8, 0);
            ops.serialize(writer, v, sz_32_64);
            writer.write_at(header_pos, 32, sz_32_64[0]);
            writer.write_at(header_pos + 4, 32, 0);
            writer.write_at(header_pos + 8, 32, sz_32_64[1]);
           }
           else{
            writer.write(8, 0x19);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            var old_pos = writer.pos();
            ops.serialize(writer, v, sz_32_64);
            if(ops.fixed_length != writer.pos() - old_pos)
             caml_failwith
              ("output_value: incorrect fixed sizes specified by " + name);
           }
           writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
           writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3);
          }
          else if(v instanceof Array && v[0] === (v[0] | 0)){
           if(v[0] == 251)
            caml_failwith("output_value: abstract value (Abstract)");
           if(caml_is_continuation_tag(v[0]))
            caml_invalid_argument("output_value: continuation value");
           if(v.length > 1 && memo(v)) return;
           if(v[0] < 16 && v.length - 1 < 8)
            writer.write(8, 0x80 + v[0] + (v.length - 1 << 4));
           else
            writer.write_code(32, 0x08, v.length - 1 << 10 | v[0]);
           writer.size_32 += v.length;
           writer.size_64 += v.length;
           if(v.length > 1) stack.push(v, 1);
          }
          else if(caml_is_ml_bytes(v)){
           if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
            caml_failwith
             ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
           if(memo(v)) return;
           var len = caml_ml_bytes_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0A, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_bytes_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(caml_is_ml_string(v)){
           if(memo(v)) return;
           var len = caml_ml_string_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0A, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_string_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(v != (v | 0)){
           var type_of_v = typeof v;
           if(type_of_v != "number")
            caml_failwith("output_value: abstract value (" + type_of_v + ")");
           if(memo(v)) return;
           var t = caml_int64_to_bytes(caml_int64_bits_of_float(v));
           writer.write(8, 0x0C);
           for(var i = 0; i < 8; i++) writer.write(8, t[7 - i]);
           writer.size_32 += 3;
           writer.size_64 += 2;
          }
          else if(v >= 0 && v < 0x40)
           writer.write(8, 0X40 + v);
          else if(v >= - (1 << 7) && v < 1 << 7)
           writer.write_code(8, 0x00, v);
          else if(v >= - (1 << 15) && v < 1 << 15)
           writer.write_code(16, 0x01, v);
          else
           writer.write_code(32, 0x02, v);
         }
         extern_rec(v);
         while(stack.length > 0){
          var i = stack.pop(), v = stack.pop();
          if(i + 1 < v.length) stack.push(v, i + 1);
          extern_rec(v[i]);
         }
         if(intern_obj_table)
          writer.obj_counter = intern_obj_table.objs.length;
         writer.finalize();
         return writer.chunk;};
       }
       ();
   function caml_output_value_to_string(v, flags){
    return caml_string_of_array(caml_output_val(v, flags));
   }
   function caml_output_value(chanid, v, flags){
    var s = caml_output_value_to_string(v, flags);
    caml_ml_output(chanid, s, 0, caml_ml_string_length(s));
    return 0;
   }
   function caml_output_value_to_buffer(s, ofs, len, v, flags){
    var t = caml_output_val(v, flags);
    if(t.length > len) caml_failwith("Marshal.to_buffer: buffer overflow");
    caml_blit_bytes(t, 0, s, ofs, t.length);
    return 0;
   }
   function caml_output_value_to_bytes(v, flags){
    return caml_bytes_of_array(caml_output_val(v, flags));
   }
   var caml_parser_trace = 0;
   function caml_parse_engine(tables, env, cmd, arg){
    var
     ERRCODE = 256,
     loop = 6,
     testshift = 7,
     shift = 8,
     shift_recover = 9,
     reduce = 10,
     READ_TOKEN = 0,
     RAISE_PARSE_ERROR = 1,
     GROW_STACKS_1 = 2,
     GROW_STACKS_2 = 3,
     COMPUTE_SEMANTIC_ACTION = 4,
     CALL_ERROR_FUNCTION = 5,
     env_s_stack = 1,
     env_v_stack = 2,
     env_symb_start_stack = 3,
     env_symb_end_stack = 4,
     env_stacksize = 5,
     env_stackbase = 6,
     env_curr_char = 7,
     env_lval = 8,
     env_symb_start = 9,
     env_symb_end = 10,
     env_asp = 11,
     env_rule_len = 12,
     env_rule_number = 13,
     env_sp = 14,
     env_state = 15,
     env_errflag = 16,
     tbl_transl_const = 2,
     tbl_transl_block = 3,
     tbl_lhs = 4,
     tbl_len = 5,
     tbl_defred = 6,
     tbl_dgoto = 7,
     tbl_sindex = 8,
     tbl_rindex = 9,
     tbl_gindex = 10,
     tbl_tablesize = 11,
     tbl_table = 12,
     tbl_check = 13,
     tbl_names_const = 15,
     tbl_names_block = 16;
    function log(x){
     var s = caml_string_of_jsbytes(x + "\n");
     caml_ml_output(2, s, 0, caml_ml_string_length(s));
    }
    function token_name(names, number){
     var str = caml_jsstring_of_string(names);
     if(str[0] == "\x00") return "<unknown token>";
     return str.split("\x00")[number];
    }
    function print_token(state, tok){
     var token, kind;
     if(tok instanceof Array){
      token = token_name(tables[tbl_names_block], tok[0]);
      if(typeof tok[1] == "number")
       kind = "" + tok[1];
      else if(typeof tok[1] == "string")
       kind = tok[1];
      else if(tok[1] instanceof MlBytes)
       kind = caml_jsbytes_of_string(tok[1]);
      else
       kind = "_";
      log("State " + state + ": read token " + token + "(" + kind + ")");
     }
     else{
      token = token_name(tables[tbl_names_const], tok);
      log("State " + state + ": read token " + token);
     }
    }
    if(! tables.dgoto){
     tables.defred = caml_lex_array(tables[tbl_defred]);
     tables.sindex = caml_lex_array(tables[tbl_sindex]);
     tables.check = caml_lex_array(tables[tbl_check]);
     tables.rindex = caml_lex_array(tables[tbl_rindex]);
     tables.table = caml_lex_array(tables[tbl_table]);
     tables.len = caml_lex_array(tables[tbl_len]);
     tables.lhs = caml_lex_array(tables[tbl_lhs]);
     tables.gindex = caml_lex_array(tables[tbl_gindex]);
     tables.dgoto = caml_lex_array(tables[tbl_dgoto]);
    }
    var
     res = 0,
     n,
     n1,
     n2,
     state1,
     sp = env[env_sp],
     state = env[env_state],
     errflag = env[env_errflag];
    exit:
    for(;;)
     next:
     switch(cmd){
       case 0:
        state = 0; errflag = 0;
       case 6:
        n = tables.defred[state];
        if(n != 0){cmd = reduce; break;}
        if(env[env_curr_char] >= 0){cmd = testshift; break;}
        res = READ_TOKEN;
        break exit;
       case 1:
        if(arg instanceof Array){
         env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
         env[env_lval] = arg[1];
        }
        else{
         env[env_curr_char] = tables[tbl_transl_const][arg + 1];
         env[env_lval] = 0;
        }
        if(caml_parser_trace) print_token(state, arg);
       case 7:
        n1 = tables.sindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == env[env_curr_char]){cmd = shift; break;}
        n1 = tables.rindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == env[env_curr_char]){
         n = tables.table[n2];
         cmd = reduce;
         break;
        }
        if(errflag <= 0){res = CALL_ERROR_FUNCTION; break exit;}
       case 5:
        if(errflag < 3){
         errflag = 3;
         for(;;){
          state1 = env[env_s_stack][sp + 1];
          n1 = tables.sindex[state1];
          n2 = n1 + ERRCODE;
          if
           (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
            && tables.check[n2] == ERRCODE){
           if(caml_parser_trace) log("Recovering in state " + state1);
           cmd = shift_recover;
           break next;
          }
          else{
           if(caml_parser_trace) log("Discarding state " + state1);
           if(sp <= env[env_stackbase]){
            if(caml_parser_trace) log("No more states to discard");
            return RAISE_PARSE_ERROR;
           }
           sp--;
          }
         }
        }
        else{
         if(env[env_curr_char] == 0) return RAISE_PARSE_ERROR;
         if(caml_parser_trace) log("Discarding last token read");
         env[env_curr_char] = - 1;
         cmd = loop;
         break;
        }
       case 8:
        env[env_curr_char] = - 1; if(errflag > 0) errflag--;
       case 9:
        if(caml_parser_trace)
         log("State " + state + ": shift to state " + tables.table[n2]);
        state = tables.table[n2];
        sp++;
        if(sp >= env[env_stacksize]){res = GROW_STACKS_1; break exit;}
       case 2:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = env[env_lval];
        env[env_symb_start_stack][sp + 1] = env[env_symb_start];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end];
        cmd = loop;
        break;
       case 10:
        if(caml_parser_trace) log("State " + state + ": reduce by rule " + n);
        var m = tables.len[n];
        env[env_asp] = sp;
        env[env_rule_number] = n;
        env[env_rule_len] = m;
        sp = sp - m + 1;
        m = tables.lhs[n];
        state1 = env[env_s_stack][sp];
        n1 = tables.gindex[m];
        n2 = n1 + state1;
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == state1)
         state = tables.table[n2];
        else
         state = tables.dgoto[m];
        if(sp >= env[env_stacksize]){res = GROW_STACKS_2; break exit;}
       case 3:
        res = COMPUTE_SEMANTIC_ACTION; break exit;
       case 4:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = arg;
        var asp = env[env_asp];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        if(sp > asp)
         env[env_symb_start_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        cmd = loop;
        break;
       default: return RAISE_PARSE_ERROR;
     }
    env[env_sp] = sp;
    env[env_state] = state;
    env[env_errflag] = errflag;
    return res;
   }
   function caml_pure_js_expr(s){
    console.error("caml_pure_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_raise_not_a_dir(name){
    caml_raise_sys_error(name + ": Not a directory");
   }
   function caml_raise_not_found(){
    caml_raise_constant(caml_global_data.Not_found);
   }
   function caml_raw_backtrace_length(){return 0;}
   function caml_raw_backtrace_next_slot(){return 0;}
   function caml_raw_backtrace_slot(){
    caml_invalid_argument
     ("Printexc.get_raw_backtrace_slot: index out of bounds");
   }
   function caml_read_file_content(name){
    var
     name = typeof name == "string" ? caml_string_of_jsbytes(name) : name,
     root = resolve_fs_device(name);
    if(root.device.exists(root.rest)){
     var
      file = root.device.open(root.rest, {rdonly: 1}),
      len = file.length(),
      buf = new Uint8Array(len);
     file.read(0, buf, 0, len);
     return caml_string_of_array(buf);
    }
    caml_raise_no_such_file(caml_jsbytes_of_string(name));
   }
   function caml_recommended_domain_count(unit){return 1;}
   function caml_record_backtrace(b){
    caml_record_backtrace_flag = b;
    return 0;
   }
   function caml_register_channel_for_spacetime(_channel){return 0;}
   function caml_register_global(n, v, name_opt){
    if(name_opt){
     var name = name_opt;
     if(globalThis.toplevelReloc)
      n = caml_callback(globalThis.toplevelReloc, [name]);
     else if(caml_global_data.symbols){
      if(! caml_global_data.symidx)
       caml_global_data.symidx = caml_build_symbols(caml_global_data.symbols);
      var nid = caml_global_data.symidx[name];
      if(nid >= 0)
       n = nid;
      else
       caml_failwith("caml_register_global: cannot locate " + name);
     }
    }
    caml_global_data[n + 1] = v;
    if(name_opt) caml_global_data[name_opt] = v;
   }
   function caml_register_named_value(nm, v){
    caml_named_values[caml_jsbytes_of_string(nm)] = v;
    return 0;
   }
   function caml_restore_raw_backtrace(exn, bt){return 0;}
   function caml_round_float(x){
    if(x >= 0){
     var y = Math.floor(x);
     return x - y >= 0.5 ? y + 1 : y;
    }
    else{var y = Math.ceil(x); return y - x >= 0.5 ? y - 1 : y;}
   }
   function caml_runtime_events_create_cursor(target){return {};}
   function caml_runtime_events_free_cursor(cursor){return 0;}
   function caml_runtime_events_read_poll(cursor, callbacks, num){return 0;}
   function caml_runtime_events_user_register
   (event_name, event_tag, event_type){
    caml_custom_event_index += 1;
    return [0, caml_custom_event_index, event_name, event_type, event_tag];
   }
   function caml_runtime_events_user_resolve(){return 0;}
   function caml_runtime_events_user_write(event, event_content){return 0;}
   function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("");}
   function caml_runtime_variant(_unit){return caml_string_of_jsbytes("");}
   function caml_set_oo_id(b){b[2] = caml_oo_last_id++; return b;}
   function caml_set_parser_trace(bool){
    var oldflag = caml_parser_trace;
    caml_parser_trace = bool;
    return oldflag;
   }
   function caml_set_static_env(k, v){
    if(! globalThis.jsoo_static_env) globalThis.jsoo_static_env = {};
    globalThis.jsoo_static_env[k] = v;
    return 0;
   }
   function caml_signbit_float(x){if(x == 0) x = 1 / x; return x < 0 ? 1 : 0;}
   function caml_sinh_float(x){return Math.sinh(x);}
   function caml_spacetime_enabled(_unit){return 0;}
   function caml_spacetime_only_works_for_native_code(){
    caml_failwith("Spacetime profiling only works for native code");
   }
   function caml_str_initialize(unit){return 0;}
   function caml_string_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_string_concat(a, b){return a + b;}
   function caml_string_equal(s1, s2){if(s1 === s2) return 1; return 0;}
   function caml_string_get(s, i){
    if(i >>> 0 >= caml_ml_string_length(s)) caml_string_bound_error();
    return caml_string_unsafe_get(s, i);
   }
   function caml_string_get16(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 1) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function caml_string_get32(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 3) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1),
     b3 = caml_string_unsafe_get(s, i + 2),
     b4 = caml_string_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_string_get64(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 7) caml_string_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_string_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   function caml_string_lessequal(s1, s2){return s1 <= s2 ? 1 : 0;}
   function caml_string_greaterequal(s1, s2){return caml_string_lessequal(s2, s1);
   }
   function caml_string_lessthan(s1, s2){return s1 < s2 ? 1 : 0;}
   function caml_string_greaterthan(s1, s2){return caml_string_lessthan(s2, s1);
   }
   function caml_string_hash(h, v){
    var h = caml_hash_mix_string(h, v), h = caml_hash_mix_final(h);
    return h & 0x3FFFFFFF;
   }
   function caml_string_notequal(s1, s2){
    return 1 - caml_string_equal(s1, s2);
   }
   function caml_string_set(s, i, c){caml_failwith("caml_string_set");}
   function caml_string_set16(s, i, i16){caml_failwith("caml_string_set16");}
   function caml_string_set32(s, i, i32){caml_failwith("caml_string_set32");}
   function caml_string_set64(s, i, i64){caml_failwith("caml_string_set64");}
   function caml_string_unsafe_set(s, i, c){
    caml_failwith("caml_string_unsafe_set");
   }
   function caml_sys_argv(a){return caml_argv;}
   function caml_sys_chdir(dir){
    var root = resolve_fs_device(dir);
    if(root.device.exists(root.rest)){
     if(root.rest)
      caml_current_dir = caml_trailing_slash(root.path + root.rest);
     else
      caml_current_dir = root.path;
     return 0;
    }
    else
     caml_raise_no_such_file(caml_jsbytes_of_string(dir));
   }
   function caml_sys_const_backend_type(){
    return [0, caml_string_of_jsbytes("js_of_ocaml")];
   }
   function caml_sys_const_big_endian(){return 0;}
   function caml_sys_const_int_size(){return 32;}
   function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0;}
   function caml_sys_const_naked_pointers_checked(_unit){return 0;}
   var
    os_type =
      globalThis.process && globalThis.process.platform
       && globalThis.process.platform == "win32"
       ? "Cygwin"
       : "Unix";
   function caml_sys_const_ostype_cygwin(){return os_type == "Cygwin" ? 1 : 0;
   }
   function caml_sys_const_ostype_unix(){return os_type == "Unix" ? 1 : 0;}
   function caml_sys_const_ostype_win32(){return os_type == "Win32" ? 1 : 0;}
   function caml_sys_const_word_size(){return 32;}
   function caml_sys_executable_name(a){return caml_executable_name;}
   function caml_sys_exit(code){
    if(globalThis.quit) globalThis.quit(code);
    if(globalThis.process && globalThis.process.exit)
     globalThis.process.exit(code);
    caml_invalid_argument("Function 'exit' not implemented");
   }
   function caml_sys_file_exists(name){
    var root = resolve_fs_device(name);
    return root.device.exists(root.rest);
   }
   function caml_sys_get_argv(a){return [0, caml_argv[1], caml_argv];}
   function caml_sys_get_config(){
    return [0, caml_string_of_jsbytes(os_type), 32, 0];
   }
   function caml_sys_getcwd(){
    return caml_string_of_jsbytes(caml_current_dir);
   }
   function caml_sys_getenv(name){
    var r = jsoo_sys_getenv(caml_jsstring_of_string(name));
    if(r === undefined) caml_raise_not_found();
    return caml_string_of_jsstring(r);
   }
   function caml_sys_is_directory(name){
    var root = resolve_fs_device(name), a = root.device.is_dir(root.rest);
    return a ? 1 : 0;
   }
   function caml_sys_is_regular_file(name){
    var root = resolve_fs_device(name);
    return root.device.isFile(root.rest);
   }
   function caml_sys_isatty(_chan){return 0;}
   function caml_sys_mkdir(name, perm){
    var root = resolve_fs_device(name);
    root.device.mkdir(root.rest, perm);
    return 0;
   }
   function caml_sys_modify_argv(arg){caml_argv = arg; return 0;}
   function caml_sys_random_seed(){
    if(globalThis.crypto)
     if(globalThis.crypto.getRandomValues){
      var a = globalThis.crypto.getRandomValues(new Int32Array(4));
      return [0, a[0], a[1], a[2], a[3]];
     }
     else if(globalThis.crypto.randomBytes){
      var a = new Int32Array(globalThis.crypto.randomBytes(16).buffer);
      return [0, a[0], a[1], a[2], a[3]];
     }
    var now = new Date().getTime(), x = now ^ 0xffffffff * Math.random();
    return [0, x];
   }
   function caml_sys_read_directory(name){
    var
     root = resolve_fs_device(name),
     a = root.device.readdir(root.rest),
     l = new Array(a.length + 1);
    l[0] = 0;
    for(var i = 0; i < a.length; i++) l[i + 1] = caml_string_of_jsbytes(a[i]);
    return l;
   }
   function caml_sys_remove(name){
    var root = resolve_fs_device(name), ok = root.device.unlink(root.rest);
    if(ok == 0) caml_raise_no_such_file(caml_jsbytes_of_string(name));
    return 0;
   }
   function caml_sys_rename(o, n){
    var o_root = resolve_fs_device(o), n_root = resolve_fs_device(n);
    if(o_root.device != n_root.device)
     caml_failwith("caml_sys_rename: cannot move file between two filesystem");
    if(! o_root.device.rename)
     caml_failwith("caml_sys_rename: no implemented");
    o_root.device.rename(o_root.rest, n_root.rest);
   }
   function caml_sys_rmdir(name){
    var root = resolve_fs_device(name);
    root.device.rmdir(root.rest);
    return 0;
   }
   function caml_sys_system_command(cmd){
    var cmd = caml_jsstring_of_string(cmd);
    if(typeof require != "undefined"){
     var child_process = require("child_process");
     if(child_process && child_process.execSync)
      try{child_process.execSync(cmd, {stdio: "inherit"}); return 0;}
      catch(e){return 1;}
    }
    else
     return 127;
   }
   var caml_initial_time = new Date().getTime() * 0.001;
   function caml_sys_time(){
    var now = new Date().getTime();
    return now * 0.001 - caml_initial_time;
   }
   function caml_sys_time_include_children(b){return caml_sys_time();}
   function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name);}
   function caml_tanh_float(x){return Math.tanh(x);}
   function caml_to_js_string(s){return caml_jsstring_of_string(s);}
   function caml_trampoline(res){
    var c = 1;
    while(res && res.joo_tramp){
     res = res.joo_tramp.apply(null, res.joo_args);
     c++;
    }
    return res;
   }
   function caml_trampoline_return(f, args){return {joo_tramp: f, joo_args: args};
   }
   function caml_trunc_float(x){return Math.trunc(x);}
   function caml_unix_cleanup(){}
   function caml_unix_closedir(dir_handle){
    try{dir_handle.pointer.closeSync();}
    catch(e){
     var unix_error = caml_named_value("Unix.Unix_error");
     caml_raise_with_args
      (unix_error, make_unix_err_args("EBADF", "closedir", dir_handle.path));
    }
   }
   function caml_unix_filedescr_of_fd(x){return x;}
   function caml_unix_findclose(dir_handle){return caml_unix_closedir(dir_handle);
   }
   function caml_unix_opendir(path){
    var root = resolve_fs_device(path);
    if(! root.device.opendir)
     caml_failwith("caml_unix_opendir: not implemented");
    var dir_handle = root.device.opendir(root.rest, true);
    return {pointer: dir_handle, path: path};
   }
   function caml_unix_readdir(dir_handle){
    var entry;
    try{entry = dir_handle.pointer.readSync();}
    catch(e){
     var unix_error = caml_named_value("Unix.Unix_error");
     caml_raise_with_args
      (unix_error, make_unix_err_args("EBADF", "readdir", dir_handle.path));
    }
    if(entry === null)
     caml_raise_end_of_file();
    else
     return caml_string_of_jsstring(entry.name);
   }
   function caml_unix_findfirst(path){
    var path_js = caml_jsstring_of_string(path);
    path_js = path_js.replace(/(^|[\\\/])\*\.\*$/, "");
    path = caml_string_of_jsstring(path_js);
    var
     dir_handle = caml_unix_opendir(path),
     first_entry = caml_unix_readdir(dir_handle);
    return [0, first_entry, dir_handle];
   }
   function caml_unix_findnext(dir_handle){return caml_unix_readdir(dir_handle);
   }
   function caml_unix_getpwuid(unit){caml_raise_not_found();}
   function caml_unix_gettimeofday(){return new Date().getTime() / 1000;}
   function caml_unix_getuid(unit){
    if(globalThis.process && globalThis.process.getuid)
     return globalThis.process.getuid();
    caml_raise_not_found();
   }
   function caml_unix_gmtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(Date.UTC(d.getUTCFullYear(), 0, 1)).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000);
    return [0,
            d.getUTCSeconds(),
            d.getUTCMinutes(),
            d.getUTCHours(),
            d.getUTCDate(),
            d.getUTCMonth(),
            d.getUTCFullYear() - 1900,
            d.getUTCDay(),
            doy,
            false | 0];
   }
   function caml_unix_has_symlink(unit){return fs_node_supported() ? 1 : 0;}
   function caml_unix_inet_addr_of_string(){return 0;}
   function caml_unix_isatty(fileDescriptor){
    if(fs_node_supported()){
     var tty = require("tty");
     return tty.isatty(fileDescriptor) ? 1 : 0;
    }
    else
     return 0;
   }
   function caml_unix_localtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(d.getFullYear(), 0, 1).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000),
     jan = new Date(d.getFullYear(), 0, 1),
     jul = new Date(d.getFullYear(), 6, 1),
     stdTimezoneOffset =
       Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    return [0,
            d.getSeconds(),
            d.getMinutes(),
            d.getHours(),
            d.getDate(),
            d.getMonth(),
            d.getFullYear() - 1900,
            d.getDay(),
            doy,
            d.getTimezoneOffset() < stdTimezoneOffset | 0];
   }
   function caml_unix_lstat(name){
    var root = resolve_fs_device(name);
    if(! root.device.lstat) caml_failwith("caml_unix_lstat: not implemented");
    return root.device.lstat(root.rest, true);
   }
   function caml_unix_lstat_64(name){
    var r = caml_unix_lstat(name);
    r[9] = caml_int64_of_int32(r[9]);
    return r;
   }
   function caml_unix_mkdir(name, perm){
    var root = resolve_fs_device(name);
    if(! root.device.mkdir) caml_failwith("caml_unix_mkdir: not implemented");
    return root.device.mkdir(root.rest, perm, true);
   }
   function caml_unix_mktime(tm){
    var
     d = new Date(tm[6] + 1900, tm[5], tm[4], tm[3], tm[2], tm[1]).getTime(),
     t = Math.floor(d / 1000),
     tm2 = caml_unix_localtime(t);
    return [0, t, tm2];
   }
   function caml_unix_readlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.readlink)
     caml_failwith("caml_unix_readlink: not implemented");
    return root.device.readlink(root.rest, true);
   }
   function caml_unix_rewinddir(dir_handle){
    caml_unix_closedir(dir_handle);
    var new_dir_handle = caml_unix_opendir(dir_handle.path);
    dir_handle.pointer = new_dir_handle.pointer;
    return 0;
   }
   function caml_unix_rmdir(name){
    var root = resolve_fs_device(name);
    if(! root.device.rmdir) caml_failwith("caml_unix_rmdir: not implemented");
    return root.device.rmdir(root.rest, true);
   }
   function caml_unix_startup(){}
   function caml_unix_stat(name){
    var root = resolve_fs_device(name);
    if(! root.device.stat) caml_failwith("caml_unix_stat: not implemented");
    return root.device.stat(root.rest, true);
   }
   function caml_unix_stat_64(name){
    var r = caml_unix_stat(name);
    r[9] = caml_int64_of_int32(r[9]);
    return r;
   }
   function caml_unix_symlink(to_dir, src, dst){
    var src_root = resolve_fs_device(src), dst_root = resolve_fs_device(dst);
    if(src_root.device != dst_root.device)
     caml_failwith
      ("caml_unix_symlink: cannot symlink between two filesystems");
    if(! src_root.device.symlink)
     caml_failwith("caml_unix_symlink: not implemented");
    return src_root.device.symlink(to_dir, src_root.rest, dst_root.rest, true);
   }
   function caml_unix_time(){return Math.floor(caml_unix_gettimeofday());}
   function caml_unix_unlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.unlink)
     caml_failwith("caml_unix_unlink: not implemented");
    return root.device.unlink(root.rest, true);
   }
   function caml_unmount(name){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/")),
     idx = - 1;
    for(var i = 0; i < jsoo_mount_point.length; i++)
     if(jsoo_mount_point[i].path == name) idx = i;
    if(idx > - 1) jsoo_mount_point.splice(idx, 1);
    return 0;
   }
   function caml_update_dummy(x, y){
    if(y.fun){x.fun = y.fun; return 0;}
    if(typeof y === "function"){x.fun = y; return 0;}
    var i = y.length;
    while(i--) x[i] = y[i];
    return 0;
   }
   function caml_weak_set(x, i, v){
    if(v == 0) caml_ephe_unset_key(x, i); else caml_ephe_set_key(x, i, v[1]);
    return 0;
   }
   function caml_wrap_exception(e){
    {
     if(e instanceof Array) return e;
     var exn;
     if
      (globalThis.RangeError && e instanceof globalThis.RangeError
       && e.message
       && e.message.match(/maximum call stack/i))
      exn = caml_global_data.Stack_overflow;
     else if
      (globalThis.InternalError && e instanceof globalThis.InternalError
       && e.message
       && e.message.match(/too much recursion/i))
      exn = caml_global_data.Stack_overflow;
     else if(e instanceof globalThis.Error && caml_named_value("jsError"))
      exn = [0, caml_named_value("jsError"), e];
     else
      exn = [0, caml_global_data.Failure, caml_string_of_jsstring(String(e))];
     if(e instanceof globalThis.Error) exn.js_error = e;
     return exn;
    }
   }
   function caml_xmlhttprequest_create(unit){
    if(typeof globalThis.XMLHttpRequest !== "undefined")
     try{return new globalThis.XMLHttpRequest;}catch(e){}
    if(typeof globalThis.activeXObject !== "undefined"){
     try{return new globalThis.activeXObject("Msxml2.XMLHTTP");}catch(e){}
     try{return new globalThis.activeXObject("Msxml3.XMLHTTP");}catch(e){}
     try{return new globalThis.activeXObject("Microsoft.XMLHTTP");}catch(e){}
    }
    caml_failwith("Cannot create a XMLHttpRequest");
   }
   function compare_digits_nat(nat1, ofs1, nat2, ofs2){
    if(nat1.data[ofs1] > nat2.data[ofs2]) return 1;
    if(nat1.data[ofs1] < nat2.data[ofs2]) return - 1;
    return 0;
   }
   function compare_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var
     a = num_digits_nat(nat1, ofs1, len1),
     b = num_digits_nat(nat2, ofs2, len2);
    if(a > b) return 1;
    if(a < b) return - 1;
    for(var i = len1 - 1; i >= 0; i--){
     if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0) return 1;
     if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0) return - 1;
    }
    return 0;
   }
   function compare_nat_real(nat1, nat2){
    return compare_nat(nat1, 0, nat1.data.length, nat2, 0, nat2.data.length);
   }
   function complement_nat(nat, ofs, len){
    for(var i = 0; i < len; i++)
     nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0);
   }
   function create_nat(size){
    var arr = new MlNat(size);
    for(var i = 0; i < size; i++) arr.data[i] = - 1;
    return arr;
   }
   function decr_nat(nat, ofs, len, carry_in){
    var borrow = carry_in == 1 ? 0 : 1;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) - borrow;
     nat.data[ofs + i] = x;
     if(x >= 0){borrow = 0; break;} else borrow = 1;
    }
    return borrow == 1 ? 0 : 1;
   }
   function deserialize_nat(reader, sz){
    var len = reader.read32s(), nat = new MlNat(len);
    for(var i = 0; i < len; i++) nat.data[i] = reader.read32s();
    sz[0] = len * 4;
    return nat;
   }
   function div_helper(a, b, c){
    var
     x = a * 65536 + (b >>> 16),
     y = Math.floor(x / c) * 65536,
     z = x % c * 65536,
     w = z + (b & 0x0000FFFF);
    return [y + Math.floor(w / c), w % c];
   }
   function div_digit_nat(natq, ofsq, natr, ofsr, nat1, ofs1, len, nat2, ofs2){
    var rem = nat1.data[ofs1 + len - 1] >>> 0;
    for(var i = len - 2; i >= 0; i--){
     var
      x = div_helper(rem, nat1.data[ofs1 + i] >>> 0, nat2.data[ofs2] >>> 0);
     natq.data[ofsq + i] = x[0];
     rem = x[1];
    }
    natr.data[ofsr] = rem;
    return 0;
   }
   function num_leading_zero_bits_in_digit(nat, ofs){
    var a = nat.data[ofs], b = 0;
    if(a & 0xFFFF0000){b += 16; a >>>= 16;}
    if(a & 0xFF00){b += 8; a >>>= 8;}
    if(a & 0xF0){b += 4; a >>>= 4;}
    if(a & 12){b += 2; a >>>= 2;}
    if(a & 2){b += 1; a >>>= 1;}
    if(a & 1) b += 1;
    return 32 - b;
   }
   function shift_left_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits == 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = 0; i < len1; i++){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a << nbits | wrap;
     wrap = a >>> 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   function shift_right_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits == 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = len1 - 1; i >= 0; i--){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a >>> nbits | wrap;
     wrap = a << 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   function set_to_zero_nat(nat, ofs, len){
    for(var i = 0; i < len; i++) nat.data[ofs + i] = 0;
    return 0;
   }
   function nat_of_array(l){return new MlNat(l);}
   function mult_digit_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3){
    var carry = 0, a = nat3.data[ofs3] >>> 0;
    for(var i = 0; i < len2; i++){
     var
      x1 =
        (nat1.data[ofs1 + i] >>> 0)
        + (nat2.data[ofs2 + i] >>> 0) * (a & 0x0000FFFF)
        + carry,
      x2 = (nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
     carry = Math.floor(x2 / 65536);
     var x3 = x1 + x2 % 65536 * 65536;
     nat1.data[ofs1 + i] = x3;
     carry += Math.floor(x3 / 4294967296);
    }
    return len2 < len1 && carry
            ? add_nat
              (nat1, ofs1 + len2, len1 - len2, nat_of_array([carry]), 0, 1, 0)
            : carry;
   }
   function sub_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var borrow = carry_in == 1 ? 0 : 1;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
     nat1.data[ofs1 + i] = x;
     if(x >= 0) borrow = 0; else borrow = 1;
    }
    return decr_nat(nat1, ofs1 + len2, len1 - len2, borrow == 1 ? 0 : 1);
   }
   function div_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    if(len2 == 1){
     div_digit_nat(nat1, ofs1 + 1, nat1, ofs1, nat1, ofs1, len1, nat2, ofs2);
     return 0;
    }
    var s = num_leading_zero_bits_in_digit(nat2, ofs2 + len2 - 1);
    shift_left_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    shift_left_nat(nat1, ofs1, len1, nat_of_array([0]), 0, s);
    var d = (nat2.data[ofs2 + len2 - 1] >>> 0) + 1, a = create_nat(len2 + 1);
    for(var i = len1 - 1; i >= len2; i--){
     var
      quo =
        d == 4294967296
         ? nat1.data[ofs1 + i] >>> 0
         : div_helper
            (nat1.data[ofs1 + i] >>> 0, nat1.data[ofs1 + i - 1] >>> 0, d)
           [0];
     set_to_zero_nat(a, 0, len2 + 1);
     mult_digit_nat(a, 0, len2 + 1, nat2, ofs2, len2, nat_of_array([quo]), 0);
     sub_nat(nat1, ofs1 + i - len2, len2 + 1, a, 0, len2 + 1, 1);
     while
     (nat1.data[ofs1 + i] != 0
      || compare_nat(nat1, ofs1 + i - len2, len2, nat2, ofs2, len2) >= 0){
      quo = quo + 1;
      sub_nat(nat1, ofs1 + i - len2, len2 + 1, nat2, ofs2, len2, 1);
     }
     nat1.data[ofs1 + i] = quo;
    }
    shift_right_nat(nat1, ofs1, len2, nat_of_array([0]), 0, s);
    shift_right_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    return 0;
   }
   function serialize_nat(writer, nat, sz){
    var len = nat.data.length;
    writer.write(32, len);
    for(var i = 0; i < len; i++) writer.write(32, nat.data[i]);
    sz[0] = len * 4;
    sz[1] = len * 8;
   }
   function initialize_nat(){
    caml_custom_ops["_nat"] =
     {deserialize: deserialize_nat,
      serialize: serialize_nat,
      hash: caml_hash_nat};
   }
   function is_digit_int(nat, ofs){if(nat.data[ofs] >= 0) return 1; return 0;}
   function is_digit_odd(nat, ofs){if(nat.data[ofs] & 1) return 1; return 0;}
   function is_digit_zero(nat, ofs){
    if(nat.data[ofs] == 0) return 1;
    return 0;
   }
   function jsoo_create_file_extern(name, content){
    if(globalThis.jsoo_create_file)
     globalThis.jsoo_create_file(name, content);
    else{
     if(! globalThis.caml_fs_tmp) globalThis.caml_fs_tmp = [];
     globalThis.caml_fs_tmp.push({name: name, content: content});
    }
    return 0;
   }
   function jsoo_effect_not_supported(){
    caml_failwith("Effect handlers are not supported");
   }
   function land_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] &= nat2.data[ofs2]; return 0;
   }
   function length_nat(x){return x.data.length;}
   function lor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] |= nat2.data[ofs2]; return 0;
   }
   function lxor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] ^= nat2.data[ofs2]; return 0;
   }
   function mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3, len3){
    var carry = 0;
    for(var i = 0; i < len3; i++)
     carry +=
      mult_digit_nat
       (nat1, ofs1 + i, len1 - i, nat2, ofs2, len2, nat3, ofs3 + i);
    return carry;
   }
   function nth_digit_nat(nat, ofs){return nat.data[ofs];}
   function nth_digit_nat_native(nat, ofs){return nat.data[ofs];}
   var
    re_match =
      function(){
        var
         re_word_letters =
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
         opcodes =
           {CHAR: 0,
            CHARNORM: 1,
            STRING: 2,
            STRINGNORM: 3,
            CHARCLASS: 4,
            BOL: 5,
            EOL: 6,
            WORDBOUNDARY: 7,
            BEGGROUP: 8,
            ENDGROUP: 9,
            REFGROUP: 10,
            ACCEPT: 11,
            SIMPLEOPT: 12,
            SIMPLESTAR: 13,
            SIMPLEPLUS: 14,
            GOTO: 15,
            PUSHBACK: 16,
            SETMARK: 17,
            CHECKPROGRESS: 18};
        function is_word_letter(c){
         return re_word_letters[c >> 3] >> (c & 7) & 1;
        }
        function in_bitset(s, i){
         return caml_string_get(s, i >> 3) >> (i & 7) & 1;
        }
        function re_match_impl(re, s, pos, partial){
         var
          prog = caml_js_from_array(re[1]),
          cpool = caml_js_from_array(re[2]),
          normtable = caml_jsbytes_of_string(re[3]),
          numgroups = re[4] | 0,
          numregisters = re[5] | 0,
          startchars = re[6] | 0,
          s = caml_uint8_array_of_string(s),
          pc = 0,
          quit = false,
          stack = [],
          groups = new Array(numgroups),
          re_register = new Array(numregisters);
         for(var i = 0; i < groups.length; i++)
          groups[i] = {start: - 1, end: - 1};
         groups[0].start = pos;
         function backtrack(){
          while(stack.length){
           var item = stack.pop();
           if(item.undo)
            item.undo.obj[item.undo.prop] = item.undo.value;
           else if(item.pos){pc = item.pos.pc; pos = item.pos.txt; return;}
          }
          quit = true;
         }
         function push(item){stack.push(item);}
         function accept(){
          groups[0].end = pos;
          var result = new Array(1 + groups.length * 2);
          result[0] = 0;
          for(var i = 0; i < groups.length; i++){
           var g = groups[i];
           if(g.start < 0 || g.end < 0) g.start = g.end = - 1;
           result[2 * i + 1] = g.start;
           result[2 * i + 1 + 1] = g.end;
          }
          return result;
         }
         function prefix_match(){
          if(partial) return accept(); else backtrack();
         }
         while(! quit){
          var
           op = prog[pc] & 0xff,
           sarg = prog[pc] >> 8,
           uarg = sarg & 0xff,
           c = s[pos],
           group;
          pc++;
          switch(op){
            case opcodes.CHAR:
             if(pos === s.length){prefix_match(); break;}
             if(c === uarg) pos++; else backtrack();
             break;
            case opcodes.CHARNORM:
             if(pos === s.length){prefix_match(); break;}
             if(normtable.charCodeAt(c) === uarg) pos++; else backtrack();
             break;
            case opcodes.STRING:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(c === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.STRINGNORM:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(normtable.charCodeAt(c) === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.CHARCLASS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c)) pos++; else backtrack();
             break;
            case opcodes.BOL:
             if(pos > 0 && s[pos - 1] != 10) backtrack(); break;
            case opcodes.EOL:
             if(pos < s.length && s[pos] != 10) backtrack(); break;
            case opcodes.WORDBOUNDARY:
             if(pos == 0){
              if(pos === s.length){prefix_match(); break;}
              if(is_word_letter(s[0])) break;
              backtrack();
             }
             else if(pos === s.length){
              if(is_word_letter(s[pos - 1])) break;
              backtrack();
             }
             else{
              if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos])) break;
              backtrack();
             }
             break;
            case opcodes.BEGGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "start", value: group.start}});
             group.start = pos;
             break;
            case opcodes.ENDGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "end", value: group.end}});
             group.end = pos;
             break;
            case opcodes.REFGROUP:
             group = groups[uarg];
             if(group.start < 0 || group.end < 0){backtrack(); break;}
             for(var i = group.start; i < group.end; i++){
              if(pos === s.length){prefix_match(); break;}
              if(s[i] != s[pos]){backtrack(); break;}
              pos++;
             }
             break;
            case opcodes.SIMPLEOPT:
             if(in_bitset(cpool[uarg], c)) pos++; break;
            case opcodes.SIMPLESTAR:
             while(in_bitset(cpool[uarg], c)) c = s[++pos]; break;
            case opcodes.SIMPLEPLUS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c))
              do c = s[++pos];while(in_bitset(cpool[uarg], c));
             else
              backtrack();
             break;
            case opcodes.ACCEPT: return accept();
            case opcodes.GOTO:
             pc = pc + sarg; break;
            case opcodes.PUSHBACK:
             push({pos: {pc: pc + sarg, txt: pos}}); break;
            case opcodes.SETMARK:
             push
              ({undo: {obj: re_register, prop: uarg, value: re_register[uarg]}});
             re_register[uarg] = pos;
             break;
            case opcodes.CHECKPROGRESS:
             if(re_register[uarg] === pos) backtrack(); break;
            default: throw new Error("Invalid bytecode");
          }
         }
         return 0;
        }
        return re_match_impl;
       }
       ();
   function re_partial_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.partial_match");
    var res = re_match(re, s, pos, 1);
    return res ? res : [0];
   }
   function re_replacement_text(repl, groups, orig){
    var
     repl = caml_jsbytes_of_string(repl),
     len = repl.length,
     orig = caml_jsbytes_of_string(orig),
     res = "",
     n = 0,
     cur,
     start,
     end,
     c;
    while(n < len){
     cur = repl.charAt(n++);
     if(cur != "\\")
      res += cur;
     else{
      if(n == len) caml_failwith("Str.replace: illegal backslash sequence");
      cur = repl.charAt(n++);
      switch(cur){
        case "\\":
         res += cur; break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
         c = + cur;
         if(c * 2 >= groups.length - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         start = caml_array_get(groups, c * 2);
         end = caml_array_get(groups, c * 2 + 1);
         if(start == - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         res += orig.slice(start, end);
         break;
        default: res += "\\" + cur;
      }
     }
    }
    return caml_string_of_jsbytes(res);
   }
   function re_search_backward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_backward");
    while(pos >= 0){
     var res = re_match(re, s, pos, 0);
     if(res) return res;
     pos--;
    }
    return [0];
   }
   function re_search_forward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_forward");
    while(pos <= caml_ml_string_length(s)){
     var res = re_match(re, s, pos, 0);
     if(res) return res;
     pos++;
    }
    return [0];
   }
   function re_string_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.string_match");
    var res = re_match(re, s, pos, 0);
    return res ? res : [0];
   }
   function set_digit_nat(nat, ofs, digit){nat.data[ofs] = digit; return 0;}
   function set_digit_nat_native(nat, ofs, digit){nat.data[ofs] = digit; return 0;
   }
   function square_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var carry = 0;
    carry += add_nat(nat1, ofs1, len1, nat1, ofs1, len1, 0);
    carry += mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat2, ofs2, len2);
    return carry;
   }
   function caml_setup_uncaught_exception_handler(){
    var process = globalThis.process;
    if(process && process.on)
     process.on
      ("uncaughtException",
       function(err, origin){
        caml_fatal_uncaught_exception(err);
        process.exit(2);
       });
    else if(globalThis.addEventListener)
     globalThis.addEventListener
      ("error",
       function(event){
        if(event.error) caml_fatal_uncaught_exception(event.error);
       });
   }
   caml_setup_uncaught_exception_handler();
   globalThis.jsoo_runtime =
    {caml_ojs_iterate_properties: caml_ojs_iterate_properties,
     caml_ojs_wrap_fun_arguments: caml_ojs_wrap_fun_arguments,
     caml_runtime_events_read_poll: caml_runtime_events_read_poll,
     caml_runtime_events_free_cursor: caml_runtime_events_free_cursor,
     caml_runtime_events_create_cursor: caml_runtime_events_create_cursor,
     caml_ml_runtime_events_resume: caml_ml_runtime_events_resume,
     caml_ml_runtime_events_pause: caml_ml_runtime_events_pause,
     caml_ml_runtime_events_start: caml_ml_runtime_events_start,
     caml_runtime_events_user_resolve: caml_runtime_events_user_resolve,
     caml_runtime_events_user_write: caml_runtime_events_user_write,
     caml_runtime_events_user_register: caml_runtime_events_user_register,
     caml_custom_event_index: caml_custom_event_index,
     caml_decompress_input: caml_decompress_input,
     jsoo_effect_not_supported: jsoo_effect_not_supported,
     caml_ml_condition_signal: caml_ml_condition_signal,
     caml_ml_condition_broadcast: caml_ml_condition_broadcast,
     caml_ml_condition_wait: caml_ml_condition_wait,
     caml_ml_condition_new: caml_ml_condition_new,
     caml_get_continuation_callstack: caml_get_continuation_callstack,
     caml_continuation_use_and_update_handler_noexc:
     caml_continuation_use_and_update_handler_noexc,
     caml_continuation_use_noexc: caml_continuation_use_noexc,
     caml_alloc_stack: caml_alloc_stack,
     caml_ml_mutex_unlock: caml_ml_mutex_unlock,
     caml_ml_mutex_try_lock: caml_ml_mutex_try_lock,
     caml_ml_mutex_lock: caml_ml_mutex_lock,
     caml_ml_mutex_new: caml_ml_mutex_new,
     MlMutex: MlMutex,
     caml_lxm_next: caml_lxm_next,
     caml_ml_domain_cpu_relax: caml_ml_domain_cpu_relax,
     caml_ml_domain_id: caml_ml_domain_id,
     caml_domain_spawn: caml_domain_spawn,
     caml_domain_id: caml_domain_id,
     caml_recommended_domain_count: caml_recommended_domain_count,
     caml_ml_domain_set_name: caml_ml_domain_set_name,
     caml_ml_domain_unique_token: caml_ml_domain_unique_token,
     caml_atomic_make_contended: caml_atomic_make_contended,
     caml_atomic_exchange: caml_atomic_exchange,
     caml_atomic_fetch_add: caml_atomic_fetch_add,
     caml_atomic_cas: caml_atomic_cas,
     caml_atomic_load: caml_atomic_load,
     caml_domain_dls_get: caml_domain_dls_get,
     caml_domain_dls_set: caml_domain_dls_set,
     caml_domain_dls: caml_domain_dls,
     caml_ephe_check_data: caml_ephe_check_data,
     caml_ephe_unset_data: caml_ephe_unset_data,
     caml_ephe_set_data: caml_ephe_set_data,
     caml_ephe_get_data_copy: caml_ephe_get_data_copy,
     caml_ephe_get_data: caml_ephe_get_data,
     caml_ephe_blit_data: caml_ephe_blit_data,
     caml_ephe_blit_key: caml_ephe_blit_key,
     caml_ephe_check_key: caml_ephe_check_key,
     caml_ephe_get_key_copy: caml_ephe_get_key_copy,
     caml_ephe_get_key: caml_ephe_get_key,
     caml_weak_set: caml_weak_set,
     caml_weak_create: caml_weak_create,
     caml_ephe_create: caml_ephe_create,
     caml_ephe_unset_key: caml_ephe_unset_key,
     caml_ephe_set_key: caml_ephe_set_key,
     caml_ephe_data_offset: caml_ephe_data_offset,
     caml_ephe_key_offset: caml_ephe_key_offset,
     caml_unix_inet_addr_of_string: caml_unix_inet_addr_of_string,
     caml_unix_findclose: caml_unix_findclose,
     caml_unix_findnext: caml_unix_findnext,
     caml_unix_findfirst: caml_unix_findfirst,
     caml_unix_rewinddir: caml_unix_rewinddir,
     caml_unix_closedir: caml_unix_closedir,
     caml_unix_readdir: caml_unix_readdir,
     caml_unix_opendir: caml_unix_opendir,
     caml_unix_has_symlink: caml_unix_has_symlink,
     caml_unix_getpwuid: caml_unix_getpwuid,
     caml_unix_getuid: caml_unix_getuid,
     caml_unix_unlink: caml_unix_unlink,
     caml_unix_readlink: caml_unix_readlink,
     caml_unix_symlink: caml_unix_symlink,
     caml_unix_rmdir: caml_unix_rmdir,
     caml_unix_mkdir: caml_unix_mkdir,
     caml_unix_lstat_64: caml_unix_lstat_64,
     caml_unix_lstat: caml_unix_lstat,
     caml_unix_stat_64: caml_unix_stat_64,
     caml_unix_stat: caml_unix_stat,
     make_unix_err_args: make_unix_err_args,
     caml_unix_isatty: caml_unix_isatty,
     caml_unix_filedescr_of_fd: caml_unix_filedescr_of_fd,
     caml_unix_cleanup: caml_unix_cleanup,
     caml_unix_startup: caml_unix_startup,
     caml_unix_mktime: caml_unix_mktime,
     caml_unix_localtime: caml_unix_localtime,
     caml_unix_gmtime: caml_unix_gmtime,
     caml_unix_time: caml_unix_time,
     caml_unix_gettimeofday: caml_unix_gettimeofday,
     caml_str_initialize: caml_str_initialize,
     re_replacement_text: re_replacement_text,
     re_partial_match: re_partial_match,
     re_string_match: re_string_match,
     re_search_backward: re_search_backward,
     re_search_forward: re_search_forward,
     re_match: re_match,
     caml_sys_is_regular_file: caml_sys_is_regular_file,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime: caml_register_channel_for_spacetime,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_spacetime_enabled: caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled: caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings: caml_ml_enable_runtime_warnings,
     caml_runtime_warnings: caml_runtime_warnings,
     caml_install_signal_handler: caml_install_signal_handler,
     caml_runtime_parameters: caml_runtime_parameters,
     caml_runtime_variant: caml_runtime_variant,
     caml_sys_isatty: caml_sys_isatty,
     caml_sys_get_config: caml_sys_get_config,
     os_type: os_type,
     caml_sys_const_backend_type: caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin: caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32: caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix: caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize: caml_sys_const_max_wosize,
     caml_sys_const_int_size: caml_sys_const_int_size,
     caml_sys_const_word_size: caml_sys_const_word_size,
     caml_sys_const_big_endian: caml_sys_const_big_endian,
     caml_sys_random_seed: caml_sys_random_seed,
     caml_sys_time_include_children: caml_sys_time_include_children,
     caml_sys_time: caml_sys_time,
     caml_sys_system_command: caml_sys_system_command,
     caml_sys_executable_name: caml_sys_executable_name,
     caml_sys_modify_argv: caml_sys_modify_argv,
     caml_sys_argv: caml_sys_argv,
     caml_sys_get_argv: caml_sys_get_argv,
     caml_executable_name: caml_executable_name,
     caml_argv: caml_argv,
     caml_sys_unsafe_getenv: caml_sys_unsafe_getenv,
     caml_sys_getenv: caml_sys_getenv,
     jsoo_sys_getenv: jsoo_sys_getenv,
     caml_set_static_env: caml_set_static_env,
     caml_fatal_uncaught_exception: caml_fatal_uncaught_exception,
     caml_format_exception: caml_format_exception,
     caml_is_special_exception: caml_is_special_exception,
     caml_sys_exit: caml_sys_exit,
     caml_raise_sys_error: caml_raise_sys_error,
     caml_maybe_print_stats: caml_maybe_print_stats,
     caml_is_printable: caml_is_printable,
     caml_get_global_data: caml_get_global_data,
     caml_register_global: caml_register_global,
     caml_build_symbols: caml_build_symbols,
     caml_global_data: caml_global_data,
     caml_named_value: caml_named_value,
     caml_register_named_value: caml_register_named_value,
     caml_named_values: caml_named_values,
     caml_call_gen: caml_call_gen,
     caml_set_parser_trace: caml_set_parser_trace,
     caml_parse_engine: caml_parse_engine,
     caml_parser_trace: caml_parser_trace,
     caml_is_continuation_tag: caml_is_continuation_tag,
     caml_lazy_read_result: caml_lazy_read_result,
     caml_lazy_reset_to_lazy: caml_lazy_reset_to_lazy,
     caml_lazy_update_to_forward: caml_lazy_update_to_forward,
     caml_lazy_update_to_forcing: caml_lazy_update_to_forcing,
     caml_obj_update_tag: caml_obj_update_tag,
     caml_obj_add_offset: caml_obj_add_offset,
     caml_obj_reachable_words: caml_obj_reachable_words,
     caml_obj_set_raw_field: caml_obj_set_raw_field,
     caml_obj_raw_field: caml_obj_raw_field,
     caml_fresh_oo_id: caml_fresh_oo_id,
     caml_set_oo_id: caml_set_oo_id,
     caml_oo_last_id: caml_oo_last_id,
     caml_get_public_method: caml_get_public_method,
     caml_lazy_make_forward: caml_lazy_make_forward,
     caml_obj_is_shared: caml_obj_is_shared,
     caml_obj_compare_and_swap: caml_obj_compare_and_swap,
     caml_obj_make_forward: caml_obj_make_forward,
     caml_obj_truncate: caml_obj_truncate,
     caml_obj_dup: caml_obj_dup,
     caml_obj_with_tag: caml_obj_with_tag,
     caml_obj_block: caml_obj_block,
     caml_obj_set_tag: caml_obj_set_tag,
     caml_obj_tag: caml_obj_tag,
     caml_obj_is_block: caml_obj_is_block,
     caml_alloc_dummy_infix: caml_alloc_dummy_infix,
     caml_update_dummy: caml_update_dummy,
     deserialize_nat: deserialize_nat,
     serialize_nat: serialize_nat,
     lxor_digit_nat: lxor_digit_nat,
     lor_digit_nat: lor_digit_nat,
     land_digit_nat: land_digit_nat,
     compare_nat_real: compare_nat_real,
     compare_nat: compare_nat,
     compare_digits_nat: compare_digits_nat,
     shift_right_nat: shift_right_nat,
     div_nat: div_nat,
     div_digit_nat: div_digit_nat,
     div_helper: div_helper,
     shift_left_nat: shift_left_nat,
     square_nat: square_nat,
     mult_nat: mult_nat,
     mult_digit_nat: mult_digit_nat,
     sub_nat: sub_nat,
     decr_nat: decr_nat,
     complement_nat: complement_nat,
     add_nat: add_nat,
     incr_nat: incr_nat,
     is_digit_odd: is_digit_odd,
     is_digit_zero: is_digit_zero,
     is_digit_int: is_digit_int,
     num_leading_zero_bits_in_digit: num_leading_zero_bits_in_digit,
     num_digits_nat: num_digits_nat,
     nth_digit_nat_native: nth_digit_nat_native,
     set_digit_nat_native: set_digit_nat_native,
     nth_digit_nat: nth_digit_nat,
     set_digit_nat: set_digit_nat,
     blit_nat: blit_nat,
     set_to_zero_nat: set_to_zero_nat,
     create_nat: create_nat,
     nat_of_array: nat_of_array,
     length_nat: length_nat,
     caml_hash_nat: caml_hash_nat,
     MlNat: MlNat,
     initialize_nat: initialize_nat,
     caml_array_of_bytes: caml_array_of_bytes,
     caml_array_of_string: caml_array_of_string,
     caml_js_to_string: caml_js_to_string,
     caml_to_js_string: caml_to_js_string,
     caml_js_from_string: caml_js_from_string,
     caml_new_string: caml_new_string,
     caml_js_to_byte_string: caml_js_to_byte_string,
     caml_is_ml_string: caml_is_ml_string,
     caml_ml_bytes_content: caml_ml_bytes_content,
     caml_is_ml_bytes: caml_is_ml_bytes,
     caml_bytes_of_jsbytes: caml_bytes_of_jsbytes,
     caml_string_of_jsstring: caml_string_of_jsstring,
     caml_jsstring_of_string: caml_jsstring_of_string,
     caml_jsbytes_of_string: caml_jsbytes_of_string,
     caml_string_of_jsbytes: caml_string_of_jsbytes,
     caml_bytes_of_string: caml_bytes_of_string,
     caml_string_of_bytes: caml_string_of_bytes,
     caml_string_lessthan: caml_string_lessthan,
     caml_string_lessequal: caml_string_lessequal,
     caml_string_equal: caml_string_equal,
     caml_string_compare: caml_string_compare,
     caml_ml_string_length: caml_ml_string_length,
     caml_string_unsafe_set: caml_string_unsafe_set,
     caml_string_unsafe_get: caml_string_unsafe_get,
     caml_string_concat: caml_string_concat,
     caml_ml_bytes_length: caml_ml_bytes_length,
     caml_blit_string: caml_blit_string,
     caml_blit_bytes: caml_blit_bytes,
     caml_fill_bytes: caml_fill_bytes,
     caml_bytes_greaterthan: caml_bytes_greaterthan,
     caml_string_greaterthan: caml_string_greaterthan,
     caml_bytes_greaterequal: caml_bytes_greaterequal,
     caml_string_greaterequal: caml_string_greaterequal,
     caml_bytes_lessthan: caml_bytes_lessthan,
     caml_bytes_lessequal: caml_bytes_lessequal,
     caml_bytes_notequal: caml_bytes_notequal,
     caml_string_notequal: caml_string_notequal,
     caml_bytes_equal: caml_bytes_equal,
     caml_bytes_compare: caml_bytes_compare,
     caml_bytes_of_array: caml_bytes_of_array,
     caml_string_of_array: caml_string_of_array,
     caml_create_bytes: caml_create_bytes,
     caml_create_string: caml_create_string,
     caml_uint8_array_of_string: caml_uint8_array_of_string,
     caml_uint8_array_of_bytes: caml_uint8_array_of_bytes,
     caml_convert_bytes_to_array: caml_convert_bytes_to_array,
     caml_convert_string_to_bytes: caml_convert_string_to_bytes,
     MlBytes: MlBytes,
     caml_bytes_of_utf16_jsstring: caml_bytes_of_utf16_jsstring,
     caml_bytes_set: caml_bytes_set,
     caml_string_set64: caml_string_set64,
     caml_bytes_set64: caml_bytes_set64,
     caml_string_set32: caml_string_set32,
     caml_bytes_set32: caml_bytes_set32,
     caml_string_set16: caml_string_set16,
     caml_bytes_set16: caml_bytes_set16,
     caml_string_set: caml_string_set,
     caml_bytes_get: caml_bytes_get,
     caml_bytes_get64: caml_bytes_get64,
     caml_string_get64: caml_string_get64,
     caml_bytes_get32: caml_bytes_get32,
     caml_string_get32: caml_string_get32,
     caml_bytes_get16: caml_bytes_get16,
     caml_string_get16: caml_string_get16,
     caml_string_get: caml_string_get,
     caml_bytes_bound_error: caml_bytes_bound_error,
     caml_string_bound_error: caml_string_bound_error,
     caml_bytes_unsafe_set: caml_bytes_unsafe_set,
     caml_bytes_unsafe_get: caml_bytes_unsafe_get,
     jsoo_is_ascii: jsoo_is_ascii,
     caml_utf16_of_utf8: caml_utf16_of_utf8,
     caml_utf8_of_utf16: caml_utf8_of_utf16,
     caml_subarray_to_jsbytes: caml_subarray_to_jsbytes,
     caml_str_repeat: caml_str_repeat,
     caml_md5_bytes: caml_md5_bytes,
     caml_MD5Final: caml_MD5Final,
     caml_MD5Update: caml_MD5Update,
     caml_MD5Init: caml_MD5Init,
     caml_MD5Transform: caml_MD5Transform,
     caml_md5_string: caml_md5_string,
     caml_md5_chan: caml_md5_chan,
     caml_output_value_to_buffer: caml_output_value_to_buffer,
     caml_output_value_to_bytes: caml_output_value_to_bytes,
     caml_output_value_to_string: caml_output_value_to_string,
     caml_output_val: caml_output_val,
     MlObjectTable: MlObjectTable,
     caml_marshal_data_size: caml_marshal_data_size,
     caml_marshal_header_size: caml_marshal_header_size,
     caml_input_value_from_reader: caml_input_value_from_reader,
     caml_custom_ops: caml_custom_ops,
     caml_nativeint_unmarshal: caml_nativeint_unmarshal,
     caml_int32_unmarshal: caml_int32_unmarshal,
     caml_int64_marshal: caml_int64_marshal,
     caml_int64_unmarshal: caml_int64_unmarshal,
     caml_input_value_from_bytes: caml_input_value_from_bytes,
     caml_input_value_from_string: caml_input_value_from_string,
     caml_float_of_bytes: caml_float_of_bytes,
     BigStringReader: BigStringReader,
     MlStringReader: MlStringReader,
     UInt8ArrayReader: UInt8ArrayReader,
     caml_marshal_constants: caml_marshal_constants,
     caml_new_lex_engine: caml_new_lex_engine,
     caml_lex_engine: caml_lex_engine,
     caml_lex_array: caml_lex_array,
     caml_js_error_of_exception: caml_js_error_of_exception,
     caml_xmlhttprequest_create: caml_xmlhttprequest_create,
     caml_js_get_console: caml_js_get_console,
     caml_js_html_entities: caml_js_html_entities,
     caml_js_html_escape: caml_js_html_escape,
     caml_js_on_ie: caml_js_on_ie,
     caml_js_object: caml_js_object,
     caml_pure_js_expr: caml_pure_js_expr,
     caml_js_expr: caml_js_expr,
     caml_js_eval_string: caml_js_eval_string,
     caml_js_strict_equals: caml_js_strict_equals,
     caml_js_equals: caml_js_equals,
     caml_js_function_arity: caml_js_function_arity,
     caml_js_wrap_meth_callback_unsafe: caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict: caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:
     caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback: caml_js_wrap_meth_callback,
     caml_js_wrap_callback_unsafe: caml_js_wrap_callback_unsafe,
     caml_js_wrap_callback_strict: caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments: caml_js_wrap_callback_arguments,
     caml_js_wrap_callback: caml_js_wrap_callback,
     caml_ojs_new_arr: caml_ojs_new_arr,
     caml_js_new: caml_js_new,
     caml_js_meth_call: caml_js_meth_call,
     caml_js_fun_call: caml_js_fun_call,
     caml_js_call: caml_js_call,
     caml_js_var: caml_js_var,
     caml_list_to_js_array: caml_list_to_js_array,
     caml_list_of_js_array: caml_list_of_js_array,
     caml_js_to_array: caml_js_to_array,
     caml_js_from_array: caml_js_from_array,
     caml_js_to_int32: caml_js_to_int32,
     caml_js_to_float: caml_js_to_float,
     caml_js_from_float: caml_js_from_float,
     caml_js_to_bool: caml_js_to_bool,
     caml_js_from_bool: caml_js_from_bool,
     caml_js_error_option_of_exception: caml_js_error_option_of_exception,
     caml_exn_with_js_backtrace: caml_exn_with_js_backtrace,
     caml_maybe_attach_backtrace: caml_maybe_attach_backtrace,
     caml_wrap_exception: caml_wrap_exception,
     caml_jsoo_flags_effects: caml_jsoo_flags_effects,
     caml_jsoo_flags_use_js_string: caml_jsoo_flags_use_js_string,
     caml_is_js: caml_is_js,
     caml_callback: caml_callback,
     caml_trampoline_return: caml_trampoline_return,
     caml_trampoline: caml_trampoline,
     caml_js_typeof: caml_js_typeof,
     caml_js_instanceof: caml_js_instanceof,
     caml_js_delete: caml_js_delete,
     caml_js_get: caml_js_get,
     caml_js_set: caml_js_set,
     caml_js_pure_expr: caml_js_pure_expr,
     caml_ml_set_buffered: caml_ml_set_buffered,
     caml_ml_is_buffered: caml_ml_is_buffered,
     caml_ml_output_int: caml_ml_output_int,
     caml_ml_pos_out_64: caml_ml_pos_out_64,
     caml_ml_pos_out: caml_ml_pos_out,
     caml_pos_out: caml_pos_out,
     caml_ml_seek_out_64: caml_ml_seek_out_64,
     caml_ml_seek_out: caml_ml_seek_out,
     caml_seek_out: caml_seek_out,
     caml_output_value: caml_output_value,
     caml_ml_output_char: caml_ml_output_char,
     caml_ml_output: caml_ml_output,
     caml_ml_output_bigarray: caml_ml_output_bigarray,
     caml_ml_output_bytes: caml_ml_output_bytes,
     caml_ml_output_ta: caml_ml_output_ta,
     caml_ml_flush: caml_ml_flush,
     caml_ml_input_scan_line: caml_ml_input_scan_line,
     caml_ml_pos_in_64: caml_ml_pos_in_64,
     caml_ml_pos_in: caml_ml_pos_in,
     caml_pos_in: caml_pos_in,
     caml_ml_seek_in_64: caml_ml_seek_in_64,
     caml_ml_seek_in: caml_ml_seek_in,
     caml_seek_in: caml_seek_in,
     caml_ml_input_int: caml_ml_input_int,
     caml_ml_input_char: caml_ml_input_char,
     caml_input_value_to_outside_heap: caml_input_value_to_outside_heap,
     caml_input_value: caml_input_value,
     caml_ml_input_block: caml_ml_input_block,
     caml_ml_input_bigarray: caml_ml_input_bigarray,
     caml_ml_input: caml_ml_input,
     caml_refill: caml_refill,
     caml_ml_set_channel_refill: caml_ml_set_channel_refill,
     caml_ml_set_channel_output: caml_ml_set_channel_output,
     caml_ml_channel_size_64: caml_ml_channel_size_64,
     caml_ml_channel_size: caml_ml_channel_size,
     caml_ml_close_channel: caml_ml_close_channel,
     caml_ml_set_binary_mode: caml_ml_set_binary_mode,
     caml_channel_descriptor: caml_channel_descriptor,
     caml_ml_open_descriptor_in: caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out: caml_ml_open_descriptor_out,
     caml_ml_out_channels_list: caml_ml_out_channels_list,
     caml_ml_channel_get: caml_ml_channel_get,
     caml_ml_channel_restore: caml_ml_channel_restore,
     caml_ml_channel_redirect: caml_ml_channel_redirect,
     caml_ml_channels: caml_ml_channels,
     caml_ml_set_channel_name: caml_ml_set_channel_name,
     caml_sys_open: caml_sys_open,
     caml_sys_close: caml_sys_close,
     caml_sys_fds: caml_sys_fds,
     caml_int64_bswap: caml_int64_bswap,
     caml_int32_bswap: caml_int32_bswap,
     caml_bswap16: caml_bswap16,
     caml_mod: caml_mod,
     caml_div: caml_div,
     caml_mul: caml_mul,
     caml_int_of_string: caml_int_of_string,
     caml_parse_digit: caml_parse_digit,
     caml_parse_sign_and_base: caml_parse_sign_and_base,
     caml_format_int: caml_format_int,
     caml_int64_hash: caml_int64_hash,
     caml_int64_to_bytes: caml_int64_to_bytes,
     caml_int64_of_bytes: caml_int64_of_bytes,
     caml_int64_hi32: caml_int64_hi32,
     caml_int64_lo32: caml_int64_lo32,
     caml_int64_create_lo_hi: caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi: caml_int64_create_lo_mi_hi,
     caml_int64_of_string: caml_int64_of_string,
     caml_int64_format: caml_int64_format,
     caml_int64_of_float: caml_int64_of_float,
     caml_int64_to_float: caml_int64_to_float,
     caml_int64_to_int32: caml_int64_to_int32,
     caml_int64_of_int32: caml_int64_of_int32,
     caml_int64_mod: caml_int64_mod,
     caml_int64_div: caml_int64_div,
     caml_int64_shift_right: caml_int64_shift_right,
     caml_int64_shift_right_unsigned: caml_int64_shift_right_unsigned,
     caml_int64_shift_left: caml_int64_shift_left,
     caml_int64_xor: caml_int64_xor,
     caml_int64_or: caml_int64_or,
     caml_int64_and: caml_int64_and,
     caml_int64_is_negative: caml_int64_is_negative,
     caml_int64_is_zero: caml_int64_is_zero,
     caml_int64_mul: caml_int64_mul,
     caml_int64_sub: caml_int64_sub,
     caml_int64_add: caml_int64_add,
     caml_int64_neg: caml_int64_neg,
     caml_int64_compare: caml_int64_compare,
     caml_int64_ult: caml_int64_ult,
     MlInt64: MlInt64,
     caml_int64_offset: caml_int64_offset,
     caml_float_of_string: caml_float_of_string,
     caml_format_float: caml_format_float,
     caml_fma_float: caml_fma_float,
     caml_erfc_float: caml_erfc_float,
     caml_erf_float: caml_erf_float,
     caml_cbrt_float: caml_cbrt_float,
     caml_round_float: caml_round_float,
     caml_atanh_float: caml_atanh_float,
     caml_tanh_float: caml_tanh_float,
     caml_asinh_float: caml_asinh_float,
     caml_sinh_float: caml_sinh_float,
     caml_acosh_float: caml_acosh_float,
     caml_cosh_float: caml_cosh_float,
     caml_log10_float: caml_log10_float,
     caml_hypot_float: caml_hypot_float,
     caml_log2_float: caml_log2_float,
     caml_log1p_float: caml_log1p_float,
     caml_exp2_float: caml_exp2_float,
     caml_expm1_float: caml_expm1_float,
     caml_signbit_float: caml_signbit_float,
     caml_copysign_float: caml_copysign_float,
     caml_float_compare: caml_float_compare,
     caml_frexp_float: caml_frexp_float,
     caml_ldexp_float: caml_ldexp_float,
     caml_modf_float: caml_modf_float,
     caml_classify_float: caml_classify_float,
     caml_int32_float_of_bits: caml_int32_float_of_bits,
     caml_trunc_float: caml_trunc_float,
     caml_nextafter_float: caml_nextafter_float,
     caml_int64_float_of_bits: caml_int64_float_of_bits,
     caml_hexstring_of_float: caml_hexstring_of_float,
     caml_int32_bits_of_float: caml_int32_bits_of_float,
     caml_int64_bits_of_float: caml_int64_bits_of_float,
     jsoo_floor_log2: jsoo_floor_log2,
     caml_string_hash: caml_string_hash,
     caml_hash: caml_hash,
     caml_hash_mix_string: caml_hash_mix_string,
     caml_hash_mix_bytes: caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr: caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes: caml_hash_mix_jsbytes,
     caml_hash_mix_int64: caml_hash_mix_int64,
     caml_hash_mix_float: caml_hash_mix_float,
     caml_hash_mix_final: caml_hash_mix_final,
     caml_hash_mix_int: caml_hash_mix_int,
     caml_gr_close_subwindow: caml_gr_close_subwindow,
     caml_gr_open_subwindow: caml_gr_open_subwindow,
     caml_gr_window_id: caml_gr_window_id,
     caml_gr_display_mode: caml_gr_display_mode,
     caml_gr_remember_mode: caml_gr_remember_mode,
     caml_gr_synchronize: caml_gr_synchronize,
     caml_gr_wait_event: caml_gr_wait_event,
     caml_gr_sigio_signal: caml_gr_sigio_signal,
     caml_gr_sigio_handler: caml_gr_sigio_handler,
     caml_gr_blit_image: caml_gr_blit_image,
     caml_gr_create_image: caml_gr_create_image,
     caml_gr_draw_image: caml_gr_draw_image,
     caml_gr_dump_image: caml_gr_dump_image,
     caml_gr_make_image: caml_gr_make_image,
     caml_gr_text_size: caml_gr_text_size,
     caml_gr_set_text_size: caml_gr_set_text_size,
     caml_gr_set_font: caml_gr_set_font,
     caml_gr_draw_string: caml_gr_draw_string,
     caml_gr_draw_char: caml_gr_draw_char,
     caml_gr_draw_str: caml_gr_draw_str,
     caml_gr_fill_arc: caml_gr_fill_arc,
     caml_gr_fill_poly: caml_gr_fill_poly,
     caml_gr_fill_rect: caml_gr_fill_rect,
     caml_gr_set_line_width: caml_gr_set_line_width,
     caml_gr_draw_arc: caml_gr_draw_arc,
     caml_gr_arc_aux: caml_gr_arc_aux,
     caml_gr_draw_rect: caml_gr_draw_rect,
     caml_gr_lineto: caml_gr_lineto,
     caml_gr_current_y: caml_gr_current_y,
     caml_gr_current_x: caml_gr_current_x,
     caml_gr_moveto: caml_gr_moveto,
     caml_gr_point_color: caml_gr_point_color,
     caml_gr_plot: caml_gr_plot,
     caml_gr_set_color: caml_gr_set_color,
     caml_gr_size_y: caml_gr_size_y,
     caml_gr_size_x: caml_gr_size_x,
     caml_gr_clear_graph: caml_gr_clear_graph,
     caml_gr_resize_window: caml_gr_resize_window,
     caml_gr_set_window_title: caml_gr_set_window_title,
     caml_gr_close_graph: caml_gr_close_graph,
     caml_gr_doc_of_state: caml_gr_doc_of_state,
     caml_gr_state_create: caml_gr_state_create,
     caml_gr_state_init: caml_gr_state_init,
     caml_gr_open_graph: caml_gr_open_graph,
     caml_gr_state_set: caml_gr_state_set,
     caml_gr_state_get: caml_gr_state_get,
     caml_gr_state: caml_gr_state,
     caml_get_major_credit: caml_get_major_credit,
     caml_get_major_bucket: caml_get_major_bucket,
     caml_get_minor_free: caml_get_minor_free,
     caml_gc_minor_words: caml_gc_minor_words,
     caml_gc_major_slice: caml_gc_major_slice,
     caml_gc_huge_fallback_count: caml_gc_huge_fallback_count,
     caml_eventlog_pause: caml_eventlog_pause,
     caml_eventlog_resume: caml_eventlog_resume,
     caml_memprof_discard: caml_memprof_discard,
     caml_memprof_stop: caml_memprof_stop,
     caml_memprof_start: caml_memprof_start,
     caml_final_release: caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register: caml_final_register,
     caml_memprof_set: caml_memprof_set,
     caml_gc_get: caml_gc_get,
     caml_gc_set: caml_gc_set,
     caml_gc_stat: caml_gc_stat,
     caml_gc_quick_stat: caml_gc_quick_stat,
     caml_gc_counters: caml_gc_counters,
     caml_gc_compaction: caml_gc_compaction,
     caml_gc_full_major: caml_gc_full_major,
     caml_gc_major: caml_gc_major,
     caml_gc_minor: caml_gc_minor,
     caml_sys_open_for_node: caml_sys_open_for_node,
     MlNodeFd: MlNodeFd,
     MlNodeDevice: MlNodeDevice,
     fs_node_supported: fs_node_supported,
     MlFakeFd: MlFakeFd,
     MlFakeFd_out: MlFakeFd_out,
     MlFakeFile: MlFakeFile,
     MlFakeDevice: MlFakeDevice,
     caml_read_file_content: caml_read_file_content,
     jsoo_create_file: jsoo_create_file,
     caml_create_file: caml_create_file,
     caml_fs_init: caml_fs_init,
     jsoo_create_file_extern: jsoo_create_file_extern,
     caml_ba_map_file_bytecode: caml_ba_map_file_bytecode,
     caml_ba_map_file: caml_ba_map_file,
     caml_sys_rmdir: caml_sys_rmdir,
     caml_sys_mkdir: caml_sys_mkdir,
     caml_sys_rename: caml_sys_rename,
     caml_sys_is_directory: caml_sys_is_directory,
     caml_sys_remove: caml_sys_remove,
     caml_sys_read_directory: caml_sys_read_directory,
     caml_sys_file_exists: caml_sys_file_exists,
     caml_raise_not_a_dir: caml_raise_not_a_dir,
     caml_raise_no_such_file: caml_raise_no_such_file,
     caml_sys_chdir: caml_sys_chdir,
     caml_sys_getcwd: caml_sys_getcwd,
     caml_unmount: caml_unmount,
     caml_mount_autoload: caml_mount_autoload,
     resolve_fs_device: resolve_fs_device,
     caml_list_mount_point: caml_list_mount_point,
     jsoo_mount_point: jsoo_mount_point,
     caml_make_path: caml_make_path,
     path_is_absolute: path_is_absolute,
     MlFile: MlFile,
     caml_root: caml_root,
     caml_get_root: caml_get_root,
     caml_current_dir: caml_current_dir,
     caml_trailing_slash: caml_trailing_slash,
     caml_finish_formatting: caml_finish_formatting,
     caml_parse_format: caml_parse_format,
     caml_array_bound_error: caml_array_bound_error,
     caml_raise_not_found: caml_raise_not_found,
     caml_raise_zero_divide: caml_raise_zero_divide,
     caml_raise_end_of_file: caml_raise_end_of_file,
     caml_invalid_argument: caml_invalid_argument,
     caml_failwith: caml_failwith,
     caml_raise_with_string: caml_raise_with_string,
     caml_raise_with_args: caml_raise_with_args,
     caml_raise_with_arg: caml_raise_with_arg,
     caml_raise_constant: caml_raise_constant,
     caml_lessthan: caml_lessthan,
     caml_lessequal: caml_lessequal,
     caml_greaterthan: caml_greaterthan,
     caml_greaterequal: caml_greaterequal,
     caml_notequal: caml_notequal,
     caml_equal: caml_equal,
     caml_int_compare: caml_int_compare,
     caml_compare: caml_compare,
     caml_compare_val: caml_compare_val,
     caml_compare_val_number_custom: caml_compare_val_number_custom,
     caml_compare_val_get_custom: caml_compare_val_get_custom,
     caml_compare_val_tag: caml_compare_val_tag,
     caml_bigstring_blit_ba_to_bytes: caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba: caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba: caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba: caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp: caml_bigstring_memcmp,
     bigstring_of_typed_array: bigstring_of_typed_array,
     bigstring_of_array_buffer: bigstring_of_array_buffer,
     bigstring_to_typed_array: bigstring_to_typed_array,
     bigstring_to_array_buffer: bigstring_to_array_buffer,
     caml_hash_mix_bigstring: caml_hash_mix_bigstring,
     caml_ba_from_typed_array: caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array: caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array: caml_ba_to_typed_array,
     caml_ba_hash: caml_ba_hash,
     caml_ba_create_from: caml_ba_create_from,
     caml_ba_deserialize: caml_ba_deserialize,
     caml_ba_serialize: caml_ba_serialize,
     caml_ba_reshape: caml_ba_reshape,
     caml_ba_slice: caml_ba_slice,
     caml_ba_sub: caml_ba_sub,
     caml_ba_blit: caml_ba_blit,
     caml_ba_fill: caml_ba_fill,
     caml_ba_set_3: caml_ba_set_3,
     caml_ba_set_2: caml_ba_set_2,
     caml_ba_set_1: caml_ba_set_1,
     caml_ba_uint8_set64: caml_ba_uint8_set64,
     caml_ba_uint8_set32: caml_ba_uint8_set32,
     caml_ba_uint8_set16: caml_ba_uint8_set16,
     caml_ba_set_generic: caml_ba_set_generic,
     caml_ba_get_3: caml_ba_get_3,
     caml_ba_get_2: caml_ba_get_2,
     caml_ba_get_1: caml_ba_get_1,
     caml_ba_uint8_get64: caml_ba_uint8_get64,
     caml_ba_uint8_get32: caml_ba_uint8_get32,
     caml_ba_uint8_get16: caml_ba_uint8_get16,
     caml_ba_get_generic: caml_ba_get_generic,
     caml_ba_dim_3: caml_ba_dim_3,
     caml_ba_dim_2: caml_ba_dim_2,
     caml_ba_dim_1: caml_ba_dim_1,
     caml_ba_dim: caml_ba_dim,
     caml_ba_num_dims: caml_ba_num_dims,
     caml_ba_layout: caml_ba_layout,
     caml_ba_kind: caml_ba_kind,
     caml_ba_change_layout: caml_ba_change_layout,
     caml_ba_create: caml_ba_create,
     caml_ba_create_unsafe: caml_ba_create_unsafe,
     caml_ba_compare: caml_ba_compare,
     Ml_Bigarray_c_1_1: Ml_Bigarray_c_1_1,
     Ml_Bigarray: Ml_Bigarray,
     caml_ba_custom_name: caml_ba_custom_name,
     caml_ba_create_buffer: caml_ba_create_buffer,
     caml_ba_get_size_per_element: caml_ba_get_size_per_element,
     caml_ba_get_size: caml_ba_get_size,
     caml_ba_init: caml_ba_init,
     caml_convert_raw_backtrace_slot: caml_convert_raw_backtrace_slot,
     caml_get_current_callstack: caml_get_current_callstack,
     caml_restore_raw_backtrace: caml_restore_raw_backtrace,
     caml_raw_backtrace_slot: caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot: caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length: caml_raw_backtrace_length,
     caml_convert_raw_backtrace: caml_convert_raw_backtrace,
     caml_record_backtrace: caml_record_backtrace,
     caml_get_exception_raw_backtrace: caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace: caml_get_exception_backtrace,
     caml_backtrace_status: caml_backtrace_status,
     caml_ml_debug_info_status: caml_ml_debug_info_status,
     caml_record_backtrace_flag: caml_record_backtrace_flag,
     caml_floatarray_create: caml_floatarray_create,
     caml_make_float_vect: caml_make_float_vect,
     caml_make_vect: caml_make_vect,
     caml_check_bound: caml_check_bound,
     caml_array_fill: caml_array_fill,
     caml_array_get: caml_array_get,
     caml_array_set: caml_array_set,
     caml_floatarray_blit: caml_floatarray_blit,
     caml_array_blit: caml_array_blit,
     caml_array_concat: caml_array_concat,
     caml_array_append: caml_array_append,
     caml_array_sub: caml_array_sub};
   var
    cst_Assert_failure = "Assert_failure",
    cst_Division_by_zero = "Division_by_zero",
    cst_End_of_file = "End_of_file",
    cst_Failure = "Failure",
    cst_Invalid_argument = "Invalid_argument",
    cst_Match_failure = "Match_failure",
    cst_Not_found = "Not_found",
    cst_Out_of_memory = "Out_of_memory",
    cst_Stack_overflow = "Stack_overflow",
    cst_Sys_blocked_io = "Sys_blocked_io",
    cst_Sys_error = "Sys_error",
    cst_Undefined_recursive_module = "Undefined_recursive_module";
   caml_fs_init();
   caml_register_global(0, [248, cst_Out_of_memory, -1], cst_Out_of_memory);
   caml_register_global(1, [248, cst_Sys_error, -2], cst_Sys_error);
   caml_register_global(2, [248, cst_Failure, -3], cst_Failure);
   caml_register_global
    (3, [248, cst_Invalid_argument, -4], cst_Invalid_argument);
   caml_register_global(4, [248, cst_End_of_file, -5], cst_End_of_file);
   caml_register_global
    (5, [248, cst_Division_by_zero, -6], cst_Division_by_zero);
   caml_register_global(6, [248, cst_Not_found, -7], cst_Not_found);
   caml_register_global(7, [248, cst_Match_failure, -8], cst_Match_failure);
   caml_register_global(8, [248, cst_Stack_overflow, -9], cst_Stack_overflow);
   caml_register_global(9, [248, cst_Sys_blocked_io, -10], cst_Sys_blocked_io);
   caml_register_global
    (10, [248, cst_Assert_failure, -11], cst_Assert_failure);
   caml_register_global
    (11,
     [248, cst_Undefined_recursive_module, -12],
     cst_Undefined_recursive_module);
   return;
  }
  (globalThis));


(function(a){"use strict";var
J="Sys_error",S="Stdlib__Obj",aa="Stdlib__Unit",aE="Stdlib__Nativeint",w="Stdlib__Gc",aD="Stdlib__Stack",I="CamlinternalFormat",aC="Stdlib__Genlex",am="Stdlib__Random",H="Stdlib__Pervasives",n="Stdlib__ArrayLabels",v="Stdlib__Either",G="Stdlib__Printexc",$="Stack_overflow",R="Stdlib__Map",_="Stdlib__Arg",F="Ojs_exn",al="Stdlib__Array",aB="Undefined_recursive_module",ak="Assert_failure",aA="CamlinternalFormatBasics",u="Stdlib__Lazy",aj="Jsoo_runtime__",az="Stdlib__Queue",Q="Stdlib__Format",Z="Js_browser",aT="Stdlib__In_channel",m="Stdlib__Bool",E="Jsoo_runtime",ai="Stdlib__BytesLabels",aS="Stdlib__Bytes",D="Division_by_zero",P="End_of_file",ax="CamlinternalMod",ay="Definicije__Avtomat",l="Dune__exe__View",ah="Stdlib__Marshal",aR="Out_of_memory",Y="Definicije__Trak",C="Stdlib__Weak",aw="Stdlib__Parsing",k="Dune__exe",t="Not_found",X="Ojs",aQ="Failure",j="Stdlib__Int",B="Stdlib__StdLabels",ag="Jsoo_runtime__Runtime_version",h="Stdlib__Ephemeron",i="Stdlib__Oo",af="Stdlib__String",au="Stdlib__Bigarray",av="Stdlib__List",aP="Stdlib__Printf",aO="Stdlib",O="Stdlib__Callback",N="Stdlib__Hashtbl",aM="Definicije__Pravila",aN="Stdlib__Filename",s="Invalid_argument",g="Stdlib__Fun",M="Stdlib__Option",W="Stdlib__Lexing",aL="Stdlib__ListLabels",L="CamlinternalAtomic",at="Stdlib__Atomic",K="Stdlib__MoreLabels",aJ="Definicije__Stanje",aK="Dune__exe__Vektor",f="Stdlib__Result",A="Vdom",V="Dune__exe__Model",r="Std_exit",as="Stdlib__Set",e="Stdlib__Buffer",aI="Match_failure",q="Stdlib__StringLabels",ar="Definicije",U="Dune__exe__SpletniVmesnik",ae="Stdlib__Complex",d="Stdlib__Out_channel",aH="Stdlib__Int64",z="Stdlib__Seq",ad="Stdlib__Sys",aq="Definicije__ZagnaniAvtomat",p="CamlinternalLazy",ap="Vdom_blit",ao="Sys_blocked_io",T="Stdlib__Float",an="Stdlib__Uchar",o="Stdlib__Scanf",y="CamlinternalOO",aG="Definicije__Izlocisosede",aF="Stdlib__Digest",x="Stdlib__Stream",ac="Stdlib__Char",ab="Stdlib__Int32",c=a.jsoo_runtime,b=c.caml_get_global_data();b.prim_count=718;b.symbols=[0,[0,ap,83],[0,A,81],[0,aB,11],[0,J,10],[0,ao,9],[0,C,56],[0,aa,31],[0,an,26],[0,ad,17],[0,q,70],[0,af,30],[0,x,44],[0,B,72],[0,aD,42],[0,as,40],[0,z,21],[0,o,58],[0,f,23],[0,am,54],[0,az,43],[0,aP,47],[0,G,50],[0,H,15],[0,aw,39],[0,d,75],[0,M,22],[0,i,61],[0,S,18],[0,aE,37],[0,K,71],[0,ah,32],[0,R,41],[0,aL,68],[0,av,27],[0,W,38],[0,u,20],[0,aH,36],[0,ab,35],[0,j,28],[0,aT,74],[0,N,55],[0,aC,63],[0,w,52],[0,g,51],[0,Q,57],[0,T,34],[0,aN,65],[0,h,64],[0,v,16],[0,aF,53],[0,ae,66],[0,ac,25],[0,O,59],[0,ai,69],[0,aS,29],[0,e,45],[0,m,24],[0,au,73],[0,at,49],[0,n,67],[0,al,33],[0,_,48],[0,aO,14],[0,r,96],[0,$,8],[0,aR,7],[0,F,80],[0,X,79],[0,t,6],[0,aI,5],[0,ag,77],[0,aj,76],[0,E,78],[0,Z,82],[0,s,4],[0,aQ,3],[0,P,2],[0,l,94],[0,aK,92],[0,U,95],[0,V,93],[0,k,91],[0,D,1],[0,aq,88],[0,Y,87],[0,aJ,85],[0,aM,89],[0,aG,90],[0,ay,86],[0,ar,84],[0,y,60],[0,ax,62],[0,p,19],[0,aA,12],[0,I,46],[0,L,13],[0,ak,0]];var
aU=[2,U];b.sections=[0,[0,97,[0,[0,[0,[0,[0,[0,0,[2,ak],0,0,1],[2,L],13,[0,0,[2,I],46,0,1],2],[2,aA],12,[0,[0,0,[2,p],19,[0,0,[2,ax],62,0,1],2],[2,y],60,0,3],4],[2,ar],84,[0,[0,0,[2,ay],86,[0,[0,0,[2,aG],90,0,1],[2,aM],89,0,2],3],[2,aJ],85,[0,[0,0,[2,Y],87,[0,0,[2,aq],88,0,1],2],[2,D],1,[0,[0,0,[2,k],91,[0,0,[2,V],93,[0,0,aU,95,0,1],2],3],[2,aK],92,[0,[0,0,[2,l],94,0,1],[2,P],2,0,2],4],5],6],7],[2,aQ],3,[0,[0,[0,[0,0,[2,s],4,[0,0,[2,Z],82,0,1],2],[2,E],78,[0,0,[2,aj],76,[0,0,[2,ag],77,0,1],2],3],[2,aI],5,[0,[0,0,[2,t],6,[0,0,[2,X],79,[0,0,[2,F],80,0,1],2],3],[2,aR],7,[0,0,[2,$],8,[0,0,[2,r],96,0,1],2],4],5],[2,aO],14,[0,[0,[0,0,[2,_],48,0,1],[2,al],33,[0,[0,0,[2,n],67,0,1],[2,at],49,[0,0,[2,au],73,0,1],2],3],[2,m],24,[0,[0,[0,0,[2,e],45,0,1],[2,aS],29,[0,[0,0,[2,ai],69,0,1],[2,O],59,0,2],3],[2,ac],25,[0,[0,0,[2,ae],66,0,1],[2,aF],53,0,2],4],5],6],8],[2,v],16,[0,[0,[0,[0,[0,[0,0,[2,h],64,[0,0,[2,aN],65,0,1],2],[2,T],34,[0,0,[2,Q],57,0,1],3],[2,g],51,[0,0,[2,w],52,[0,[0,0,[2,aC],63,0,1],[2,N],55,[0,0,[2,aT],74,0,1],2],3],4],[2,j],28,[0,0,[2,ab],35,[0,0,[2,aH],36,0,1],2],5],[2,u],20,[0,[0,[0,0,[2,W],38,0,1],[2,av],27,[0,[0,[0,0,[2,aL],68,0,1],[2,R],41,0,2],[2,ah],32,[0,[0,0,[2,K],71,0,1],[2,aE],37,0,2],3],4],[2,S],18,[0,[0,0,[2,i],61,0,1],[2,M],22,[0,[0,0,[2,d],75,0,1],[2,aw],39,0,2],3],5],6],[2,H],15,[0,[0,[0,[0,[0,0,[2,G],50,0,1],[2,aP],47,0,2],[2,az],43,[0,[0,0,[2,am],54,0,1],[2,f],23,[0,0,[2,o],58,0,1],2],3],[2,z],21,[0,[0,0,[2,as],40,0,1],[2,aD],42,[0,[0,[0,0,[2,B],72,0,1],[2,x],44,0,2],[2,af],30,[0,0,[2,q],70,0,1],3],4],5],[2,ad],17,[0,[0,0,[2,an],26,[0,0,[2,aa],31,[0,0,[2,C],56,0,1],2],3],[2,ao],9,[0,[0,0,[2,J],10,0,1],[2,aB],11,[0,0,[2,A],81,[0,0,[2,ap],83,0,1],2],3],4],6],7],9]],0,c.caml_list_of_js_array(["BigStringReader","MlBytes","MlFakeDevice","MlFakeFd","MlFakeFd_out","MlFakeFile","MlFile","MlInt64","MlMutex","MlNat","MlNodeDevice","MlNodeFd","MlObjectTable","MlStringReader","Ml_Bigarray","Ml_Bigarray_c_1_1","UInt8ArrayReader","add_nat","bigstring_of_array_buffer","bigstring_of_typed_array","bigstring_to_array_buffer","bigstring_to_typed_array","blit_nat","caml_MD5Final","caml_MD5Init","caml_MD5Transform","caml_MD5Update","caml_acosh_float","caml_alloc_dummy_infix","caml_alloc_stack","caml_argv","caml_array_append","caml_array_blit","caml_array_bound_error","caml_array_concat","caml_array_fill","caml_array_get","caml_array_of_bytes","caml_array_of_string","caml_array_set","caml_array_sub","caml_asinh_float","caml_atanh_float","caml_atomic_cas","caml_atomic_exchange","caml_atomic_fetch_add","caml_atomic_load","caml_atomic_make_contended","caml_ba_blit","caml_ba_change_layout","caml_ba_compare","caml_ba_create","caml_ba_create_buffer","caml_ba_create_from","caml_ba_create_unsafe","caml_ba_custom_name","caml_ba_deserialize","caml_ba_dim","caml_ba_dim_1","caml_ba_dim_2","caml_ba_dim_3","caml_ba_fill","caml_ba_from_typed_array","caml_ba_get_1","caml_ba_get_2","caml_ba_get_3","caml_ba_get_generic","caml_ba_get_size","caml_ba_get_size_per_element","caml_ba_hash","caml_ba_init","caml_ba_kind","caml_ba_kind_of_typed_array","caml_ba_layout","caml_ba_map_file","caml_ba_map_file_bytecode","caml_ba_num_dims","caml_ba_reshape","caml_ba_serialize","caml_ba_set_1","caml_ba_set_2","caml_ba_set_3","caml_ba_set_generic","caml_ba_slice","caml_ba_sub","caml_ba_to_typed_array","caml_ba_uint8_get16","caml_ba_uint8_get32","caml_ba_uint8_get64","caml_ba_uint8_set16","caml_ba_uint8_set32","caml_ba_uint8_set64","caml_backtrace_status","caml_bigstring_blit_ba_to_ba","caml_bigstring_blit_ba_to_bytes","caml_bigstring_blit_bytes_to_ba","caml_bigstring_blit_string_to_ba","caml_bigstring_memcmp","caml_blit_bytes","caml_blit_string","caml_bswap16","caml_build_symbols","caml_bytes_bound_error","caml_bytes_compare","caml_bytes_equal","caml_bytes_get","caml_bytes_get16","caml_bytes_get32","caml_bytes_get64","caml_bytes_greaterequal","caml_bytes_greaterthan","caml_bytes_lessequal","caml_bytes_lessthan","caml_bytes_notequal","caml_bytes_of_array","caml_bytes_of_jsbytes","caml_bytes_of_string","caml_bytes_of_utf16_jsstring","caml_bytes_set","caml_bytes_set16","caml_bytes_set32","caml_bytes_set64","caml_bytes_unsafe_get","caml_bytes_unsafe_set","caml_call_gen","caml_callback","caml_cbrt_float","caml_channel_descriptor","caml_check_bound","caml_classify_float","caml_compare","caml_compare_val","caml_compare_val_get_custom","caml_compare_val_number_custom","caml_compare_val_tag","caml_continuation_use_and_update_handler_noexc","caml_continuation_use_noexc","caml_convert_bytes_to_array","caml_convert_raw_backtrace","caml_convert_raw_backtrace_slot","caml_convert_string_to_bytes","caml_copysign_float","caml_cosh_float","caml_create_bytes","caml_create_file","caml_create_string","caml_current_dir","caml_custom_event_index","caml_custom_ops","caml_decompress_input","caml_div","caml_domain_dls","caml_domain_dls_get","caml_domain_dls_set","caml_domain_id","caml_domain_spawn","caml_ephe_blit_data","caml_ephe_blit_key","caml_ephe_check_data","caml_ephe_check_key","caml_ephe_create","caml_ephe_data_offset","caml_ephe_get_data","caml_ephe_get_data_copy","caml_ephe_get_key","caml_ephe_get_key_copy","caml_ephe_key_offset","caml_ephe_set_data","caml_ephe_set_key","caml_ephe_unset_data","caml_ephe_unset_key","caml_equal","caml_erf_float","caml_erfc_float","caml_eventlog_pause","caml_eventlog_resume","caml_executable_name","caml_exn_with_js_backtrace","caml_exp2_float","caml_expm1_float","caml_failwith","caml_fatal_uncaught_exception","caml_fill_bytes","caml_final_register","caml_final_register_called_without_value","caml_final_release","caml_finish_formatting","caml_float_compare","caml_float_of_bytes","caml_float_of_string","caml_floatarray_blit","caml_floatarray_create","caml_fma_float","caml_format_exception","caml_format_float","caml_format_int","caml_fresh_oo_id","caml_frexp_float","caml_fs_init","caml_gc_compaction","caml_gc_counters","caml_gc_full_major","caml_gc_get","caml_gc_huge_fallback_count","caml_gc_major","caml_gc_major_slice","caml_gc_minor","caml_gc_minor_words","caml_gc_quick_stat","caml_gc_set","caml_gc_stat","caml_get_continuation_callstack","caml_get_current_callstack","caml_get_exception_backtrace","caml_get_exception_raw_backtrace","caml_get_global_data","caml_get_major_bucket","caml_get_major_credit","caml_get_minor_free","caml_get_public_method","caml_get_root","caml_global_data","caml_gr_arc_aux","caml_gr_blit_image","caml_gr_clear_graph","caml_gr_close_graph","caml_gr_close_subwindow","caml_gr_create_image","caml_gr_current_x","caml_gr_current_y","caml_gr_display_mode","caml_gr_doc_of_state","caml_gr_draw_arc","caml_gr_draw_char","caml_gr_draw_image","caml_gr_draw_rect","caml_gr_draw_str","caml_gr_draw_string","caml_gr_dump_image","caml_gr_fill_arc","caml_gr_fill_poly","caml_gr_fill_rect","caml_gr_lineto","caml_gr_make_image","caml_gr_moveto","caml_gr_open_graph","caml_gr_open_subwindow","caml_gr_plot","caml_gr_point_color","caml_gr_remember_mode","caml_gr_resize_window","caml_gr_set_color","caml_gr_set_font","caml_gr_set_line_width","caml_gr_set_text_size","caml_gr_set_window_title","caml_gr_sigio_handler","caml_gr_sigio_signal","caml_gr_size_x","caml_gr_size_y","caml_gr_state","caml_gr_state_create","caml_gr_state_get","caml_gr_state_init","caml_gr_state_set","caml_gr_synchronize","caml_gr_text_size","caml_gr_wait_event","caml_gr_window_id","caml_greaterequal","caml_greaterthan","caml_hash","caml_hash_mix_bigstring","caml_hash_mix_bytes","caml_hash_mix_bytes_arr","caml_hash_mix_final","caml_hash_mix_float","caml_hash_mix_int","caml_hash_mix_int64","caml_hash_mix_jsbytes","caml_hash_mix_string","caml_hash_nat","caml_hexstring_of_float","caml_hypot_float","caml_input_value","caml_input_value_from_bytes","caml_input_value_from_reader","caml_input_value_from_string","caml_input_value_to_outside_heap","caml_install_signal_handler","caml_int32_bits_of_float","caml_int32_bswap","caml_int32_float_of_bits","caml_int32_unmarshal","caml_int64_add","caml_int64_and","caml_int64_bits_of_float","caml_int64_bswap","caml_int64_compare","caml_int64_create_lo_hi","caml_int64_create_lo_mi_hi","caml_int64_div","caml_int64_float_of_bits","caml_int64_format","caml_int64_hash","caml_int64_hi32","caml_int64_is_negative","caml_int64_is_zero","caml_int64_lo32","caml_int64_marshal","caml_int64_mod","caml_int64_mul","caml_int64_neg","caml_int64_of_bytes","caml_int64_of_float","caml_int64_of_int32","caml_int64_of_string","caml_int64_offset","caml_int64_or","caml_int64_shift_left","caml_int64_shift_right","caml_int64_shift_right_unsigned","caml_int64_sub","caml_int64_to_bytes","caml_int64_to_float","caml_int64_to_int32","caml_int64_ult","caml_int64_unmarshal","caml_int64_xor","caml_int_compare","caml_int_of_string","caml_invalid_argument","caml_is_continuation_tag","caml_is_js","caml_is_ml_bytes","caml_is_ml_string","caml_is_printable","caml_is_special_exception","caml_js_call","caml_js_delete","caml_js_equals","caml_js_error_of_exception","caml_js_error_option_of_exception","caml_js_eval_string","caml_js_expr","caml_js_from_array","caml_js_from_bool","caml_js_from_float","caml_js_from_string","caml_js_fun_call","caml_js_function_arity","caml_js_get","caml_js_get_console","caml_js_html_entities","caml_js_html_escape","caml_js_instanceof","caml_js_meth_call","caml_js_new","caml_js_object","caml_js_on_ie","caml_js_pure_expr","caml_js_set","caml_js_strict_equals","caml_js_to_array","caml_js_to_bool","caml_js_to_byte_string","caml_js_to_float","caml_js_to_int32","caml_js_to_string","caml_js_typeof","caml_js_var","caml_js_wrap_callback","caml_js_wrap_callback_arguments","caml_js_wrap_callback_strict","caml_js_wrap_callback_unsafe","caml_js_wrap_meth_callback","caml_js_wrap_meth_callback_arguments","caml_js_wrap_meth_callback_strict","caml_js_wrap_meth_callback_unsafe","caml_jsbytes_of_string","caml_jsoo_flags_effects","caml_jsoo_flags_use_js_string","caml_jsstring_of_string","caml_lazy_make_forward","caml_lazy_read_result","caml_lazy_reset_to_lazy","caml_lazy_update_to_forcing","caml_lazy_update_to_forward","caml_ldexp_float","caml_lessequal","caml_lessthan","caml_lex_array","caml_lex_engine","caml_list_mount_point","caml_list_of_js_array","caml_list_to_js_array","caml_log10_float","caml_log1p_float","caml_log2_float","caml_lxm_next","caml_make_float_vect","caml_make_path","caml_make_vect","caml_marshal_constants","caml_marshal_data_size","caml_marshal_header_size","caml_maybe_attach_backtrace","caml_maybe_print_stats","caml_md5_bytes","caml_md5_chan","caml_md5_string","caml_memprof_discard","caml_memprof_set","caml_memprof_start","caml_memprof_stop","caml_ml_bytes_content","caml_ml_bytes_length","caml_ml_channel_get","caml_ml_channel_redirect","caml_ml_channel_restore","caml_ml_channel_size","caml_ml_channel_size_64","caml_ml_channels","caml_ml_close_channel","caml_ml_condition_broadcast","caml_ml_condition_new","caml_ml_condition_signal","caml_ml_condition_wait","caml_ml_debug_info_status","caml_ml_domain_cpu_relax","caml_ml_domain_id","caml_ml_domain_set_name","caml_ml_domain_unique_token","caml_ml_enable_runtime_warnings","caml_ml_flush","caml_ml_input","caml_ml_input_bigarray","caml_ml_input_block","caml_ml_input_char","caml_ml_input_int","caml_ml_input_scan_line","caml_ml_is_buffered","caml_ml_mutex_lock","caml_ml_mutex_new","caml_ml_mutex_try_lock","caml_ml_mutex_unlock","caml_ml_open_descriptor_in","caml_ml_open_descriptor_out","caml_ml_out_channels_list","caml_ml_output","caml_ml_output_bigarray","caml_ml_output_bytes","caml_ml_output_char","caml_ml_output_int","caml_ml_output_ta","caml_ml_pos_in","caml_ml_pos_in_64","caml_ml_pos_out","caml_ml_pos_out_64","caml_ml_runtime_events_pause","caml_ml_runtime_events_resume","caml_ml_runtime_events_start","caml_ml_runtime_warnings_enabled","caml_ml_seek_in","caml_ml_seek_in_64","caml_ml_seek_out","caml_ml_seek_out_64","caml_ml_set_binary_mode","caml_ml_set_buffered","caml_ml_set_channel_name","caml_ml_set_channel_output","caml_ml_set_channel_refill","caml_ml_string_length","caml_mod","caml_modf_float","caml_mount_autoload","caml_mul","caml_named_value","caml_named_values","caml_nativeint_unmarshal","caml_new_lex_engine","caml_new_string","caml_nextafter_float","caml_notequal","caml_obj_add_offset","caml_obj_block","caml_obj_compare_and_swap","caml_obj_dup","caml_obj_is_block","caml_obj_is_shared","caml_obj_make_forward","caml_obj_raw_field","caml_obj_reachable_words","caml_obj_set_raw_field","caml_obj_set_tag","caml_obj_tag","caml_obj_truncate","caml_obj_update_tag","caml_obj_with_tag","caml_ojs_iterate_properties","caml_ojs_new_arr","caml_ojs_wrap_fun_arguments","caml_oo_last_id","caml_output_val","caml_output_value","caml_output_value_to_buffer","caml_output_value_to_bytes","caml_output_value_to_string","caml_parse_digit","caml_parse_engine","caml_parse_format","caml_parse_sign_and_base","caml_parser_trace","caml_pos_in","caml_pos_out","caml_pure_js_expr","caml_raise_constant","caml_raise_end_of_file","caml_raise_no_such_file","caml_raise_not_a_dir","caml_raise_not_found","caml_raise_sys_error","caml_raise_with_arg","caml_raise_with_args","caml_raise_with_string","caml_raise_zero_divide","caml_raw_backtrace_length","caml_raw_backtrace_next_slot","caml_raw_backtrace_slot","caml_read_file_content","caml_recommended_domain_count","caml_record_backtrace","caml_record_backtrace_flag","caml_refill","caml_register_channel_for_spacetime","caml_register_global","caml_register_named_value","caml_restore_raw_backtrace","caml_root","caml_round_float","caml_runtime_events_create_cursor","caml_runtime_events_free_cursor","caml_runtime_events_read_poll","caml_runtime_events_user_register","caml_runtime_events_user_resolve","caml_runtime_events_user_write","caml_runtime_parameters","caml_runtime_variant","caml_runtime_warnings","caml_seek_in","caml_seek_out","caml_set_oo_id","caml_set_parser_trace","caml_set_static_env","caml_signbit_float","caml_sinh_float","caml_spacetime_enabled","caml_spacetime_only_works_for_native_code","caml_str_initialize","caml_str_repeat","caml_string_bound_error","caml_string_compare","caml_string_concat","caml_string_equal","caml_string_get","caml_string_get16","caml_string_get32","caml_string_get64","caml_string_greaterequal","caml_string_greaterthan","caml_string_hash","caml_string_lessequal","caml_string_lessthan","caml_string_notequal","caml_string_of_array","caml_string_of_bytes","caml_string_of_jsbytes","caml_string_of_jsstring","caml_string_set","caml_string_set16","caml_string_set32","caml_string_set64","caml_string_unsafe_get","caml_string_unsafe_set","caml_subarray_to_jsbytes","caml_sys_argv","caml_sys_chdir","caml_sys_close","caml_sys_const_backend_type","caml_sys_const_big_endian","caml_sys_const_int_size","caml_sys_const_max_wosize","caml_sys_const_naked_pointers_checked","caml_sys_const_ostype_cygwin","caml_sys_const_ostype_unix","caml_sys_const_ostype_win32","caml_sys_const_word_size","caml_sys_executable_name","caml_sys_exit","caml_sys_fds","caml_sys_file_exists","caml_sys_get_argv","caml_sys_get_config","caml_sys_getcwd","caml_sys_getenv","caml_sys_is_directory","caml_sys_is_regular_file","caml_sys_isatty","caml_sys_mkdir","caml_sys_modify_argv","caml_sys_open","caml_sys_open_for_node","caml_sys_random_seed","caml_sys_read_directory","caml_sys_remove","caml_sys_rename","caml_sys_rmdir","caml_sys_system_command","caml_sys_time","caml_sys_time_include_children","caml_sys_unsafe_getenv","caml_tanh_float","caml_to_js_string","caml_trailing_slash","caml_trampoline","caml_trampoline_return","caml_trunc_float","caml_uint8_array_of_bytes","caml_uint8_array_of_string","caml_unix_cleanup","caml_unix_closedir","caml_unix_filedescr_of_fd","caml_unix_findclose","caml_unix_findfirst","caml_unix_findnext","caml_unix_getpwuid","caml_unix_gettimeofday","caml_unix_getuid","caml_unix_gmtime","caml_unix_has_symlink","caml_unix_inet_addr_of_string","caml_unix_isatty","caml_unix_localtime","caml_unix_lstat","caml_unix_lstat_64","caml_unix_mkdir","caml_unix_mktime","caml_unix_opendir","caml_unix_readdir","caml_unix_readlink","caml_unix_rewinddir","caml_unix_rmdir","caml_unix_startup","caml_unix_stat","caml_unix_stat_64","caml_unix_symlink","caml_unix_time","caml_unix_unlink","caml_unmount","caml_update_dummy","caml_utf16_of_utf8","caml_utf8_of_utf16","caml_weak_create","caml_weak_set","caml_wrap_exception","caml_xmlhttprequest_create","compare_digits_nat","compare_nat","compare_nat_real","complement_nat","create_nat","decr_nat","deserialize_nat","div_digit_nat","div_helper","div_nat","fs_node_supported","incr_nat","initialize_nat","is_digit_int","is_digit_odd","is_digit_zero","jsoo_create_file","jsoo_create_file_extern","jsoo_effect_not_supported","jsoo_floor_log2","jsoo_is_ascii","jsoo_mount_point","jsoo_sys_getenv","land_digit_nat","length_nat","lor_digit_nat","lxor_digit_nat","make_unix_err_args","mult_digit_nat","mult_nat","nat_of_array","nth_digit_nat","nth_digit_nat_native","num_digits_nat","num_leading_zero_bits_in_digit","os_type","path_is_absolute","re_match","re_partial_match","re_replacement_text","re_search_backward","re_search_forward","re_string_match","resolve_fs_device","serialize_nat","set_digit_nat","set_digit_nat_native","set_to_zero_nat","shift_left_nat","shift_right_nat","square_nat","sub_nat"]),0];return}(globalThis));
//# 1 "../../.js/default/stdlib/stdlib.cma.js"
// Generated by js_of_ocaml
//# 3 "../../.js/default/stdlib/stdlib.cma.js"

//# 5 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function erase_rel(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, erase_rel(rest)];
      case 1:
       var rest$0 = param[1]; return [1, erase_rel(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, erase_rel(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, erase_rel(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, erase_rel(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, erase_rel(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, erase_rel(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, erase_rel(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1];
       return [8, ty, erase_rel(rest$7)];
      case 9:
       var rest$8 = param[3], ty1 = param[1];
       return [9, ty1, ty1, erase_rel(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, erase_rel(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, erase_rel(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, erase_rel(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, erase_rel(rest$12)];
      default: var rest$13 = param[1]; return [14, erase_rel(rest$13)];
    }
   }
   function concat_fmtty(fmtty1, fmtty2){
    if(typeof fmtty1 === "number") return fmtty2;
    switch(fmtty1[0]){
      case 0:
       var rest = fmtty1[1]; return [0, concat_fmtty(rest, fmtty2)];
      case 1:
       var rest$0 = fmtty1[1]; return [1, concat_fmtty(rest$0, fmtty2)];
      case 2:
       var rest$1 = fmtty1[1]; return [2, concat_fmtty(rest$1, fmtty2)];
      case 3:
       var rest$2 = fmtty1[1]; return [3, concat_fmtty(rest$2, fmtty2)];
      case 4:
       var rest$3 = fmtty1[1]; return [4, concat_fmtty(rest$3, fmtty2)];
      case 5:
       var rest$4 = fmtty1[1]; return [5, concat_fmtty(rest$4, fmtty2)];
      case 6:
       var rest$5 = fmtty1[1]; return [6, concat_fmtty(rest$5, fmtty2)];
      case 7:
       var rest$6 = fmtty1[1]; return [7, concat_fmtty(rest$6, fmtty2)];
      case 8:
       var rest$7 = fmtty1[2], ty = fmtty1[1];
       return [8, ty, concat_fmtty(rest$7, fmtty2)];
      case 9:
       var rest$8 = fmtty1[3], ty2 = fmtty1[2], ty1 = fmtty1[1];
       return [9, ty1, ty2, concat_fmtty(rest$8, fmtty2)];
      case 10:
       var rest$9 = fmtty1[1]; return [10, concat_fmtty(rest$9, fmtty2)];
      case 11:
       var rest$10 = fmtty1[1]; return [11, concat_fmtty(rest$10, fmtty2)];
      case 12:
       var rest$11 = fmtty1[1]; return [12, concat_fmtty(rest$11, fmtty2)];
      case 13:
       var rest$12 = fmtty1[1]; return [13, concat_fmtty(rest$12, fmtty2)];
      default:
       var rest$13 = fmtty1[1]; return [14, concat_fmtty(rest$13, fmtty2)];
    }
   }
   function concat_fmt(fmt1, fmt2){
    if(typeof fmt1 === "number") return fmt2;
    switch(fmt1[0]){
      case 0:
       var rest = fmt1[1]; return [0, concat_fmt(rest, fmt2)];
      case 1:
       var rest$0 = fmt1[1]; return [1, concat_fmt(rest$0, fmt2)];
      case 2:
       var rest$1 = fmt1[2], pad = fmt1[1];
       return [2, pad, concat_fmt(rest$1, fmt2)];
      case 3:
       var rest$2 = fmt1[2], pad$0 = fmt1[1];
       return [3, pad$0, concat_fmt(rest$2, fmt2)];
      case 4:
       var rest$3 = fmt1[4], prec = fmt1[3], pad$1 = fmt1[2], iconv = fmt1[1];
       return [4, iconv, pad$1, prec, concat_fmt(rest$3, fmt2)];
      case 5:
       var
        rest$4 = fmt1[4],
        prec$0 = fmt1[3],
        pad$2 = fmt1[2],
        iconv$0 = fmt1[1];
       return [5, iconv$0, pad$2, prec$0, concat_fmt(rest$4, fmt2)];
      case 6:
       var
        rest$5 = fmt1[4],
        prec$1 = fmt1[3],
        pad$3 = fmt1[2],
        iconv$1 = fmt1[1];
       return [6, iconv$1, pad$3, prec$1, concat_fmt(rest$5, fmt2)];
      case 7:
       var
        rest$6 = fmt1[4],
        prec$2 = fmt1[3],
        pad$4 = fmt1[2],
        iconv$2 = fmt1[1];
       return [7, iconv$2, pad$4, prec$2, concat_fmt(rest$6, fmt2)];
      case 8:
       var
        rest$7 = fmt1[4],
        prec$3 = fmt1[3],
        pad$5 = fmt1[2],
        fconv = fmt1[1];
       return [8, fconv, pad$5, prec$3, concat_fmt(rest$7, fmt2)];
      case 9:
       var rest$8 = fmt1[2], pad$6 = fmt1[1];
       return [9, pad$6, concat_fmt(rest$8, fmt2)];
      case 10:
       var rest$9 = fmt1[1]; return [10, concat_fmt(rest$9, fmt2)];
      case 11:
       var rest$10 = fmt1[2], str = fmt1[1];
       return [11, str, concat_fmt(rest$10, fmt2)];
      case 12:
       var rest$11 = fmt1[2], chr = fmt1[1];
       return [12, chr, concat_fmt(rest$11, fmt2)];
      case 13:
       var rest$12 = fmt1[3], fmtty = fmt1[2], pad$7 = fmt1[1];
       return [13, pad$7, fmtty, concat_fmt(rest$12, fmt2)];
      case 14:
       var rest$13 = fmt1[3], fmtty$0 = fmt1[2], pad$8 = fmt1[1];
       return [14, pad$8, fmtty$0, concat_fmt(rest$13, fmt2)];
      case 15:
       var rest$14 = fmt1[1]; return [15, concat_fmt(rest$14, fmt2)];
      case 16:
       var rest$15 = fmt1[1]; return [16, concat_fmt(rest$15, fmt2)];
      case 17:
       var rest$16 = fmt1[2], fmting_lit = fmt1[1];
       return [17, fmting_lit, concat_fmt(rest$16, fmt2)];
      case 18:
       var rest$17 = fmt1[2], fmting_gen = fmt1[1];
       return [18, fmting_gen, concat_fmt(rest$17, fmt2)];
      case 19:
       var rest$18 = fmt1[1]; return [19, concat_fmt(rest$18, fmt2)];
      case 20:
       var rest$19 = fmt1[3], char_set = fmt1[2], width_opt = fmt1[1];
       return [20, width_opt, char_set, concat_fmt(rest$19, fmt2)];
      case 21:
       var rest$20 = fmt1[2], counter = fmt1[1];
       return [21, counter, concat_fmt(rest$20, fmt2)];
      case 22:
       var rest$21 = fmt1[1]; return [22, concat_fmt(rest$21, fmt2)];
      case 23:
       var rest$22 = fmt1[2], ign = fmt1[1];
       return [23, ign, concat_fmt(rest$22, fmt2)];
      default:
       var rest$23 = fmt1[3], f = fmt1[2], arity = fmt1[1];
       return [24, arity, f, concat_fmt(rest$23, fmt2)];
    }
   }
   var CamlinternalFormatBasics = [0, concat_fmtty, erase_rel, concat_fmt];
   runtime.caml_register_global
    (0, CamlinternalFormatBasics, "CamlinternalFormatBasics");
   return;
  }
  (globalThis));

//# 179 "../../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function make(v){return [0, v];}
   function get(r){return r[1];}
   function set(r, v){r[1] = v; return 0;}
   function exchange(r, v){var cur = r[1]; r[1] = v; return cur;}
   function compare_and_set(r, seen, v){
    var cur = r[1];
    return cur === seen ? (r[1] = v, 1) : 0;
   }
   function fetch_and_add(r, n){
    var cur = r[1];
    r[1] = cur + n | 0;
    return cur;
   }
   function incr(r){fetch_and_add(r, 1); return 0;}
   function decr(r){fetch_and_add(r, -1); return 0;}
   var
    CamlinternalAtomic =
      [0,
       make,
       get,
       set,
       exchange,
       compare_and_set,
       fetch_and_add,
       incr,
       decr];
   runtime.caml_register_global(0, CamlinternalAtomic, "CamlinternalAtomic");
   return;
  }
  (globalThis));

//# 215 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_false$0 = "false",
    cst_true$0 = "true",
    caml_create_bytes = runtime.caml_create_bytes,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_channel_size = runtime.caml_ml_channel_size,
    caml_ml_channel_size_64 = runtime.caml_ml_channel_size_64,
    caml_ml_close_channel = runtime.caml_ml_close_channel,
    caml_ml_flush = runtime.caml_ml_flush,
    caml_ml_input = runtime.caml_ml_input,
    caml_ml_input_char = runtime.caml_ml_input_char,
    caml_ml_open_descriptor_in = runtime.caml_ml_open_descriptor_in,
    caml_ml_open_descriptor_out = runtime.caml_ml_open_descriptor_out,
    caml_ml_output = runtime.caml_ml_output,
    caml_ml_output_bytes = runtime.caml_ml_output_bytes,
    caml_ml_output_char = runtime.caml_ml_output_char,
    caml_ml_set_binary_mode = runtime.caml_ml_set_binary_mode,
    caml_ml_set_channel_name = runtime.caml_ml_set_channel_name,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_concat = runtime.caml_string_concat,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_sys_open = runtime.caml_sys_open,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalAtomic = global_data.CamlinternalAtomic,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Invalid_argument = global_data.Invalid_argument,
    Failure = global_data.Failure,
    Match_failure = global_data.Match_failure,
    Assert_failure = global_data.Assert_failure,
    Not_found = global_data.Not_found,
    Out_of_memory = global_data.Out_of_memory,
    Stack_overflow = global_data.Stack_overflow,
    Sys_error = global_data.Sys_error,
    End_of_file = global_data.End_of_file,
    Division_by_zero = global_data.Division_by_zero,
    Sys_blocked_io = global_data.Sys_blocked_io,
    Undefined_recursive_module = global_data.Undefined_recursive_module;
   function failwith(s){
    throw caml_maybe_attach_backtrace([0, Failure, s], 1);
   }
   function invalid_arg(s){
    throw caml_maybe_attach_backtrace([0, Invalid_argument, s], 1);
   }
   var Exit = [248, "Stdlib.Exit", runtime.caml_fresh_oo_id(0)];
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return runtime.caml_greaterequal(x, y) ? x : y;}
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lnot(x){return x ^ -1;}
   var
    infinity =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 32752)),
    neg_infinity =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 65520)),
    nan =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(1, 0, 32752)),
    max_float =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32751)),
    min_float =
      caml_int64_float_of_bits(runtime.caml_int64_create_lo_mi_hi(0, 0, 16)),
    epsilon_float =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 15536)),
    symbol_concat = caml_string_concat,
    cst_char_of_int = "char_of_int",
    cst_true = cst_true$0,
    cst_false = cst_false$0,
    cst_bool_of_string = "bool_of_string",
    _a_ = [0, 1],
    _b_ = [0, 0];
   function char_of_int(n){
    if(0 <= n && 255 >= n) return n;
    return invalid_arg(cst_char_of_int);
   }
   function string_of_bool(b){return b ? cst_true : cst_false;}
   function bool_of_string(param){
    return param !== cst_false$0
            ? param !== cst_true$0 ? invalid_arg(cst_bool_of_string) : 1
            : 0;
   }
   function bool_of_string_opt(param){
    return param !== cst_false$0 ? param !== cst_true$0 ? 0 : _a_ : _b_;
   }
   function string_of_int(n){return "" + n;}
   function int_of_string_opt(s){
    try{var _u_ = [0, caml_int_of_string(s)]; return _u_;}
    catch(_v_){
     var _t_ = caml_wrap_exception(_v_);
     if(_t_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_t_, 0);
    }
   }
   function valid_float_lexem(s1){
    var l = caml_ml_string_length(s1), i = 0;
    for(;;){
     if(l <= i) return s1 + ".";
     var match = runtime.caml_string_get(s1, i);
     a:
     {
      if(48 <= match){if(58 > match) break a;} else if(45 === match) break a;
      return s1;
     }
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function string_of_float(f){
    return valid_float_lexem(runtime.caml_format_float("%.12g", f));
   }
   function float_of_string_opt(s){
    try{var _r_ = [0, caml_float_of_string(s)]; return _r_;}
    catch(_s_){
     var _q_ = caml_wrap_exception(_s_);
     if(_q_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_q_, 0);
    }
   }
   function symbol(l1, l2){
    if(! l1) return l2;
    var tl = l1[2], hd = l1[1];
    return [0, hd, symbol(tl, l2)];
   }
   var
    stdin = caml_ml_open_descriptor_in(0),
    stdout = caml_ml_open_descriptor_out(1),
    stderr = caml_ml_open_descriptor_out(2),
    _c_ = [0, 1, [0, 3, [0, 4, [0, 7, 0]]]],
    _d_ = [0, 1, [0, 3, [0, 4, [0, 6, 0]]]],
    cst_output = "output",
    cst_output_substring = "output_substring",
    _e_ = [0, 0, [0, 7, 0]],
    _f_ = [0, 0, [0, 6, 0]],
    cst_input = "input",
    cst_really_input = "really_input";
   function open_out_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_out(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_out(name){return open_out_gen(_c_, 438, name);}
   function open_out_bin(name){return open_out_gen(_d_, 438, name);}
   function flush_all(param){
    var param$0 = runtime.caml_ml_out_channels_list(0);
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     try{caml_ml_flush(a);}
     catch(_p_){
      var _o_ = caml_wrap_exception(_p_);
      if(_o_[1] !== Sys_error) throw caml_maybe_attach_backtrace(_o_, 0);
     }
     param$0 = l;
    }
   }
   function output_bytes(oc, s){
    return caml_ml_output_bytes(oc, s, 0, caml_ml_bytes_length(s));
   }
   function output_string(oc, s){
    return caml_ml_output(oc, s, 0, caml_ml_string_length(s));
   }
   function output(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_output_bytes(oc, s, ofs, len);
    return invalid_arg(cst_output);
   }
   function output_substring(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(s) - len | 0) >= ofs)
     return caml_ml_output(oc, s, ofs, len);
    return invalid_arg(cst_output_substring);
   }
   function output_value(chan, v){
    return runtime.caml_output_value(chan, v, 0);
   }
   function close_out(oc){
    caml_ml_flush(oc);
    return caml_ml_close_channel(oc);
   }
   function close_out_noerr(oc){
    try{caml_ml_flush(oc);}catch(_n_){}
    try{var _l_ = caml_ml_close_channel(oc); return _l_;}catch(_m_){return 0;}
   }
   function open_in_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_in(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_in(name){return open_in_gen(_e_, 0, name);}
   function open_in_bin(name){return open_in_gen(_f_, 0, name);}
   function input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_input(ic, s, ofs, len);
    return invalid_arg(cst_input);
   }
   function unsafe_really_input(ic, s, ofs, len){
    var ofs$0 = ofs, len$0 = len;
    for(;;){
     if(0 >= len$0) return 0;
     var r = caml_ml_input(ic, s, ofs$0, len$0);
     if(0 === r) throw caml_maybe_attach_backtrace(End_of_file, 1);
     var len$1 = len$0 - r | 0, ofs$1 = ofs$0 + r | 0;
     ofs$0 = ofs$1;
     len$0 = len$1;
    }
   }
   function really_input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return unsafe_really_input(ic, s, ofs, len);
    return invalid_arg(cst_really_input);
   }
   function really_input_string(ic, len){
    var s = caml_create_bytes(len);
    really_input(ic, s, 0, len);
    return caml_string_of_bytes(s);
   }
   function input_line(chan){
    function build_result(buf, pos, param){
     var pos$0 = pos, param$0 = param;
     for(;;){
      if(! param$0) return buf;
      var tl = param$0[2], hd = param$0[1], len = caml_ml_bytes_length(hd);
      runtime.caml_blit_bytes(hd, 0, buf, pos$0 - len | 0, len);
      var pos$1 = pos$0 - len | 0;
      pos$0 = pos$1;
      param$0 = tl;
     }
    }
    var accu = 0, len = 0;
    for(;;){
     var n = runtime.caml_ml_input_scan_line(chan);
     if(0 === n){
      if(! accu) throw caml_maybe_attach_backtrace(End_of_file, 1);
      var _k_ = build_result(caml_create_bytes(len), len, accu);
     }
     else{
      if(0 >= n){
       var beg = caml_create_bytes(- n | 0);
       caml_ml_input(chan, beg, 0, - n | 0);
       var len$1 = len - n | 0, accu$0 = [0, beg, accu];
       accu = accu$0;
       len = len$1;
       continue;
      }
      var res = caml_create_bytes(n - 1 | 0);
      caml_ml_input(chan, res, 0, n - 1 | 0);
      caml_ml_input_char(chan);
      if(accu)
       var
        len$0 = (len + n | 0) - 1 | 0,
        _k_ = build_result(caml_create_bytes(len$0), len$0, [0, res, accu]);
      else
       var _k_ = res;
     }
     return caml_string_of_bytes(_k_);
    }
   }
   function close_in_noerr(ic){
    try{var _i_ = caml_ml_close_channel(ic); return _i_;}catch(_j_){return 0;}
   }
   function print_char(c){return caml_ml_output_char(stdout, c);}
   function print_string(s){return output_string(stdout, s);}
   function print_bytes(s){return output_bytes(stdout, s);}
   function print_int(i){return output_string(stdout, "" + i);}
   function print_float(f){return output_string(stdout, string_of_float(f));}
   function print_endline(s){
    output_string(stdout, s);
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function print_newline(param){
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function prerr_char(c){return caml_ml_output_char(stderr, c);}
   function prerr_string(s){return output_string(stderr, s);}
   function prerr_bytes(s){return output_bytes(stderr, s);}
   function prerr_int(i){return output_string(stderr, "" + i);}
   function prerr_float(f){return output_string(stderr, string_of_float(f));}
   function prerr_endline(s){
    output_string(stderr, s);
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function prerr_newline(param){
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function read_line(param){caml_ml_flush(stdout); return input_line(stdin);}
   function read_int(param){return caml_int_of_string(read_line(0));}
   function read_int_opt(param){return int_of_string_opt(read_line(0));}
   function read_float(param){return caml_float_of_string(read_line(0));}
   function read_float_opt(param){return float_of_string_opt(read_line(0));}
   function string_of_format(param){var str = param[2]; return str;}
   function symbol$0(param, _h_){
    var
     str2 = _h_[2],
     fmt2 = _h_[1],
     str1 = param[2],
     fmt1 = param[1],
     s2 = "%," + str2;
    return [0, caml_call2(CamlinternalFormatBasics[3], fmt1, fmt2), str1 + s2];
   }
   var exit_function = caml_call1(CamlinternalAtomic[1], flush_all);
   function at_exit(f){
    for(;;){
     var
      f_yet_to_run = caml_call1(CamlinternalAtomic[1], 1),
      old_exit = caml_call1(CamlinternalAtomic[2], exit_function);
     let f_yet_to_run$0 = f_yet_to_run, old_exit$0 = old_exit;
     var
      new_exit =
        function(param){
         if(caml_call3(CamlinternalAtomic[5], f_yet_to_run$0, 1, 0))
          caml_call1(f, 0);
         return caml_call1(old_exit$0, 0);
        },
      success =
        caml_call3(CamlinternalAtomic[5], exit_function, old_exit, new_exit),
      _g_ = 1 - success;
     if(! _g_) return _g_;
    }
   }
   function do_at_exit(param){
    return caml_call1(caml_call1(CamlinternalAtomic[2], exit_function), 0);
   }
   function exit(retcode){
    do_at_exit(0);
    return runtime.caml_sys_exit(retcode);
   }
   runtime.caml_register_named_value("Pervasives.do_at_exit", do_at_exit);
   var
    Stdlib =
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       2147483647,
       -2147483648,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       symbol_concat,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       symbol,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       runtime.caml_ml_output_int,
       output_value,
       runtime.caml_ml_seek_out,
       runtime.caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       runtime.caml_ml_input_int,
       runtime.caml_input_value,
       runtime.caml_ml_seek_in,
       runtime.caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
   runtime.caml_register_global(46, Stdlib, "Stdlib");
   return;
  }
  (globalThis));

//# 978 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    ocaml_version = "4.14.0",
    ocaml_release = [0, 4, 14, 0, 0],
    Stdlib = global_data.Stdlib,
    executable_name = runtime.caml_sys_executable_name(0),
    os_type = runtime.caml_sys_get_config(0)[1],
    backend_type = [0, "js_of_ocaml"],
    unix = runtime.caml_sys_const_ostype_unix(0),
    win32 = runtime.caml_sys_const_ostype_win32(0),
    cygwin = runtime.caml_sys_const_ostype_cygwin(0),
    max_array_length = runtime.caml_sys_const_max_wosize(0),
    max_floatarray_length = max_array_length / 2 | 0,
    max_string_length = (4 * max_array_length | 0) - 1 | 0;
   function getenv_opt(s){
    try{var _d_ = [0, runtime.caml_sys_getenv(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var interactive = [0, 0];
   function set_signal(sig_num, sig_beh){return 0;}
   var Break = [248, "Stdlib.Sys.Break", runtime.caml_fresh_oo_id(0)];
   function catch_break(on){return on ? 0 : 0;}
   function Make(_b_, _a_){return [0, 1];}
   var
    Immediate64 = [0, Make],
    Stdlib_Sys =
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       backend_type,
       unix,
       win32,
       cygwin,
       32,
       32,
       0,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       -1,
       -2,
       -3,
       -4,
       -5,
       -6,
       -7,
       -8,
       -9,
       -10,
       -11,
       -12,
       -13,
       -14,
       -15,
       -16,
       -17,
       -18,
       -19,
       -20,
       -21,
       -22,
       -23,
       -24,
       -25,
       -26,
       -27,
       -28,
       Break,
       catch_break,
       ocaml_version,
       0,
       ocaml_release,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
   runtime.caml_register_global(4, Stdlib_Sys, "Stdlib__Sys");
   return;
  }
  (globalThis));

//# 1073 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Obj_extension_constructor$1 = "Obj.extension_constructor",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys;
   function is_block(a){return 1 - (typeof a === "number" ? 1 : 0);}
   var
    double_field = runtime.caml_array_get,
    set_double_field = runtime.caml_array_set,
    custom_tag = 255,
    _a_ = [0, "obj.ml", 95, 4],
    cst_Obj_extension_constructor = cst_Obj_extension_constructor$1,
    cst_Obj_extension_constructor$0 = cst_Obj_extension_constructor$1;
   function info(obj){
    if(caml_obj_tag(obj) !== 247)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var
     info = runtime.caml_obj_raw_field(obj, 1),
     arity = 64 === Stdlib_Sys[9] ? info >> 56 : info >> 24,
     start_env = info << 8 >>> 9 | 0;
    return [0, arity, start_env];
   }
   function of_val(x){
    a:
    {
     if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1){var slot = x[1]; break a;}
     var slot = x;
    }
    a:
    {
     if(is_block(slot) && caml_obj_tag(slot) === 248){var name = slot[1]; break a;}
     var name = caml_call1(Stdlib[1], cst_Obj_extension_constructor$0);
    }
    return caml_obj_tag(name) === 252
            ? slot
            : caml_call1(Stdlib[1], cst_Obj_extension_constructor);
   }
   function name(slot){return slot[1];}
   function id(slot){return slot[2];}
   var
    Extension_constructor = [0, of_val, name, id],
    extension_constructor = Extension_constructor[1],
    extension_name = Extension_constructor[2],
    extension_id = Extension_constructor[3],
    max_ephe_length = Stdlib_Sys[13] - 2 | 0,
    cst_Obj_Ephemeron_create = "Obj.Ephemeron.create",
    cst_Obj_Ephemeron_get_key = "Obj.Ephemeron.get_key",
    cst_Obj_Ephemeron_get_key_copy = "Obj.Ephemeron.get_key_copy",
    cst_Obj_Ephemeron_set_key = "Obj.Ephemeron.set_key",
    cst_Obj_Ephemeron_unset_key = "Obj.Ephemeron.unset_key",
    cst_Obj_Ephemeron_check_key = "Obj.Ephemeron.check_key",
    cst_Obj_Ephemeron_blit_key = "Obj.Ephemeron.blit_key";
   function create(l){
    var _g_ = 0 <= l ? 1 : 0, _h_ = _g_ ? l <= max_ephe_length ? 1 : 0 : _g_;
    if(1 - _h_) caml_call1(Stdlib[1], cst_Obj_Ephemeron_create);
    return runtime.caml_ephe_create(l);
   }
   function length(x){return x.length - 3 | 0;}
   function raise_if_invalid_offset(e, o, msg){
    var
     _d_ = 0 <= o ? 1 : 0,
     _e_ = _d_ ? o < length(e) ? 1 : 0 : _d_,
     _f_ = 1 - _e_;
    return _f_ ? caml_call1(Stdlib[1], msg) : _f_;
   }
   function get_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key);
    return runtime.caml_ephe_get_key(e, o);
   }
   function get_key_copy(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key_copy);
    return runtime.caml_ephe_get_key_copy(e, o);
   }
   function set_key(e, o, x){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_set_key);
    return runtime.caml_ephe_set_key(e, o, x);
   }
   function unset_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_unset_key);
    return runtime.caml_ephe_unset_key(e, o);
   }
   function check_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_check_key);
    return runtime.caml_ephe_check_key(e, o);
   }
   function blit_key(e1, o1, e2, o2, l){
    if
     (0 <= l
      &&
       0 <= o1
       && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2){
     var
      _b_ = 0 !== l ? 1 : 0,
      _c_ = _b_ ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : _b_;
     return _c_;
    }
    return caml_call1(Stdlib[1], cst_Obj_Ephemeron_blit_key);
   }
   var
    Stdlib_Obj =
      [0,
       is_block,
       double_field,
       set_double_field,
       0,
       245,
       246,
       247,
       248,
       249,
       250,
       251,
       251,
       252,
       253,
       254,
       custom_tag,
       custom_tag,
       1000,
       1001,
       1002,
       [0, info],
       Extension_constructor,
       extension_constructor,
       extension_name,
       extension_id,
       [0,
        create,
        length,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        runtime.caml_ephe_get_data,
        runtime.caml_ephe_get_data_copy,
        runtime.caml_ephe_set_data,
        runtime.caml_ephe_unset_data,
        runtime.caml_ephe_check_data,
        runtime.caml_ephe_blit_data,
        max_ephe_length]];
   runtime.caml_register_global(13, Stdlib_Obj, "Stdlib__Obj");
   return;
  }
  (globalThis));

//# 1235 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_make_forward = runtime.caml_obj_make_forward,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined =
      [248, "CamlinternalLazy.Undefined", runtime.caml_fresh_oo_id(0)];
   function raise_undefined(param){
    throw caml_maybe_attach_backtrace(Undefined, 1);
   }
   function force_lazy_block(blk){
    var closure = blk[1];
    blk[1] = raise_undefined;
    try{
     var result = caml_call1(closure, 0);
     caml_obj_make_forward(blk, result);
     return result;
    }
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     blk[1] = function(param){throw caml_maybe_attach_backtrace(e, 0);};
     throw caml_maybe_attach_backtrace(e, 0);
    }
   }
   function force_val_lazy_block(blk){
    var closure = blk[1];
    blk[1] = raise_undefined;
    var result = caml_call1(closure, 0);
    caml_obj_make_forward(blk, result);
    return result;
   }
   function force(lzv){
    var t = caml_obj_tag(lzv);
    return t === Stdlib_Obj[10]
            ? lzv[1]
            : t !== Stdlib_Obj[6] ? lzv : force_lazy_block(lzv);
   }
   function force_val(lzv){
    var t = caml_obj_tag(lzv);
    return t === Stdlib_Obj[10]
            ? lzv[1]
            : t !== Stdlib_Obj[6] ? lzv : force_val_lazy_block(lzv);
   }
   var
    CamlinternalLazy =
      [0, Undefined, force_lazy_block, force_val_lazy_block, force, force_val];
   runtime.caml_register_global(2, CamlinternalLazy, "CamlinternalLazy");
   return;
  }
  (globalThis));

//# 1300 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined = CamlinternalLazy[1],
    force_val = CamlinternalLazy[5];
   function from_fun(f){
    var x = runtime.caml_obj_block(Stdlib_Obj[6], 1);
    x[1] = f;
    return x;
   }
   function from_val(v){
    var t = caml_obj_tag(v);
    if(t !== Stdlib_Obj[10] && t !== Stdlib_Obj[6] && t !== Stdlib_Obj[14])
     return v;
    return runtime.caml_lazy_make_forward(v);
   }
   function is_val(l){
    var _i_ = Stdlib_Obj[6];
    return caml_obj_tag(l) !== _i_ ? 1 : 0;
   }
   function map(f, x){
    return [246,
            function(_f_){
             var
              _g_ = caml_obj_tag(x),
              _h_ =
                250 === _g_
                 ? x[1]
                 : 246 === _g_ ? caml_call1(CamlinternalLazy[2], x) : x;
             return caml_call1(f, _h_);
            }];
   }
   function map_val(f, x){
    if(! is_val(x))
     return [246,
             function(_c_){
              var
               _d_ = caml_obj_tag(x),
               _e_ =
                 250 === _d_
                  ? x[1]
                  : 246 === _d_ ? caml_call1(CamlinternalLazy[2], x) : x;
              return caml_call1(f, _e_);
             }];
    var
     _a_ = caml_obj_tag(x),
     _b_ =
       250 === _a_
        ? x[1]
        : 246 === _a_ ? caml_call1(CamlinternalLazy[2], x) : x;
    return from_val(caml_call1(f, _b_));
   }
   var
    Stdlib_Lazy =
      [0,
       Undefined,
       map,
       is_val,
       from_val,
       map_val,
       from_fun,
       force_val,
       from_fun,
       from_val,
       is_val];
   runtime.caml_register_global(2, Stdlib_Lazy, "Stdlib__Lazy");
   return;
  }
  (globalThis));

//# 1382 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    CamlinternalAtomic = global_data.CamlinternalAtomic,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib = global_data.Stdlib,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    cst_Seq_init = "Seq.init",
    cst_Seq_take = "Seq.take",
    cst_Seq_drop = "Seq.drop";
   function empty(param){return 0;}
   function return$0(x, param){return [0, x, empty];}
   function cons(x, next, param){return [0, x, next];}
   function append(seq1, seq2, param){
    var match = caml_call1(seq1, 0);
    if(! match) return caml_call1(seq2, 0);
    var next = match[2], x = match[1];
    return [0, x, function(_av_){return append(next, seq2, _av_);}];
   }
   function map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return [0, caml_call1(f, x), function(_au_){return map(f, next, _au_);}];
   }
   function filter_map(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(match$0){
      var y = match$0[1];
      return [0, y, function(_at_){return filter_map(f, next, _at_);}];
     }
     seq$0 = next;
    }
   }
   function filter(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     if(caml_call1(f, x))
      return [0, x, function(_as_){return filter(f, next, _as_);}];
     seq$0 = next;
    }
   }
   function concat(seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return append(x, function(_ar_){return concat(next, _ar_);}, 0);
   }
   function flat_map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return append
            (caml_call1(f, x),
             function(_aq_){return flat_map(f, next, _aq_);},
             0);
   }
   function fold_left(f, acc, seq){
    var acc$0 = acc, seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return acc$0;
     var next = match[2], x = match[1], acc$1 = caml_call2(f, acc$0, x);
     acc$0 = acc$1;
     seq$0 = next;
    }
   }
   function iter(f, seq){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     caml_call1(f, x);
     seq$0 = next;
    }
   }
   function unfold(f, u, param){
    var match = caml_call1(f, u);
    if(! match) return 0;
    var match$0 = match[1], u$0 = match$0[2], x = match$0[1];
    return [0, x, function(_ap_){return unfold(f, u$0, _ap_);}];
   }
   function is_empty(xs){return caml_call1(xs, 0) ? 0 : 1;}
   function uncons(xs){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return [0, [0, x, xs$0]];
   }
   function length(xs$1){
    var accu = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var xs$0 = match[2], accu$0 = accu + 1 | 0;
     accu = accu$0;
     xs = xs$0;
    }
   }
   function iteri(f, xs$1){
    var i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     caml_call2(f, i, x);
     var i$0 = i + 1 | 0;
     i = i$0;
     xs = xs$0;
    }
   }
   function fold_lefti(f, accu$1, xs$1){
    var accu = accu$1, i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var
      xs$0 = match[2],
      x = match[1],
      accu$0 = caml_call3(f, accu, i, x),
      i$0 = i + 1 | 0;
     accu = accu$0;
     i = i$0;
     xs = xs$0;
    }
   }
   function for_all(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], _ao_ = caml_call1(p, x);
     if(! _ao_) return _ao_;
     xs$0 = xs$1;
    }
   }
   function exists(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], _an_ = caml_call1(p, x);
     if(_an_) return _an_;
     xs$0 = xs$1;
    }
   }
   function find(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1];
     if(caml_call1(p, x)) return [0, x];
     xs$0 = xs$1;
    }
   }
   function find_map(f, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], result = caml_call1(f, x);
     if(result) return result;
     xs$0 = xs$1;
    }
   }
   function iter2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1];
     caml_call2(f, x, y);
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function fold_left2(f, accu, xs, ys){
    var accu$0 = accu, xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return accu$0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return accu$0;
     var
      ys$1 = match$0[2],
      y = match$0[1],
      accu$1 = caml_call3(f, accu$0, x, y);
     accu$0 = accu$1;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function for_all2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], _am_ = caml_call2(f, x, y);
     if(! _am_) return _am_;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function exists2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1], _al_ = caml_call2(f, x, y);
     if(_al_) return _al_;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function equal(eq, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(match){
      if(match$0){
       var
        ys$1 = match$0[2],
        y = match$0[1],
        xs$1 = match[2],
        x = match[1],
        _ak_ = caml_call2(eq, x, y);
       if(! _ak_) return _ak_;
       xs$0 = xs$1;
       ys$0 = ys$1;
       continue;
      }
     }
     else if(! match$0) return 1;
     return 0;
    }
   }
   function compare(cmp, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(! match) return match$0 ? -1 : 0;
     var xs$1 = match[2], x = match[1];
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], c = caml_call2(cmp, x, y);
     if(0 !== c) return c;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function init_aux(f, i, j, param){
    if(i >= j) return 0;
    var _ai_ = i + 1 | 0;
    return [0,
            caml_call1(f, i),
            function(_aj_){return init_aux(f, _ai_, j, _aj_);}];
   }
   function init(n, f){
    if(0 > n) return caml_call1(Stdlib[1], cst_Seq_init);
    var _ag_ = 0;
    return function(_ah_){return init_aux(f, _ag_, n, _ah_);};
   }
   function repeat(x, param){
    return [0, x, function(_af_){return repeat(x, _af_);}];
   }
   function forever(f, param){
    return [0, caml_call1(f, 0), function(_ae_){return forever(f, _ae_);}];
   }
   function cycle_nonempty(xs, param){
    return append(xs, function(_ad_){return cycle_nonempty(xs, _ad_);}, 0);
   }
   function cycle(xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    function _aa_(_ac_){return cycle_nonempty(xs, _ac_);}
    return [0, x, function(_ab_){return append(xs$0, _aa_, _ab_);}];
   }
   function iterate1(f, x, param){
    var y = caml_call1(f, x);
    return [0, y, function(_$_){return iterate1(f, y, _$_);}];
   }
   function iterate(f, x){
    function next(___){return iterate1(f, x, ___);}
    return function(_Z_){return [0, x, next];};
   }
   function mapi_aux(f, i, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _X_ = i + 1 | 0;
    return [0,
            caml_call2(f, i, x),
            function(_Y_){return mapi_aux(f, _X_, xs$0, _Y_);}];
   }
   function mapi(f, xs){
    var _V_ = 0;
    return function(_W_){return mapi_aux(f, _V_, xs, _W_);};
   }
   function tail_scan(f, s, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], s$0 = caml_call2(f, s, x);
    return [0, s$0, function(_U_){return tail_scan(f, s$0, xs$0, _U_);}];
   }
   function scan(f, s, xs){
    function next(_T_){return tail_scan(f, s, xs, _T_);}
    return function(_S_){return [0, s, next];};
   }
   function take_aux(n, xs){
    return 0 === n
            ? empty
            : function
             (param){
              var match = caml_call1(xs, 0);
              if(! match) return 0;
              var xs$0 = match[2], x = match[1];
              return [0, x, take_aux(n - 1 | 0, xs$0)];
             };
   }
   function take(n, xs){
    if(n < 0) caml_call1(Stdlib[1], cst_Seq_take);
    return take_aux(n, xs);
   }
   function drop(n, xs){
    return 0 <= n
            ? 0
              === n
              ? xs
              : function
               (param){
                var n$0 = n, xs$0 = xs;
                for(;;){
                 var match = caml_call1(xs$0, 0);
                 if(! match) return 0;
                 var xs$1 = match[2], n$1 = n$0 - 1 | 0;
                 if(0 === n$1) return caml_call1(xs$1, 0);
                 n$0 = n$1;
                 xs$0 = xs$1;
                }
               }
            : caml_call1(Stdlib[1], cst_Seq_drop);
   }
   function take_while(p, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return caml_call1(p, x)
            ? [0, x, function(_R_){return take_while(p, xs$0, _R_);}]
            : 0;
   }
   function drop_while(p, xs, param){
    var xs$0 = xs;
    for(;;){
     var node = caml_call1(xs$0, 0);
     if(! node) return 0;
     var xs$1 = node[2], x = node[1];
     if(! caml_call1(p, x)) return node;
     xs$0 = xs$1;
    }
   }
   function group(eq, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _K_ = caml_call1(eq, x);
    function _L_(_Q_){return drop_while(_K_, xs$0, _Q_);}
    var _M_ = caml_call1(eq, x);
    function next(_P_){return take_while(_M_, xs$0, _P_);}
    return [0,
            function(_O_){return [0, x, next];},
            function(_N_){return group(eq, _L_, _N_);}];
   }
   var
    Forced_twice =
      [248, "Stdlib.Seq.Forced_twice", runtime.caml_fresh_oo_id(0)],
    to_lazy = Stdlib_Lazy[6],
    _a_ = [0, "seq.ml", 596, 4];
   function failure(param){
    throw caml_maybe_attach_backtrace(Forced_twice, 1);
   }
   function memoize(xs){
    function s$0(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, memoize(xs$0)];
    }
    var s = caml_call1(to_lazy, s$0);
    return function(_J_){
     var _I_ = runtime.caml_obj_tag(s);
     return 250 === _I_
             ? s[1]
             : 246 === _I_ ? caml_call1(CamlinternalLazy[2], s) : s;};
   }
   function once(xs){
    function f(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, once(xs$0)];
    }
    var action = caml_call1(CamlinternalAtomic[1], f);
    return function(param){
     var f = caml_call2(CamlinternalAtomic[4], action, failure);
     return caml_call1(f, 0);};
   }
   function zip(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0, [0, x, y], function(_H_){return zip(xs$0, ys$0, _H_);}];
   }
   function map2(f, xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0,
            caml_call2(f, x, y),
            function(_G_){return map2(f, xs$0, ys$0, _G_);}];
   }
   function interleave(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return caml_call1(ys, 0);
    var xs$0 = match[2], x = match[1];
    return [0, x, function(_F_){return interleave(ys, xs$0, _F_);}];
   }
   function sorted_merge1(cmp, x, xs, y, ys){
    return 0 < caml_call2(cmp, x, y)
            ? [0,
              y,
              function(_D_){
               var match = caml_call1(ys, 0);
               if(! match) return [0, x, xs];
               var ys$0 = match[2], y = match[1];
               return sorted_merge1(cmp, x, xs, y, ys$0);
              }]
            : [0,
              x,
              function(_E_){
               var match = caml_call1(xs, 0);
               if(! match) return [0, y, ys];
               var xs$0 = match[2], x = match[1];
               return sorted_merge1(cmp, x, xs$0, y, ys);
              }];
   }
   function sorted_merge(cmp, xs, ys, param){
    var match = caml_call1(xs, 0), match$0 = caml_call1(ys, 0);
    if(match){
     if(match$0){
      var ys$0 = match$0[2], y = match$0[1], xs$0 = match[2], x = match[1];
      return sorted_merge1(cmp, x, xs$0, y, ys$0);
     }
     var c = match;
    }
    else{if(! match$0) return 0; var c = match$0;}
    return c;
   }
   function map_fst(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], x = match[1][1];
    return [0, x, function(_C_){return map_fst(xys$0, _C_);}];
   }
   function map_snd(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], y = match[1][2];
    return [0, y, function(_B_){return map_snd(xys$0, _B_);}];
   }
   function unzip(xys){
    return [0,
            function(_A_){return map_fst(xys, _A_);},
            function(_z_){return map_snd(xys, _z_);}];
   }
   function filter_map_find_left_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 === match$0[0]){
      var y = match$0[1];
      return [0,
              y,
              function(_y_){return filter_map_find_left_map(f, xs$1, _y_);}];
     }
     xs$0 = xs$1;
    }
   }
   function filter_map_find_right_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 !== match$0[0]){
      var z = match$0[1];
      return [0,
              z,
              function(_x_){return filter_map_find_right_map(f, xs$1, _x_);}];
     }
     xs$0 = xs$1;
    }
   }
   function partition_map(f, xs){
    return [0,
            function(_w_){return filter_map_find_left_map(f, xs, _w_);},
            function(_v_){return filter_map_find_right_map(f, xs, _v_);}];
   }
   function partition(p, xs){
    function _s_(x){return 1 - caml_call1(p, x);}
    return [0,
            function(_u_){return filter(p, xs, _u_);},
            function(_t_){return filter(_s_, xs, _t_);}];
   }
   function peel(xss){
    return unzip(function(_r_){return filter_map(uncons, xss, _r_);});
   }
   function transpose(xss, param){
    var match = peel(xss), tails = match[2], heads = match[1];
    if(! is_empty(heads))
     return [0, heads, function(_q_){return transpose(tails, _q_);}];
    if(is_empty(tails)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function _b_(remainders, xss, param){
    var match = caml_call1(xss, 0);
    if(! match) return transpose(remainders, 0);
    var xss$0 = match[2], xs = match[1], match$0 = caml_call1(xs, 0);
    if(match$0){
     var
      xs$0 = match$0[2],
      x = match$0[1],
      match$1 = peel(remainders),
      tails = match$1[2],
      heads = match$1[1],
      _l_ = function(_p_){return [0, xs$0, tails];};
     return [0,
             function(_o_){return [0, x, heads];},
             function(_n_){return _b_(_l_, xss$0, _n_);}];
    }
    var
     match$2 = peel(remainders),
     tails$0 = match$2[2],
     heads$0 = match$2[1];
    return [0, heads$0, function(_m_){return _b_(tails$0, xss$0, _m_);}];
   }
   function map_product(f, xs, ys){
    function _f_(x){
     function _j_(y){return caml_call2(f, x, y);}
     return function(_k_){return map(_j_, ys, _k_);};
    }
    function xss(_i_){return map(_f_, xs, _i_);}
    function _e_(_h_){return _b_(empty, xss, _h_);}
    return function(_g_){return concat(_e_, _g_);};
   }
   function product(xs, ys){
    return map_product(function(x, y){return [0, x, y];}, xs, ys);
   }
   function of_dispenser(it){
    function c(param){
     var match = caml_call1(it, 0);
     if(! match) return 0;
     var x = match[1];
     return [0, x, c];
    }
    return c;
   }
   function to_dispenser(xs){
    var s = [0, xs];
    return function(param){
     var match = caml_call1(s[1], 0);
     if(! match) return 0;
     var xs = match[2], x = match[1];
     s[1] = xs;
     return [0, x];};
   }
   function ints(i, param){
    var _c_ = i + 1 | 0;
    return [0, i, function(_d_){return ints(_c_, _d_);}];
   }
   var
    Stdlib_Seq =
      [0,
       is_empty,
       uncons,
       length,
       iter,
       fold_left,
       iteri,
       fold_lefti,
       for_all,
       exists,
       find,
       find_map,
       iter2,
       fold_left2,
       for_all2,
       exists2,
       equal,
       compare,
       empty,
       return$0,
       cons,
       init,
       unfold,
       repeat,
       forever,
       cycle,
       iterate,
       map,
       mapi,
       filter,
       filter_map,
       scan,
       take,
       drop,
       take_while,
       drop_while,
       group,
       memoize,
       Forced_twice,
       once,
       transpose,
       append,
       concat,
       flat_map,
       flat_map,
       zip,
       map2,
       interleave,
       sorted_merge,
       product,
       map_product,
       unzip,
       unzip,
       partition_map,
       partition,
       of_dispenser,
       to_dispenser,
       ints];
   runtime.caml_register_global(10, Stdlib_Seq, "Stdlib__Seq");
   return;
  }
  (globalThis));

//# 2068 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    cst_option_is_None = "option is None";
   function some(v){return [0, v];}
   function value(o, default$0){
    if(! o) return default$0;
    var v = o[1];
    return v;
   }
   function get(param){
    if(! param) return caml_call1(Stdlib[1], cst_option_is_None);
    var v = param[1];
    return v;
   }
   function bind(o, f){
    if(! o) return 0;
    var v = o[1];
    return caml_call1(f, v);
   }
   function join(param){if(! param) return 0; var o = param[1]; return o;}
   function map(f, o){
    if(! o) return 0;
    var v = o[1];
    return [0, caml_call1(f, v)];
   }
   function fold(none, some, param){
    if(! param) return none;
    var v = param[1];
    return caml_call1(some, v);
   }
   function iter(f, param){
    if(! param) return 0;
    var v = param[1];
    return caml_call1(f, v);
   }
   function is_none(param){return param ? 0 : 1;}
   function is_some(param){return param ? 1 : 0;}
   function equal(eq, o0, o1){
    if(o0){
     if(o1){var v1 = o1[1], v0 = o0[1]; return caml_call2(eq, v0, v1);}
    }
    else if(! o1) return 1;
    return 0;
   }
   function compare(cmp, o0, o1){
    if(! o0) return o1 ? -1 : 0;
    var v0 = o0[1];
    if(! o1) return 1;
    var v1 = o1[1];
    return caml_call2(cmp, v0, v1);
   }
   function to_result(none, param){
    if(! param) return [1, none];
    var v = param[1];
    return [0, v];
   }
   function to_list(param){
    if(! param) return 0;
    var v = param[1];
    return [0, v, 0];
   }
   function to_seq(param){
    if(! param) return Stdlib_Seq[18];
    var v = param[1];
    return caml_call1(Stdlib_Seq[19], v);
   }
   var
    Stdlib_Option =
      [0,
       0,
       some,
       value,
       get,
       bind,
       join,
       map,
       fold,
       iter,
       is_none,
       is_some,
       equal,
       compare,
       to_result,
       to_list,
       to_seq];
   runtime.caml_register_global(3, Stdlib_Option, "Stdlib__Option");
   return;
  }
  (globalThis));

//# 2176 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    cst_result_is_Error = "result is Error _",
    cst_result_is_Ok = "result is Ok _";
   function ok(v){return [0, v];}
   function error(e){return [1, e];}
   function value(r, default$0){
    if(0 !== r[0]) return default$0;
    var v = r[1];
    return v;
   }
   function get_ok(param){
    if(0 !== param[0]) return caml_call1(Stdlib[1], cst_result_is_Error);
    var v = param[1];
    return v;
   }
   function get_error(param){
    if(0 === param[0]) return caml_call1(Stdlib[1], cst_result_is_Ok);
    var e = param[1];
    return e;
   }
   function bind(r, f){
    if(0 !== r[0]) return r;
    var v = r[1];
    return caml_call1(f, v);
   }
   function join(e){if(0 !== e[0]) return e; var r = e[1]; return r;}
   function map(f, e){
    if(0 !== e[0]) return e;
    var v = e[1];
    return [0, caml_call1(f, v)];
   }
   function map_error(f, v){
    if(0 === v[0]) return v;
    var e = v[1];
    return [1, caml_call1(f, e)];
   }
   function fold(ok, error, param){
    if(0 === param[0]){var v = param[1]; return caml_call1(ok, v);}
    var e = param[1];
    return caml_call1(error, e);
   }
   function iter(f, param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return caml_call1(f, v);
   }
   function iter_error(f, param){
    if(0 === param[0]) return 0;
    var e = param[1];
    return caml_call1(f, e);
   }
   function is_ok(param){return 0 === param[0] ? 1 : 0;}
   function is_error(param){return 0 === param[0] ? 0 : 1;}
   function equal(ok, error, r0, r1){
    if(0 === r0[0]){
     var v0 = r0[1];
     if(0 === r1[0]){var v1 = r1[1]; return caml_call2(ok, v0, v1);}
    }
    else{
     var e0 = r0[1];
     if(0 !== r1[0]){var e1 = r1[1]; return caml_call2(error, e0, e1);}
    }
    return 0;
   }
   function compare(ok, error, r0, r1){
    if(0 === r0[0]){
     var v0 = r0[1];
     if(0 !== r1[0]) return -1;
     var v1 = r1[1];
     return caml_call2(ok, v0, v1);
    }
    var e0 = r0[1];
    if(0 === r1[0]) return 1;
    var e1 = r1[1];
    return caml_call2(error, e0, e1);
   }
   function to_option(param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return [0, v];
   }
   function to_list(param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return [0, v, 0];
   }
   function to_seq(param){
    if(0 !== param[0]) return Stdlib_Seq[18];
    var v = param[1];
    return caml_call1(Stdlib_Seq[19], v);
   }
   var
    Stdlib_Result =
      [0,
       ok,
       error,
       value,
       get_ok,
       get_error,
       bind,
       join,
       map,
       map_error,
       fold,
       iter,
       iter_error,
       is_ok,
       is_error,
       equal,
       compare,
       to_option,
       to_list,
       to_seq];
   runtime.caml_register_global(4, Stdlib_Result, "Stdlib__Result");
   return;
  }
  (globalThis));

//# 2338 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_string_of_bytes = runtime.caml_string_of_bytes;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\\\\",
    cst$0 = "\\'",
    Stdlib = global_data.Stdlib,
    cst_Char_chr = "Char.chr",
    cst_b = "\\b",
    cst_t = "\\t",
    cst_n = "\\n",
    cst_r = "\\r";
   function chr(n){
    if(0 <= n && 255 >= n) return n;
    return caml_call1(Stdlib[1], cst_Char_chr);
   }
   function escaped(c){
    a:
    {
     if(40 <= c){
      if(92 === c) return cst;
      if(127 > c) break a;
     }
     else{
      if(32 <= c){if(39 <= c) return cst$0; break a;}
      if(14 > c)
       switch(c){
         case 8:
          return cst_b;
         case 9:
          return cst_t;
         case 10:
          return cst_n;
         case 13:
          return cst_r;
       }
     }
     var s = caml_create_bytes(4);
     caml_bytes_unsafe_set(s, 0, 92);
     caml_bytes_unsafe_set(s, 1, 48 + (c / 100 | 0) | 0);
     caml_bytes_unsafe_set(s, 2, 48 + ((c / 10 | 0) % 10 | 0) | 0);
     caml_bytes_unsafe_set(s, 3, 48 + (c % 10 | 0) | 0);
     return caml_string_of_bytes(s);
    }
    var s$0 = caml_create_bytes(1);
    caml_bytes_unsafe_set(s$0, 0, c);
    return caml_string_of_bytes(s$0);
   }
   function lowercase(c){
    var _b_ = c - 192 | 0;
    a:
    {
     if(30 < _b_ >>> 0){
      if(25 < _b_ + 127 >>> 0) break a;
     }
     else if(23 === _b_) break a;
     return c + 32 | 0;
    }
    return c;
   }
   function uppercase(c){
    var _a_ = c - 224 | 0;
    a:
    {
     if(30 < _a_ >>> 0){
      if(25 < _a_ + 127 >>> 0) break a;
     }
     else if(23 === _a_) break a;
     return c - 32 | 0;
    }
    return c;
   }
   function lowercase_ascii(c){return 25 < c - 65 >>> 0 ? c : c + 32 | 0;}
   function uppercase_ascii(c){return 25 < c - 97 >>> 0 ? c : c - 32 | 0;}
   function compare(c1, c2){return c1 - c2 | 0;}
   function equal(c1, c2){return 0 === (c1 - c2 | 0) ? 1 : 0;}
   var
    Stdlib_Char =
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare,
       equal];
   runtime.caml_register_global(8, Stdlib_Char, "Stdlib__Char");
   return;
  }
  (globalThis));

//# 2443 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_uchar_ml = "uchar.ml",
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    err_no_pred = "U+0000 has no predecessor",
    err_no_succ = "U+10FFFF has no successor",
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    cst_is_not_an_Unicode_scalar_v = " is not an Unicode scalar value",
    cst_is_not_a_latin1_character = " is not a latin1 character",
    cst_U = "U+",
    lo_bound = 55295,
    hi_bound = 57344;
   function succ(u){
    return u === 55295
            ? hi_bound
            : u === 1114111 ? caml_call1(Stdlib[1], err_no_succ) : u + 1 | 0;
   }
   function pred(u){
    return u === 57344
            ? lo_bound
            : u === 0 ? caml_call1(Stdlib[1], err_no_pred) : u - 1 | 0;
   }
   function is_valid(i){
    var _n_ = 0 <= i ? 1 : 0, _o_ = _n_ ? i <= 55295 ? 1 : 0 : _n_;
    if(_o_)
     var _p_ = _o_;
    else
     var _q_ = 57344 <= i ? 1 : 0, _p_ = _q_ ? i <= 1114111 ? 1 : 0 : _q_;
    return _p_;
   }
   function of_int(i){
    if(is_valid(i)) return i;
    var
     _m_ =
       caml_call2
        (Stdlib[28], caml_format_int("%X", i), cst_is_not_an_Unicode_scalar_v);
    return caml_call1(Stdlib[1], _m_);
   }
   function is_char(u){return u < 256 ? 1 : 0;}
   function of_char(c){return c;}
   function to_char(u){
    if(255 >= u) return u;
    var
     _k_ =
       caml_call2
        (Stdlib[28],
         caml_format_int("%04X", u),
         cst_is_not_a_latin1_character),
     _l_ = caml_call2(Stdlib[28], cst_U, _k_);
    return caml_call1(Stdlib[1], _l_);
   }
   function unsafe_to_char(_j_){return _j_;}
   function equal(_i_, _h_){return _i_ === _h_ ? 1 : 0;}
   var
    compare = runtime.caml_int_compare,
    _a_ = [0, cst_uchar_ml, 85, 7],
    _b_ = [0, cst_uchar_ml, 80, 18],
    _c_ = [0, cst_uchar_ml, 91, 7],
    _d_ = [0, cst_uchar_ml, 88, 18];
   function hash(_g_){return _g_;}
   function utf_decode_is_valid(d){return 1 === (d >>> 27 | 0) ? 1 : 0;}
   function utf_decode_length(d){return (d >>> 24 | 0) & 7;}
   function utf_decode_uchar(d){return d & 16777215;}
   function utf_decode(n, u){return (8 | n) << 24 | u;}
   function utf_decode_invalid(n){return n << 24 | 65533;}
   function utf_8_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u) return 1;
    if(2047 >= u) return 2;
    if(65535 >= u) return 3;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return 4;
   }
   function utf_16_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    if(65535 >= u) return 2;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    return 4;
   }
   var
    Stdlib_Uchar =
      [0,
       0,
       1114111,
       65279,
       65533,
       succ,
       pred,
       is_valid,
       of_int,
       function(_f_){return _f_;},
       function(_e_){return _e_;},
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal,
       compare,
       hash,
       utf_decode_is_valid,
       utf_decode_uchar,
       utf_decode_length,
       utf_decode,
       utf_decode_invalid,
       utf_8_byte_length,
       utf_16_byte_length];
   runtime.caml_register_global(13, Stdlib_Uchar, "Stdlib__Uchar");
   return;
  }
  (globalThis));

//# 2575 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_List_nth$1 = "List.nth",
    caml_compare = runtime.caml_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Sys = global_data.Stdlib__Sys,
    cst_hd = "hd",
    cst_tl = "tl",
    cst_nth = "nth",
    cst_List_nth = cst_List_nth$1,
    cst_List_nth$0 = cst_List_nth$1;
   function length(l$0){
    var len = 0, param = l$0;
    for(;;){
     if(! param) return len;
     var l = param[2], len$0 = len + 1 | 0;
     len = len$0;
     param = l;
    }
   }
   function cons(a, l){return [0, a, l];}
   function hd(param){
    if(! param) return caml_call1(Stdlib[2], cst_hd);
    var a = param[1];
    return a;
   }
   function tl(param){
    if(! param) return caml_call1(Stdlib[2], cst_tl);
    var l = param[2];
    return l;
   }
   function nth(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return caml_call1(Stdlib[2], cst_nth);
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return a;
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   function nth_opt(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth$0);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0;
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   var append = Stdlib[37];
   function rev_append(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var l1$1 = l1$0[2], a = l1$0[1], l2$1 = [0, a, l2$0];
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function rev(l){return rev_append(l, 0);}
   function init_aux(i, n, f){
    if(n <= i) return 0;
    var r = caml_call1(f, i);
    return [0, r, init_aux(i + 1 | 0, n, f)];
   }
   var
    cst_List_map2 = "List.map2",
    cst_List_iter2 = "List.iter2",
    cst_List_fold_left2 = "List.fold_left2",
    cst_List_fold_right2 = "List.fold_right2",
    cst_List_for_all2 = "List.for_all2",
    cst_List_exists2 = "List.exists2",
    _b_ = [0, 0, 0],
    cst_List_combine = "List.combine",
    cst_List_rev_map2 = "List.rev_map2",
    cst_List_init = "List.init",
    rev_init_threshold = typeof Stdlib_Sys[5] === "number" ? 10000 : 50;
   function init(len, f){
    if(0 > len) return caml_call1(Stdlib[1], cst_List_init);
    if(rev_init_threshold >= len) return init_aux(0, len, f);
    var acc = 0, i = 0;
    for(;;){
     if(len <= i) return rev(acc);
     var i$0 = i + 1 | 0, acc$0 = [0, caml_call1(f, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function flatten(param){
    if(! param) return 0;
    var r = param[2], l = param[1], _H_ = flatten(r);
    return caml_call2(Stdlib[37], l, _H_);
   }
   function map(f, param){
    if(! param) return 0;
    var l = param[2], a = param[1], r = caml_call1(f, a);
    return [0, r, map(f, l)];
   }
   function _a_(i, f, param){
    if(! param) return 0;
    var l = param[2], a = param[1], r = caml_call2(f, i, a);
    return [0, r, _a_(i + 1 | 0, f, l)];
   }
   function mapi(f, l){return _a_(0, f, l);}
   function rev_map(f, l){
    var accu = 0, param = l;
    for(;;){
     if(! param) return accu;
     var l$0 = param[2], a = param[1], accu$0 = [0, caml_call1(f, a), accu];
     accu = accu$0;
     param = l$0;
    }
   }
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     caml_call1(f, a);
     param$0 = l;
    }
   }
   function iteri(f, l$0){
    var i = 0, param = l$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1];
     caml_call2(f, i, a);
     var i$0 = i + 1 | 0;
     i = i$0;
     param = l;
    }
   }
   function fold_left(f, accu, l){
    var accu$0 = accu, l$0 = l;
    for(;;){
     if(! l$0) return accu$0;
     var l$1 = l$0[2], a = l$0[1], accu$1 = caml_call2(f, accu$0, a);
     accu$0 = accu$1;
     l$0 = l$1;
    }
   }
   function fold_right(f, l, accu){
    if(! l) return accu;
    var l$0 = l[2], a = l[1];
    return caml_call2(f, a, fold_right(f, l$0, accu));
   }
   function map2(f, l1, l2){
    if(l1){
     if(l2){
      var
       l2$0 = l2[2],
       a2 = l2[1],
       l1$0 = l1[2],
       a1 = l1[1],
       r = caml_call2(f, a1, a2);
      return [0, r, map2(f, l1$0, l2$0)];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_map2);
   }
   function rev_map2(f, l1, l2){
    var accu = 0, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$0 = [0, caml_call2(f, a1, a2), accu];
       accu = accu$0;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu;
     return caml_call1(Stdlib[1], cst_List_rev_map2);
    }
   }
   function iter2(f, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1];
       caml_call2(f, a1, a2);
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_iter2);
    }
   }
   function fold_left2(f, accu, l1, l2){
    var accu$0 = accu, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$1 = caml_call3(f, accu$0, a1, a2);
       accu$0 = accu$1;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu$0;
     return caml_call1(Stdlib[1], cst_List_fold_left2);
    }
   }
   function fold_right2(f, l1, l2, accu){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return caml_call3(f, a1, a2, fold_right2(f, l1$0, l2$0, accu));
     }
    }
    else if(! l2) return accu;
    return caml_call1(Stdlib[1], cst_List_fold_right2);
   }
   function for_all(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 1;
     var l = param$0[2], a = param$0[1], _G_ = caml_call1(p, a);
     if(! _G_) return _G_;
     param$0 = l;
    }
   }
   function exists(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _F_ = caml_call1(p, a);
     if(_F_) return _F_;
     param$0 = l;
    }
   }
   function for_all2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _E_ = caml_call2(p, a1, a2);
       if(! _E_) return _E_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return caml_call1(Stdlib[1], cst_List_for_all2);
    }
   }
   function exists2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _D_ = caml_call2(p, a1, a2);
       if(_D_) return _D_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_exists2);
    }
   }
   function mem(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1],
      _C_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_C_) return _C_;
     param$0 = l;
    }
   }
   function memq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _B_ = a === x ? 1 : 0;
     if(_B_) return _B_;
     param$0 = l;
    }
   }
   function assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return b;
     param$0 = l;
    }
   }
   function assoc_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return [0, b];
     param$0 = l;
    }
   }
   function assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return b;
     param$0 = l;
    }
   }
   function assq_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return [0, b];
     param$0 = l;
    }
   }
   function mem_assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1][1],
      _A_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_A_) return _A_;
     param$0 = l;
    }
   }
   function mem_assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1][1], _z_ = a === x ? 1 : 0;
     if(_z_) return _z_;
     param$0 = l;
    }
   }
   function remove_assoc(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return 0 === caml_compare(a, x) ? l : [0, pair, remove_assoc(x, l)];
   }
   function remove_assq(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return a === x ? l : [0, pair, remove_assq(x, l)];
   }
   function find(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return x;
     param$0 = l;
    }
   }
   function find_opt(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return [0, x];
     param$0 = l;
    }
   }
   function find_map(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1], result = caml_call1(f, x);
     if(result) return result;
     param$0 = l;
    }
   }
   function find_all(p){
    var accu = 0;
    return function(param$0){
     var accu$0 = accu, param = param$0;
     for(;;){
      if(! param) return rev(accu$0);
      var l = param[2], x = param[1];
      if(caml_call1(p, x)){
       var accu$1 = [0, x, accu$0];
       accu$0 = accu$1;
       param = l;
      }
      else
       param = l;
     }};
   }
   function filteri(p, l){
    var i = 0, acc = 0, param = l;
    for(;;){
     if(! param) return rev(acc);
     var
      l$0 = param[2],
      x = param[1],
      acc$0 = caml_call2(p, i, x) ? [0, x, acc] : acc,
      i$0 = i + 1 | 0;
     i = i$0;
     acc = acc$0;
     param = l$0;
    }
   }
   function filter_map(f){
    var accu = 0;
    return function(param$0){
     var accu$0 = accu, param = param$0;
     for(;;){
      if(! param) return rev(accu$0);
      var l = param[2], x = param[1], match = caml_call1(f, x);
      if(match){
       var v = match[1], accu$1 = [0, v, accu$0];
       accu$0 = accu$1;
       param = l;
      }
      else
       param = l;
     }};
   }
   function concat_map(f, l){
    var acc = 0, param = l;
    for(;;){
     if(! param) return rev(acc);
     var
      l$0 = param[2],
      x = param[1],
      xs = caml_call1(f, x),
      acc$0 = rev_append(xs, acc);
     acc = acc$0;
     param = l$0;
    }
   }
   function fold_left_map(f, accu, l){
    var accu$0 = accu, l_accu = 0, param = l;
    for(;;){
     if(! param) return [0, accu$0, rev(l_accu)];
     var
      l$0 = param[2],
      x = param[1],
      match = caml_call2(f, accu$0, x),
      x$0 = match[2],
      accu$1 = match[1],
      l_accu$0 = [0, x$0, l_accu];
     accu$0 = accu$1;
     l_accu = l_accu$0;
     param = l$0;
    }
   }
   function partition(p, l){
    var yes = 0, no = 0, param = l;
    for(;;){
     if(! param){var _y_ = rev(no); return [0, rev(yes), _y_];}
     var l$0 = param[2], x = param[1];
     if(caml_call1(p, x)){
      var yes$0 = [0, x, yes];
      yes = yes$0;
      param = l$0;
     }
     else{var no$0 = [0, x, no]; no = no$0; param = l$0;}
    }
   }
   function partition_map(p, l){
    var left = 0, right = 0, param = l;
    for(;;){
     if(! param){var _x_ = rev(right); return [0, rev(left), _x_];}
     var l$0 = param[2], x = param[1], match = caml_call1(p, x);
     if(0 === match[0]){
      var v = match[1], left$0 = [0, v, left];
      left = left$0;
      param = l$0;
     }
     else{
      var v$0 = match[1], right$0 = [0, v$0, right];
      right = right$0;
      param = l$0;
     }
    }
   }
   function split(param){
    if(! param) return _b_;
    var
     l = param[2],
     match = param[1],
     y = match[2],
     x = match[1],
     match$0 = split(l),
     ry = match$0[2],
     rx = match$0[1];
    return [0, [0, x, rx], [0, y, ry]];
   }
   function combine(l1, l2){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return [0, [0, a1, a2], combine(l1$0, l2$0)];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_combine);
   }
   function merge(cmp, l1, l2){
    if(! l1) return l2;
    if(! l2) return l1;
    var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
    return 0 < caml_call2(cmp, h1, h2)
            ? [0, h2, merge(cmp, l1, t2)]
            : [0, h1, merge(cmp, t1, l2)];
   }
   function stable_sort(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x2, [0, x1, 0]]
            : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _w_ = l[2];
      if(_w_){
       var match$2 = _w_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _w_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x1$0, x3)
              ? 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]]
              : [0, x2$0, [0, x1$0, [0, x3, 0]]]
            : 0
              < caml_call2(cmp, x2$0, x3)
              ? 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]]
              : [0, x1$0, [0, x2$0, [0, x3, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h2, accu];
        l2 = t2;
        accu = accu$1;
        continue;
       }
       var _v_ = rev_append(l1, accu);
      }
      else
       var _v_ = rev_append(l2, accu);
      return [0, _v_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x1, [0, x2, 0]]
            : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _u_ = l[2];
      if(_u_){
       var match$2 = _u_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _u_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x2$0, x3)
              ? [0, x1$0, [0, x2$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]]
            : 0
              < caml_call2(cmp, x1$0, x3)
              ? [0, x2$0, [0, x1$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h2, accu];
         l2 = t2;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h1, accu];
        l1 = t1;
        accu = accu$1;
        continue;
       }
       var _t_ = rev_append(l1, accu);
      }
      else
       var _t_ = rev_append(l2, accu);
      return [0, _t_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function sort_uniq(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 <= c$0 ? [0, x2, [0, x1, 0]] : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _n_ = l[2];
      if(_n_){
       var match$2 = _n_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _n_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _o_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 <= c$2 ? [0, x3, [0, x2$0, 0]] : [0, x2$0, [0, x3, 0]],
          s$0 = _o_;
        else if(0 <= c$1){
         var c$3 = caml_call2(cmp, x1$0, x3);
         if(0 === c$3)
          var _p_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 <= c$3)
          var
           c$4 = caml_call2(cmp, x2$0, x3),
           _q_ =
             0 === c$4
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                <= c$4
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]],
           _p_ = _q_;
         else
          var _p_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         var s$0 = _p_;
        }
        else{
         var c$5 = caml_call2(cmp, x2$0, x3);
         if(0 === c$5)
          var _r_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 <= c$5)
          var
           c$6 = caml_call2(cmp, x1$0, x3),
           _s_ =
             0 === c$6
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                <= c$6
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]],
           _r_ = _s_;
         else
          var _r_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         var s$0 = _r_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         l2 = t2;
         accu = accu$0;
         continue;
        }
        if(0 < c){
         var accu$1 = [0, h1, accu];
         l1 = t1;
         accu = accu$1;
         continue;
        }
        var accu$2 = [0, h2, accu];
        l2 = t2;
        accu = accu$2;
        continue;
       }
       var _m_ = rev_append(l1, accu);
      }
      else
       var _m_ = rev_append(l2, accu);
      return [0, _m_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 < c$0 ? [0, x1, [0, x2, 0]] : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _g_ = l[2];
      if(_g_){
       var match$2 = _g_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _g_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _h_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 < c$2 ? [0, x2$0, [0, x3, 0]] : [0, x3, [0, x2$0, 0]],
          s$0 = _h_;
        else if(0 < c$1){
         var c$3 = caml_call2(cmp, x2$0, x3);
         if(0 === c$3)
          var _i_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 < c$3)
          var _i_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         else
          var
           c$4 = caml_call2(cmp, x1$0, x3),
           _j_ =
             0 === c$4
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                < c$4
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]],
           _i_ = _j_;
         var s$0 = _i_;
        }
        else{
         var c$5 = caml_call2(cmp, x1$0, x3);
         if(0 === c$5)
          var _k_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 < c$5)
          var _k_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         else
          var
           c$6 = caml_call2(cmp, x2$0, x3),
           _l_ =
             0 === c$6
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                < c$6
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]],
           _k_ = _l_;
         var s$0 = _k_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         l2 = t2;
         accu = accu$0;
         continue;
        }
        if(0 <= c){
         var accu$1 = [0, h2, accu];
         l2 = t2;
         accu = accu$1;
         continue;
        }
        var accu$2 = [0, h1, accu];
        l1 = t1;
        accu = accu$2;
        continue;
       }
       var _f_ = rev_append(l1, accu);
      }
      else
       var _f_ = rev_append(l2, accu);
      return [0, _f_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function compare_lengths(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], l1$1 = l1$0[2];
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function compare_length_with(l, n){
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0 === n$0 ? 0 : 0 < n$0 ? -1 : 1;
     var l$1 = l$0[2];
     if(0 >= n$0) return 1;
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   function equal(eq, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _e_ = caml_call2(eq, a1, a2);
       if(! _e_) return _e_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return 0;
    }
   }
   function compare(cmp, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     var l1$1 = l1$0[2], a1 = l1$0[1];
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], a2 = l2$0[1], c = caml_call2(cmp, a1, a2);
     if(0 !== c) return c;
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function to_seq(l){
    function aux(l, param){
     if(! l) return 0;
     var tail = l[2], x = l[1];
     return [0, x, function(_d_){return aux(tail, _d_);}];
    }
    return function(_c_){return aux(l, _c_);};
   }
   function of_seq(seq){
    function direct(depth, seq){
     if(0 === depth)
      return rev
              (caml_call3
                (Stdlib_Seq[5], function(acc, x){return [0, x, acc];}, 0, seq));
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     return [0, x, direct(depth - 1 | 0, next)];
    }
    return direct(500, seq);
   }
   var
    Stdlib_List =
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal,
       compare,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       stable_sort,
       stable_sort,
       stable_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
   runtime.caml_register_global(18, Stdlib_List, "Stdlib__List");
   return;
  }
  (globalThis));

//# 3709 "../../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lognot(x){return x ^ -1;}
   function equal(_b_, _a_){return _b_ === _a_ ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function min(x, y){return x <= y ? x : y;}
   function max(x, y){return y <= x ? x : y;}
   function to_string(x){return "" + x;}
   var
    Stdlib_Int =
      [0,
       0,
       1,
       -1,
       abs,
       2147483647,
       -2147483648,
       lognot,
       equal,
       compare,
       min,
       max,
       to_string];
   runtime.caml_register_global(1, Stdlib_Int, "Stdlib__Int");
   return;
  }
  (globalThis));

//# 3741 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_bytes_ml = "bytes.ml",
    cst_index_out_of_bounds$3 = "index out of bounds",
    caml_blit_bytes = runtime.caml_blit_bytes,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_get16 = runtime.caml_bytes_get16,
    caml_bytes_get32 = runtime.caml_bytes_get32,
    caml_bytes_get64 = runtime.caml_bytes_get64,
    caml_bytes_of_string = runtime.caml_bytes_of_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_bytes_set32 = runtime.caml_bytes_set32,
    caml_bytes_set64 = runtime.caml_bytes_set64,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fill_bytes = runtime.caml_fill_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Char = global_data.Stdlib__Char;
   function make(n, c){
    var s = caml_create_bytes(n);
    caml_fill_bytes(s, 0, n, c);
    return s;
   }
   function init(n, f){
    var s = caml_create_bytes(n), _ap_ = n - 1 | 0, _ao_ = 0;
    if(_ap_ >= 0){
     var i = _ao_;
     for(;;){
      caml_bytes_unsafe_set(s, i, caml_call1(f, i));
      var _aq_ = i + 1 | 0;
      if(_ap_ === i) break;
      i = _aq_;
     }
    }
    return s;
   }
   var
    empty = caml_create_bytes(0),
    cst_String_sub_Bytes_sub = "String.sub / Bytes.sub",
    cst_Bytes_extend = "Bytes.extend",
    cst_String_fill_Bytes_fill = "String.fill / Bytes.fill",
    cst_Bytes_blit = "Bytes.blit",
    cst_String_blit_Bytes_blit_str = "String.blit / Bytes.blit_string",
    cst_Bytes_concat = "Bytes.concat",
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from";
   function copy(s){
    var len = caml_ml_bytes_length(s), r = caml_create_bytes(len);
    caml_blit_bytes(s, 0, r, 0, len);
    return r;
   }
   function to_string(b){return caml_string_of_bytes(copy(b));}
   function of_string(s){return copy(caml_bytes_of_string(s));}
   function sub(s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs){
     var r = caml_create_bytes(len);
     caml_blit_bytes(s, ofs, r, 0, len);
     return r;
    }
    return caml_call1(Stdlib[1], cst_String_sub_Bytes_sub);
   }
   function sub_string(b, ofs, len){
    return caml_string_of_bytes(sub(b, ofs, len));
   }
   function symbol(a, b){
    var c = a + b | 0, _an_ = b < 0 ? 1 : 0, match = c < 0 ? 1 : 0;
    a:
    {
     if(a < 0){if(_an_ && ! match) break a;} else if(! _an_ && match) break a;
     return c;
    }
    return caml_call1(Stdlib[1], cst_Bytes_extend);
   }
   function extend(s, left, right){
    var
     len = symbol(symbol(caml_ml_bytes_length(s), left), right),
     r = caml_create_bytes(len);
    if(0 <= left)
     var dstoff = left, srcoff = 0;
    else
     var dstoff = 0, srcoff = - left | 0;
    var
     cpylen =
       caml_call2
        (Stdlib_Int[10],
         caml_ml_bytes_length(s) - srcoff | 0,
         len - dstoff | 0);
    if(0 < cpylen) caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
    return r;
   }
   function fill(s, ofs, len, c){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_fill_bytes(s, ofs, len, c);
    return caml_call1(Stdlib[1], cst_String_fill_Bytes_fill);
   }
   function blit(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (caml_ml_bytes_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return caml_blit_bytes(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Bytes_blit);
   }
   function blit_string(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (runtime.caml_ml_string_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return runtime.caml_blit_string(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_String_blit_Bytes_blit_str);
   }
   function iter(f, a){
    var _al_ = caml_ml_bytes_length(a) - 1 | 0, _ak_ = 0;
    if(_al_ >= 0){
     var i = _ak_;
     for(;;){
      caml_call1(f, caml_bytes_unsafe_get(a, i));
      var _am_ = i + 1 | 0;
      if(_al_ === i) break;
      i = _am_;
     }
    }
    return 0;
   }
   function iteri(f, a){
    var _ai_ = caml_ml_bytes_length(a) - 1 | 0, _ah_ = 0;
    if(_ai_ >= 0){
     var i = _ah_;
     for(;;){
      caml_call2(f, i, caml_bytes_unsafe_get(a, i));
      var _aj_ = i + 1 | 0;
      if(_ai_ === i) break;
      i = _aj_;
     }
    }
    return 0;
   }
   function concat(sep, l){
    if(! l) return empty;
    var seplen = caml_ml_bytes_length(sep);
    a:
    {
     b:
     {
      var acc = 0, param = l, pos$1 = 0;
      for(;;){
       if(! param) break;
       var hd = param[1];
       if(! param[2]) break b;
       var
        tl = param[2],
        x = (caml_ml_bytes_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_Bytes_concat);
       acc = acc$0;
       param = tl;
      }
      var _ag_ = acc;
      break a;
     }
     var _ag_ = caml_ml_bytes_length(hd) + acc | 0;
    }
    var dst = caml_create_bytes(_ag_), pos = pos$1, param$0 = l;
    for(;;){
     if(! param$0) return dst;
     var hd$0 = param$0[1];
     if(! param$0[2]){
      caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
      return dst;
     }
     var tl$0 = param$0[2];
     caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
     caml_blit_bytes
      (sep, 0, dst, pos + caml_ml_bytes_length(hd$0) | 0, seplen);
     var pos$0 = (pos + caml_ml_bytes_length(hd$0) | 0) + seplen | 0;
     pos = pos$0;
     param$0 = tl$0;
    }
   }
   function cat(s1, s2){
    var
     l1 = caml_ml_bytes_length(s1),
     l2 = caml_ml_bytes_length(s2),
     r = caml_create_bytes(l1 + l2 | 0);
    caml_blit_bytes(s1, 0, r, 0, l1);
    caml_blit_bytes(s2, 0, r, l1, l2);
    return r;
   }
   function is_space(param){
    var _af_ = param - 9 | 0;
    a:
    {
     if(4 < _af_ >>> 0){if(23 !== _af_) break a;} else if(2 === _af_) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    var len = caml_ml_bytes_length(s), i = [0, 0];
    for(;;){
     if(i[1] >= len) break;
     if(! is_space(caml_bytes_unsafe_get(s, i[1]))) break;
     i[1]++;
    }
    var j = [0, len - 1 | 0];
    for(;;){
     if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s, j[1]))){j[1]--; continue;}
     return i[1] <= j[1] ? sub(s, i[1], (j[1] - i[1] | 0) + 1 | 0) : empty;
    }
   }
   function escaped(s){
    var n = [0, 0], ___ = caml_ml_bytes_length(s) - 1 | 0, _Z_ = 0;
    if(___ >= 0){
     var i$0 = _Z_;
     for(;;){
      var match = caml_bytes_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var _ac_ = match - 34 | 0;
          if(58 < _ac_ >>> 0){
           if(93 <= _ac_) break c;
          }
          else if(56 < _ac_ - 1 >>> 0) break b;
          var _ad_ = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var _ad_ = 4;
        break a;
       }
       var _ad_ = 2;
      }
      n[1] = n[1] + _ad_ | 0;
      var _ae_ = i$0 + 1 | 0;
      if(___ === i$0) break;
      i$0 = _ae_;
     }
    }
    if(n[1] === caml_ml_bytes_length(s)) return copy(s);
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _aa_ = caml_ml_bytes_length(s) - 1 | 0, _$_ = 0;
    if(_aa_ >= 0){
     var i = _$_;
     for(;;){
      var c = caml_bytes_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break c; break b;}
         }
         else{
          if(32 > c){
           if(14 <= c) break c;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break c;
           }
          }
          if(34 > c) break b;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], 92);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + (c / 100 | 0) | 0);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + (c % 10 | 0) | 0);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], c);
      }
      n[1]++;
      var _ab_ = i + 1 | 0;
      if(_aa_ === i) break;
      i = _ab_;
     }
    }
    return s$0;
   }
   function map(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _X_ = l - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(s, i)));
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return r;
   }
   function mapi(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _U_ = l - 1 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_bytes_unsafe_set
       (r, i, caml_call2(f, i, caml_bytes_unsafe_get(s, i)));
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return r;
   }
   function fold_left(f, x, a){
    var r = [0, x], _R_ = caml_ml_bytes_length(a) - 1 | 0, _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      r[1] = caml_call2(f, r[1], caml_bytes_unsafe_get(a, i));
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      i = _S_;
     }
    }
    return r[1];
   }
   function fold_right(f, a, x){
    var r = [0, x], _O_ = caml_ml_bytes_length(a) - 1 | 0;
    if(_O_ >= 0){
     var i = _O_;
     for(;;){
      r[1] = caml_call2(f, caml_bytes_unsafe_get(a, i), r[1]);
      var _P_ = i - 1 | 0;
      if(0 === i) break;
      i = _P_;
     }
    }
    return r[1];
   }
   function exists(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, caml_bytes_unsafe_get(s, i))) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, caml_bytes_unsafe_get(s, i))) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function uppercase_ascii(s){return map(Stdlib_Char[6], s);}
   function lowercase_ascii(s){return map(Stdlib_Char[5], s);}
   function apply1(f, s){
    if(0 === caml_ml_bytes_length(s)) return s;
    var r = copy(s);
    caml_bytes_unsafe_set(r, 0, caml_call1(f, caml_bytes_unsafe_get(s, 0)));
    return r;
   }
   function capitalize_ascii(s){return apply1(Stdlib_Char[6], s);}
   function uncapitalize_ascii(s){return apply1(Stdlib_Char[5], s);}
   function starts_with(prefix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_pre = caml_ml_bytes_length(prefix),
     _N_ = len_pre <= len_s ? 1 : 0;
    if(! _N_) return _N_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_bytes_unsafe_get(s, i) !== caml_bytes_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_suf = caml_ml_bytes_length(suffix),
     diff = len_s - len_suf | 0,
     _M_ = 0 <= diff ? 1 : 0;
    if(! _M_) return _M_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_bytes_unsafe_get(s, diff + i | 0)
       !== caml_bytes_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_bytes_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_bytes_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _K_ = 1; return _K_;}
     catch(_L_){
      var _J_ = caml_wrap_exception(_L_);
      if(_J_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_J_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_bytes_length(s) > i)
     try{rindex_rec(s, i, c); var _H_ = 1; return _H_;}
     catch(_I_){
      var _G_ = caml_wrap_exception(_I_);
      if(_G_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_G_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   var
    compare = runtime.caml_bytes_compare,
    cst_Bytes_of_seq_cannot_grow_b = "Bytes.of_seq: cannot grow bytes";
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_bytes_length(s)],
     _C_ = caml_ml_bytes_length(s) - 1 | 0;
    if(_C_ >= 0){
     var i = _C_;
     for(;;){
      if(caml_bytes_unsafe_get(s, i) === sep){
       var _E_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _E_];
       j[1] = i;
      }
      var _F_ = i - 1 | 0;
      if(0 === i) break;
      i = _F_;
     }
    }
    var _D_ = r[1];
    return [0, sub(s, 0, j[1]), _D_];
   }
   function uppercase(s){return map(Stdlib_Char[4], s);}
   function lowercase(s){return map(Stdlib_Char[3], s);}
   function capitalize(s){return apply1(Stdlib_Char[4], s);}
   function uncapitalize(s){return apply1(Stdlib_Char[3], s);}
   function to_seq(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _A_ = i + 1 | 0;
     return [0, x, function(_B_){return aux(_A_, _B_);}];
    }
    var _y_ = 0;
    return function(_z_){return aux(_y_, _z_);};
   }
   function to_seqi(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _w_ = i + 1 | 0;
     return [0, [0, i, x], function(_x_){return aux(_w_, _x_);}];
    }
    var _u_ = 0;
    return function(_v_){return aux(_u_, _v_);};
   }
   function of_seq(i){
    var n = [0, 0], buf = [0, make(256, 0)];
    caml_call2
     (Stdlib_Seq[4],
      function(c){
       if(n[1] === caml_ml_bytes_length(buf[1])){
        var
         new_len =
           caml_call2
            (Stdlib_Int[10],
             2 * caml_ml_bytes_length(buf[1]) | 0,
             Stdlib_Sys[12]);
        if(caml_ml_bytes_length(buf[1]) === new_len)
         caml_call1(Stdlib[2], cst_Bytes_of_seq_cannot_grow_b);
        var new_buf = make(new_len, 0);
        blit(buf[1], 0, new_buf, 0, n[1]);
        buf[1] = new_buf;
       }
       caml_bytes_set(buf[1], n[1], c);
       n[1]++;
       return 0;
      },
      i);
    return sub(buf[1], 0, n[1]);
   }
   function unsafe_get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function unsafe_get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int8(b, i){
    var _s_ = Stdlib_Sys[10] - 8 | 0, _t_ = Stdlib_Sys[10] - 8 | 0;
    return caml_bytes_get(b, i) << _t_ >> _s_;
   }
   function get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int16_ne(b, i){
    var _q_ = Stdlib_Sys[10] - 16 | 0, _r_ = Stdlib_Sys[10] - 16 | 0;
    return caml_bytes_get16(b, i) << _r_ >> _q_;
   }
   function get_int16_le(b, i){
    var _o_ = Stdlib_Sys[10] - 16 | 0, _p_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_le(b, i) << _p_ >> _o_;
   }
   function get_int16_be(b, i){
    var _m_ = Stdlib_Sys[10] - 16 | 0, _n_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_be(b, i) << _n_ >> _m_;
   }
   function get_int32_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int32_bswap(caml_bytes_get32(b, i))
            : caml_bytes_get32(b, i);
   }
   function get_int32_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get32(b, i)
            : caml_int32_bswap(caml_bytes_get32(b, i));
   }
   function get_int64_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int64_bswap(caml_bytes_get64(b, i))
            : caml_bytes_get64(b, i);
   }
   function get_int64_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get64(b, i)
            : caml_int64_bswap(caml_bytes_get64(b, i));
   }
   function unsafe_set_uint16_le(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, caml_bswap16(x)); return;}
    caml_bytes_set16(b, i, x);
    return;
   }
   function unsafe_set_uint16_be(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, x); return;}
    caml_bytes_set16(b, i, caml_bswap16(x));
    return;
   }
   function set_int16_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, caml_bswap16(x))
            : caml_bytes_set16(b, i, x);
   }
   function set_int16_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, x)
            : caml_bytes_set16(b, i, caml_bswap16(x));
   }
   function set_int32_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, caml_int32_bswap(x))
            : caml_bytes_set32(b, i, x);
   }
   function set_int32_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, x)
            : caml_bytes_set32(b, i, caml_int32_bswap(x));
   }
   function set_int64_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, caml_int64_bswap(x))
            : caml_bytes_set64(b, i, x);
   }
   function set_int64_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, x)
            : caml_bytes_set64(b, i, caml_int64_bswap(x));
   }
   var
    set_uint8 = caml_bytes_set,
    set_uint16_ne = caml_bytes_set16,
    dec_invalid = Stdlib_Uchar[22],
    _a_ = [0, cst_bytes_ml, 667, 9],
    _b_ = [0, cst_bytes_ml, 642, 20],
    cst_index_out_of_bounds = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$0 = cst_index_out_of_bounds$3,
    _c_ = [0, cst_bytes_ml, 765, 9],
    _d_ = [0, cst_bytes_ml, 754, 20],
    cst_index_out_of_bounds$1 = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$2 = cst_index_out_of_bounds$3,
    _e_ = [0, cst_bytes_ml, 819, 9],
    _f_ = [0, cst_bytes_ml, 808, 20];
   function dec_ret(n, u){
    var _l_ = caml_call1(Stdlib_Uchar[9], u);
    return caml_call2(Stdlib_Uchar[21], n, _l_);
   }
   function not_in_x80_to_xBF(b){return 2 !== (b >>> 6 | 0) ? 1 : 0;}
   function not_in_xA0_to_xBF(b){return 5 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x80_to_x9F(b){return 4 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x90_to_xBF(b){
    var _j_ = b < 144 ? 1 : 0, _k_ = _j_ || (191 < b ? 1 : 0);
    return _k_;
   }
   function not_in_x80_to_x8F(b){return 8 !== (b >>> 4 | 0) ? 1 : 0;}
   function utf_8_uchar_3(b0, b1, b2){
    return (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
   }
   function utf_8_uchar_4(b0, b1, b2, b3){
    return (b0 & 7) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
   }
   function get_utf_8_uchar(b, i){
    var b0 = caml_bytes_get(b, i), max = caml_ml_bytes_length(b) - 1 | 0;
    a:
    {
     if(224 <= b0){
      if(237 <= b0){
       if(245 <= b0) break a;
       switch(b0 - 237 | 0){
         case 0:
          var i$0 = i + 1 | 0;
          if(max < i$0) return caml_call1(dec_invalid, 1);
          var b1$4 = caml_bytes_unsafe_get(b, i$0);
          if(not_in_x80_to_x9F(b1$4)) return caml_call1(dec_invalid, 1);
          var i$1 = i$0 + 1 | 0;
          if(max < i$1) return caml_call1(dec_invalid, 2);
          var b2$3 = caml_bytes_unsafe_get(b, i$1);
          return not_in_x80_to_xBF(b2$3)
                  ? caml_call1(dec_invalid, 2)
                  : dec_ret(3, utf_8_uchar_3(b0, b1$4, b2$3));
         case 3:
          var i$4 = i + 1 | 0;
          if(max < i$4) return caml_call1(dec_invalid, 1);
          var b1$2 = caml_bytes_unsafe_get(b, i$4);
          if(not_in_x90_to_xBF(b1$2)) return caml_call1(dec_invalid, 1);
          var i$5 = i$4 + 1 | 0;
          if(max < i$5) return caml_call1(dec_invalid, 2);
          var b2$1 = caml_bytes_unsafe_get(b, i$5);
          if(not_in_x80_to_xBF(b2$1)) return caml_call1(dec_invalid, 2);
          var i$6 = i$5 + 1 | 0;
          if(max < i$6) return caml_call1(dec_invalid, 3);
          var b3$1 = caml_bytes_unsafe_get(b, i$6);
          return not_in_x80_to_xBF(b3$1)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$2, b2$1, b3$1));
         case 7:
          var i$10 = i + 1 | 0;
          if(max < i$10) return caml_call1(dec_invalid, 1);
          var b1$0 = caml_bytes_unsafe_get(b, i$10);
          if(not_in_x80_to_x8F(b1$0)) return caml_call1(dec_invalid, 1);
          var i$11 = i$10 + 1 | 0;
          if(max < i$11) return caml_call1(dec_invalid, 2);
          var b2 = caml_bytes_unsafe_get(b, i$11);
          if(not_in_x80_to_xBF(b2)) return caml_call1(dec_invalid, 2);
          var i$12 = i$11 + 1 | 0;
          if(max < i$12) return caml_call1(dec_invalid, 3);
          var b3 = caml_bytes_unsafe_get(b, i$12);
          return not_in_x80_to_xBF(b3)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$0, b2, b3));
         case 1:
         case 2: break;
         default:
          var i$7 = i + 1 | 0;
          if(max < i$7) return caml_call1(dec_invalid, 1);
          var b1$1 = caml_bytes_unsafe_get(b, i$7);
          if(not_in_x80_to_xBF(b1$1)) return caml_call1(dec_invalid, 1);
          var i$8 = i$7 + 1 | 0;
          if(max < i$8) return caml_call1(dec_invalid, 2);
          var b2$0 = caml_bytes_unsafe_get(b, i$8);
          if(not_in_x80_to_xBF(b2$0)) return caml_call1(dec_invalid, 2);
          var i$9 = i$8 + 1 | 0;
          if(max < i$9) return caml_call1(dec_invalid, 3);
          var b3$0 = caml_bytes_unsafe_get(b, i$9);
          return not_in_x80_to_xBF(b3$0)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$1, b2$0, b3$0));
       }
      }
      else if(225 > b0){
       var i$13 = i + 1 | 0;
       if(max < i$13) return caml_call1(dec_invalid, 1);
       var b1$5 = caml_bytes_unsafe_get(b, i$13);
       if(not_in_xA0_to_xBF(b1$5)) return caml_call1(dec_invalid, 1);
       var i$14 = i$13 + 1 | 0;
       if(max < i$14) return caml_call1(dec_invalid, 2);
       var b2$4 = caml_bytes_unsafe_get(b, i$14);
       return not_in_x80_to_xBF(b2$4)
               ? caml_call1(dec_invalid, 2)
               : dec_ret(3, utf_8_uchar_3(b0, b1$5, b2$4));
      }
      var i$2 = i + 1 | 0;
      if(max < i$2) return caml_call1(dec_invalid, 1);
      var b1$3 = caml_bytes_unsafe_get(b, i$2);
      if(not_in_x80_to_xBF(b1$3)) return caml_call1(dec_invalid, 1);
      var i$3 = i$2 + 1 | 0;
      if(max < i$3) return caml_call1(dec_invalid, 2);
      var b2$2 = caml_bytes_unsafe_get(b, i$3);
      return not_in_x80_to_xBF(b2$2)
              ? caml_call1(dec_invalid, 2)
              : dec_ret(3, utf_8_uchar_3(b0, b1$3, b2$2));
     }
     if(128 > b0) return dec_ret(1, b0);
     if(194 <= b0){
      var i$15 = i + 1 | 0;
      if(max < i$15) return caml_call1(dec_invalid, 1);
      var b1 = caml_bytes_unsafe_get(b, i$15);
      return not_in_x80_to_xBF(b1)
              ? caml_call1(dec_invalid, 1)
              : dec_ret(2, (b0 & 31) << 6 | b1 & 63);
     }
    }
    return caml_call1(dec_invalid, 1);
   }
   function set_utf_8_uchar(b, i, u){
    function set(_i_, _h_, _g_){caml_bytes_unsafe_set(_i_, _h_, _g_); return;}
    var
     max = caml_ml_bytes_length(b) - 1 | 0,
     u$0 = caml_call1(Stdlib_Uchar[10], u);
    if(0 > u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u$0){caml_bytes_set(b, i, u$0); return 1;}
    if(2047 >= u$0){
     var last$1 = i + 1 | 0;
     return max < last$1
             ? 0
             : (caml_bytes_set
                (b, i, 192 | u$0 >>> 6 | 0),
               set(b, last$1, 128 | u$0 & 63),
               2);
    }
    if(65535 >= u$0){
     var last$0 = i + 2 | 0;
     return max < last$0
             ? 0
             : (caml_bytes_set
                (b, i, 224 | u$0 >>> 12 | 0),
               set(b, i + 1 | 0, 128 | (u$0 >>> 6 | 0) & 63),
               set(b, last$0, 128 | u$0 & 63),
               3);
    }
    if(1114111 < u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var last = i + 3 | 0;
    return max < last
            ? 0
            : (caml_bytes_set
               (b, i, 240 | u$0 >>> 18 | 0),
              set(b, i + 1 | 0, 128 | (u$0 >>> 12 | 0) & 63),
              set(b, i + 2 | 0, 128 | (u$0 >>> 6 | 0) & 63),
              set(b, last, 128 | u$0 & 63),
              4);
   }
   function is_valid_utf_8(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     var match = caml_bytes_unsafe_get(b, i);
     a:
     {
      if(224 <= match){
       if(237 <= match){
        if(245 <= match) break a;
        switch(match - 237 | 0){
          case 0:
           var last = i + 2 | 0;
           if
            (max >= last
             &&
              !
              not_in_x80_to_x9F(caml_bytes_unsafe_get(b, i + 1 | 0))
              && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last))){var i$0 = last + 1 | 0; i = i$0; continue;}
           return 0;
          case 3:
           var last$1 = i + 3 | 0;
           if
            (max >= last$1
             &&
              !
              not_in_x90_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$1))){var i$2 = last$1 + 1 | 0; i = i$2; continue;}
           return 0;
          case 7:
           var last$3 = i + 3 | 0;
           if
            (max >= last$3
             &&
              !
              not_in_x80_to_x8F(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$3))){var i$4 = last$3 + 1 | 0; i = i$4; continue;}
           return 0;
          case 1:
          case 2: break;
          default:
           var last$2 = i + 3 | 0;
           if
            (max >= last$2
             &&
              !
              not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$2))){var i$3 = last$2 + 1 | 0; i = i$3; continue;}
           return 0;
        }
       }
       else if(225 > match){
        var last$4 = i + 2 | 0;
        if
         (max >= last$4
          &&
           !
           not_in_xA0_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
           && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$4))){var i$5 = last$4 + 1 | 0; i = i$5; continue;}
        return 0;
       }
       var last$0 = i + 2 | 0;
       if
        (max >= last$0
         &&
          !
          not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
          && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$0))){var i$1 = last$0 + 1 | 0; i = i$1; continue;}
       return 0;
      }
      if(128 > match){var i$7 = i + 1 | 0; i = i$7; continue;}
      if(194 <= match){
       var last$5 = i + 1 | 0;
       if
        (max >= last$5
         && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$5))){var i$6 = last$5 + 1 | 0; i = i$6; continue;}
       return 0;
      }
     }
     return 0;
    }
   }
   function get_utf_16be_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_be(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds);
   }
   function set_utf_16be_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_be(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_be(b, i, hi);
     unsafe_set_uint16_be(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$0);
   }
   function is_valid_utf_16be(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_be(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0;
       i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0;
     i = i$0;
    }
   }
   function get_utf_16le_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_le(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$1);
   }
   function set_utf_16le_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_le(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_le(b, i, hi);
     unsafe_set_uint16_le(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$2);
   }
   function is_valid_utf_16le(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_le(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0;
       i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0;
     i = i$0;
    }
   }
   var
    Stdlib_Bytes =
      [0,
       make,
       init,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit_string,
       concat,
       cat,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare,
       runtime.caml_bytes_equal,
       starts_with,
       ends_with,
       caml_string_of_bytes,
       caml_bytes_of_string,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       set_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       set_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       set_utf_16le_uchar,
       is_valid_utf_16le,
       caml_bytes_get,
       get_int8,
       caml_bytes_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       caml_bytes_get32,
       get_int32_be,
       get_int32_le,
       caml_bytes_get64,
       get_int64_be,
       get_int64_le,
       set_uint8,
       caml_bytes_set,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       caml_bytes_set16,
       set_int16_be,
       set_int16_le,
       caml_bytes_set32,
       set_int32_be,
       set_int32_le,
       caml_bytes_set64,
       set_int64_be,
       set_int64_le];
   runtime.caml_register_global(30, Stdlib_Bytes, "Stdlib__Bytes");
   return;
  }
  (globalThis));

//# 4969 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    caml_blit_string = runtime.caml_blit_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    empty = cst$0,
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    bts = Stdlib_Bytes[48],
    bos = Stdlib_Bytes[49];
   function make(n, c){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[1], n, c));
   }
   function init(n, f){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[2], n, f));
   }
   function copy(s){
    var _ac_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[4], _ac_));
   }
   var of_bytes = Stdlib_Bytes[6], to_bytes = Stdlib_Bytes[5];
   function sub(s, ofs, len){
    var _ab_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call3(Stdlib_Bytes[7], _ab_, ofs, len));
   }
   var
    fill = Stdlib_Bytes[10],
    blit = Stdlib_Bytes[12],
    cst_String_concat = "String.concat";
   function concat(sep, l){
    if(! l) return cst;
    var seplen = caml_ml_string_length(sep);
    a:
    {
     b:
     {
      var acc = 0, param = l, pos$1 = 0;
      for(;;){
       if(! param) break;
       var hd = param[1];
       if(! param[2]) break b;
       var
        tl = param[2],
        x = (caml_ml_string_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_String_concat);
       acc = acc$0;
       param = tl;
      }
      var _aa_ = acc;
      break a;
     }
     var _aa_ = caml_ml_string_length(hd) + acc | 0;
    }
    var dst = runtime.caml_create_bytes(_aa_), pos = pos$1, param$0 = l;
    for(;;){
     if(param$0){
      var hd$0 = param$0[1];
      if(param$0[2]){
       var tl$0 = param$0[2];
       caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
       caml_blit_string
        (sep, 0, dst, pos + caml_ml_string_length(hd$0) | 0, seplen);
       var pos$0 = (pos + caml_ml_string_length(hd$0) | 0) + seplen | 0;
       pos = pos$0;
       param$0 = tl$0;
       continue;
      }
      caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
     }
     return caml_call1(bts, dst);
    }
   }
   var
    cat = Stdlib[28],
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from";
   function iter(f, s){
    var ___ = caml_ml_string_length(s) - 1 | 0, _Z_ = 0;
    if(___ >= 0){
     var i = _Z_;
     for(;;){
      caml_call1(f, caml_string_unsafe_get(s, i));
      var _$_ = i + 1 | 0;
      if(___ === i) break;
      i = _$_;
     }
    }
    return 0;
   }
   function iteri(f, s){
    var _X_ = caml_ml_string_length(s) - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(s, i));
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return 0;
   }
   function map(f, s){
    var _V_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[17], f, _V_));
   }
   function mapi(f, s){
    var _U_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[18], f, _U_));
   }
   function fold_right(f, x, a){
    var _T_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[20], f, _T_, a);
   }
   function fold_left(f, a, x){
    var _S_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[19], f, a, _S_);
   }
   function exists(f, s){
    var _R_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[22], f, _R_);
   }
   function for_all(f, s){
    var _Q_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[21], f, _Q_);
   }
   function is_space(param){
    var _P_ = param - 9 | 0;
    a:
    {
     if(4 < _P_ >>> 0){if(23 !== _P_) break a;} else if(2 === _P_) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    if(s == cst$0) return s;
    if
     (!
      is_space(caml_string_unsafe_get(s, 0))
      &&
       !
       is_space(caml_string_unsafe_get(s, caml_ml_string_length(s) - 1 | 0)))
     return s;
    var _O_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[23], _O_));
   }
   function escaped(s){
    var n = caml_ml_string_length(s), i = 0;
    for(;;){
     if(n <= i) return s;
     var _M_ = caml_string_unsafe_get(s, i) - 32 | 0;
     a:
     {
      if(59 < _M_ >>> 0){
       if(33 < _M_ - 61 >>> 0) break a;
      }
      else if(2 === _M_) break a;
      var i$0 = i + 1 | 0;
      i = i$0;
      continue;
     }
     var _N_ = caml_call1(bos, s);
     return caml_call1(bts, caml_call1(Stdlib_Bytes[24], _N_));
    }
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_string_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_string_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i)
     return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _K_ = 1; return _K_;}
     catch(_L_){
      var _J_ = caml_wrap_exception(_L_);
      if(_J_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_J_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_string_length(s) > i)
     try{rindex_rec(s, i, c); var _H_ = 1; return _H_;}
     catch(_I_){
      var _G_ = caml_wrap_exception(_I_);
      if(_G_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_G_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   function uppercase_ascii(s){
    var _F_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[40], _F_));
   }
   function lowercase_ascii(s){
    var _E_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[41], _E_));
   }
   function capitalize_ascii(s){
    var _D_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[42], _D_));
   }
   function uncapitalize_ascii(s){
    var _C_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[43], _C_));
   }
   function starts_with(prefix, s){
    var
     len_s = caml_ml_string_length(s),
     len_pre = caml_ml_string_length(prefix),
     _B_ = len_pre <= len_s ? 1 : 0;
    if(! _B_) return _B_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_string_unsafe_get(s, i) !== caml_string_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_string_length(s),
     len_suf = caml_ml_string_length(suffix),
     diff = len_s - len_suf | 0,
     _A_ = 0 <= diff ? 1 : 0;
    if(! _A_) return _A_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_string_unsafe_get(s, diff + i | 0)
       !== caml_string_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_string_length(s)],
     _w_ = caml_ml_string_length(s) - 1 | 0;
    if(_w_ >= 0){
     var i = _w_;
     for(;;){
      if(caml_string_unsafe_get(s, i) === sep){
       var _y_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _y_];
       j[1] = i;
      }
      var _z_ = i - 1 | 0;
      if(0 === i) break;
      i = _z_;
     }
    }
    var _x_ = r[1];
    return [0, sub(s, 0, j[1]), _x_];
   }
   function uppercase(s){
    var _v_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[36], _v_));
   }
   function lowercase(s){
    var _u_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[37], _u_));
   }
   function capitalize(s){
    var _t_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[38], _t_));
   }
   function uncapitalize(s){
    var _s_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[39], _s_));
   }
   var compare = runtime.caml_string_compare;
   function to_seq(s){
    var _r_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[51], _r_);
   }
   function to_seqi(s){
    var _q_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[52], _q_);
   }
   function of_seq(g){
    return caml_call1(bts, caml_call1(Stdlib_Bytes[53], g));
   }
   function get_utf_8_uchar(s, i){
    var _p_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[54], _p_, i);
   }
   function is_valid_utf_8(s){
    var _o_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[56], _o_);
   }
   function get_utf_16be_uchar(s, i){
    var _n_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[57], _n_, i);
   }
   function is_valid_utf_16be(s){
    var _m_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[59], _m_);
   }
   function get_utf_16le_uchar(s, i){
    var _l_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[60], _l_, i);
   }
   function is_valid_utf_16le(s){
    var _k_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[62], _k_);
   }
   function get_int8(s, i){
    var _j_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[64], _j_, i);
   }
   function get_uint16_le(s, i){
    var _i_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[67], _i_, i);
   }
   function get_uint16_be(s, i){
    var _h_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[66], _h_, i);
   }
   function get_int16_ne(s, i){
    var _g_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[68], _g_, i);
   }
   function get_int16_le(s, i){
    var _f_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[70], _f_, i);
   }
   function get_int16_be(s, i){
    var _e_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[69], _e_, i);
   }
   function get_int32_le(s, i){
    var _d_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[73], _d_, i);
   }
   function get_int32_be(s, i){
    var _c_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[72], _c_, i);
   }
   function get_int64_le(s, i){
    var _b_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[76], _b_, i);
   }
   function get_int64_be(s, i){
    var _a_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[75], _a_, i);
   }
   var
    Stdlib_String =
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       concat,
       cat,
       caml_string_equal,
       compare,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       blit,
       copy,
       fill,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       runtime.caml_string_get,
       get_int8,
       runtime.caml_string_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       runtime.caml_string_get32,
       get_int32_be,
       get_int32_le,
       runtime.caml_string_get64,
       get_int64_be,
       get_int64_le];
   runtime.caml_register_global(12, Stdlib_String, "Stdlib__String");
   return;
  }
  (globalThis));

//# 5572 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_array_sub = runtime.caml_array_sub,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    make_float = runtime.caml_make_float_vect,
    Floatarray = [0],
    cst_Array_init = "Array.init",
    cst_Array_sub = "Array.sub",
    cst_Array_fill = "Array.fill",
    cst_Array_blit = "Array.blit",
    cst_Array_iter2_arrays_must_ha =
      "Array.iter2: arrays must have the same length",
    cst_Array_map2_arrays_must_hav =
      "Array.map2: arrays must have the same length",
    cst_Array_for_all2 = "Array.for_all2",
    cst_Array_exists2 = "Array.exists2",
    cst_Array_combine = "Array.combine";
   function init(l, f){
    if(0 === l) return [0];
    if(0 > l) return caml_call1(Stdlib[1], cst_Array_init);
    var res = caml_make_vect(l, caml_call1(f, 0)), _aq_ = l - 1 | 0, _ap_ = 1;
    if(_aq_ >= 1){
     var i = _ap_;
     for(;;){
      res[1 + i] = caml_call1(f, i);
      var _ar_ = i + 1 | 0;
      if(_aq_ === i) break;
      i = _ar_;
     }
    }
    return res;
   }
   function make_matrix(sx, sy, init){
    var res = caml_make_vect(sx, [0]), _an_ = sx - 1 | 0, _am_ = 0;
    if(_an_ >= 0){
     var x = _am_;
     for(;;){
      res[1 + x] = caml_make_vect(sy, init);
      var _ao_ = x + 1 | 0;
      if(_an_ === x) break;
      x = _ao_;
     }
    }
    return res;
   }
   function copy(a){
    var l = a.length - 1;
    return 0 === l ? [0] : caml_array_sub(a, 0, l);
   }
   function append(a1, a2){
    var l1 = a1.length - 1;
    return 0 === l1
            ? copy(a2)
            : 0
              === a2.length - 1
              ? caml_array_sub(a1, 0, l1)
              : runtime.caml_array_append(a1, a2);
   }
   function sub(a, ofs, len){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return caml_array_sub(a, ofs, len);
    return caml_call1(Stdlib[1], cst_Array_sub);
   }
   function fill(a, ofs, len, v){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return runtime.caml_array_fill(a, ofs, len, v);
    return caml_call1(Stdlib[1], cst_Array_fill);
   }
   function blit(a1, ofs1, a2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (a1.length - 1 - len | 0) >= ofs1
        && 0 <= ofs2 && (a2.length - 1 - len | 0) >= ofs2)
     return runtime.caml_array_blit(a1, ofs1, a2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Array_blit);
   }
   function iter(f, a){
    var _ak_ = a.length - 2 | 0, _aj_ = 0;
    if(_ak_ >= 0){
     var i = _aj_;
     for(;;){
      caml_call1(f, a[1 + i]);
      var _al_ = i + 1 | 0;
      if(_ak_ === i) break;
      i = _al_;
     }
    }
    return 0;
   }
   function iter2(f, a, b){
    if(a.length - 1 !== b.length - 1)
     return caml_call1(Stdlib[1], cst_Array_iter2_arrays_must_ha);
    var _ah_ = a.length - 2 | 0, _ag_ = 0;
    if(_ah_ >= 0){
     var i = _ag_;
     for(;;){
      caml_call2(f, a[1 + i], b[1 + i]);
      var _ai_ = i + 1 | 0;
      if(_ah_ === i) break;
      i = _ai_;
     }
    }
    return 0;
   }
   function map(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call1(f, a[1])),
     _ae_ = l - 1 | 0,
     _ad_ = 1;
    if(_ae_ >= 1){
     var i = _ad_;
     for(;;){
      r[1 + i] = caml_call1(f, a[1 + i]);
      var _af_ = i + 1 | 0;
      if(_ae_ === i) break;
      i = _af_;
     }
    }
    return r;
   }
   function map2(f, a, b){
    var la = a.length - 1, lb = b.length - 1;
    if(la !== lb)
     return caml_call1(Stdlib[1], cst_Array_map2_arrays_must_hav);
    if(0 === la) return [0];
    var
     r = caml_make_vect(la, caml_call2(f, a[1], b[1])),
     _ab_ = la - 1 | 0,
     _aa_ = 1;
    if(_ab_ >= 1){
     var i = _aa_;
     for(;;){
      r[1 + i] = caml_call2(f, a[1 + i], b[1 + i]);
      var _ac_ = i + 1 | 0;
      if(_ab_ === i) break;
      i = _ac_;
     }
    }
    return r;
   }
   function iteri(f, a){
    var ___ = a.length - 2 | 0, _Z_ = 0;
    if(___ >= 0){
     var i = _Z_;
     for(;;){
      caml_call2(f, i, a[1 + i]);
      var _$_ = i + 1 | 0;
      if(___ === i) break;
      i = _$_;
     }
    }
    return 0;
   }
   function mapi(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call2(f, 0, a[1])),
     _X_ = l - 1 | 0,
     _W_ = 1;
    if(_X_ >= 1){
     var i = _W_;
     for(;;){
      r[1 + i] = caml_call2(f, i, a[1 + i]);
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return r;
   }
   function to_list(a){
    var i$1 = a.length - 2 | 0, i = i$1, res = 0;
    for(;;){
     if(0 > i) return res;
     var res$0 = [0, a[1 + i], res], i$0 = i - 1 | 0;
     i = i$0;
     res = res$0;
    }
   }
   function list_length(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(! param$0) return accu$0;
     var t = param$0[2], accu$1 = accu$0 + 1 | 0;
     accu$0 = accu$1;
     param$0 = t;
    }
   }
   function of_list(l){
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     a = caml_make_vect(list_length(0, l), hd),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i + 1 | 0;
     i = i$0;
     param = tl$0;
    }
   }
   function fold_left(f, x, a){
    var r = [0, x], _U_ = a.length - 2 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      r[1] = caml_call2(f, r[1], a[1 + i]);
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return r[1];
   }
   function fold_left_map(f, acc, input_array){
    var len = input_array.length - 1;
    if(0 === len) return [0, acc, [0]];
    var
     match = caml_call2(f, acc, input_array[1]),
     elt = match[2],
     acc$0 = match[1],
     output_array = caml_make_vect(len, elt),
     acc$1 = [0, acc$0],
     _R_ = len - 1 | 0,
     _Q_ = 1;
    if(_R_ >= 1){
     var i = _Q_;
     for(;;){
      var
       match$0 = caml_call2(f, acc$1[1], input_array[1 + i]),
       elt$0 = match$0[2],
       acc$2 = match$0[1];
      acc$1[1] = acc$2;
      output_array[1 + i] = elt$0;
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      i = _S_;
     }
    }
    return [0, acc$1[1], output_array];
   }
   function fold_right(f, a, x){
    var r = [0, x], _O_ = a.length - 2 | 0;
    if(_O_ >= 0){
     var i = _O_;
     for(;;){
      r[1] = caml_call2(f, a[1 + i], r[1]);
      var _P_ = i - 1 | 0;
      if(0 === i) break;
      i = _P_;
     }
    }
    return r[1];
   }
   function exists(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, a[1 + i])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_for_all2);
    var i = 0;
    for(;;){
     if(i === n1) return 1;
     if(! caml_call2(p, l1[1 + i], l2[1 + i])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function exists2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_exists2);
    var i = 0;
    for(;;){
     if(i === n1) return 0;
     if(caml_call2(p, l1[1 + i], l2[1 + i])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function mem(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(0 === runtime.caml_compare(a[1 + i], x)) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function memq(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(x === a[1 + i]) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_opt(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var x = a[1 + i];
     if(caml_call1(p, x)) return [0, x];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_map(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call1(f, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function split(x){
    if(runtime.caml_equal(x, [0])) return [0, [0], [0]];
    var
     match = x[1],
     b0 = match[2],
     a0 = match[1],
     n = x.length - 1,
     a = caml_make_vect(n, a0),
     b = caml_make_vect(n, b0),
     _M_ = n - 1 | 0,
     _L_ = 1;
    if(_M_ >= 1){
     var i = _L_;
     for(;;){
      var match$0 = x[1 + i], bi = match$0[2], ai = match$0[1];
      a[1 + i] = ai;
      b[1 + i] = bi;
      var _N_ = i + 1 | 0;
      if(_M_ === i) break;
      i = _N_;
     }
    }
    return [0, a, b];
   }
   function combine(a, b){
    var na = a.length - 1, nb = b.length - 1;
    if(na !== nb) caml_call1(Stdlib[1], cst_Array_combine);
    if(0 === na) return [0];
    var x = caml_make_vect(na, [0, a[1], b[1]]), _J_ = na - 1 | 0, _I_ = 1;
    if(_J_ >= 1){
     var i = _I_;
     for(;;){
      x[1 + i] = [0, a[1 + i], b[1 + i]];
      var _K_ = i + 1 | 0;
      if(_J_ === i) break;
      i = _K_;
     }
    }
    return x;
   }
   var
    Bottom = [248, "Stdlib.Array.Bottom", runtime.caml_fresh_oo_id(0)],
    _a_ = [0, "array.ml", 322, 4];
   function sort(cmp, a){
    function maxson(l, i){
     var i31 = ((i + i | 0) + i | 0) + 1 | 0, x = [0, i31];
     if((i31 + 2 | 0) < l){
      var _B_ = i31 + 1 | 0, _C_ = caml_check_bound(a, _B_)[1 + _B_];
      if(caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _C_) < 0)
       x[1] = i31 + 1 | 0;
      var
       _D_ = i31 + 2 | 0,
       _E_ = caml_check_bound(a, _D_)[1 + _D_],
       _F_ = x[1];
      if(caml_call2(cmp, caml_check_bound(a, _F_)[1 + _F_], _E_) < 0)
       x[1] = i31 + 2 | 0;
      return x[1];
     }
     if((i31 + 1 | 0) < l){
      var _G_ = i31 + 1 | 0, _H_ = caml_check_bound(a, _G_)[1 + _G_];
      if(0 > caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _H_))
       return i31 + 1 | 0;
     }
     if(i31 < l) return i31;
     throw caml_maybe_attach_backtrace([0, Bottom, i], 1);
    }
    var l = a.length - 1, _v_ = ((l + 1 | 0) / 3 | 0) - 1 | 0;
    if(_v_ >= 0){
     var i$6 = _v_;
     for(;;){
      var e$1 = caml_check_bound(a, i$6)[1 + i$6];
      try{
       var i = i$6;
       for(;;){
        var j = maxson(l, i);
        if(0 >= caml_call2(cmp, caml_check_bound(a, j)[1 + j], e$1)) break;
        var _s_ = caml_check_bound(a, j)[1 + j];
        caml_check_bound(a, i)[1 + i] = _s_;
        i = j;
       }
       caml_check_bound(a, i)[1 + i] = e$1;
      }
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(exn[1] !== Bottom) throw caml_maybe_attach_backtrace(exn, 0);
       var i$0 = exn[2];
       caml_check_bound(a, i$0)[1 + i$0] = e$1;
      }
      var _A_ = i$6 - 1 | 0;
      if(0 === i$6) break;
      i$6 = _A_;
     }
    }
    var _w_ = l - 1 | 0;
    if(_w_ >= 2){
     var i$4 = _w_;
     for(;;){
      var e$0 = caml_check_bound(a, i$4)[1 + i$4];
      a[1 + i$4] = caml_check_bound(a, 0)[1];
      var i$5 = 0;
      try{
       var i$1 = i$5;
       for(;;){
        var j$0 = maxson(i$4, i$1), _t_ = caml_check_bound(a, j$0)[1 + j$0];
        caml_check_bound(a, i$1)[1 + i$1] = _t_;
        i$1 = j$0;
       }
      }
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(exn$0[1] !== Bottom) throw caml_maybe_attach_backtrace(exn$0, 0);
       var i$2 = exn$0[2];
       a:
       {
        b:
        {
         var i$3 = i$2;
         for(;;){
          var father = (i$3 - 1 | 0) / 3 | 0;
          if(i$3 === father)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
          if
           (0 <= caml_call2(cmp, caml_check_bound(a, father)[1 + father], e$0))
           break;
          var _u_ = caml_check_bound(a, father)[1 + father];
          caml_check_bound(a, i$3)[1 + i$3] = _u_;
          if(0 >= father) break b;
          i$3 = father;
         }
         caml_check_bound(a, i$3)[1 + i$3] = e$0;
         break a;
        }
        caml_check_bound(a, 0)[1] = e$0;
       }
       var _z_ = i$4 - 1 | 0;
       if(2 === i$4) break;
       i$4 = _z_;
      }
     }
    }
    var _x_ = 1 < l ? 1 : 0;
    if(_x_){
     var e = caml_check_bound(a, 1)[2];
     a[2] = caml_check_bound(a, 0)[1];
     a[1] = e;
     var _y_ = 0;
    }
    else
     var _y_ = _x_;
    return _y_;
   }
   function stable_sort(cmp, a){
    function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs){
     var
      src1r = src1ofs + src1len | 0,
      src2r = src2ofs + src2len | 0,
      s2$1 = caml_check_bound(src2, src2ofs)[1 + src2ofs],
      s1$1 = caml_check_bound(a, src1ofs)[1 + src1ofs],
      i1 = src1ofs,
      s1 = s1$1,
      i2 = src2ofs,
      s2 = s2$1,
      d = dstofs;
     for(;;)
      if(0 < caml_call2(cmp, s1, s2)){
       caml_check_bound(dst, d)[1 + d] = s2;
       var i2$0 = i2 + 1 | 0;
       if(i2$0 >= src2r) return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
       var d$0 = d + 1 | 0, s2$0 = caml_check_bound(src2, i2$0)[1 + i2$0];
       i2 = i2$0;
       s2 = s2$0;
       d = d$0;
      }
      else{
       caml_check_bound(dst, d)[1 + d] = s1;
       var i1$0 = i1 + 1 | 0;
       if(i1$0 >= src1r)
        return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
       var d$1 = d + 1 | 0, s1$0 = caml_check_bound(a, i1$0)[1 + i1$0];
       i1 = i1$0;
       s1 = s1$0;
       d = d$1;
      }
    }
    function isortto(srcofs, dst, dstofs, len){
     var _k_ = len - 1 | 0, _j_ = 0;
     if(_k_ >= 0){
      var i = _j_;
      for(;;){
       var
        _l_ = srcofs + i | 0,
        e = caml_check_bound(a, _l_)[1 + _l_],
        j = [0, (dstofs + i | 0) - 1 | 0];
       for(;;){
        if(dstofs > j[1]) break;
        var _m_ = j[1];
        if(0 >= caml_call2(cmp, caml_check_bound(dst, _m_)[1 + _m_], e))
         break;
        var
         _n_ = j[1],
         _o_ = caml_check_bound(dst, _n_)[1 + _n_],
         _p_ = j[1] + 1 | 0;
        caml_check_bound(dst, _p_)[1 + _p_] = _o_;
        j[1]--;
       }
       var _q_ = j[1] + 1 | 0;
       caml_check_bound(dst, _q_)[1 + _q_] = e;
       var _r_ = i + 1 | 0;
       if(_k_ === i) break;
       i = _r_;
      }
     }
     return 0;
    }
    function sortto(srcofs, dst, dstofs, len){
     if(len <= 5) return isortto(srcofs, dst, dstofs, len);
     var l1 = len / 2 | 0, l2 = len - l1 | 0;
     sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
     sortto(srcofs, a, srcofs + l2 | 0, l1);
     return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
    var l = a.length - 1;
    if(l <= 5) return isortto(0, a, 0, l);
    var
     l1 = l / 2 | 0,
     l2 = l - l1 | 0,
     t = caml_make_vect(l2, caml_check_bound(a, 0)[1]);
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
   }
   function to_seq(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _h_ = i + 1 | 0;
     return [0, x, function(_i_){return aux(_h_, _i_);}];
    }
    var _f_ = 0;
    return function(_g_){return aux(_f_, _g_);};
   }
   function to_seqi(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _d_ = i + 1 | 0;
     return [0, [0, i, x], function(_e_){return aux(_d_, _e_);}];
    }
    var _b_ = 0;
    return function(_c_){return aux(_b_, _c_);};
   }
   function of_seq(i$2){
    var
     l =
       caml_call3
        (Stdlib_Seq[5], function(acc, x){return [0, x, acc];}, 0, i$2);
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     len = list_length(0, l),
     a = caml_make_vect(len, hd),
     i$1 = len - 2 | 0,
     i = i$1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i - 1 | 0;
     i = i$0;
     param = tl$0;
    }
   }
   var
    Stdlib_Array =
      [0,
       make_float,
       init,
       make_matrix,
       make_matrix,
       append,
       runtime.caml_array_concat,
       sub,
       copy,
       fill,
       blit,
       to_list,
       of_list,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_left_map,
       fold_right,
       iter2,
       map2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find_opt,
       find_map,
       split,
       combine,
       sort,
       stable_sort,
       stable_sort,
       to_seq,
       to_seqi,
       of_seq,
       Floatarray];
   runtime.caml_register_global(14, Stdlib_Array, "Stdlib__Array");
   return;
  }
  (globalThis));

//# 7011 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Assert_failure = global_data.Assert_failure,
    zero = 0,
    one = 1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   function lognot(n){return n ^ -1;}
   var
    _a_ = Stdlib_Sys[9],
    _b_ = [0, "int32.ml", 69, 6],
    minus_one = -1,
    min_int = -2147483648,
    max_int = 2147483647;
   if(32 === _a_)
    var
     max_int$0 = Stdlib[19],
     unsigned_to_int =
       function(n){
        if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
         return [0, n];
        return 0;
       };
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var unsigned_to_int = function(n){return [0, n & -1];};
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _d_ = [0, runtime.caml_int_of_string(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = m + 2147483648 | 0, x = n + 2147483648 | 0;
    return caml_int_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   var
    Stdlib_Int32 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(14, Stdlib_Int32, "Stdlib__Int32");
   return;
  }
  (globalThis));

//# 7106 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    zero = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    one = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    minus_one = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    min_int = runtime.caml_int64_create_lo_mi_hi(0, 0, 32768),
    max_int = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Stdlib = global_data.Stdlib,
    _b_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535);
   function succ(n){return caml_int64_add(n, _a_);}
   function pred(n){return caml_int64_sub(n, _b_);}
   function abs(n){
    return caml_greaterequal(n, _c_) ? n : runtime.caml_int64_neg(n);
   }
   function lognot(n){return runtime.caml_int64_xor(n, _d_);}
   var max_int$0 = runtime.caml_int64_of_int32(Stdlib[19]);
   function unsigned_to_int(n){
    if
     (0 >= caml_int64_compare(zero, n)
      && 0 >= caml_int64_compare(n, max_int$0))
     return [0, runtime.caml_int64_to_int32(n)];
    return 0;
   }
   function to_string(n){return runtime.caml_int64_format("%d", n);}
   function of_string_opt(s){
    try{var _f_ = [0, runtime.caml_int64_of_string(s)]; return _f_;}
    catch(_g_){
     var _e_ = caml_wrap_exception(_g_);
     if(_e_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_e_, 0);
    }
   }
   function compare(x, y){return caml_int64_compare(x, y);}
   function equal(x, y){return 0 === caml_int64_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = caml_int64_sub(m, min_int), x = caml_int64_sub(n, min_int);
    return caml_int64_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, zero))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var
     q =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_div
          (runtime.caml_int64_shift_right_unsigned(n, 1), d),
         1),
     r = caml_int64_sub(n, caml_int64_mul(q, d));
    return 0 <= unsigned_compare(r, d) ? caml_int64_add(q, _a_) : q;
   }
   function unsigned_rem(n, d){
    return caml_int64_sub(n, caml_int64_mul(unsigned_div(n, d), d));
   }
   var
    Stdlib_Int64 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(11, Stdlib_Int64, "Stdlib__Int64");
   return;
  }
  (globalThis));

//# 7204 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    zero = 0,
    one = 1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   var
    size = Stdlib_Sys[9],
    min_int = 1 << (size - 1 | 0),
    max_int = min_int - 1 | 0;
   function lognot(n){return n ^ -1;}
   var max_int$0 = Stdlib[19];
   function unsigned_to_int(n){
    if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
     return [0, n];
    return 0;
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _b_ = [0, runtime.caml_int_of_string(s)]; return _b_;}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = m - min_int | 0, x = n - min_int | 0;
    return caml_int_compare(x, y);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   var
    Stdlib_Nativeint =
      [0,
       zero,
       one,
       -1,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       size,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(12, Stdlib_Nativeint, "Stdlib__Nativeint");
   return;
  }
  (globalThis));

//# 8582 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Seq = global_data.Stdlib__Seq,
    cst_Map_bal = cst_Map_bal$3,
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    cst_Map_bal$2 = cst_Map_bal$3,
    cst_Map_remove_min_elt = "Map.remove_min_elt",
    _a_ = [0, 0, 0, 0],
    _b_ = [0, "map.ml", 400, 10],
    _c_ = [0, 0, 0],
    Stdlib_Map =
      [0,
       function(Ord){
        function height(param){
         if(! param) return 0;
         var h = param[5];
         return h;
        }
        function create(l, x, d, r){
         var
          hl = height(l),
          hr = height(r),
          _K_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
         return [0, l, x, d, r, _K_];
        }
        function singleton(x, d){return [0, 0, x, d, 0, 1];}
        function bal(l, x, d, r){
         if(l) var h = l[5], hl = h; else var hl = 0;
         if(r) var h$0 = r[5], hr = h$0; else var hr = 0;
         if((hr + 2 | 0) < hl){
          if(! l) return caml_call1(Stdlib[1], cst_Map_bal$0);
          var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _F_ = height(lr);
          if(_F_ <= height(ll))
           return create(ll, lv, ld, create(lr, x, d, r));
          if(! lr) return caml_call1(Stdlib[1], cst_Map_bal);
          var
           lrr = lr[4],
           lrd = lr[3],
           lrv = lr[2],
           lrl = lr[1],
           _G_ = create(lrr, x, d, r);
          return create(create(ll, lv, ld, lrl), lrv, lrd, _G_);
         }
         if((hl + 2 | 0) >= hr){
          var _J_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
          return [0, l, x, d, r, _J_];
         }
         if(! r) return caml_call1(Stdlib[1], cst_Map_bal$2);
         var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _H_ = height(rl);
         if(_H_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
         if(! rl) return caml_call1(Stdlib[1], cst_Map_bal$1);
         var
          rlr = rl[4],
          rld = rl[3],
          rlv = rl[2],
          rll = rl[1],
          _I_ = create(rlr, rv, rd, rr);
         return create(create(l, x, d, rll), rlv, rld, _I_);
        }
        var empty = 0;
        function is_empty(param){return param ? 0 : 1;}
        function add(x, data, m){
         if(! m) return [0, 0, x, data, 0, 1];
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return d === data ? m : [0, l, x, data, r, h];
         if(0 <= c){
          var rr = add(x, data, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = add(x, data, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function find(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return d;
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function find_first(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           for(;;){
            if(! param) return [0, v0, d0];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = l;
            }
            else
             param = r;
           }
          }
          else
           param$1 = r$0;
         }
        }
        function find_first_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           for(;;){
            if(! param) return [0, [0, v0, d0]];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = l;
            }
            else
             param = r;
           }
          }
          else
           param$1 = r$0;
         }
        }
        function find_last(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           for(;;){
            if(! param) return [0, v0, d0];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = r;
            }
            else
             param = l;
           }
          }
          else
           param$1 = l$0;
         }
        }
        function find_last_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           for(;;){
            if(! param) return [0, [0, v0, d0]];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = r;
            }
            else
             param = l;
           }
          }
          else
           param$1 = l$0;
         }
        }
        function find_opt(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return [0, d];
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function mem(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v),
           _E_ = 0 === c ? 1 : 0;
          if(_E_) return _E_;
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function min_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var l = param$0[1];
          if(! l){var d = param$0[3], v = param$0[2]; return [0, v, d];}
          param$0 = l;
         }
        }
        function min_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var l = param$0[1];
          if(! l){var d = param$0[3], v = param$0[2]; return [0, [0, v, d]];}
          param$0 = l;
         }
        }
        function max_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          if(! param$0[4]){
           var d = param$0[3], v = param$0[2];
           return [0, v, d];
          }
          var r = param$0[4];
          param$0 = r;
         }
        }
        function max_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          if(! param$0[4]){
           var d = param$0[3], v = param$0[2];
           return [0, [0, v, d]];
          }
          var r = param$0[4];
          param$0 = r;
         }
        }
        function remove_min_binding(param){
         if(! param) return caml_call1(Stdlib[1], cst_Map_remove_min_elt);
         var l = param[1];
         if(l){
          var r = param[4], d = param[3], v = param[2];
          return bal(remove_min_binding(l), v, d, r);
         }
         var r$0 = param[4];
         return r$0;
        }
        function _d_(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return bal(t1, x, d, remove_min_binding(t2));
        }
        function remove(x, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return _d_(l, r);
         if(0 <= c){
          var rr = remove(x, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = remove(x, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function update(x, f, m){
         if(! m){
          var match$0 = caml_call1(f, 0);
          if(! match$0) return 0;
          var data$0 = match$0[1];
          return [0, 0, x, data$0, 0, 1];
         }
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c){
          var match = caml_call1(f, [0, d]);
          if(! match) return _d_(l, r);
          var data = match[1];
          return d === data ? m : [0, l, x, data, r, h];
         }
         if(0 <= c){
          var rr = update(x, f, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = update(x, f, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function iter(f, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1];
          iter(f, l);
          caml_call2(f, v, d);
          param$0 = r;
         }
        }
        function map(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = map(f, l),
          d$0 = caml_call1(f, d),
          r$0 = map(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function mapi(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = mapi(f, l),
          d$0 = caml_call2(f, v, d),
          r$0 = mapi(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function fold(f, m, accu){
         var m$0 = m, accu$0 = accu;
         for(;;){
          if(! m$0) return accu$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           accu$1 = caml_call3(f, v, d, fold(f, l, accu$0));
          m$0 = r;
          accu$0 = accu$1;
         }
        }
        function for_all(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 1;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _B_ = caml_call2(p, v, d);
          if(_B_){
           var _C_ = for_all(p, l);
           if(_C_){param$0 = r; continue;}
           var _D_ = _C_;
          }
          else
           var _D_ = _B_;
          return _D_;
         }
        }
        function exists(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _y_ = caml_call2(p, v, d);
          if(_y_)
           var _z_ = _y_;
          else{
           var _A_ = exists(p, l);
           if(! _A_){param$0 = r; continue;}
           var _z_ = _A_;
          }
          return _z_;
         }
        }
        function add_min_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(add_min_binding(k, x, l), v, d, r);
        }
        function add_max_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(l, v, d, add_max_binding(k, x, r));
        }
        function join(l, v, d, r){
         if(! l) return add_min_binding(v, d, r);
         if(! r) return add_max_binding(v, d, l);
         var
          rh = r[5],
          rr = r[4],
          rd = r[3],
          rv = r[2],
          rl = r[1],
          lh = l[5],
          lr = l[4],
          ld = l[3],
          lv = l[2],
          ll = l[1];
         return (rh + 2 | 0) < lh
                 ? bal(ll, lv, ld, join(lr, v, d, r))
                 : (lh
                   + 2
                   | 0)
                   < rh
                   ? bal(join(l, v, d, rl), rv, rd, rr)
                   : create(l, v, d, r);
        }
        function concat(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return join(t1, x, d, remove_min_binding(t2));
        }
        function concat_or_join(t1, v, d, t2){
         if(! d) return concat(t1, t2);
         var d$0 = d[1];
         return join(t1, v, d$0, t2);
        }
        function split(x, param){
         if(! param) return _a_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return [0, l, [0, d], r];
         if(0 <= c){
          var
           match = split(x, r),
           rr = match[3],
           pres = match[2],
           lr = match[1];
          return [0, join(l, v, d, lr), pres, rr];
         }
         var
          match$0 = split(x, l),
          rl = match$0[3],
          pres$0 = match$0[2],
          ll = match$0[1];
         return [0, ll, pres$0, join(rl, v, d, r)];
        }
        function merge(f, s1, s2){
         if(s1){
          var h1 = s1[5], r1 = s1[4], d1 = s1[3], v1 = s1[2], l1 = s1[1];
          if(height(s2) <= h1){
           var
            match = split(v1, s2),
            r2 = match[3],
            d2 = match[2],
            l2 = match[1],
            _u_ = merge(f, r1, r2),
            _v_ = caml_call3(f, v1, [0, d1], d2);
           return concat_or_join(merge(f, l1, l2), v1, _v_, _u_);
          }
         }
         else if(! s2) return 0;
         if(! s2)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
         var
          r2$0 = s2[4],
          d2$0 = s2[3],
          v2 = s2[2],
          l2$0 = s2[1],
          match$0 = split(v2, s1),
          r1$0 = match$0[3],
          d1$0 = match$0[2],
          l1$0 = match$0[1],
          _w_ = merge(f, r1$0, r2$0),
          _x_ = caml_call3(f, v2, d1$0, [0, d2$0]);
         return concat_or_join(merge(f, l1$0, l2$0), v2, _x_, _w_);
        }
        function union(f, s1, s2){
         if(s1){
          if(s2){
           var
            h2 = s2[5],
            r2 = s2[4],
            d2 = s2[3],
            v2 = s2[2],
            l2 = s2[1],
            h1 = s1[5],
            r1 = s1[4],
            d1 = s1[3],
            v1 = s1[2],
            l1 = s1[1];
           if(h2 <= h1){
            var
             match = split(v1, s2),
             r2$0 = match[3],
             d2$0 = match[2],
             l2$0 = match[1],
             l = union(f, l1, l2$0),
             r = union(f, r1, r2$0);
            if(! d2$0) return join(l, v1, d1, r);
            var d2$1 = d2$0[1];
            return concat_or_join(l, v1, caml_call3(f, v1, d1, d2$1), r);
           }
           var
            match$0 = split(v2, s1),
            r1$0 = match$0[3],
            d1$0 = match$0[2],
            l1$0 = match$0[1],
            l$0 = union(f, l1$0, l2),
            r$0 = union(f, r1$0, r2);
           if(! d1$0) return join(l$0, v2, d2, r$0);
           var d1$1 = d1$0[1];
           return concat_or_join(l$0, v2, caml_call3(f, v2, d1$1, d2), r$0);
          }
          var s = s1;
         }
         else
          var s = s2;
         return s;
        }
        function filter(p, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          l$0 = filter(p, l),
          pvd = caml_call2(p, v, d),
          r$0 = filter(p, r);
         if(! pvd) return concat(l$0, r$0);
         if(l === l$0 && r === r$0) return m;
         return join(l$0, v, d, r$0);
        }
        function filter_map(f, param){
         if(! param) return 0;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = filter_map(f, l),
          fvd = caml_call2(f, v, d),
          r$0 = filter_map(f, r);
         if(! fvd) return concat(l$0, r$0);
         var d$0 = fvd[1];
         return join(l$0, v, d$0, r$0);
        }
        function partition(p, param){
         if(! param) return _c_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          match = partition(p, l),
          lf = match[2],
          lt = match[1],
          pvd = caml_call2(p, v, d),
          match$0 = partition(p, r),
          rf = match$0[2],
          rt = match$0[1];
         if(pvd){
          var _s_ = concat(lf, rf);
          return [0, join(lt, v, d, rt), _s_];
         }
         var _t_ = join(lf, v, d, rf);
         return [0, concat(lt, rt), _t_];
        }
        function cons_enum(m, e){
         var m$0 = m, e$0 = e;
         for(;;){
          if(! m$0) return e$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           e$1 = [0, v, d, r, e$0];
          m$0 = l;
          e$0 = e$1;
         }
        }
        function compare(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? -1 : 0;
          if(! e2) return 1;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 !== c) return c;
          var c$0 = caml_call2(cmp, d1, d2);
          if(0 !== c$0) return c$0;
          var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
          e1 = e1$1;
          e2 = e2$1;
         }
        }
        function equal(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? 0 : 1;
          if(! e2) return 0;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           _p_ = 0 === caml_call2(Ord[1], v1, v2) ? 1 : 0;
          if(_p_){
           var _q_ = caml_call2(cmp, d1, d2);
           if(_q_){
            var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
            e1 = e1$1;
            e2 = e2$1;
            continue;
           }
           var _r_ = _q_;
          }
          else
           var _r_ = _p_;
          return _r_;
         }
        }
        function cardinal(param){
         if(! param) return 0;
         var r = param[4], l = param[1], _o_ = cardinal(r);
         return (cardinal(l) + 1 | 0) + _o_ | 0;
        }
        function bindings_aux(accu, param){
         var accu$0 = accu, param$0 = param;
         for(;;){
          if(! param$0) return accu$0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           accu$1 = [0, [0, v, d], bindings_aux(accu$0, r)];
          accu$0 = accu$1;
          param$0 = l;
         }
        }
        function bindings(s){return bindings_aux(0, s);}
        function add_seq(i, m){
         return caml_call3
                 (Stdlib_Seq[5],
                  function(m, param){
                   var v = param[2], k = param[1];
                   return add(k, v, m);
                  },
                  m,
                  i);
        }
        function of_seq(i){return add_seq(i, empty);}
        function seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _m_ = cons_enum(t, rest);
         return [0, [0, k, v], function(_n_){return seq_of_enum(_m_, _n_);}];
        }
        function to_seq(m){
         var _k_ = cons_enum(m, 0);
         return function(_l_){return seq_of_enum(_k_, _l_);};
        }
        function snoc_enum(s, e){
         var s$0 = s, e$0 = e;
         for(;;){
          if(! s$0) return e$0;
          var
           r = s$0[4],
           d = s$0[3],
           v = s$0[2],
           l = s$0[1],
           e$1 = [0, v, d, l, e$0];
          s$0 = r;
          e$0 = e$1;
         }
        }
        function rev_seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _i_ = snoc_enum(t, rest);
         return [0,
                 [0, k, v],
                 function(_j_){return rev_seq_of_enum(_i_, _j_);}];
        }
        function to_rev_seq(c){
         var _g_ = snoc_enum(c, 0);
         return function(_h_){return rev_seq_of_enum(_g_, _h_);};
        }
        function to_seq_from(low, m){
         a:
         {
          b:
          {
           var m$0 = m, c = 0;
           for(;;){
            if(! m$0) break;
            var
             r = m$0[4],
             d = m$0[3],
             v = m$0[2],
             l = m$0[1],
             n = caml_call2(Ord[1], v, low);
            if(0 === n) break b;
            if(0 <= n){
             var c$0 = [0, v, d, r, c];
             m$0 = l;
             c = c$0;
            }
            else
             m$0 = r;
           }
           var _e_ = c;
           break a;
          }
          var _e_ = [0, v, d, r, c];
         }
         return function(_f_){return seq_of_enum(_e_, _f_);};
        }
        return [0,
                empty,
                is_empty,
                mem,
                add,
                update,
                singleton,
                remove,
                merge,
                union,
                compare,
                equal,
                iter,
                fold,
                for_all,
                exists,
                filter,
                filter_map,
                partition,
                cardinal,
                bindings,
                min_binding,
                min_binding_opt,
                max_binding,
                max_binding_opt,
                min_binding,
                min_binding_opt,
                split,
                find,
                find_opt,
                find_first,
                find_first_opt,
                find_last,
                find_last_opt,
                map,
                mapi,
                to_seq,
                to_rev_seq,
                to_seq_from,
                add_seq,
                of_seq];
       }];
   runtime.caml_register_global(11, Stdlib_Map, "Stdlib__Map");
   return;
  }
  (globalThis));

//# 10064 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_buffer_ml = "buffer.ml",
    caml_blit_string = runtime.caml_blit_string,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    cst_Buffer_sub = "Buffer.sub",
    cst_Buffer_blit = "Buffer.blit",
    cst_Buffer_nth = "Buffer.nth",
    _a_ = [0, cst_buffer_ml, 94, 2],
    _b_ = [0, cst_buffer_ml, 93, 2],
    cst_Buffer_add_cannot_grow_buf = "Buffer.add: cannot grow buffer";
   function create(n){
    var
     n$0 = 1 <= n ? n : 1,
     n$1 = Stdlib_Sys[12] < n$0 ? Stdlib_Sys[12] : n$0,
     s = caml_create_bytes(n$1);
    return [0, s, 0, n$1, s];
   }
   function contents(b){return caml_call3(Stdlib_Bytes[8], b[1], 0, b[2]);}
   function to_bytes(b){return caml_call3(Stdlib_Bytes[7], b[1], 0, b[2]);}
   function sub(b, ofs, len){
    if(0 <= ofs && 0 <= len && (b[2] - len | 0) >= ofs)
     return caml_call3(Stdlib_Bytes[8], b[1], ofs, len);
    return caml_call1(Stdlib[1], cst_Buffer_sub);
   }
   function blit(src, srcoff, dst, dstoff, len){
    if
     (0 <= len
      &&
       0 <= srcoff
       &&
        (src[2] - len | 0) >= srcoff
        && 0 <= dstoff && (caml_ml_bytes_length(dst) - len | 0) >= dstoff)
     return runtime.caml_blit_bytes(src[1], srcoff, dst, dstoff, len);
    return caml_call1(Stdlib[1], cst_Buffer_blit);
   }
   function nth(b, ofs){
    if(0 <= ofs && b[2] > ofs) return caml_bytes_unsafe_get(b[1], ofs);
    return caml_call1(Stdlib[1], cst_Buffer_nth);
   }
   function length(b){return b[2];}
   function clear(b){b[2] = 0; return 0;}
   function reset(b){
    b[2] = 0;
    b[1] = b[4];
    b[3] = caml_ml_bytes_length(b[1]);
    return 0;
   }
   function resize(b, more){
    var old_pos = b[2], old_len = b[3], new_len = [0, old_len];
    for(;;){
     if(new_len[1] >= (old_pos + more | 0)) break;
     new_len[1] = 2 * new_len[1] | 0;
    }
    if(Stdlib_Sys[12] < new_len[1])
     if((old_pos + more | 0) <= Stdlib_Sys[12])
      new_len[1] = Stdlib_Sys[12];
     else
      caml_call1(Stdlib[2], cst_Buffer_add_cannot_grow_buf);
    var new_buffer = caml_create_bytes(new_len[1]);
    caml_call5(Stdlib_Bytes[11], b[1], 0, new_buffer, 0, b[2]);
    b[1] = new_buffer;
    b[3] = new_len[1];
    if((b[2] + more | 0) > b[3])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if((old_pos + more | 0) <= b[3]) return;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function add_char(b, c){
    var pos = b[2];
    if(b[3] <= pos) resize(b, 1);
    caml_bytes_unsafe_set(b[1], pos, c);
    b[2] = pos + 1 | 0;
    return 0;
   }
   var
    uchar_utf_8_byte_length_max = 4,
    uchar_utf_16_byte_length_max = 4,
    cst_Buffer_add_substring_add_s = "Buffer.add_substring/add_subbytes",
    _c_ = [0, cst_buffer_ml, 212, 2],
    cst_Buffer_add_channel = "Buffer.add_channel",
    _d_ = [0, cst_buffer_ml, 231, 9],
    cst_Buffer_truncate = "Buffer.truncate";
   function add_utf_8_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[3] <= pos) resize(b, uchar_utf_8_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[55], b[1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_8_byte_length_max);
    }
   }
   function add_utf_16be_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[3] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[58], b[1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_utf_16le_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[3] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[61], b[1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_substring(b, s, offset, len){
    var _t_ = offset < 0 ? 1 : 0;
    if(_t_)
     var _u_ = _t_;
    else
     var
      _v_ = len < 0 ? 1 : 0,
      _u_ = _v_ || ((caml_ml_string_length(s) - len | 0) < offset ? 1 : 0);
    if(_u_) caml_call1(Stdlib[1], cst_Buffer_add_substring_add_s);
    var new_position = b[2] + len | 0;
    if(b[3] < new_position) resize(b, len);
    caml_blit_string(s, offset, b[1], b[2], len);
    b[2] = new_position;
    return 0;
   }
   function add_subbytes(b, s, offset, len){
    return add_substring(b, caml_call1(Stdlib_Bytes[48], s), offset, len);
   }
   function add_string(b, s){
    var len = caml_ml_string_length(s), new_position = b[2] + len | 0;
    if(b[3] < new_position) resize(b, len);
    caml_blit_string(s, 0, b[1], b[2], len);
    b[2] = new_position;
    return 0;
   }
   function add_bytes(b, s){
    return add_string(b, caml_call1(Stdlib_Bytes[48], s));
   }
   function add_buffer(b, bs){return add_subbytes(b, bs[1], 0, bs[2]);}
   function add_channel(b, ic, to_read$1){
    var
     _r_ = to_read$1 < 0 ? 1 : 0,
     _s_ = _r_ || (Stdlib_Sys[12] < to_read$1 ? 1 : 0);
    if(_s_) caml_call1(Stdlib[1], cst_Buffer_add_channel);
    if(b[3] < (b[2] + to_read$1 | 0)) resize(b, to_read$1);
    var
     ofs$1 = b[2],
     buf = b[1],
     already_read = 0,
     ofs = ofs$1,
     to_read = to_read$1;
    for(;;){
     if(0 !== to_read){
      var r = caml_call4(Stdlib[84], ic, buf, ofs, to_read);
      if(0 !== r){
       var
        already_read$0 = already_read + r | 0,
        ofs$0 = ofs + r | 0,
        to_read$0 = to_read - r | 0;
       already_read = already_read$0;
       ofs = ofs$0;
       to_read = to_read$0;
       continue;
      }
     }
     if((b[2] + already_read | 0) > b[3])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     b[2] = b[2] + already_read | 0;
     if(already_read < to_read$1)
      throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     return 0;
    }
   }
   function output_buffer(oc, b){
    return caml_call4(Stdlib[68], oc, b[1], 0, b[2]);
   }
   function add_substitute(b, f, s){
    var lim$1 = caml_ml_string_length(s), previous = 32, i$4 = 0;
    for(;;){
     if(i$4 >= lim$1){
      var _q_ = 92 === previous ? 1 : 0;
      return _q_ ? add_char(b, previous) : _q_;
     }
     var previous$0 = caml_string_get(s, i$4);
     if(36 === previous$0)
      if(92 === previous){
       add_char(b, previous$0);
       var i$5 = i$4 + 1 | 0;
       previous = 32;
       i$4 = i$5;
      }
      else{
       var start$0 = i$4 + 1 | 0;
       if(lim$1 <= start$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
       var opening = caml_string_get(s, start$0);
       a:
       {
        if(40 !== opening && 123 !== opening){
         var start = start$0 + 1 | 0, lim$0 = caml_ml_string_length(s);
         b:
         {
          c:
          {
           d:
           {
            var i$2 = start;
            for(;;){
             if(lim$0 <= i$2) break c;
             var match = caml_string_get(s, i$2);
             if(91 <= match){
              if(97 <= match){
               if(123 <= match) break d;
              }
              else if(95 !== match) break d;
             }
             else
              if(58 <= match){
               if(65 > match) break;
              }
              else if(48 > match) break d;
             var i$3 = i$2 + 1 | 0;
             i$2 = i$3;
            }
           }
           var stop$0 = i$2;
           break b;
          }
          var stop$0 = lim$0;
         }
         var
          match$0 =
            [0,
             caml_call3(Stdlib_String[15], s, start$0, stop$0 - start$0 | 0),
             stop$0];
         break a;
        }
        var new_start = start$0 + 1 | 0, k$2 = 0;
        if(40 === opening)
         var closing = 41;
        else{
         if(123 !== opening)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
         var closing = 125;
        }
        var lim = caml_ml_string_length(s), k = k$2, stop = new_start;
        for(;;){
         if(lim <= stop) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
         if(caml_string_get(s, stop) === opening){
          var i = stop + 1 | 0, k$0 = k + 1 | 0;
          k = k$0;
          stop = i;
         }
         else if(caml_string_get(s, stop) === closing){
          if(0 === k) break;
          var i$0 = stop + 1 | 0, k$1 = k - 1 | 0;
          k = k$1;
          stop = i$0;
         }
         else{var i$1 = stop + 1 | 0; stop = i$1;}
        }
        var
         match$0 =
           [0,
            caml_call3
             (Stdlib_String[15], s, new_start, (stop - start$0 | 0) - 1 | 0),
            stop + 1 | 0];
       }
       var next_i = match$0[2], ident = match$0[1];
       add_string(b, caml_call1(f, ident));
       previous = 32;
       i$4 = next_i;
      }
     else if(92 === previous){
      add_char(b, 92);
      add_char(b, previous$0);
      var i$6 = i$4 + 1 | 0;
      previous = 32;
      i$4 = i$6;
     }
     else if(92 === previous$0){
      var i$7 = i$4 + 1 | 0;
      previous = previous$0;
      i$4 = i$7;
     }
     else{
      add_char(b, previous$0);
      var i$8 = i$4 + 1 | 0;
      previous = previous$0;
      i$4 = i$8;
     }
    }
   }
   function truncate(b, len){
    if(0 <= len && b[2] >= len){b[2] = len; return 0;}
    return caml_call1(Stdlib[1], cst_Buffer_truncate);
   }
   function to_seq(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_unsafe_get(b[1], i), _o_ = i + 1 | 0;
     return [0, x, function(_p_){return aux(_o_, _p_);}];
    }
    var _m_ = 0;
    return function(_n_){return aux(_m_, _n_);};
   }
   function to_seqi(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_unsafe_get(b[1], i), _k_ = i + 1 | 0;
     return [0, [0, i, x], function(_l_){return aux(_k_, _l_);}];
    }
    var _i_ = 0;
    return function(_j_){return aux(_i_, _j_);};
   }
   function add_seq(b, seq){
    return caml_call2
            (Stdlib_Seq[4], function(_h_){return add_char(b, _h_);}, seq);
   }
   function of_seq(i){var b = create(32); add_seq(b, i); return b;}
   function add_int8(b, x){
    var new_position = b[2] + 1 | 0;
    if(b[3] < new_position) resize(b, 1);
    caml_bytes_unsafe_set(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_ne(b, x){
    var new_position = b[2] + 2 | 0;
    if(b[3] < new_position) resize(b, 2);
    runtime.caml_bytes_set16(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int32_ne(b, x){
    var new_position = b[2] + 4 | 0;
    if(b[3] < new_position) resize(b, 4);
    runtime.caml_bytes_set32(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int64_ne(b, x){
    var new_position = b[2] + 8 | 0;
    if(b[3] < new_position) resize(b, 8);
    runtime.caml_bytes_set64(b[1], b[2], x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_le(b, x){
    var _g_ = Stdlib_Sys[11] ? caml_bswap16(x) : x;
    return add_int16_ne(b, _g_);
   }
   function add_int16_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_bswap16(x);
    return add_int16_ne(b, x$0);
   }
   function add_int32_le(b, x){
    var _f_ = Stdlib_Sys[11] ? caml_int32_bswap(x) : x;
    return add_int32_ne(b, _f_);
   }
   function add_int32_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int32_bswap(x);
    return add_int32_ne(b, x$0);
   }
   function add_int64_le(b, x){
    var _e_ = Stdlib_Sys[11] ? caml_int64_bswap(x) : x;
    return add_int64_ne(b, _e_);
   }
   function add_int64_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int64_bswap(x);
    return add_int64_ne(b, x$0);
   }
   var
    Stdlib_Buffer =
      [0,
       create,
       contents,
       to_bytes,
       sub,
       blit,
       nth,
       length,
       clear,
       reset,
       output_buffer,
       truncate,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       to_seq,
       to_seqi,
       add_seq,
       of_seq,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
   runtime.caml_register_global(17, Stdlib_Buffer, "Stdlib__Buffer");
   return;
  }
  (globalThis));

//# 10531 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$43 = "",
    cst_and = " and ",
    cst_Li$3 = "%Li",
    cst_i$3 = "%i",
    cst_li$3 = "%li",
    cst_ni$3 = "%ni",
    cst_u$0 = "%u",
    cst$42 = "' '",
    cst$41 = "'#'",
    cst$39 = "'*'",
    cst$40 = "'+'",
    cst$44 = ", ",
    cst_0$3 = "0",
    cst_at_character_number = ": at character number ",
    cst$38 = "@[",
    cst$37 = "@{",
    cst_bad_input_format_type_mism =
      "bad input: format type mismatch between ",
    cst_bad_input_format_type_mism$0 =
      "bad input: format type mismatch between %S and %S",
    cst_camlinternalFormat_ml = "camlinternalFormat.ml",
    cst_invalid_format = "invalid format ",
    cst_precision$3 = "precision",
    caml_blit_string = runtime.caml_blit_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_format_float = runtime.caml_format_float,
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$9 = "%{",
    cst$10 = "%}",
    cst$11 = "%(",
    cst$12 = "%)",
    cst$13 = "%?",
    cst$18 = cst$37,
    cst$19 = cst$38,
    cst$20 = cst$37,
    cst$21 = cst$38,
    cst$22 = cst$37,
    cst$23 = cst$38,
    cst$26 = cst$39,
    cst$24 = "'-'",
    cst$25 = cst$39,
    cst$27 = cst$40,
    cst$28 = cst$41,
    cst$29 = cst$42,
    cst$30 = cst$40,
    cst$31 = "'_'",
    sub_format = [0, 0, cst$43],
    formatting_lit = [0, "@;", 1, 0],
    cst$35 = cst$41,
    cst$32 = cst$40,
    cst$33 = cst$40,
    cst$34 = cst$42,
    cst$36 = cst$40,
    cst_unexpected_end_of_format = "unexpected end of format",
    cst$17 = ".",
    cst$14 = "%!",
    cst$15 = cst$37,
    cst$16 = cst$38,
    cst$8 = "%%",
    cst$0 = "@]",
    cst$1 = "@}",
    cst$2 = "@?",
    cst$3 = "@\n",
    cst$4 = "@.",
    cst$5 = "@@",
    cst$6 = "@%",
    cst$7 = "@",
    cst = ".*",
    Assert_failure = global_data.Assert_failure,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Int = global_data.Stdlib__Int,
    _a_ = [0, 0, 0],
    cst_c = "%c",
    cst_s = "%s",
    cst_i = cst_i$3,
    cst_li = cst_li$3,
    cst_ni = cst_ni$3,
    cst_Li = cst_Li$3,
    cst_f = "%f",
    cst_B = "%B",
    cst_a = "%a",
    cst_t = "%t",
    cst_r = "%r",
    cst_r$0 = "%_r",
    cst_0c = "0c",
    _b_ = [0, cst_camlinternalFormat_ml, 850, 23],
    _c_ = [0, cst_camlinternalFormat_ml, 837, 26],
    _d_ = [0, cst_camlinternalFormat_ml, 847, 28],
    _e_ = [0, cst_camlinternalFormat_ml, 815, 21],
    _f_ = [0, cst_camlinternalFormat_ml, 819, 21],
    _g_ = [0, cst_camlinternalFormat_ml, 823, 19],
    _h_ = [0, cst_camlinternalFormat_ml, 827, 22],
    _i_ = [0, cst_camlinternalFormat_ml, 832, 30],
    _j_ = [0, cst_camlinternalFormat_ml, 851, 23],
    _k_ = [0, cst_camlinternalFormat_ml, 836, 26],
    _l_ = [0, cst_camlinternalFormat_ml, 846, 28],
    _m_ = [0, cst_camlinternalFormat_ml, 814, 21],
    _n_ = [0, cst_camlinternalFormat_ml, 818, 21],
    _o_ = [0, cst_camlinternalFormat_ml, 822, 19],
    _p_ = [0, cst_camlinternalFormat_ml, 826, 22],
    _q_ = [0, cst_camlinternalFormat_ml, 831, 30];
   function create_char_set(param){return caml_call2(Stdlib_Bytes[1], 32, 0);}
   function add_in_char_set(char_set, c){
    var
     str_ind = c >>> 3 | 0,
     mask = 1 << (c & 7),
     _cU_ = runtime.caml_bytes_get(char_set, str_ind) | mask;
    return caml_bytes_set(char_set, str_ind, caml_call1(Stdlib[29], _cU_));
   }
   function freeze_char_set(char_set){
    return caml_call1(Stdlib_Bytes[6], char_set);
   }
   function rev_char_set(char_set){
    var char_set$0 = create_char_set(0), i = 0;
    for(;;){
     var _cS_ = caml_string_get(char_set, i) ^ 255;
     caml_bytes_set(char_set$0, i, caml_call1(Stdlib[29], _cS_));
     var _cT_ = i + 1 | 0;
     if(31 === i) return caml_call1(Stdlib_Bytes[48], char_set$0);
     i = _cT_;
    }
   }
   function is_in_char_set(char_set, c){
    var str_ind = c >>> 3 | 0, mask = 1 << (c & 7);
    return 0 !== (caml_string_get(char_set, str_ind) & mask) ? 1 : 0;
   }
   function pad_of_pad_opt(pad_opt){
    if(! pad_opt) return 0;
    var width = pad_opt[1];
    return [0, 1, width];
   }
   function param_format_of_ignored_format(ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        return [0, [0, fmt]];
       case 1:
        return [0, [1, fmt]];
       case 2:
        return [0, [19, fmt]];
       default: return [0, [22, fmt]];
     }
    switch(ign[0]){
      case 0:
       var pad_opt = ign[1]; return [0, [2, pad_of_pad_opt(pad_opt), fmt]];
      case 1:
       var pad_opt$0 = ign[1];
       return [0, [3, pad_of_pad_opt(pad_opt$0), fmt]];
      case 2:
       var pad_opt$1 = ign[2], iconv = ign[1];
       return [0, [4, iconv, pad_of_pad_opt(pad_opt$1), 0, fmt]];
      case 3:
       var pad_opt$2 = ign[2], iconv$0 = ign[1];
       return [0, [5, iconv$0, pad_of_pad_opt(pad_opt$2), 0, fmt]];
      case 4:
       var pad_opt$3 = ign[2], iconv$1 = ign[1];
       return [0, [6, iconv$1, pad_of_pad_opt(pad_opt$3), 0, fmt]];
      case 5:
       var pad_opt$4 = ign[2], iconv$2 = ign[1];
       return [0, [7, iconv$2, pad_of_pad_opt(pad_opt$4), 0, fmt]];
      case 6:
       var prec_opt = ign[2], pad_opt$5 = ign[1];
       if(prec_opt)
        var ndec = prec_opt[1], _cR_ = [0, ndec];
       else
        var _cR_ = 0;
       return [0, [8, _a_, pad_of_pad_opt(pad_opt$5), _cR_, fmt]];
      case 7:
       var pad_opt$6 = ign[1];
       return [0, [9, pad_of_pad_opt(pad_opt$6), fmt]];
      case 8:
       var fmtty = ign[2], pad_opt$7 = ign[1];
       return [0, [13, pad_opt$7, fmtty, fmt]];
      case 9:
       var fmtty$0 = ign[2], pad_opt$8 = ign[1];
       return [0, [14, pad_opt$8, fmtty$0, fmt]];
      case 10:
       var char_set = ign[2], width_opt = ign[1];
       return [0, [20, width_opt, char_set, fmt]];
      default: var counter = ign[1]; return [0, [21, counter, fmt]];
    }
   }
   function default_float_precision(fconv){return 5 === fconv[2] ? 12 : -6;}
   function buffer_create(init_size){
    return [0, 0, caml_create_bytes(init_size)];
   }
   function buffer_check_size(buf, overhead){
    var
     len = runtime.caml_ml_bytes_length(buf[2]),
     min_len = buf[1] + overhead | 0;
    if(len < min_len){
     var
      new_len = caml_call2(Stdlib_Int[11], len * 2 | 0, min_len),
      new_str = caml_create_bytes(new_len);
     caml_call5(Stdlib_Bytes[11], buf[2], 0, new_str, 0, len);
     buf[2] = new_str;
    }
    return;
   }
   function buffer_add_char(buf, c){
    buffer_check_size(buf, 1);
    caml_bytes_set(buf[2], buf[1], c);
    buf[1] = buf[1] + 1 | 0;
    return;
   }
   function buffer_add_string(buf, s){
    var str_len = caml_ml_string_length(s);
    buffer_check_size(buf, str_len);
    caml_call5(Stdlib_String[48], s, 0, buf[2], buf[1], str_len);
    buf[1] = buf[1] + str_len | 0;
    return;
   }
   function buffer_contents(buf){
    return caml_call3(Stdlib_Bytes[8], buf[2], 0, buf[1]);
   }
   function char_of_iconv(iconv){
    switch(iconv){
      case 6:
      case 7:
       return 120;
      case 8:
      case 9:
       return 88;
      case 10:
      case 11:
       return 111;
      case 12:
      case 15:
       return 117;
      case 0:
      case 1:
      case 2:
      case 13:
       return 100;
      default: return 105;
    }
   }
   function char_of_fconv(opt, fconv){
    if(opt) var sth = opt[1], cF = sth; else var cF = 70;
    switch(fconv[2]){
      case 0:
       return 102;
      case 1:
       return 101;
      case 2:
       return 69;
      case 3:
       return 103;
      case 4:
       return 71;
      case 5:
       return cF;
      case 6:
       return 104;
      case 7:
       return 72;
      default: return 70;
    }
   }
   function bprint_padty(buf, padty){
    switch(padty){
      case 0:
       return buffer_add_char(buf, 45);
      case 1:
       return;
      default: return buffer_add_char(buf, 48);
    }
   }
   function bprint_ignored_flag(buf, ign_flag){
    return ign_flag ? buffer_add_char(buf, 95) : ign_flag;
   }
   function bprint_pad_opt(buf, pad_opt){
    if(! pad_opt) return;
    var width = pad_opt[1];
    return buffer_add_string(buf, caml_call1(Stdlib_Int[12], width));
   }
   function bprint_padding(buf, pad){
    if(typeof pad === "number") return;
    if(0 === pad[0]){
     var n = pad[2], padty = pad[1];
     bprint_padty(buf, padty);
     return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
    }
    var padty$0 = pad[1];
    bprint_padty(buf, padty$0);
    return buffer_add_char(buf, 42);
   }
   function bprint_precision(buf, prec){
    if(typeof prec !== "number"){
     var n = prec[1];
     buffer_add_char(buf, 46);
     return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
    }
    if(prec) return buffer_add_string(buf, cst);
    return;
   }
   function bprint_iconv_flag(buf, iconv){
    switch(iconv){
      case 1:
      case 4:
       return buffer_add_char(buf, 43);
      case 2:
      case 5:
       return buffer_add_char(buf, 32);
      case 7:
      case 9:
      case 11:
      case 13:
      case 14:
      case 15:
       return buffer_add_char(buf, 35);
      default: return;
    }
   }
   function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c){
    buffer_add_char(buf, 37);
    bprint_ignored_flag(buf, ign_flag);
    bprint_iconv_flag(buf, iconv);
    bprint_padding(buf, pad);
    bprint_precision(buf, prec);
    buffer_add_char(buf, c);
    return buffer_add_char(buf, char_of_iconv(iconv));
   }
   function bprint_fconv_flag(buf, fconv){
    switch(fconv[1]){
      case 0: break;
      case 1:
       buffer_add_char(buf, 43); break;
      default: buffer_add_char(buf, 32);
    }
    if(8 <= fconv[2]) return buffer_add_char(buf, 35);
    return;
   }
   function string_of_formatting_lit(formatting_lit){
    if(typeof formatting_lit === "number")
     switch(formatting_lit){
       case 0:
        return cst$0;
       case 1:
        return cst$1;
       case 2:
        return cst$2;
       case 3:
        return cst$3;
       case 4:
        return cst$4;
       case 5:
        return cst$5;
       default: return cst$6;
     }
    switch(formatting_lit[0]){
      case 0:
       var str = formatting_lit[1]; return str;
      case 1:
       var str$0 = formatting_lit[1]; return str$0;
      default:
       var c = formatting_lit[1], _cQ_ = caml_call2(Stdlib_String[1], 1, c);
       return caml_call2(Stdlib[28], cst$7, _cQ_);
    }
   }
   function bprint_char_literal(buf, chr){
    return 37 === chr
            ? buffer_add_string(buf, cst$8)
            : buffer_add_char(buf, chr);
   }
   function bprint_string_literal(buf, str){
    var _cO_ = caml_ml_string_length(str) - 1 | 0, _cN_ = 0;
    if(_cO_ >= 0){
     var i = _cN_;
     for(;;){
      bprint_char_literal(buf, caml_string_get(str, i));
      var _cP_ = i + 1 | 0;
      if(_cO_ === i) break;
      i = _cP_;
     }
    }
    return;
   }
   function bprint_fmtty(buf, fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return;
     switch(fmtty$0[0]){
       case 0:
        var fmtty$1 = fmtty$0[1];
        buffer_add_string(buf, cst_c);
        fmtty$0 = fmtty$1;
        break;
       case 1:
        var fmtty$2 = fmtty$0[1];
        buffer_add_string(buf, cst_s);
        fmtty$0 = fmtty$2;
        break;
       case 2:
        var fmtty$3 = fmtty$0[1];
        buffer_add_string(buf, cst_i);
        fmtty$0 = fmtty$3;
        break;
       case 3:
        var fmtty$4 = fmtty$0[1];
        buffer_add_string(buf, cst_li);
        fmtty$0 = fmtty$4;
        break;
       case 4:
        var fmtty$5 = fmtty$0[1];
        buffer_add_string(buf, cst_ni);
        fmtty$0 = fmtty$5;
        break;
       case 5:
        var fmtty$6 = fmtty$0[1];
        buffer_add_string(buf, cst_Li);
        fmtty$0 = fmtty$6;
        break;
       case 6:
        var fmtty$7 = fmtty$0[1];
        buffer_add_string(buf, cst_f);
        fmtty$0 = fmtty$7;
        break;
       case 7:
        var fmtty$8 = fmtty$0[1];
        buffer_add_string(buf, cst_B);
        fmtty$0 = fmtty$8;
        break;
       case 8:
        var fmtty$9 = fmtty$0[2], sub_fmtty = fmtty$0[1];
        buffer_add_string(buf, cst$9);
        bprint_fmtty(buf, sub_fmtty);
        buffer_add_string(buf, cst$10);
        fmtty$0 = fmtty$9;
        break;
       case 9:
        var fmtty$10 = fmtty$0[3], sub_fmtty$0 = fmtty$0[1];
        buffer_add_string(buf, cst$11);
        bprint_fmtty(buf, sub_fmtty$0);
        buffer_add_string(buf, cst$12);
        fmtty$0 = fmtty$10;
        break;
       case 10:
        var fmtty$11 = fmtty$0[1];
        buffer_add_string(buf, cst_a);
        fmtty$0 = fmtty$11;
        break;
       case 11:
        var fmtty$12 = fmtty$0[1];
        buffer_add_string(buf, cst_t);
        fmtty$0 = fmtty$12;
        break;
       case 12:
        var fmtty$13 = fmtty$0[1];
        buffer_add_string(buf, cst$13);
        fmtty$0 = fmtty$13;
        break;
       case 13:
        var fmtty$14 = fmtty$0[1];
        buffer_add_string(buf, cst_r);
        fmtty$0 = fmtty$14;
        break;
       default:
        var fmtty$15 = fmtty$0[1];
        buffer_add_string(buf, cst_r$0);
        fmtty$0 = fmtty$15;
     }
    }
   }
   function int_of_custom_arity(param){
    if(! param) return 0;
    var x = param[1];
    return 1 + int_of_custom_arity(x) | 0;
   }
   function string_of_fmt(fmt){
    var buf = buffer_create(16);
    function fmtiter(fmt, ign_flag){
     var fmt$0 = fmt, ign_flag$0 = ign_flag;
     for(;;){
      if(typeof fmt$0 === "number") return;
      switch(fmt$0[0]){
        case 0:
         var rest = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 99);
         fmt$0 = rest;
         ign_flag$0 = 0;
         break;
        case 1:
         var rest$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 67);
         fmt$0 = rest$0;
         ign_flag$0 = 0;
         break;
        case 2:
         var rest$1 = fmt$0[2], pad = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad);
         buffer_add_char(buf, 115);
         fmt$0 = rest$1;
         ign_flag$0 = 0;
         break;
        case 3:
         var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$0);
         buffer_add_char(buf, 83);
         fmt$0 = rest$2;
         ign_flag$0 = 0;
         break;
        case 4:
         var
          rest$3 = fmt$0[4],
          prec = fmt$0[3],
          pad$1 = fmt$0[2],
          iconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_iconv_flag(buf, iconv);
         bprint_padding(buf, pad$1);
         bprint_precision(buf, prec);
         buffer_add_char(buf, char_of_iconv(iconv));
         fmt$0 = rest$3;
         ign_flag$0 = 0;
         break;
        case 5:
         var
          rest$4 = fmt$0[4],
          prec$0 = fmt$0[3],
          pad$2 = fmt$0[2],
          iconv$0 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$0, pad$2, prec$0, 108);
         fmt$0 = rest$4;
         ign_flag$0 = 0;
         break;
        case 6:
         var
          rest$5 = fmt$0[4],
          prec$1 = fmt$0[3],
          pad$3 = fmt$0[2],
          iconv$1 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$1, pad$3, prec$1, 110);
         fmt$0 = rest$5;
         ign_flag$0 = 0;
         break;
        case 7:
         var
          rest$6 = fmt$0[4],
          prec$2 = fmt$0[3],
          pad$4 = fmt$0[2],
          iconv$2 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$2, pad$4, prec$2, 76);
         fmt$0 = rest$6;
         ign_flag$0 = 0;
         break;
        case 8:
         var
          rest$7 = fmt$0[4],
          prec$3 = fmt$0[3],
          pad$5 = fmt$0[2],
          fconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_fconv_flag(buf, fconv);
         bprint_padding(buf, pad$5);
         bprint_precision(buf, prec$3);
         buffer_add_char(buf, char_of_fconv(0, fconv));
         fmt$0 = rest$7;
         ign_flag$0 = 0;
         break;
        case 9:
         var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$6);
         buffer_add_char(buf, 66);
         fmt$0 = rest$8;
         ign_flag$0 = 0;
         break;
        case 10:
         var rest$9 = fmt$0[1];
         buffer_add_string(buf, cst$14);
         fmt$0 = rest$9;
         break;
        case 11:
         var rest$10 = fmt$0[2], str = fmt$0[1];
         bprint_string_literal(buf, str);
         fmt$0 = rest$10;
         break;
        case 12:
         var rest$11 = fmt$0[2], chr = fmt$0[1];
         bprint_char_literal(buf, chr);
         fmt$0 = rest$11;
         break;
        case 13:
         var rest$12 = fmt$0[3], fmtty = fmt$0[2], pad_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt);
         buffer_add_char(buf, 123);
         bprint_fmtty(buf, fmtty);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 125);
         fmt$0 = rest$12;
         ign_flag$0 = 0;
         break;
        case 14:
         var rest$13 = fmt$0[3], fmtty$0 = fmt$0[2], pad_opt$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt$0);
         buffer_add_char(buf, 40);
         bprint_fmtty(buf, fmtty$0);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 41);
         fmt$0 = rest$13;
         ign_flag$0 = 0;
         break;
        case 15:
         var rest$14 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 97);
         fmt$0 = rest$14;
         ign_flag$0 = 0;
         break;
        case 16:
         var rest$15 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 116);
         fmt$0 = rest$15;
         ign_flag$0 = 0;
         break;
        case 17:
         var rest$16 = fmt$0[2], fmting_lit = fmt$0[1];
         bprint_string_literal(buf, string_of_formatting_lit(fmting_lit));
         fmt$0 = rest$16;
         break;
        case 18:
         var rest$17 = fmt$0[2], fmting_gen = fmt$0[1];
         if(0 === fmting_gen[0]){
          var str$0 = fmting_gen[1][2];
          buffer_add_string(buf, cst$15);
          buffer_add_string(buf, str$0);
         }
         else{
          var str$1 = fmting_gen[1][2];
          buffer_add_string(buf, cst$16);
          buffer_add_string(buf, str$1);
         }
         fmt$0 = rest$17;
         break;
        case 19:
         var rest$18 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 114);
         fmt$0 = rest$18;
         ign_flag$0 = 0;
         break;
        case 20:
         var rest$19 = fmt$0[3], char_set = fmt$0[2], width_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, width_opt);
         var
          print_char =
            function(buf, i){
             var c = caml_call1(Stdlib[29], i);
             return 37 === c
                     ? (buffer_add_char(buf, 37), buffer_add_char(buf, 37))
                     : 64
                       === c
                       ? (buffer_add_char(buf, 37), buffer_add_char(buf, 64))
                       : buffer_add_char(buf, c);
            };
         buffer_add_char(buf, 91);
         var
          set =
            is_in_char_set(char_set, 0)
             ? (buffer_add_char(buf, 94), rev_char_set(char_set))
             : char_set;
         let set$0 = set;
         var
          is_alone =
            function(c){
             var
              after = caml_call1(Stdlib_Char[1], c + 1 | 0),
              before = caml_call1(Stdlib_Char[1], c - 1 | 0),
              _cJ_ = is_in_char_set(set$0, c);
             if(_cJ_)
              var
               _cK_ = is_in_char_set(set$0, before),
               _cL_ = _cK_ ? is_in_char_set(set$0, after) : _cK_,
               _cM_ = 1 - _cL_;
             else
              var _cM_ = _cJ_;
             return _cM_;
            };
         if(is_alone(93)) buffer_add_char(buf, 93);
         a:
         b:
         {
          c:
          {
           d:
           {
            var i = 1;
            for(;;){
             if(i >= 256) break;
             if(is_in_char_set(set, caml_call1(Stdlib[29], i))){
              var switcher = caml_call1(Stdlib[29], i) - 45 | 0;
              if(48 < switcher >>> 0){
               if(210 <= switcher) break d;
              }
              else if(46 < switcher - 1 >>> 0){
               var i$2 = i + 1 | 0;
               i = i$2;
               continue;
              }
              var i$1 = i + 1 | 0;
              if(is_in_char_set(set, caml_call1(Stdlib[29], i$1))){
               var switcher$0 = caml_call1(Stdlib[29], i$1) - 45 | 0;
               if(48 < switcher$0 >>> 0){
                if(210 <= switcher$0) break c;
               }
               else if
                (46 < switcher$0 - 1 >>> 0
                 && ! is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
                print_char(buf, i$1 - 1 | 0);
                var i$5 = i$1 + 1 | 0;
                i = i$5;
                continue;
               }
               if(is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
                var j = i$1 + 2 | 0, i$3 = i$1 - 1 | 0, j$0 = j;
                for(;;){
                 if(256 === j$0) break;
                 if(! is_in_char_set(set, caml_call1(Stdlib[29], j$0))) break;
                 var j$1 = j$0 + 1 | 0;
                 j$0 = j$1;
                }
                print_char(buf, i$3);
                print_char(buf, 45);
                print_char(buf, j$0 - 1 | 0);
                if(j$0 >= 256) break b;
                var i$7 = j$0 + 1 | 0;
                i = i$7;
               }
               else{
                print_char(buf, i$1 - 1 | 0);
                print_char(buf, i$1);
                var i$4 = i$1 + 2 | 0;
                i = i$4;
               }
              }
              else{
               print_char(buf, i$1 - 1 | 0);
               var i$6 = i$1 + 1 | 0;
               i = i$6;
              }
             }
             else{var i$0 = i + 1 | 0; i = i$0;}
            }
            break a;
           }
           print_char(buf, 255);
           break a;
          }
          print_char(buf, 254);
          print_char(buf, 255);
          break a;
         }
         if(is_alone(45)) buffer_add_char(buf, 45);
         buffer_add_char(buf, 93);
         fmt$0 = rest$19;
         ign_flag$0 = 0;
         break;
        case 21:
         var rest$20 = fmt$0[2], counter = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         switch(counter){
           case 0:
            var _cF_ = 108; break;
           case 1:
            var _cF_ = 110; break;
           default: var _cF_ = 78;
         }
         buffer_add_char(buf, _cF_);
         fmt$0 = rest$20;
         ign_flag$0 = 0;
         break;
        case 22:
         var rest$21 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_string_literal(buf, cst_0c);
         fmt$0 = rest$21;
         ign_flag$0 = 0;
         break;
        case 23:
         var
          rest$22 = fmt$0[2],
          ign = fmt$0[1],
          fmt$1 = param_format_of_ignored_format(ign, rest$22)[1];
         fmt$0 = fmt$1;
         ign_flag$0 = 1;
         break;
        default:
         var
          rest$23 = fmt$0[3],
          arity = fmt$0[1],
          _cH_ = int_of_custom_arity(arity),
          _cG_ = 1;
         if(_cH_ >= 1){
          var i$8 = _cG_;
          for(;;){
           buffer_add_char(buf, 37);
           bprint_ignored_flag(buf, ign_flag$0);
           buffer_add_char(buf, 63);
           var _cI_ = i$8 + 1 | 0;
           if(_cH_ === i$8) break;
           i$8 = _cI_;
          }
         }
         fmt$0 = rest$23;
         ign_flag$0 = 0;
      }
     }
    }
    fmtiter(fmt, 0);
    return buffer_contents(buf);
   }
   function symm(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, symm(rest)];
      case 1:
       var rest$0 = param[1]; return [1, symm(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, symm(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, symm(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, symm(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, symm(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, symm(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, symm(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1]; return [8, ty, symm(rest$7)];
      case 9:
       var rest$8 = param[3], ty2 = param[2], ty1 = param[1];
       return [9, ty2, ty1, symm(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, symm(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, symm(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, symm(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, symm(rest$12)];
      default: var rest$13 = param[1]; return [14, symm(rest$13)];
    }
   }
   function fmtty_rel_det(param){
    if(typeof param === "number")
     return [0,
             function(param){return;},
             function(param){return;},
             function(param){return;},
             function(param){return;}];
    switch(param[0]){
      case 0:
       var
        rest = param[1],
        match = fmtty_rel_det(rest),
        de = match[4],
        ed = match[3],
        af = match[2],
        fa = match[1];
       return [0,
               function(param){fa(0); return;},
               function(param){af(0); return;},
               ed,
               de];
      case 1:
       var
        rest$0 = param[1],
        match$0 = fmtty_rel_det(rest$0),
        de$0 = match$0[4],
        ed$0 = match$0[3],
        af$0 = match$0[2],
        fa$0 = match$0[1];
       return [0,
               function(param){fa$0(0); return;},
               function(param){af$0(0); return;},
               ed$0,
               de$0];
      case 2:
       var
        rest$1 = param[1],
        match$1 = fmtty_rel_det(rest$1),
        de$1 = match$1[4],
        ed$1 = match$1[3],
        af$1 = match$1[2],
        fa$1 = match$1[1];
       return [0,
               function(param){fa$1(0); return;},
               function(param){af$1(0); return;},
               ed$1,
               de$1];
      case 3:
       var
        rest$2 = param[1],
        match$2 = fmtty_rel_det(rest$2),
        de$2 = match$2[4],
        ed$2 = match$2[3],
        af$2 = match$2[2],
        fa$2 = match$2[1];
       return [0,
               function(param){fa$2(0); return;},
               function(param){af$2(0); return;},
               ed$2,
               de$2];
      case 4:
       var
        rest$3 = param[1],
        match$3 = fmtty_rel_det(rest$3),
        de$3 = match$3[4],
        ed$3 = match$3[3],
        af$3 = match$3[2],
        fa$3 = match$3[1];
       return [0,
               function(param){fa$3(0); return;},
               function(param){af$3(0); return;},
               ed$3,
               de$3];
      case 5:
       var
        rest$4 = param[1],
        match$4 = fmtty_rel_det(rest$4),
        de$4 = match$4[4],
        ed$4 = match$4[3],
        af$4 = match$4[2],
        fa$4 = match$4[1];
       return [0,
               function(param){fa$4(0); return;},
               function(param){af$4(0); return;},
               ed$4,
               de$4];
      case 6:
       var
        rest$5 = param[1],
        match$5 = fmtty_rel_det(rest$5),
        de$5 = match$5[4],
        ed$5 = match$5[3],
        af$5 = match$5[2],
        fa$5 = match$5[1];
       return [0,
               function(param){fa$5(0); return;},
               function(param){af$5(0); return;},
               ed$5,
               de$5];
      case 7:
       var
        rest$6 = param[1],
        match$6 = fmtty_rel_det(rest$6),
        de$6 = match$6[4],
        ed$6 = match$6[3],
        af$6 = match$6[2],
        fa$6 = match$6[1];
       return [0,
               function(param){fa$6(0); return;},
               function(param){af$6(0); return;},
               ed$6,
               de$6];
      case 8:
       var
        rest$7 = param[2],
        match$7 = fmtty_rel_det(rest$7),
        de$7 = match$7[4],
        ed$7 = match$7[3],
        af$7 = match$7[2],
        fa$7 = match$7[1];
       return [0,
               function(param){fa$7(0); return;},
               function(param){af$7(0); return;},
               ed$7,
               de$7];
      case 9:
       var
        rest$8 = param[3],
        ty2 = param[2],
        ty1 = param[1],
        match$8 = fmtty_rel_det(rest$8),
        de$8 = match$8[4],
        ed$8 = match$8[3],
        af$8 = match$8[2],
        fa$8 = match$8[1],
        ty = trans(symm(ty1), ty2),
        match$9 = fmtty_rel_det(ty),
        jd = match$9[4],
        dj = match$9[3],
        ga = match$9[2],
        ag = match$9[1];
       return [0,
               function(param){fa$8(0); ag(0); return;},
               function(param){ga(0); af$8(0); return;},
               function(param){ed$8(0); dj(0); return;},
               function(param){jd(0); de$8(0); return;}];
      case 10:
       var
        rest$9 = param[1],
        match$10 = fmtty_rel_det(rest$9),
        de$9 = match$10[4],
        ed$9 = match$10[3],
        af$9 = match$10[2],
        fa$9 = match$10[1];
       return [0,
               function(param){fa$9(0); return;},
               function(param){af$9(0); return;},
               ed$9,
               de$9];
      case 11:
       var
        rest$10 = param[1],
        match$11 = fmtty_rel_det(rest$10),
        de$10 = match$11[4],
        ed$10 = match$11[3],
        af$10 = match$11[2],
        fa$10 = match$11[1];
       return [0,
               function(param){fa$10(0); return;},
               function(param){af$10(0); return;},
               ed$10,
               de$10];
      case 12:
       var
        rest$11 = param[1],
        match$12 = fmtty_rel_det(rest$11),
        de$11 = match$12[4],
        ed$11 = match$12[3],
        af$11 = match$12[2],
        fa$11 = match$12[1];
       return [0,
               function(param){fa$11(0); return;},
               function(param){af$11(0); return;},
               ed$11,
               de$11];
      case 13:
       var
        rest$12 = param[1],
        match$13 = fmtty_rel_det(rest$12),
        de$12 = match$13[4],
        ed$12 = match$13[3],
        af$12 = match$13[2],
        fa$12 = match$13[1];
       return [0,
               function(param){fa$12(0); return;},
               function(param){af$12(0); return;},
               function(param){ed$12(0); return;},
               function(param){de$12(0); return;}];
      default:
       var
        rest$13 = param[1],
        match$14 = fmtty_rel_det(rest$13),
        de$13 = match$14[4],
        ed$13 = match$14[3],
        af$13 = match$14[2],
        fa$13 = match$14[1];
       return [0,
               function(param){fa$13(0); return;},
               function(param){af$13(0); return;},
               function(param){ed$13(0); return;},
               function(param){de$13(0); return;}];
    }
   }
   function trans(ty1, ty2){
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           if(typeof ty1 !== "number"){
            switch(ty1[0]){
              case 0:
               var rest1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 0:
                   var rest2 = ty2[1]; return [0, trans(rest1, rest2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 1:
               var rest1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 1:
                   var rest2$0 = ty2[1]; return [1, trans(rest1$0, rest2$0)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 2:
               var rest1$1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 2:
                   var rest2$1 = ty2[1]; return [2, trans(rest1$1, rest2$1)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 3:
               var rest1$2 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 3:
                   var rest2$2 = ty2[1]; return [3, trans(rest1$2, rest2$2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 4:
               var rest1$3 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 4:
                   var rest2$3 = ty2[1]; return [4, trans(rest1$3, rest2$3)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 5:
               var rest1$4 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 5:
                   var rest2$4 = ty2[1]; return [5, trans(rest1$4, rest2$4)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 6:
               var rest1$5 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 6:
                   var rest2$5 = ty2[1]; return [6, trans(rest1$5, rest2$5)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 7:
               var rest1$6 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 7:
                   var rest2$6 = ty2[1]; return [7, trans(rest1$6, rest2$6)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 8:
               var rest1$7 = ty1[2], ty1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   var
                    rest2$7 = ty2[2],
                    ty2$0 = ty2[1],
                    _cE_ = trans(rest1$7, rest2$7);
                   return [8, trans(ty1$0, ty2$0), _cE_];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
              case 9:
               var rest1$8 = ty1[3], ty12 = ty1[2], ty11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   break f;
                  case 9:
                   var
                    rest2$8 = ty2[3],
                    ty22 = ty2[2],
                    ty21 = ty2[1],
                    ty = trans(symm(ty12), ty21),
                    match = fmtty_rel_det(ty),
                    f4 = match[4],
                    f2 = match[2];
                   f2(0);
                   f4(0);
                   return [9, ty11, ty22, trans(rest1$8, rest2$8)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
              case 10:
               var rest1$9 = ty1[1];
               if(typeof ty2 !== "number" && 10 === ty2[0]){
                var rest2$9 = ty2[1];
                return [10, trans(rest1$9, rest2$9)];
               }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
              case 11:
               var rest1$10 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   var rest2$10 = ty2[1];
                   return [11, trans(rest1$10, rest2$10)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
              case 12:
               var rest1$11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   var rest2$11 = ty2[1];
                   return [12, trans(rest1$11, rest2$11)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
              case 13:
               var rest1$12 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   var rest2$12 = ty2[1];
                   return [13, trans(rest1$12, rest2$12)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
              default:
               var rest1$13 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   var rest2$13 = ty2[1];
                   return [14, trans(rest1$13, rest2$13)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
           }
           if(typeof ty2 === "number") return 0;
           switch(ty2[0]){
             case 10:
              break a;
             case 11:
              break b;
             case 12:
              break c;
             case 13:
              break d;
             case 14:
              break e;
             case 8:
              break f;
             case 9: break;
             default:
              throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
           }
          }
          throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        }
        throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function fmtty_of_fmt(fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return 0;
     switch(fmtty$0[0]){
       case 0:
        var rest = fmtty$0[1]; return [0, fmtty_of_fmt(rest)];
       case 1:
        var rest$0 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$0)];
       case 2:
        var rest$1 = fmtty$0[2], pad = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad, [1, fmtty_of_fmt(rest$1)]);
       case 3:
        var rest$2 = fmtty$0[2], pad$0 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$0, [1, fmtty_of_fmt(rest$2)]);
       case 4:
        var
         rest$3 = fmtty$0[4],
         prec = fmtty$0[3],
         pad$1 = fmtty$0[2],
         ty_rest = fmtty_of_fmt(rest$3),
         prec_ty = fmtty_of_precision_fmtty(prec, [2, ty_rest]);
        return fmtty_of_padding_fmtty(pad$1, prec_ty);
       case 5:
        var
         rest$4 = fmtty$0[4],
         prec$0 = fmtty$0[3],
         pad$2 = fmtty$0[2],
         ty_rest$0 = fmtty_of_fmt(rest$4),
         prec_ty$0 = fmtty_of_precision_fmtty(prec$0, [3, ty_rest$0]);
        return fmtty_of_padding_fmtty(pad$2, prec_ty$0);
       case 6:
        var
         rest$5 = fmtty$0[4],
         prec$1 = fmtty$0[3],
         pad$3 = fmtty$0[2],
         ty_rest$1 = fmtty_of_fmt(rest$5),
         prec_ty$1 = fmtty_of_precision_fmtty(prec$1, [4, ty_rest$1]);
        return fmtty_of_padding_fmtty(pad$3, prec_ty$1);
       case 7:
        var
         rest$6 = fmtty$0[4],
         prec$2 = fmtty$0[3],
         pad$4 = fmtty$0[2],
         ty_rest$2 = fmtty_of_fmt(rest$6),
         prec_ty$2 = fmtty_of_precision_fmtty(prec$2, [5, ty_rest$2]);
        return fmtty_of_padding_fmtty(pad$4, prec_ty$2);
       case 8:
        var
         rest$7 = fmtty$0[4],
         prec$3 = fmtty$0[3],
         pad$5 = fmtty$0[2],
         ty_rest$3 = fmtty_of_fmt(rest$7),
         prec_ty$3 = fmtty_of_precision_fmtty(prec$3, [6, ty_rest$3]);
        return fmtty_of_padding_fmtty(pad$5, prec_ty$3);
       case 9:
        var rest$8 = fmtty$0[2], pad$6 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$6, [7, fmtty_of_fmt(rest$8)]);
       case 10:
        var fmtty$1 = fmtty$0[1]; fmtty$0 = fmtty$1; break;
       case 11:
        var fmtty$2 = fmtty$0[2]; fmtty$0 = fmtty$2; break;
       case 12:
        var fmtty$3 = fmtty$0[2]; fmtty$0 = fmtty$3; break;
       case 13:
        var rest$9 = fmtty$0[3], ty = fmtty$0[2];
        return [8, ty, fmtty_of_fmt(rest$9)];
       case 14:
        var rest$10 = fmtty$0[3], ty$0 = fmtty$0[2];
        return [9, ty$0, ty$0, fmtty_of_fmt(rest$10)];
       case 15:
        var rest$11 = fmtty$0[1]; return [10, fmtty_of_fmt(rest$11)];
       case 16:
        var rest$12 = fmtty$0[1]; return [11, fmtty_of_fmt(rest$12)];
       case 17:
        var fmtty$4 = fmtty$0[2]; fmtty$0 = fmtty$4; break;
       case 18:
        var
         rest$13 = fmtty$0[2],
         formatting_gen = fmtty$0[1],
         _cB_ = fmtty_of_fmt(rest$13);
        if(0 === formatting_gen[0])
         var fmt = formatting_gen[1][1], _cC_ = fmtty_of_fmt(fmt);
        else
         var fmt$0 = formatting_gen[1][1], _cC_ = fmtty_of_fmt(fmt$0);
        return caml_call2(CamlinternalFormatBasics[1], _cC_, _cB_);
       case 19:
        var rest$14 = fmtty$0[1]; return [13, fmtty_of_fmt(rest$14)];
       case 20:
        var rest$15 = fmtty$0[3]; return [1, fmtty_of_fmt(rest$15)];
       case 21:
        var rest$16 = fmtty$0[2]; return [2, fmtty_of_fmt(rest$16)];
       case 22:
        var rest$17 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$17)];
       case 23:
        var fmtty$5 = fmtty$0[2], ign = fmtty$0[1];
        if(typeof ign === "number")
         switch(ign){
           case 0:
            fmtty$0 = fmtty$5; break;
           case 1:
            fmtty$0 = fmtty$5; break;
           case 2:
            return [14, fmtty_of_fmt(fmtty$5)];
           default: fmtty$0 = fmtty$5;
         }
        else
         switch(ign[0]){
           case 0:
            fmtty$0 = fmtty$5; break;
           case 1:
            fmtty$0 = fmtty$5; break;
           case 2:
            fmtty$0 = fmtty$5; break;
           case 3:
            fmtty$0 = fmtty$5; break;
           case 4:
            fmtty$0 = fmtty$5; break;
           case 5:
            fmtty$0 = fmtty$5; break;
           case 6:
            fmtty$0 = fmtty$5; break;
           case 7:
            fmtty$0 = fmtty$5; break;
           case 8:
            fmtty$0 = fmtty$5; break;
           case 9:
            var fmtty$6 = ign[2], _cD_ = fmtty_of_fmt(fmtty$5);
            return caml_call2(CamlinternalFormatBasics[1], fmtty$6, _cD_);
           case 10:
            fmtty$0 = fmtty$5; break;
           default: fmtty$0 = fmtty$5;
         }
        break;
       default:
        var rest$18 = fmtty$0[3], arity = fmtty$0[1];
        return fmtty_of_custom(arity, fmtty_of_fmt(rest$18));
     }
    }
   }
   function fmtty_of_custom(arity, fmtty){
    if(! arity) return fmtty;
    var arity$0 = arity[1];
    return [12, fmtty_of_custom(arity$0, fmtty)];
   }
   function fmtty_of_padding_fmtty(pad, fmtty){
    return typeof pad === "number" ? fmtty : 0 === pad[0] ? fmtty : [2, fmtty];
   }
   function fmtty_of_precision_fmtty(prec, fmtty){
    return typeof prec === "number" ? prec ? [2, fmtty] : fmtty : fmtty;
   }
   var
    Type_mismatch =
      [248, "CamlinternalFormat.Type_mismatch", runtime.caml_fresh_oo_id(0)],
    cst_d = "%d",
    cst_d$0 = "%+d",
    cst_d$1 = "% d",
    cst_i$0 = cst_i$3,
    cst_i$1 = "%+i",
    cst_i$2 = "% i",
    cst_x = "%x",
    cst_x$0 = "%#x",
    cst_X = "%X",
    cst_X$0 = "%#X",
    cst_o = "%o",
    cst_o$0 = "%#o",
    cst_u = cst_u$0,
    cst_Ld = "%Ld",
    cst_Ld$0 = "%+Ld",
    cst_Ld$1 = "% Ld",
    cst_Li$0 = cst_Li$3,
    cst_Li$1 = "%+Li",
    cst_Li$2 = "% Li",
    cst_Lx = "%Lx",
    cst_Lx$0 = "%#Lx",
    cst_LX = "%LX",
    cst_LX$0 = "%#LX",
    cst_Lo = "%Lo",
    cst_Lo$0 = "%#Lo",
    cst_Lu = "%Lu",
    cst_ld = "%ld",
    cst_ld$0 = "%+ld",
    cst_ld$1 = "% ld",
    cst_li$0 = cst_li$3,
    cst_li$1 = "%+li",
    cst_li$2 = "% li",
    cst_lx = "%lx",
    cst_lx$0 = "%#lx",
    cst_lX = "%lX",
    cst_lX$0 = "%#lX",
    cst_lo = "%lo",
    cst_lo$0 = "%#lo",
    cst_lu = "%lu",
    cst_nd = "%nd",
    cst_nd$0 = "%+nd",
    cst_nd$1 = "% nd",
    cst_ni$0 = cst_ni$3,
    cst_ni$1 = "%+ni",
    cst_ni$2 = "% ni",
    cst_nx = "%nx",
    cst_nx$0 = "%#nx",
    cst_nX = "%nX",
    cst_nX$0 = "%#nX",
    cst_no = "%no",
    cst_no$0 = "%#no",
    cst_nu = "%nu",
    _r_ = [0, 103],
    cst_neg_infinity = "neg_infinity",
    cst_infinity = "infinity",
    cst_nan = "nan",
    _s_ = [0, cst_camlinternalFormat_ml, 1558, 4],
    cst_Printf_bad_conversion = "Printf: bad conversion %[",
    _t_ = [0, cst_camlinternalFormat_ml, 1626, 39],
    _u_ = [0, cst_camlinternalFormat_ml, 1649, 31],
    _v_ = [0, cst_camlinternalFormat_ml, 1650, 31],
    cst_Printf_bad_conversion$0 = "Printf: bad conversion %_",
    _w_ = [0, cst_camlinternalFormat_ml, 1830, 8],
    _x_ = [0, 0, 4],
    _y_ =
      [0,
       [11, "invalid box description ", [3, 0, 0]],
       "invalid box description %S"],
    _z_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11, cst_at_character_number, [4, 0, 0, 0, [11, cst$44, [2, 0, 0]]]]]],
       "invalid format %S: at character number %d, %s"],
    cst_non_zero_widths_are_unsupp =
      "non-zero widths are unsupported for %c conversions",
    _A_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", '", [0, [11, "' without ", [2, 0, 0]]]]]]]],
       "invalid format %S: at character number %d, '%c' without %s"],
    _B_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, cst$44, [2, 0, [11, " expected, read ", [1, 0]]]]]]]],
       "invalid format %S: at character number %d, %s expected, read %C"],
    _C_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", duplicate flag ", [1, 0]]]]]],
       "invalid format %S: at character number %d, duplicate flag %C"],
    cst_padding = "padding",
    _D_ = [0, 1, 0],
    cst_0 = cst_0$3,
    _E_ = [0, 0],
    cst_precision = cst_precision$3,
    _F_ = [1, 0],
    _G_ = [1, 1],
    cst_precision$0 = cst_precision$3,
    _H_ = [1, 1],
    cst_precision$1 = cst_precision$3,
    cst_0$0 = cst_0$3,
    _I_ = [1, 1],
    cst_0$1 = cst_0$3,
    cst_0$2 = "'0'",
    _J_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11, ', invalid conversion "', [12, 37, [0, [12, 34, 0]]]]]]]],
       'invalid format %S: at character number %d, invalid conversion "%%%c"'],
    _K_ = [0, 0],
    cst_padding$0 = "`padding'",
    _L_ = [0, 0],
    cst_precision$2 = "`precision'",
    _M_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            ", flag ",
            [1,
             [11,
              " is only allowed after the '",
              [12, 37, [11, "', before padding and precision", 0]]]]]]]]],
       "invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision"],
    _N_ = [0, [12, 64, 0]],
    _O_ = [0, "@ ", 1, 0],
    _P_ = [0, "@,", 0, 0],
    _Q_ = [2, 60],
    _R_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": '",
          [12,
           37,
           [11,
            "' alone is not accepted in character sets, use ",
            [12,
             37,
             [12,
              37,
              [11, " instead at position ", [4, 0, 0, 0, [12, 46, 0]]]]]]]]]],
       "invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d."],
    _S_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": integer ",
          [4, 0, 0, 0, [11, " is greater than the limit ", [4, 0, 0, 0, 0]]]]]],
       "invalid format %S: integer %d is greater than the limit %d"],
    _T_ = [0, cst_camlinternalFormat_ml, 2837, 11],
    cst_digit = "digit",
    _U_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ': unclosed sub-format, expected "',
          [12, 37, [0, [11, '" at character number ', [4, 0, 0, 0, 0]]]]]]],
       'invalid format %S: unclosed sub-format, expected "%%%c" at character number %d'],
    cst_character = "character ')'",
    cst_character$0 = "character '}'",
    _V_ = [0, cst_camlinternalFormat_ml, 2899, 34],
    _W_ = [0, cst_camlinternalFormat_ml, 2935, 28],
    _X_ = [0, cst_camlinternalFormat_ml, 2957, 11],
    _Y_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            cst$44,
            [2,
             0,
             [11,
              " is incompatible with '",
              [0, [11, "' in sub-format ", [3, 0, 0]]]]]]]]]],
       "invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S"],
    _Z_ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0],
    ___ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0];
   function type_padding(pad, fmtty){
    if(typeof pad === "number") return [0, 0, fmtty];
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     return [0, [0, padty, w], fmtty];
    }
    if(typeof fmtty !== "number" && 2 === fmtty[0]){
     var rest = fmtty[1], padty$0 = pad[1];
     return [0, [1, padty$0], rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_padprec(pad, prec, fmtty){
    var match = type_padding(pad, fmtty);
    if(typeof prec !== "number"){
     var rest$1 = match[2], pad$2 = match[1], p = prec[1];
     return [0, pad$2, [0, p], rest$1];
    }
    if(! prec){
     var rest$0 = match[2], pad$1 = match[1];
     return [0, pad$1, 0, rest$0];
    }
    var match$0 = match[2];
    if(typeof match$0 !== "number" && 2 === match$0[0]){
     var rest = match$0[1], pad$0 = match[1];
     return [0, pad$0, 1, rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_format(fmt, fmtty){
    var _cA_ = type_format_gen(fmt, fmtty);
    if(typeof _cA_[2] !== "number")
     throw caml_maybe_attach_backtrace(Type_mismatch, 1);
    var fmt$0 = _cA_[1];
    return fmt$0;
   }
   function type_format_gen(fmt, fmtty0){
    if(typeof fmt === "number") return [0, 0, fmtty0];
    switch(fmt[0]){
      case 0:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest = fmtty0[1],
         fmt_rest = fmt[1],
         match = type_format_gen(fmt_rest, fmtty_rest),
         fmtty = match[2],
         fmt$0 = match[1];
        return [0, [0, fmt$0], fmtty];
       }
       break;
      case 1:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest$0 = fmtty0[1],
         fmt_rest$0 = fmt[1],
         match$0 = type_format_gen(fmt_rest$0, fmtty_rest$0),
         fmtty$0 = match$0[2],
         fmt$1 = match$0[1];
        return [0, [1, fmt$1], fmtty$0];
       }
       break;
      case 2:
       var
        fmt_rest$1 = fmt[2],
        pad = fmt[1],
        match$1 = type_padding(pad, fmtty0),
        pad$0 = match$1[1],
        match$2 = match$1[2];
       if(typeof match$2 !== "number" && 1 === match$2[0]){
        var
         fmtty_rest$1 = match$2[1],
         match$3 = type_format_gen(fmt_rest$1, fmtty_rest$1),
         fmtty$1 = match$3[2],
         fmt$2 = match$3[1];
        return [0, [2, pad$0, fmt$2], fmtty$1];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 3:
       var
        fmt_rest$2 = fmt[2],
        pad$1 = fmt[1],
        match$4 = type_padding(pad$1, fmtty0),
        pad$2 = match$4[1],
        match$5 = match$4[2];
       if(typeof match$5 !== "number" && 1 === match$5[0]){
        var
         fmtty_rest$2 = match$5[1],
         match$6 = type_format_gen(fmt_rest$2, fmtty_rest$2),
         fmtty$2 = match$6[2],
         fmt$3 = match$6[1];
        return [0, [3, pad$2, fmt$3], fmtty$2];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 4:
       var
        fmt_rest$3 = fmt[4],
        prec = fmt[3],
        pad$3 = fmt[2],
        iconv = fmt[1],
        match$7 = type_padprec(pad$3, prec, fmtty0),
        pad$4 = match$7[1],
        match$8 = match$7[3];
       if(typeof match$8 !== "number" && 2 === match$8[0]){
        var
         fmtty_rest$3 = match$8[1],
         prec$0 = match$7[2],
         match$9 = type_format_gen(fmt_rest$3, fmtty_rest$3),
         fmtty$3 = match$9[2],
         fmt$4 = match$9[1];
        return [0, [4, iconv, pad$4, prec$0, fmt$4], fmtty$3];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 5:
       var
        fmt_rest$4 = fmt[4],
        prec$1 = fmt[3],
        pad$5 = fmt[2],
        iconv$0 = fmt[1],
        match$10 = type_padprec(pad$5, prec$1, fmtty0),
        pad$6 = match$10[1],
        match$11 = match$10[3];
       if(typeof match$11 !== "number" && 3 === match$11[0]){
        var
         fmtty_rest$4 = match$11[1],
         prec$2 = match$10[2],
         match$12 = type_format_gen(fmt_rest$4, fmtty_rest$4),
         fmtty$4 = match$12[2],
         fmt$5 = match$12[1];
        return [0, [5, iconv$0, pad$6, prec$2, fmt$5], fmtty$4];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 6:
       var
        fmt_rest$5 = fmt[4],
        prec$3 = fmt[3],
        pad$7 = fmt[2],
        iconv$1 = fmt[1],
        match$13 = type_padprec(pad$7, prec$3, fmtty0),
        pad$8 = match$13[1],
        match$14 = match$13[3];
       if(typeof match$14 !== "number" && 4 === match$14[0]){
        var
         fmtty_rest$5 = match$14[1],
         prec$4 = match$13[2],
         match$15 = type_format_gen(fmt_rest$5, fmtty_rest$5),
         fmtty$5 = match$15[2],
         fmt$6 = match$15[1];
        return [0, [6, iconv$1, pad$8, prec$4, fmt$6], fmtty$5];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 7:
       var
        fmt_rest$6 = fmt[4],
        prec$5 = fmt[3],
        pad$9 = fmt[2],
        iconv$2 = fmt[1],
        match$16 = type_padprec(pad$9, prec$5, fmtty0),
        pad$10 = match$16[1],
        match$17 = match$16[3];
       if(typeof match$17 !== "number" && 5 === match$17[0]){
        var
         fmtty_rest$6 = match$17[1],
         prec$6 = match$16[2],
         match$18 = type_format_gen(fmt_rest$6, fmtty_rest$6),
         fmtty$6 = match$18[2],
         fmt$7 = match$18[1];
        return [0, [7, iconv$2, pad$10, prec$6, fmt$7], fmtty$6];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 8:
       var
        fmt_rest$7 = fmt[4],
        prec$7 = fmt[3],
        pad$11 = fmt[2],
        fconv = fmt[1],
        match$19 = type_padprec(pad$11, prec$7, fmtty0),
        pad$12 = match$19[1],
        match$20 = match$19[3];
       if(typeof match$20 !== "number" && 6 === match$20[0]){
        var
         fmtty_rest$7 = match$20[1],
         prec$8 = match$19[2],
         match$21 = type_format_gen(fmt_rest$7, fmtty_rest$7),
         fmtty$7 = match$21[2],
         fmt$8 = match$21[1];
        return [0, [8, fconv, pad$12, prec$8, fmt$8], fmtty$7];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 9:
       var
        fmt_rest$8 = fmt[2],
        pad$13 = fmt[1],
        match$22 = type_padding(pad$13, fmtty0),
        pad$14 = match$22[1],
        match$23 = match$22[2];
       if(typeof match$23 !== "number" && 7 === match$23[0]){
        var
         fmtty_rest$8 = match$23[1],
         match$24 = type_format_gen(fmt_rest$8, fmtty_rest$8),
         fmtty$8 = match$24[2],
         fmt$9 = match$24[1];
        return [0, [9, pad$14, fmt$9], fmtty$8];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 10:
       var
        fmt_rest$9 = fmt[1],
        match$25 = type_format_gen(fmt_rest$9, fmtty0),
        fmtty$9 = match$25[2],
        fmt$10 = match$25[1];
       return [0, [10, fmt$10], fmtty$9];
      case 11:
       var
        fmt_rest$10 = fmt[2],
        str = fmt[1],
        match$26 = type_format_gen(fmt_rest$10, fmtty0),
        fmtty$10 = match$26[2],
        fmt$11 = match$26[1];
       return [0, [11, str, fmt$11], fmtty$10];
      case 12:
       var
        fmt_rest$11 = fmt[2],
        chr = fmt[1],
        match$27 = type_format_gen(fmt_rest$11, fmtty0),
        fmtty$11 = match$27[2],
        fmt$12 = match$27[1];
       return [0, [12, chr, fmt$12], fmtty$11];
      case 13:
       if(typeof fmtty0 !== "number" && 8 === fmtty0[0]){
        var
         fmtty_rest$9 = fmtty0[2],
         sub_fmtty = fmtty0[1],
         fmt_rest$12 = fmt[3],
         sub_fmtty$0 = fmt[2],
         pad_opt = fmt[1];
        if(caml_notequal([0, sub_fmtty$0], [0, sub_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$28 = type_format_gen(fmt_rest$12, fmtty_rest$9),
         fmtty$12 = match$28[2],
         fmt$13 = match$28[1];
        return [0, [13, pad_opt, sub_fmtty, fmt$13], fmtty$12];
       }
       break;
      case 14:
       if(typeof fmtty0 !== "number" && 9 === fmtty0[0]){
        var
         fmtty_rest$10 = fmtty0[3],
         sub_fmtty1 = fmtty0[1],
         fmt_rest$13 = fmt[3],
         sub_fmtty$1 = fmt[2],
         pad_opt$0 = fmt[1],
         _cy_ = [0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty$1)], _cy_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$29 =
           type_format_gen
            (fmt_rest$13,
             caml_call1(CamlinternalFormatBasics[2], fmtty_rest$10)),
         fmtty$13 = match$29[2],
         fmt$14 = match$29[1];
        return [0, [14, pad_opt$0, sub_fmtty1, fmt$14], fmtty$13];
       }
       break;
      case 15:
       if(typeof fmtty0 !== "number" && 10 === fmtty0[0]){
        var
         fmtty_rest$11 = fmtty0[1],
         fmt_rest$14 = fmt[1],
         match$30 = type_format_gen(fmt_rest$14, fmtty_rest$11),
         fmtty$14 = match$30[2],
         fmt$15 = match$30[1];
        return [0, [15, fmt$15], fmtty$14];
       }
       break;
      case 16:
       if(typeof fmtty0 !== "number" && 11 === fmtty0[0]){
        var
         fmtty_rest$12 = fmtty0[1],
         fmt_rest$15 = fmt[1],
         match$31 = type_format_gen(fmt_rest$15, fmtty_rest$12),
         fmtty$15 = match$31[2],
         fmt$16 = match$31[1];
        return [0, [16, fmt$16], fmtty$15];
       }
       break;
      case 17:
       var
        fmt_rest$16 = fmt[2],
        formatting_lit = fmt[1],
        match$32 = type_format_gen(fmt_rest$16, fmtty0),
        fmtty$16 = match$32[2],
        fmt$17 = match$32[1];
       return [0, [17, formatting_lit, fmt$17], fmtty$16];
      case 18:
       var fmt_rest$17 = fmt[2], formatting_gen = fmt[1];
       if(0 === formatting_gen[0]){
        var
         match$36 = formatting_gen[1],
         str$0 = match$36[2],
         fmt1 = match$36[1],
         match$37 = type_format_gen(fmt1, fmtty0),
         fmtty2 = match$37[2],
         fmt2 = match$37[1],
         match$38 = type_format_gen(fmt_rest$17, fmtty2),
         fmtty3 = match$38[2],
         fmt3 = match$38[1];
        return [0, [18, [0, [0, fmt2, str$0]], fmt3], fmtty3];
       }
       var
        match$39 = formatting_gen[1],
        str$1 = match$39[2],
        fmt1$0 = match$39[1],
        match$40 = type_format_gen(fmt1$0, fmtty0),
        fmtty2$0 = match$40[2],
        fmt2$0 = match$40[1],
        match$41 = type_format_gen(fmt_rest$17, fmtty2$0),
        fmtty3$0 = match$41[2],
        fmt3$0 = match$41[1];
       return [0, [18, [1, [0, fmt2$0, str$1]], fmt3$0], fmtty3$0];
      case 19:
       if(typeof fmtty0 !== "number" && 13 === fmtty0[0]){
        var
         fmtty_rest$13 = fmtty0[1],
         fmt_rest$18 = fmt[1],
         match$33 = type_format_gen(fmt_rest$18, fmtty_rest$13),
         fmtty$17 = match$33[2],
         fmt$18 = match$33[1];
        return [0, [19, fmt$18], fmtty$17];
       }
       break;
      case 20:
       if(typeof fmtty0 !== "number" && 1 === fmtty0[0]){
        var
         fmtty_rest$14 = fmtty0[1],
         fmt_rest$19 = fmt[3],
         char_set = fmt[2],
         width_opt = fmt[1],
         match$34 = type_format_gen(fmt_rest$19, fmtty_rest$14),
         fmtty$18 = match$34[2],
         fmt$19 = match$34[1];
        return [0, [20, width_opt, char_set, fmt$19], fmtty$18];
       }
       break;
      case 21:
       if(typeof fmtty0 !== "number" && 2 === fmtty0[0]){
        var
         fmtty_rest$15 = fmtty0[1],
         fmt_rest$20 = fmt[2],
         counter = fmt[1],
         match$35 = type_format_gen(fmt_rest$20, fmtty_rest$15),
         fmtty$19 = match$35[2],
         fmt$20 = match$35[1];
        return [0, [21, counter, fmt$20], fmtty$19];
       }
       break;
      case 23:
       var rest = fmt[2], ign = fmt[1];
       if(typeof ign !== "number")
        switch(ign[0]){
          case 0:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 1:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 2:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 3:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 4:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 5:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 6:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 7:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 8:
           var sub_fmtty$2 = ign[2], pad_opt$1 = ign[1];
           return type_ignored_param_one
                   ([8, pad_opt$1, sub_fmtty$2], rest, fmtty0);
          case 9:
           var
            sub_fmtty$3 = ign[2],
            pad_opt$2 = ign[1],
            _cz_ = type_ignored_format_substituti(sub_fmtty$3, rest, fmtty0),
            match$43 = _cz_[2],
            fmtty$21 = match$43[2],
            fmt$22 = match$43[1],
            sub_fmtty$4 = _cz_[1];
           return [0, [23, [9, pad_opt$2, sub_fmtty$4], fmt$22], fmtty$21];
          case 10:
           return type_ignored_param_one(ign, rest, fmtty0);
          default: return type_ignored_param_one(ign, rest, fmtty0);
        }
       switch(ign){
         case 0:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 1:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 2:
          if(typeof fmtty0 !== "number" && 14 === fmtty0[0]){
           var
            fmtty_rest$16 = fmtty0[1],
            match$42 = type_format_gen(rest, fmtty_rest$16),
            fmtty$20 = match$42[2],
            fmt$21 = match$42[1];
           return [0, [23, 2, fmt$21], fmtty$20];
          }
          throw caml_maybe_attach_backtrace(Type_mismatch, 1);
         default: return type_ignored_param_one(ign, rest, fmtty0);
       }
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_ignored_param_one(ign, fmt, fmtty){
    var
     match = type_format_gen(fmt, fmtty),
     fmtty$0 = match[2],
     fmt$0 = match[1];
    return [0, [23, ign, fmt$0], fmtty$0];
   }
   function type_ignored_format_substituti(sub_fmtty, fmt, fmtty){
    if(typeof sub_fmtty === "number")
     return [0, 0, type_format_gen(fmt, fmtty)];
    switch(sub_fmtty[0]){
      case 0:
       if(typeof fmtty !== "number" && 0 === fmtty[0]){
        var
         fmtty_rest = fmtty[1],
         sub_fmtty_rest = sub_fmtty[1],
         match =
           type_ignored_format_substituti(sub_fmtty_rest, fmt, fmtty_rest),
         fmt$0 = match[2],
         sub_fmtty_rest$0 = match[1];
        return [0, [0, sub_fmtty_rest$0], fmt$0];
       }
       break;
      case 1:
       if(typeof fmtty !== "number" && 1 === fmtty[0]){
        var
         fmtty_rest$0 = fmtty[1],
         sub_fmtty_rest$1 = sub_fmtty[1],
         match$0 =
           type_ignored_format_substituti(sub_fmtty_rest$1, fmt, fmtty_rest$0),
         fmt$1 = match$0[2],
         sub_fmtty_rest$2 = match$0[1];
        return [0, [1, sub_fmtty_rest$2], fmt$1];
       }
       break;
      case 2:
       if(typeof fmtty !== "number" && 2 === fmtty[0]){
        var
         fmtty_rest$1 = fmtty[1],
         sub_fmtty_rest$3 = sub_fmtty[1],
         match$1 =
           type_ignored_format_substituti(sub_fmtty_rest$3, fmt, fmtty_rest$1),
         fmt$2 = match$1[2],
         sub_fmtty_rest$4 = match$1[1];
        return [0, [2, sub_fmtty_rest$4], fmt$2];
       }
       break;
      case 3:
       if(typeof fmtty !== "number" && 3 === fmtty[0]){
        var
         fmtty_rest$2 = fmtty[1],
         sub_fmtty_rest$5 = sub_fmtty[1],
         match$2 =
           type_ignored_format_substituti(sub_fmtty_rest$5, fmt, fmtty_rest$2),
         fmt$3 = match$2[2],
         sub_fmtty_rest$6 = match$2[1];
        return [0, [3, sub_fmtty_rest$6], fmt$3];
       }
       break;
      case 4:
       if(typeof fmtty !== "number" && 4 === fmtty[0]){
        var
         fmtty_rest$3 = fmtty[1],
         sub_fmtty_rest$7 = sub_fmtty[1],
         match$3 =
           type_ignored_format_substituti(sub_fmtty_rest$7, fmt, fmtty_rest$3),
         fmt$4 = match$3[2],
         sub_fmtty_rest$8 = match$3[1];
        return [0, [4, sub_fmtty_rest$8], fmt$4];
       }
       break;
      case 5:
       if(typeof fmtty !== "number" && 5 === fmtty[0]){
        var
         fmtty_rest$4 = fmtty[1],
         sub_fmtty_rest$9 = sub_fmtty[1],
         match$4 =
           type_ignored_format_substituti(sub_fmtty_rest$9, fmt, fmtty_rest$4),
         fmt$5 = match$4[2],
         sub_fmtty_rest$10 = match$4[1];
        return [0, [5, sub_fmtty_rest$10], fmt$5];
       }
       break;
      case 6:
       if(typeof fmtty !== "number" && 6 === fmtty[0]){
        var
         fmtty_rest$5 = fmtty[1],
         sub_fmtty_rest$11 = sub_fmtty[1],
         match$5 =
           type_ignored_format_substituti
            (sub_fmtty_rest$11, fmt, fmtty_rest$5),
         fmt$6 = match$5[2],
         sub_fmtty_rest$12 = match$5[1];
        return [0, [6, sub_fmtty_rest$12], fmt$6];
       }
       break;
      case 7:
       if(typeof fmtty !== "number" && 7 === fmtty[0]){
        var
         fmtty_rest$6 = fmtty[1],
         sub_fmtty_rest$13 = sub_fmtty[1],
         match$6 =
           type_ignored_format_substituti
            (sub_fmtty_rest$13, fmt, fmtty_rest$6),
         fmt$7 = match$6[2],
         sub_fmtty_rest$14 = match$6[1];
        return [0, [7, sub_fmtty_rest$14], fmt$7];
       }
       break;
      case 8:
       if(typeof fmtty !== "number" && 8 === fmtty[0]){
        var
         fmtty_rest$7 = fmtty[2],
         sub2_fmtty = fmtty[1],
         sub_fmtty_rest$15 = sub_fmtty[2],
         sub2_fmtty$0 = sub_fmtty[1];
        if(caml_notequal([0, sub2_fmtty$0], [0, sub2_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$7 =
           type_ignored_format_substituti
            (sub_fmtty_rest$15, fmt, fmtty_rest$7),
         fmt$8 = match$7[2],
         sub_fmtty_rest$16 = match$7[1];
        return [0, [8, sub2_fmtty, sub_fmtty_rest$16], fmt$8];
       }
       break;
      case 9:
       if(typeof fmtty !== "number" && 9 === fmtty[0]){
        var
         fmtty_rest$8 = fmtty[3],
         sub2_fmtty$1 = fmtty[2],
         sub1_fmtty = fmtty[1],
         sub_fmtty_rest$17 = sub_fmtty[3],
         sub2_fmtty$2 = sub_fmtty[2],
         sub1_fmtty$0 = sub_fmtty[1],
         _cw_ = [0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty$0)], _cw_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var _cx_ = [0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$2)], _cx_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         sub_fmtty$0 = trans(symm(sub1_fmtty), sub2_fmtty$1),
         match$8 = fmtty_rel_det(sub_fmtty$0),
         f4 = match$8[4],
         f2 = match$8[2];
        f2(0);
        f4(0);
        var
         match$9 =
           type_ignored_format_substituti
            (caml_call1(CamlinternalFormatBasics[2], sub_fmtty_rest$17),
             fmt,
             fmtty_rest$8),
         fmt$9 = match$9[2],
         sub_fmtty_rest$18 = match$9[1];
        return [0,
                [9, sub1_fmtty, sub2_fmtty$1, symm(sub_fmtty_rest$18)],
                fmt$9];
       }
       break;
      case 10:
       if(typeof fmtty !== "number" && 10 === fmtty[0]){
        var
         fmtty_rest$9 = fmtty[1],
         sub_fmtty_rest$19 = sub_fmtty[1],
         match$10 =
           type_ignored_format_substituti
            (sub_fmtty_rest$19, fmt, fmtty_rest$9),
         fmt$10 = match$10[2],
         sub_fmtty_rest$20 = match$10[1];
        return [0, [10, sub_fmtty_rest$20], fmt$10];
       }
       break;
      case 11:
       if(typeof fmtty !== "number" && 11 === fmtty[0]){
        var
         fmtty_rest$10 = fmtty[1],
         sub_fmtty_rest$21 = sub_fmtty[1],
         match$11 =
           type_ignored_format_substituti
            (sub_fmtty_rest$21, fmt, fmtty_rest$10),
         fmt$11 = match$11[2],
         sub_fmtty_rest$22 = match$11[1];
        return [0, [11, sub_fmtty_rest$22], fmt$11];
       }
       break;
      case 13:
       if(typeof fmtty !== "number" && 13 === fmtty[0]){
        var
         fmtty_rest$11 = fmtty[1],
         sub_fmtty_rest$23 = sub_fmtty[1],
         match$12 =
           type_ignored_format_substituti
            (sub_fmtty_rest$23, fmt, fmtty_rest$11),
         fmt$12 = match$12[2],
         sub_fmtty_rest$24 = match$12[1];
        return [0, [13, sub_fmtty_rest$24], fmt$12];
       }
       break;
      case 14:
       if(typeof fmtty !== "number" && 14 === fmtty[0]){
        var
         fmtty_rest$12 = fmtty[1],
         sub_fmtty_rest$25 = sub_fmtty[1],
         match$13 =
           type_ignored_format_substituti
            (sub_fmtty_rest$25, fmt, fmtty_rest$12),
         fmt$13 = match$13[2],
         sub_fmtty_rest$26 = match$13[1];
        return [0, [14, sub_fmtty_rest$26], fmt$13];
       }
       break;
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function recast(fmt, fmtty){
    var _cv_ = symm(fmtty);
    return type_format(fmt, caml_call1(CamlinternalFormatBasics[2], _cv_));
   }
   function fix_padding(padty, width, str){
    var
     len = caml_ml_string_length(str),
     padty$0 = 0 <= width ? padty : 0,
     width$0 = caml_call1(Stdlib[18], width);
    if(width$0 <= len) return str;
    var
     _cu_ = 2 === padty$0 ? 48 : 32,
     res = caml_call2(Stdlib_Bytes[1], width$0, _cu_);
    switch(padty$0){
      case 0:
       caml_call5(Stdlib_String[48], str, 0, res, 0, len); break;
      case 1:
       caml_call5(Stdlib_String[48], str, 0, res, width$0 - len | 0, len);
       break;
      default:
       a:
       if(0 < len){
        if
         (43 !== caml_string_get(str, 0)
          && 45 !== caml_string_get(str, 0) && 32 !== caml_string_get(str, 0))
         break a;
        caml_bytes_set(res, 0, caml_string_get(str, 0));
        caml_call5
         (Stdlib_String[48],
          str,
          1,
          res,
          (width$0 - len | 0) + 1 | 0,
          len - 1 | 0);
        break;
       }
       a:
       if(1 < len && 48 === caml_string_get(str, 0)){
        if(120 !== caml_string_get(str, 1) && 88 !== caml_string_get(str, 1))
         break a;
        caml_bytes_set(res, 1, caml_string_get(str, 1));
        caml_call5
         (Stdlib_String[48],
          str,
          2,
          res,
          (width$0 - len | 0) + 2 | 0,
          len - 2 | 0);
        break;
       }
       caml_call5(Stdlib_String[48], str, 0, res, width$0 - len | 0, len);
    }
    return caml_call1(Stdlib_Bytes[48], res);
   }
   function fix_int_precision(prec, str){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     len = caml_ml_string_length(str),
     c = caml_string_get(str, 0);
    a:
    {
     b:
     {
      if(58 > c){
       if(32 !== c){
        if(43 > c) break a;
        switch(c - 43 | 0){
          case 5:
           c:
           if(len < (prec$0 + 2 | 0) && 1 < len){
            if
             (120 !== caml_string_get(str, 1)
              && 88 !== caml_string_get(str, 1))
             break c;
            var res$1 = caml_call2(Stdlib_Bytes[1], prec$0 + 2 | 0, 48);
            caml_bytes_set(res$1, 1, caml_string_get(str, 1));
            caml_call5
             (Stdlib_String[48],
              str,
              2,
              res$1,
              (prec$0 - len | 0) + 4 | 0,
              len - 2 | 0);
            return caml_call1(Stdlib_Bytes[48], res$1);
           }
           break b;
          case 0:
          case 2: break;
          case 1:
          case 3:
          case 4:
           break a;
          default: break b;
        }
       }
       if(len >= (prec$0 + 1 | 0)) break a;
       var res$0 = caml_call2(Stdlib_Bytes[1], prec$0 + 1 | 0, 48);
       caml_bytes_set(res$0, 0, c);
       caml_call5
        (Stdlib_String[48],
         str,
         1,
         res$0,
         (prec$0 - len | 0) + 2 | 0,
         len - 1 | 0);
       return caml_call1(Stdlib_Bytes[48], res$0);
      }
      if(71 <= c){if(5 < c - 97 >>> 0) break a;} else if(65 > c) break a;
     }
     if(len < prec$0){
      var res = caml_call2(Stdlib_Bytes[1], prec$0, 48);
      caml_call5(Stdlib_String[48], str, 0, res, prec$0 - len | 0, len);
      return caml_call1(Stdlib_Bytes[48], res);
     }
    }
    return str;
   }
   function string_to_caml_string(str){
    var
     str$0 = caml_call1(Stdlib_String[24], str),
     l = caml_ml_string_length(str$0),
     res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 34);
    caml_blit_string(str$0, 0, res, 1, l);
    return caml_call1(Stdlib_Bytes[48], res);
   }
   function format_of_fconv(fconv, prec){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     symb = char_of_fconv(_r_, fconv),
     buf = buffer_create(16);
    buffer_add_char(buf, 37);
    bprint_fconv_flag(buf, fconv);
    buffer_add_char(buf, 46);
    buffer_add_string(buf, caml_call1(Stdlib_Int[12], prec$0));
    buffer_add_char(buf, symb);
    return buffer_contents(buf);
   }
   function transform_int_alt(iconv, s){
    if(13 > iconv) return s;
    var n = [0, 0], _cp_ = caml_ml_string_length(s) - 1 | 0, _co_ = 0;
    if(_cp_ >= 0){
     var i$0 = _co_;
     for(;;){
      if(9 >= caml_string_unsafe_get(s, i$0) - 48 >>> 0) n[1]++;
      var _ct_ = i$0 + 1 | 0;
      if(_cp_ === i$0) break;
      i$0 = _ct_;
     }
    }
    var
     digits = n[1],
     buf =
       caml_create_bytes
        (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
     pos = [0, 0];
    function put(c){caml_bytes_set(buf, pos[1], c); pos[1]++; return;}
    var
     left = [0, ((digits - 1 | 0) % 3 | 0) + 1 | 0],
     _cr_ = caml_ml_string_length(s) - 1 | 0,
     _cq_ = 0;
    if(_cr_ >= 0){
     var i = _cq_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      if(9 < c - 48 >>> 0)
       put(c);
      else{if(0 === left[1]){put(95); left[1] = 3;} left[1]--; put(c);}
      var _cs_ = i + 1 | 0;
      if(_cr_ === i) break;
      i = _cs_;
     }
    }
    return caml_call1(Stdlib_Bytes[48], buf);
   }
   function convert_int(iconv, n){
    switch(iconv){
      case 1:
       var _cn_ = cst_d$0; break;
      case 2:
       var _cn_ = cst_d$1; break;
      case 4:
       var _cn_ = cst_i$1; break;
      case 5:
       var _cn_ = cst_i$2; break;
      case 6:
       var _cn_ = cst_x; break;
      case 7:
       var _cn_ = cst_x$0; break;
      case 8:
       var _cn_ = cst_X; break;
      case 9:
       var _cn_ = cst_X$0; break;
      case 10:
       var _cn_ = cst_o; break;
      case 11:
       var _cn_ = cst_o$0; break;
      case 0:
      case 13:
       var _cn_ = cst_d; break;
      case 3:
      case 14:
       var _cn_ = cst_i$0; break;
      default: var _cn_ = cst_u;
    }
    return transform_int_alt(iconv, caml_format_int(_cn_, n));
   }
   function convert_int32(iconv, n){
    switch(iconv){
      case 1:
       var _cm_ = cst_ld$0; break;
      case 2:
       var _cm_ = cst_ld$1; break;
      case 4:
       var _cm_ = cst_li$1; break;
      case 5:
       var _cm_ = cst_li$2; break;
      case 6:
       var _cm_ = cst_lx; break;
      case 7:
       var _cm_ = cst_lx$0; break;
      case 8:
       var _cm_ = cst_lX; break;
      case 9:
       var _cm_ = cst_lX$0; break;
      case 10:
       var _cm_ = cst_lo; break;
      case 11:
       var _cm_ = cst_lo$0; break;
      case 0:
      case 13:
       var _cm_ = cst_ld; break;
      case 3:
      case 14:
       var _cm_ = cst_li$0; break;
      default: var _cm_ = cst_lu;
    }
    return transform_int_alt(iconv, caml_format_int(_cm_, n));
   }
   function convert_nativeint(iconv, n){
    switch(iconv){
      case 1:
       var _cl_ = cst_nd$0; break;
      case 2:
       var _cl_ = cst_nd$1; break;
      case 4:
       var _cl_ = cst_ni$1; break;
      case 5:
       var _cl_ = cst_ni$2; break;
      case 6:
       var _cl_ = cst_nx; break;
      case 7:
       var _cl_ = cst_nx$0; break;
      case 8:
       var _cl_ = cst_nX; break;
      case 9:
       var _cl_ = cst_nX$0; break;
      case 10:
       var _cl_ = cst_no; break;
      case 11:
       var _cl_ = cst_no$0; break;
      case 0:
      case 13:
       var _cl_ = cst_nd; break;
      case 3:
      case 14:
       var _cl_ = cst_ni$0; break;
      default: var _cl_ = cst_nu;
    }
    return transform_int_alt(iconv, caml_format_int(_cl_, n));
   }
   function convert_int64(iconv, n){
    switch(iconv){
      case 1:
       var _ck_ = cst_Ld$0; break;
      case 2:
       var _ck_ = cst_Ld$1; break;
      case 4:
       var _ck_ = cst_Li$1; break;
      case 5:
       var _ck_ = cst_Li$2; break;
      case 6:
       var _ck_ = cst_Lx; break;
      case 7:
       var _ck_ = cst_Lx$0; break;
      case 8:
       var _ck_ = cst_LX; break;
      case 9:
       var _ck_ = cst_LX$0; break;
      case 10:
       var _ck_ = cst_Lo; break;
      case 11:
       var _ck_ = cst_Lo$0; break;
      case 0:
      case 13:
       var _ck_ = cst_Ld; break;
      case 3:
      case 14:
       var _ck_ = cst_Li$0; break;
      default: var _ck_ = cst_Lu;
    }
    return transform_int_alt(iconv, runtime.caml_int64_format(_ck_, n));
   }
   function convert_float(fconv, prec, x){
    function hex(param){
     switch(fconv[1]){
       case 0:
        var sign = 45; break;
       case 1:
        var sign = 43; break;
       default: var sign = 32;
     }
     return runtime.caml_hexstring_of_float(x, prec, sign);
    }
    function caml_special_val(str){
     var match = runtime.caml_classify_float(x);
     return 3 === match
             ? x < 0. ? cst_neg_infinity : cst_infinity
             : 4 <= match ? cst_nan : str;
    }
    switch(fconv[2]){
      case 5:
       var
        str = caml_format_float(format_of_fconv(fconv, prec), x),
        len = caml_ml_string_length(str),
        i = 0;
       for(;;){
        if(i === len)
         var _ch_ = 0;
        else{
         var _cg_ = caml_string_get(str, i) - 46 | 0;
         a:
         {
          if(23 < _cg_ >>> 0){
           if(55 === _cg_) break a;
          }
          else if(21 < _cg_ - 1 >>> 0) break a;
          var i$0 = i + 1 | 0;
          i = i$0;
          continue;
         }
         var _ch_ = 1;
        }
        var _ci_ = _ch_ ? str : caml_call2(Stdlib[28], str, cst$17);
        return caml_special_val(_ci_);
       }
      case 6:
       return hex(0);
      case 7:
       var _cj_ = hex(0); return caml_call1(Stdlib_String[25], _cj_);
      case 8:
       return caml_special_val(hex(0));
      default: return caml_format_float(format_of_fconv(fconv, prec), x);
    }
   }
   function string_of_fmtty(fmtty){
    var buf = buffer_create(16);
    bprint_fmtty(buf, fmtty);
    return buffer_contents(buf);
   }
   function make_printf$0(counter, k, acc, fmt){
    var k$0 = k, acc$0 = acc, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, acc$0);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest);};
       case 1:
        var rest$0 = fmt$0[1];
        return function(c){
         var
          str = caml_call1(Stdlib_Char[2], c),
          l = caml_ml_string_length(str),
          res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 39);
         caml_blit_string(str, 0, res, 1, l);
         var new_acc = [4, acc$0, caml_call1(Stdlib_Bytes[48], res)];
         return make_printf(k$0, new_acc, rest$0);};
       case 2:
        var rest$1 = fmt$0[2], pad = fmt$0[1];
        return make_padding
                (k$0, acc$0, rest$1, pad, function(str){return str;});
       case 3:
        var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$2, pad$0, string_to_caml_string);
       case 4:
        var
         rest$3 = fmt$0[4],
         prec = fmt$0[3],
         pad$1 = fmt$0[2],
         iconv = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$3, pad$1, prec, convert_int, iconv);
       case 5:
        var
         rest$4 = fmt$0[4],
         prec$0 = fmt$0[3],
         pad$2 = fmt$0[2],
         iconv$0 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$4, pad$2, prec$0, convert_int32, iconv$0);
       case 6:
        var
         rest$5 = fmt$0[4],
         prec$1 = fmt$0[3],
         pad$3 = fmt$0[2],
         iconv$1 = fmt$0[1];
        return make_int_padding_precision
                (k$0,
                 acc$0,
                 rest$5,
                 pad$3,
                 prec$1,
                 convert_nativeint,
                 iconv$1);
       case 7:
        var
         rest$6 = fmt$0[4],
         prec$2 = fmt$0[3],
         pad$4 = fmt$0[2],
         iconv$2 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$6, pad$4, prec$2, convert_int64, iconv$2);
       case 8:
        var
         rest$7 = fmt$0[4],
         prec$3 = fmt$0[3],
         pad$5 = fmt$0[2],
         fconv = fmt$0[1];
        if(typeof pad$5 === "number"){
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = convert_float(fconv, p, x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   };
         var p = prec$3[1];
         return function(x){
          var str = convert_float(fconv, p, x);
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        if(0 === pad$5[0]){
         var w = pad$5[2], padty = pad$5[1];
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = fix_padding(padty, w, convert_float(fconv, p, x));
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x),
                     str$0 = fix_padding(padty, w, str);
                    return make_printf(k$0, [4, acc$0, str$0], rest$7);
                   };
         var p$0 = prec$3[1];
         return function(x){
          var str = fix_padding(padty, w, convert_float(fconv, p$0, x));
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        var padty$0 = pad$5[1];
        if(typeof prec$3 === "number")
         return prec$3
                 ? function
                  (w, p, x){
                   var
                    str = fix_padding(padty$0, w, convert_float(fconv, p, x));
                   return make_printf(k$0, [4, acc$0, str], rest$7);
                  }
                 : function
                  (w, x){
                   var
                    str =
                      convert_float(fconv, default_float_precision(fconv), x),
                    str$0 = fix_padding(padty$0, w, str);
                   return make_printf(k$0, [4, acc$0, str$0], rest$7);
                  };
        var p$1 = prec$3[1];
        return function(w, x){
         var str = fix_padding(padty$0, w, convert_float(fconv, p$1, x));
         return make_printf(k$0, [4, acc$0, str], rest$7);};
       case 9:
        var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$8, pad$6, Stdlib[30]);
       case 10:
        var rest$9 = fmt$0[1], acc$1 = [7, acc$0];
        acc$0 = acc$1;
        fmt$0 = rest$9;
        break;
       case 11:
        var rest$10 = fmt$0[2], str = fmt$0[1], acc$2 = [2, acc$0, str];
        acc$0 = acc$2;
        fmt$0 = rest$10;
        break;
       case 12:
        var rest$11 = fmt$0[2], chr = fmt$0[1], acc$3 = [3, acc$0, chr];
        acc$0 = acc$3;
        fmt$0 = rest$11;
        break;
       case 13:
        var
         rest$12 = fmt$0[3],
         sub_fmtty = fmt$0[2],
         ty = string_of_fmtty(sub_fmtty);
        return function(str){
         return make_printf(k$0, [4, acc$0, ty], rest$12);};
       case 14:
        var rest$13 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _cf_ = recast(fmt, fmtty);
         return make_printf
                 (k$0,
                  acc$0,
                  caml_call2(CamlinternalFormatBasics[3], _cf_, rest$13));};
       case 15:
        var rest$14 = fmt$0[1];
        return function(f, x){
         return make_printf
                 (k$0,
                  [6, acc$0, function(o){return caml_call2(f, o, x);}],
                  rest$14);};
       case 16:
        var rest$15 = fmt$0[1];
        return function(f){return make_printf(k$0, [6, acc$0, f], rest$15);};
       case 17:
        var
         rest$16 = fmt$0[2],
         fmting_lit = fmt$0[1],
         acc$4 = [0, acc$0, fmting_lit];
        acc$0 = acc$4;
        fmt$0 = rest$16;
        break;
       case 18:
        var _cd_ = fmt$0[1];
        if(0 === _cd_[0]){
         var rest$17 = fmt$0[2], fmt$1 = _cd_[1][1];
         let acc = acc$0, k = k$0, rest = rest$17;
         var
          k$1 =
            function(kacc){return make_printf(k, [1, acc, [0, kacc]], rest);};
         k$0 = k$1;
         acc$0 = 0;
         fmt$0 = fmt$1;
        }
        else{
         var rest$18 = fmt$0[2], fmt$2 = _cd_[1][1];
         let acc = acc$0, k = k$0, rest = rest$18;
         var
          k$2 =
            function(kacc){return make_printf(k, [1, acc, [1, kacc]], rest);};
         k$0 = k$2;
         acc$0 = 0;
         fmt$0 = fmt$2;
        }
        break;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
       case 20:
        var
         rest$19 = fmt$0[3],
         new_acc = [8, acc$0, cst_Printf_bad_conversion];
        return function(param){return make_printf(k$0, new_acc, rest$19);};
       case 21:
        var rest$20 = fmt$0[2];
        return function(n){
         var new_acc = [4, acc$0, caml_format_int(cst_u$0, n)];
         return make_printf(k$0, new_acc, rest$20);};
       case 22:
        var rest$21 = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest$21);};
       case 23:
        var rest$22 = fmt$0[2], ign = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (make_ignored_param$0, [0, k$0, acc$0, ign, rest$22]);
        var counter$1 = counter + 1 | 0;
        return make_ignored_param$0(counter$1, k$0, acc$0, ign, rest$22);
       default:
        var
         rest$23 = fmt$0[3],
         f = fmt$0[2],
         arity = fmt$0[1],
         _ce_ = caml_call1(f, 0);
        if(counter >= 50)
         return caml_trampoline_return
                 (make_custom$0, [0, k$0, acc$0, rest$23, arity, _ce_]);
        var counter$0 = counter + 1 | 0;
        return make_custom$0(counter$0, k$0, acc$0, rest$23, arity, _ce_);
     }
    }
   }
   function make_printf(k, acc, fmt){
    return caml_trampoline(make_printf$0(0, k, acc, fmt));
   }
   function make_ignored_param$0(counter, k, acc, ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$0 = counter + 1 | 0;
        return make_invalid_arg(counter$0, k, acc, fmt);
       case 1:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$1 = counter + 1 | 0;
        return make_invalid_arg(counter$1, k, acc, fmt);
       case 2:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
       default:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$2 = counter + 1 | 0;
        return make_invalid_arg(counter$2, k, acc, fmt);
     }
    switch(ign[0]){
      case 0:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$3 = counter + 1 | 0;
       return make_invalid_arg(counter$3, k, acc, fmt);
      case 1:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$4 = counter + 1 | 0;
       return make_invalid_arg(counter$4, k, acc, fmt);
      case 2:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$5 = counter + 1 | 0;
       return make_invalid_arg(counter$5, k, acc, fmt);
      case 3:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$6 = counter + 1 | 0;
       return make_invalid_arg(counter$6, k, acc, fmt);
      case 4:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$7 = counter + 1 | 0;
       return make_invalid_arg(counter$7, k, acc, fmt);
      case 5:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$8 = counter + 1 | 0;
       return make_invalid_arg(counter$8, k, acc, fmt);
      case 6:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$9 = counter + 1 | 0;
       return make_invalid_arg(counter$9, k, acc, fmt);
      case 7:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$10 = counter + 1 | 0;
       return make_invalid_arg(counter$10, k, acc, fmt);
      case 8:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$11 = counter + 1 | 0;
       return make_invalid_arg(counter$11, k, acc, fmt);
      case 9:
       var fmtty = ign[2];
       if(counter >= 50)
        return caml_trampoline_return
                (make_from_fmtty$0, [0, k, acc, fmtty, fmt]);
       var counter$14 = counter + 1 | 0;
       return make_from_fmtty$0(counter$14, k, acc, fmtty, fmt);
      case 10:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$12 = counter + 1 | 0;
       return make_invalid_arg(counter$12, k, acc, fmt);
      default:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$13 = counter + 1 | 0;
       return make_invalid_arg(counter$13, k, acc, fmt);
    }
   }
   function make_ignored_param(k, acc, ign, fmt){
    return caml_trampoline(make_ignored_param$0(0, k, acc, ign, fmt));
   }
   function make_from_fmtty$0(counter, k, acc, fmtty, fmt){
    if(typeof fmtty !== "number")
     switch(fmtty[0]){
       case 0:
        var rest = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest, fmt);};
       case 1:
        var rest$0 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$0, fmt);};
       case 2:
        var rest$1 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$1, fmt);};
       case 3:
        var rest$2 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$2, fmt);};
       case 4:
        var rest$3 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$3, fmt);};
       case 5:
        var rest$4 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$4, fmt);};
       case 6:
        var rest$5 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$5, fmt);};
       case 7:
        var rest$6 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$6, fmt);};
       case 8:
        var rest$7 = fmtty[2];
        return function(param){return make_from_fmtty(k, acc, rest$7, fmt);};
       case 9:
        var
         rest$8 = fmtty[3],
         ty2 = fmtty[2],
         ty1 = fmtty[1],
         ty = trans(symm(ty1), ty2);
        return function(param){
         return make_from_fmtty
                 (k,
                  acc,
                  caml_call2(CamlinternalFormatBasics[1], ty, rest$8),
                  fmt);};
       case 10:
        var rest$9 = fmtty[1];
        return function(param, _cc_){
         return make_from_fmtty(k, acc, rest$9, fmt);};
       case 11:
        var rest$10 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$10, fmt);};
       case 12:
        var rest$11 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$11, fmt);};
       case 13:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
     }
    if(counter >= 50)
     return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_invalid_arg(counter$0, k, acc, fmt);
   }
   function make_from_fmtty(k, acc, fmtty, fmt){
    return caml_trampoline(make_from_fmtty$0(0, k, acc, fmtty, fmt));
   }
   function make_invalid_arg(counter, k, acc, fmt){
    var _cb_ = [8, acc, cst_Printf_bad_conversion$0];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _cb_, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _cb_, fmt);
   }
   function make_padding(k, acc, fmt, pad, trans){
    if(typeof pad === "number")
     return function(x){
      var new_acc = [4, acc, caml_call1(trans, x)];
      return make_printf(k, new_acc, fmt);};
    if(0 === pad[0]){
     var width = pad[2], padty = pad[1];
     return function(x){
      var new_acc = [4, acc, fix_padding(padty, width, caml_call1(trans, x))];
      return make_printf(k, new_acc, fmt);};
    }
    var padty$0 = pad[1];
    return function(w, x){
     var new_acc = [4, acc, fix_padding(padty$0, w, caml_call1(trans, x))];
     return make_printf(k, new_acc, fmt);};
   }
   function make_int_padding_precision(k, acc, fmt, pad, prec, trans, iconv){
    if(typeof pad === "number"){
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var str = fix_int_precision(p, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = caml_call2(trans, iconv, x);
                return make_printf(k, [4, acc, str], fmt);
               };
     var p = prec[1];
     return function(x){
      var str = fix_int_precision(p, caml_call2(trans, iconv, x));
      return make_printf(k, [4, acc, str], fmt);};
    }
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var
                 str =
                   fix_padding
                    (padty,
                     w,
                     fix_int_precision(p, caml_call2(trans, iconv, x)));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = fix_padding(padty, w, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               };
     var p$0 = prec[1];
     return function(x){
      var
       str =
         fix_padding
          (padty, w, fix_int_precision(p$0, caml_call2(trans, iconv, x)));
      return make_printf(k, [4, acc, str], fmt);};
    }
    var padty$0 = pad[1];
    if(typeof prec === "number")
     return prec
             ? function
              (w, p, x){
               var
                str =
                  fix_padding
                   (padty$0,
                    w,
                    fix_int_precision(p, caml_call2(trans, iconv, x)));
               return make_printf(k, [4, acc, str], fmt);
              }
             : function
              (w, x){
               var str = fix_padding(padty$0, w, caml_call2(trans, iconv, x));
               return make_printf(k, [4, acc, str], fmt);
              };
    var p$1 = prec[1];
    return function(w, x){
     var
      str =
        fix_padding
         (padty$0, w, fix_int_precision(p$1, caml_call2(trans, iconv, x)));
     return make_printf(k, [4, acc, str], fmt);};
   }
   function make_custom$0(counter, k, acc, rest, arity, f){
    if(arity){
     var arity$0 = arity[1];
     return function(x){
      return make_custom(k, acc, rest, arity$0, caml_call1(f, x));};
    }
    var _ca_ = [4, acc, f];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _ca_, rest]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _ca_, rest);
   }
   function make_custom(k, acc, rest, arity, f){
    return caml_trampoline(make_custom$0(0, k, acc, rest, arity, f));
   }
   function make_iprintf$0(counter, k, o, fmt){
    var k$0 = k, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, o);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1], x = make_iprintf(k$0, o, rest);
        return function(_b$_){return x;};
       case 1:
        var rest$0 = fmt$0[1], x$0 = make_iprintf(k$0, o, rest$0);
        return function(_b__){return x$0;};
       case 2:
        var _bM_ = fmt$0[1];
        if(typeof _bM_ === "number"){
         var rest$1 = fmt$0[2], x$1 = make_iprintf(k$0, o, rest$1);
         return function(_b9_){return x$1;};
        }
        if(0 === _bM_[0]){
         var rest$2 = fmt$0[2], x$2 = make_iprintf(k$0, o, rest$2);
         return function(_b8_){return x$2;};
        }
        var
         rest$3 = fmt$0[2],
         x$3 = make_iprintf(k$0, o, rest$3),
         x$4 = function(_b7_){return x$3;};
        return function(_b6_){return x$4;};
       case 3:
        var _bN_ = fmt$0[1];
        if(typeof _bN_ === "number"){
         var rest$4 = fmt$0[2], x$5 = make_iprintf(k$0, o, rest$4);
         return function(_b5_){return x$5;};
        }
        if(0 === _bN_[0]){
         var rest$5 = fmt$0[2], x$6 = make_iprintf(k$0, o, rest$5);
         return function(_b4_){return x$6;};
        }
        var
         rest$6 = fmt$0[2],
         x$7 = make_iprintf(k$0, o, rest$6),
         x$8 = function(_b3_){return x$7;};
        return function(_b2_){return x$8;};
       case 4:
        var rest$7 = fmt$0[4], prec = fmt$0[3], pad = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$7, pad, prec);
       case 5:
        var rest$8 = fmt$0[4], prec$0 = fmt$0[3], pad$0 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$8, pad$0, prec$0);
       case 6:
        var rest$9 = fmt$0[4], prec$1 = fmt$0[3], pad$1 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$9, pad$1, prec$1);
       case 7:
        var rest$10 = fmt$0[4], prec$2 = fmt$0[3], pad$2 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$10, pad$2, prec$2);
       case 8:
        var rest$11 = fmt$0[4], prec$3 = fmt$0[3], pad$3 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$11, pad$3, prec$3);
       case 9:
        var _bO_ = fmt$0[1];
        if(typeof _bO_ === "number"){
         var rest$12 = fmt$0[2], x$9 = make_iprintf(k$0, o, rest$12);
         return function(_b1_){return x$9;};
        }
        if(0 === _bO_[0]){
         var rest$13 = fmt$0[2], x$10 = make_iprintf(k$0, o, rest$13);
         return function(_b0_){return x$10;};
        }
        var
         rest$14 = fmt$0[2],
         x$11 = make_iprintf(k$0, o, rest$14),
         x$12 = function(_bZ_){return x$11;};
        return function(_bY_){return x$12;};
       case 10:
        var rest$15 = fmt$0[1]; fmt$0 = rest$15; break;
       case 11:
        var rest$16 = fmt$0[2]; fmt$0 = rest$16; break;
       case 12:
        var rest$17 = fmt$0[2]; fmt$0 = rest$17; break;
       case 13:
        var rest$18 = fmt$0[3], x$13 = make_iprintf(k$0, o, rest$18);
        return function(_bX_){return x$13;};
       case 14:
        var rest$19 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _bW_ = recast(fmt, fmtty);
         return make_iprintf
                 (k$0,
                  o,
                  caml_call2(CamlinternalFormatBasics[3], _bW_, rest$19));};
       case 15:
        var
         rest$20 = fmt$0[1],
         x$14 = make_iprintf(k$0, o, rest$20),
         x$15 = function(_bV_){return x$14;};
        return function(_bU_){return x$15;};
       case 16:
        var rest$21 = fmt$0[1], x$16 = make_iprintf(k$0, o, rest$21);
        return function(_bT_){return x$16;};
       case 17:
        var rest$22 = fmt$0[2]; fmt$0 = rest$22; break;
       case 18:
        var _bP_ = fmt$0[1];
        if(0 === _bP_[0]){
         var rest$23 = fmt$0[2], fmt$1 = _bP_[1][1];
         let k = k$0, rest = rest$23;
         var k$1 = function(koc){return make_iprintf(k, koc, rest);};
         k$0 = k$1;
         fmt$0 = fmt$1;
        }
        else{
         var rest$24 = fmt$0[2], fmt$2 = _bP_[1][1];
         let k = k$0, rest = rest$24;
         var k$2 = function(koc){return make_iprintf(k, koc, rest);};
         k$0 = k$2;
         fmt$0 = fmt$2;
        }
        break;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
       case 20:
        var rest$25 = fmt$0[3], x$17 = make_iprintf(k$0, o, rest$25);
        return function(_bS_){return x$17;};
       case 21:
        var rest$26 = fmt$0[2], x$18 = make_iprintf(k$0, o, rest$26);
        return function(_bR_){return x$18;};
       case 22:
        var rest$27 = fmt$0[1], x$19 = make_iprintf(k$0, o, rest$27);
        return function(_bQ_){return x$19;};
       case 23:
        var rest$28 = fmt$0[2], ign = fmt$0[1];
        return make_ignored_param
                (function(param){return caml_call1(k$0, o);}, 0, ign, rest$28);
       default:
        var rest$29 = fmt$0[3], arity = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (fn_of_custom_arity$0, [0, k$0, o, rest$29, arity]);
        var counter$0 = counter + 1 | 0;
        return fn_of_custom_arity$0(counter$0, k$0, o, rest$29, arity);
     }
    }
   }
   function make_iprintf(k, o, fmt){
    return caml_trampoline(make_iprintf$0(0, k, o, fmt));
   }
   function fn_of_padding_precision(k, o, fmt, pad, prec){
    if(typeof pad === "number"){
     if(typeof prec !== "number"){
      var x$2 = make_iprintf(k, o, fmt);
      return function(_bL_){return x$2;};
     }
     if(prec){
      var x = make_iprintf(k, o, fmt), x$0 = function(_bK_){return x;};
      return function(_bJ_){return x$0;};
     }
     var x$1 = make_iprintf(k, o, fmt);
     return function(_bI_){return x$1;};
    }
    if(0 === pad[0]){
     if(typeof prec !== "number"){
      var x$6 = make_iprintf(k, o, fmt);
      return function(_bH_){return x$6;};
     }
     if(prec){
      var x$3 = make_iprintf(k, o, fmt), x$4 = function(_bG_){return x$3;};
      return function(_bF_){return x$4;};
     }
     var x$5 = make_iprintf(k, o, fmt);
     return function(_bE_){return x$5;};
    }
    if(typeof prec !== "number"){
     var x$12 = make_iprintf(k, o, fmt), x$13 = function(_bD_){return x$12;};
     return function(_bC_){return x$13;};
    }
    if(prec){
     var
      x$7 = make_iprintf(k, o, fmt),
      x$8 = function(_bB_){return x$7;},
      x$9 = function(_bA_){return x$8;};
     return function(_bz_){return x$9;};
    }
    var x$10 = make_iprintf(k, o, fmt);
    function x$11(_by_){return x$10;}
    return function(_bx_){return x$11;};
   }
   function fn_of_custom_arity$0(counter, k, o, fmt, param){
    if(param){
     var arity = param[1], x = fn_of_custom_arity(k, o, fmt, arity);
     return function(_bw_){return x;};
    }
    if(counter >= 50)
     return caml_trampoline_return(make_iprintf$0, [0, k, o, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_iprintf$0(counter$0, k, o, fmt);
   }
   function fn_of_custom_arity(k, o, fmt, param){
    return caml_trampoline(fn_of_custom_arity$0(0, k, o, fmt, param));
   }
   function output_acc(o, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        output_acc(o, p);
        return caml_call2(Stdlib[66], o, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         output_acc(o, p$0);
         caml_call2(Stdlib[66], o, cst$18);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         output_acc(o, p$0);
         caml_call2(Stdlib[66], o, cst$19);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        output_acc(o, p$3);
        return caml_call1(f, o);
       case 7:
        var p$4 = acc$0[1];
        output_acc(o, p$4);
        return caml_call1(Stdlib[63], o);
       case 8:
        var msg = acc$0[2], p$5 = acc$0[1];
        output_acc(o, p$5);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        output_acc(o, p$1);
        return caml_call2(Stdlib[66], o, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        output_acc(o, p$2);
        return caml_call2(Stdlib[65], o, c);
     }
    }
   }
   function bufput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        bufput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         bufput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$20);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         bufput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$21);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        bufput_acc(b, p$3);
        return caml_call1(f, b);
       case 7:
        var acc$3 = acc$0[1]; acc$0 = acc$3; break;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        bufput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        bufput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        bufput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function strput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        strput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         strput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$22);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         strput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$23);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        strput_acc(b, p$3);
        var _bv_ = caml_call1(f, 0);
        return caml_call2(Stdlib_Buffer[16], b, _bv_);
       case 7:
        var acc$3 = acc$0[1]; acc$0 = acc$3; break;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        strput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        strput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        strput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function failwith_message(param){
    var fmt = param[1], buf = caml_call1(Stdlib_Buffer[1], 256);
    function k(acc){
     strput_acc(buf, acc);
     var _bu_ = caml_call1(Stdlib_Buffer[2], buf);
     return caml_call1(Stdlib[2], _bu_);
    }
    return make_printf(k, 0, fmt);
   }
   function open_box_of_string(str){
    if(str == cst$43) return _x_;
    var len = caml_ml_string_length(str);
    function invalid_box(param){
     return caml_call1(failwith_message(_y_), str);
    }
    function parse_spaces(i){
     var i$0 = i;
     for(;;){
      if(i$0 === len) return i$0;
      var match = caml_string_get(str, i$0);
      if(9 !== match && 32 !== match) return i$0;
      var i$1 = i$0 + 1 | 0;
      i$0 = i$1;
     }
    }
    var wstart = parse_spaces(0);
    a:
    b:
    {
     var wend = wstart;
     for(;;){
      if(wend === len) break b;
      if(25 < caml_string_get(str, wend) - 97 >>> 0) break;
      var j = wend + 1 | 0;
      wend = j;
     }
     break a;
    }
    var
     box_name = caml_call3(Stdlib_String[15], str, wstart, wend - wstart | 0),
     nstart = parse_spaces(wend);
    a:
    b:
    {
     var nend = nstart;
     for(;;){
      if(nend === len) break b;
      var match = caml_string_get(str, nend);
      if(48 <= match){if(58 <= match) break;} else if(45 !== match) break;
      var j$0 = nend + 1 | 0;
      nend = j$0;
     }
     break a;
    }
    if(nstart === nend)
     var indent = 0;
    else
     try{
      var
       _bs_ =
         runtime.caml_int_of_string
          (caml_call3(Stdlib_String[15], str, nstart, nend - nstart | 0)),
       indent = _bs_;
     }
     catch(_bt_){
      var _br_ = caml_wrap_exception(_bt_);
      if(_br_[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(_br_, 0);
      var indent = invalid_box(0);
     }
    var exp_end = parse_spaces(nend);
    if(exp_end !== len) invalid_box(0);
    a:
    {
     if(box_name !== cst$43 && box_name !== "b"){
      if(box_name === "h"){var box_type = 0; break a;}
      if(box_name === "hov"){var box_type = 3; break a;}
      if(box_name === "hv"){var box_type = 2; break a;}
      if(box_name !== "v"){var box_type = invalid_box(0); break a;}
      var box_type = 1;
      break a;
     }
     var box_type = 4;
    }
    return [0, indent, box_type];
   }
   function make_padding_fmt_ebb(pad, fmt){
    if(typeof pad === "number") return [0, 0, fmt];
    if(0 === pad[0]){var w = pad[2], s = pad[1]; return [0, [0, s, w], fmt];}
    var s$0 = pad[1];
    return [0, [1, s$0], fmt];
   }
   function make_padprec_fmt_ebb(pad, prec, fmt){
    if(typeof prec === "number")
     var match = prec ? [0, 1] : [0, 0];
    else
     var p = prec[1], match = [0, [0, p]];
    var prec$0 = match[1];
    if(typeof pad === "number") return [0, 0, prec$0, fmt];
    if(0 === pad[0]){
     var w = pad[2], s = pad[1];
     return [0, [0, s, w], prec$0, fmt];
    }
    var s$0 = pad[1];
    return [0, [1, s$0], prec$0, fmt];
   }
   function fmt_ebb_of_string(legacy_behavior, str){
    if(legacy_behavior)
     var flag = legacy_behavior[1], legacy_behavior$0 = flag;
    else
     var legacy_behavior$0 = 1;
    function invalid_format_message(str_ind, msg){
     return caml_call3(failwith_message(_z_), str, str_ind, msg);
    }
    function invalid_format_without(str_ind, c, s){
     return caml_call4(failwith_message(_A_), str, str_ind, c, s);
    }
    function expected_character(str_ind, expected, read){
     return caml_call4(failwith_message(_B_), str, str_ind, expected, read);
    }
    function parse(lit_start, end_ind){
     a:
     {
      var str_ind = lit_start;
      for(;;){
       if(str_ind === end_ind) return add_literal(lit_start, str_ind, 0);
       var match = caml_string_get(str, str_ind);
       if(37 === match) break;
       if(64 === match) break a;
       var str_ind$1 = str_ind + 1 | 0;
       str_ind = str_ind$1;
      }
      var str_ind$2 = str_ind + 1 | 0;
      if(str_ind$2 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var
       match$1 =
         95 === caml_string_get(str, str_ind$2)
          ? parse_flags(str_ind, str_ind$2 + 1 | 0, end_ind, 1)
          : parse_flags(str_ind, str_ind$2, end_ind, 0),
       fmt_rest = match$1[1];
      return add_literal(lit_start, str_ind, fmt_rest);
     }
     var str_ind$0 = str_ind + 1 | 0;
     a:
     if(str_ind$0 === end_ind)
      var match$0 = _N_;
     else{
      var c = caml_string_get(str, str_ind$0);
      if(65 <= c){
       if(94 <= c){
        var switcher = c - 123 | 0;
        if(2 >= switcher >>> 0)
         switch(switcher){
           case 0:
            var match$0 = parse_tag(1, str_ind$0 + 1 | 0, end_ind); break a;
           case 1: break;
           default:
            var
             fmt_rest$2 = parse(str_ind$0 + 1 | 0, end_ind)[1],
             match$0 = [0, [17, 1, fmt_rest$2]];
            break a;
         }
       }
       else if(91 <= c)
        switch(c - 91 | 0){
          case 0:
           var match$0 = parse_tag(0, str_ind$0 + 1 | 0, end_ind); break a;
          case 1: break;
          default:
           var
            fmt_rest$3 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 0, fmt_rest$3]];
           break a;
        }
      }
      else{
       if(10 === c){
        var
         fmt_rest$4 = parse(str_ind$0 + 1 | 0, end_ind)[1],
         match$0 = [0, [17, 3, fmt_rest$4]];
        break a;
       }
       if(32 <= c)
        switch(c - 32 | 0){
          case 0:
           var
            fmt_rest$5 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _O_, fmt_rest$5]];
           break a;
          case 5:
           if
            ((str_ind$0 + 1 | 0) < end_ind
             && 37 === caml_string_get(str, str_ind$0 + 1 | 0)){
            var
             fmt_rest$6 = parse(str_ind$0 + 2 | 0, end_ind)[1],
             match$0 = [0, [17, 6, fmt_rest$6]];
            break a;
           }
           var
            fmt_rest$7 = parse(str_ind$0, end_ind)[1],
            match$0 = [0, [12, 64, fmt_rest$7]];
           break a;
          case 12:
           var
            fmt_rest$8 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _P_, fmt_rest$8]];
           break a;
          case 14:
           var
            fmt_rest$9 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 4, fmt_rest$9]];
           break a;
          case 27:
           var str_ind$3 = str_ind$0 + 1 | 0;
           b:
           try{
            var
             _bg_ = str_ind$3 === end_ind ? 1 : 0,
             _bh_ = _bg_ || (60 !== caml_string_get(str, str_ind$3) ? 1 : 0);
            if(_bh_) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            var
             str_ind_1 = parse_spaces(str_ind$3 + 1 | 0, end_ind),
             match$2 = caml_string_get(str, str_ind_1);
            c:
            {
             if(48 <= match$2){
              if(58 > match$2) break c;
             }
             else if(45 === match$2) break c;
             throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            }
            var
             match$3 = parse_integer(str_ind_1, end_ind),
             width = match$3[2],
             str_ind_2 = match$3[1],
             str_ind_3 = parse_spaces(str_ind_2, end_ind),
             switcher$0 = caml_string_get(str, str_ind_3) - 45 | 0;
            if(12 < switcher$0 >>> 0){
             if(17 === switcher$0){
              var
               s =
                 caml_call3
                  (Stdlib_String[15],
                   str,
                   str_ind$3 - 2 | 0,
                   (str_ind_3 - str_ind$3 | 0) + 3 | 0),
               _bi_ = [0, s, width, 0],
               _bj_ = str_ind_3 + 1 | 0,
               formatting_lit$0 = _bi_,
               next_ind = _bj_;
              break b;
             }
            }
            else if(1 < switcher$0 - 1 >>> 0){
             var
              match$4 = parse_integer(str_ind_3, end_ind),
              offset = match$4[2],
              str_ind_4 = match$4[1],
              str_ind_5 = parse_spaces(str_ind_4, end_ind);
             if(62 !== caml_string_get(str, str_ind_5))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$0 =
                caml_call3
                 (Stdlib_String[15],
                  str,
                  str_ind$3 - 2 | 0,
                  (str_ind_5 - str_ind$3 | 0) + 3 | 0),
              _bk_ = [0, s$0, width, offset],
              _bl_ = str_ind_5 + 1 | 0,
              formatting_lit$0 = _bk_,
              next_ind = _bl_;
             break b;
            }
            throw caml_maybe_attach_backtrace(Stdlib[8], 1);
           }
           catch(_bq_){
            var _bf_ = caml_wrap_exception(_bq_);
            if(_bf_ !== Stdlib[8] && _bf_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bf_, 0);
            var formatting_lit$0 = formatting_lit, next_ind = str_ind$3;
           }
           var
            fmt_rest$12 = parse(next_ind, end_ind)[1],
            match$0 = [0, [17, formatting_lit$0, fmt_rest$12]];
           break a;
          case 28:
           var str_ind$4 = str_ind$0 + 1 | 0;
           try{
            var
             str_ind_1$0 = parse_spaces(str_ind$4, end_ind),
             match$6 = caml_string_get(str, str_ind_1$0);
            b:
            {
             c:
             {
              if(48 <= match$6){
               if(58 > match$6) break c;
              }
              else if(45 === match$6) break c;
              var _bo_ = 0;
              break b;
             }
             var
              match$7 = parse_integer(str_ind_1$0, end_ind),
              size = match$7[2],
              str_ind_2$0 = match$7[1],
              str_ind_3$0 = parse_spaces(str_ind_2$0, end_ind);
             if(62 !== caml_string_get(str, str_ind_3$0))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$1 =
                caml_call3
                 (Stdlib_String[15],
                  str,
                  str_ind$4 - 2 | 0,
                  (str_ind_3$0 - str_ind$4 | 0) + 3 | 0),
              _bo_ = [0, [0, str_ind_3$0 + 1 | 0, [1, s$1, size]]];
            }
            var _bn_ = _bo_;
           }
           catch(_bp_){
            var _bm_ = caml_wrap_exception(_bp_);
            if(_bm_ !== Stdlib[8] && _bm_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bm_, 0);
            var _bn_ = 0;
           }
           if(_bn_)
            var
             match$5 = _bn_[1],
             formatting_lit$1 = match$5[2],
             next_ind$0 = match$5[1],
             fmt_rest$13 = parse(next_ind$0, end_ind)[1],
             _be_ = [0, [17, formatting_lit$1, fmt_rest$13]];
           else
            var
             fmt_rest$14 = parse(str_ind$4, end_ind)[1],
             _be_ = [0, [17, _Q_, fmt_rest$14]];
           var match$0 = _be_;
           break a;
          case 31:
           var
            fmt_rest$10 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 2, fmt_rest$10]];
           break a;
          case 32:
           var
            fmt_rest$11 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 5, fmt_rest$11]];
           break a;
        }
      }
      var
       fmt_rest$1 = parse(str_ind$0 + 1 | 0, end_ind)[1],
       match$0 = [0, [17, [2, c], fmt_rest$1]];
     }
     var fmt_rest$0 = match$0[1];
     return add_literal(lit_start, str_ind, fmt_rest$0);
    }
    function parse_flags(pct_ind, str_ind, end_ind, ign){
     var
      zero = [0, 0],
      minus = [0, 0],
      plus = [0, 0],
      space = [0, 0],
      hash = [0, 0];
     function set_flag(str_ind, flag){
      var _bb_ = flag[1], _bc_ = _bb_ ? 1 - legacy_behavior$0 : _bb_;
      if(_bc_){
       var _bd_ = caml_string_get(str, str_ind);
       caml_call3(failwith_message(_C_), str, str_ind, _bd_);
      }
      flag[1] = 1;
      return;
     }
     a:
     b:
     {
      var str_ind$0 = str_ind;
      c:
      for(;;){
       if(str_ind$0 === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       var switcher = caml_string_get(str, str_ind$0) - 32 | 0;
       if(16 < switcher >>> 0) break b;
       switch(switcher){
         case 0:
          set_flag(str_ind$0, space);
          var str_ind$1 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$1;
          break;
         case 3:
          set_flag(str_ind$0, hash);
          var str_ind$2 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$2;
          break;
         case 11:
          set_flag(str_ind$0, plus);
          var str_ind$3 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$3;
          break;
         case 13:
          set_flag(str_ind$0, minus);
          var str_ind$4 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$4;
          break;
         case 16:
          set_flag(str_ind$0, zero);
          var str_ind$5 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$5;
          break;
         default: break c;
       }
      }
      break a;
     }
     var
      space$0 = space[1],
      hash$0 = hash[1],
      plus$0 = plus[1],
      minus$0 = minus[1],
      zero$0 = zero[1];
     if(str_ind$0 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var
      padty =
        zero$0
         ? minus$0
           ? legacy_behavior$0
             ? 0
             : incompatible_flag(pct_ind, str_ind$0, 45, cst_0)
           : 2
         : minus$0 ? 0 : 1,
      match = caml_string_get(str, str_ind$0);
     if(48 <= match){
      if(58 > match){
       var
        match$0 = parse_positive(str_ind$0, end_ind, 0),
        width = match$0[2],
        new_ind = match$0[1];
       return parse_after_padding
               (pct_ind,
                new_ind,
                end_ind,
                minus$0,
                plus$0,
                hash$0,
                space$0,
                ign,
                [0, padty, width]);
      }
     }
     else if(42 === match)
      return parse_after_padding
              (pct_ind,
               str_ind$0 + 1 | 0,
               end_ind,
               minus$0,
               plus$0,
               hash$0,
               space$0,
               ign,
               [1, padty]);
     switch(padty){
       case 0:
        if(1 - legacy_behavior$0)
         invalid_format_without(str_ind$0 - 1 | 0, 45, cst_padding);
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       case 1:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       default:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 _D_);
     }
    }
    function parse_after_padding
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var symb = caml_string_get(str, str_ind);
     if(46 !== symb)
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               0,
               pad,
               symb);
     var str_ind$0 = str_ind + 1 | 0;
     if(str_ind$0 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     function parse_literal(minus, str_ind){
      var
       match = parse_positive(str_ind, end_ind, 0),
       prec = match[2],
       new_ind = match[1];
      return parse_after_precision
              (pct_ind,
               new_ind,
               end_ind,
               minus,
               plus,
               hash,
               space,
               ign,
               pad,
               [0, prec]);
     }
     var symb$0 = caml_string_get(str, str_ind$0);
     if(48 <= symb$0){
      if(58 > symb$0) return parse_literal(minus, str_ind$0);
     }
     else if(42 <= symb$0)
      switch(symb$0 - 42 | 0){
        case 0:
         return parse_after_precision
                 (pct_ind,
                  str_ind$0 + 1 | 0,
                  end_ind,
                  minus,
                  plus,
                  hash,
                  space,
                  ign,
                  pad,
                  1);
        case 1:
        case 3:
         if(legacy_behavior$0){
          var
           _ba_ = str_ind$0 + 1 | 0,
           minus$0 = minus || (45 === symb$0 ? 1 : 0);
          return parse_literal(minus$0, _ba_);
         }
         break;
      }
     return legacy_behavior$0
             ? parse_after_precision
               (pct_ind,
                str_ind$0,
                end_ind,
                minus,
                plus,
                hash,
                space,
                ign,
                pad,
                _E_)
             : invalid_format_without(str_ind$0 - 1 | 0, 46, cst_precision);
    }
    function parse_after_precision
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     function parse_conv(padprec){
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               prec,
               padprec,
               caml_string_get(str, str_ind));
     }
     if(typeof pad !== "number") return parse_conv(pad);
     if(typeof prec === "number" && ! prec) return parse_conv(0);
     if(minus){
      if(typeof prec === "number") return parse_conv(_F_);
      var n = prec[1];
      return parse_conv([0, 0, n]);
     }
     if(typeof prec === "number") return parse_conv(_G_);
     var n$0 = prec[1];
     return parse_conv([0, 1, n$0]);
    }
    function parse_conversion
    (pct_ind,
     str_ind,
     end_ind,
     plus,
     hash,
     space,
     ign,
     pad,
     prec,
     padprec,
     symb){
     var
      plus_used = [0, 0],
      hash_used = [0, 0],
      space_used = [0, 0],
      ign_used = [0, 0],
      pad_used = [0, 0],
      prec_used = [0, 0];
     function get_plus(param){plus_used[1] = 1; return plus;}
     function get_hash(param){hash_used[1] = 1; return hash;}
     function get_space(param){space_used[1] = 1; return space;}
     function get_ign(param){ign_used[1] = 1; return ign;}
     function get_pad(param){pad_used[1] = 1; return pad;}
     function get_prec(param){prec_used[1] = 1; return prec;}
     function get_padprec(param){pad_used[1] = 1; return padprec;}
     function get_int_pad(param){
      var pad = get_pad(0), match = get_prec(0);
      if(typeof match === "number" && ! match) return pad;
      if(typeof pad === "number") return 0;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _H_
                 : incompatible_flag(pct_ind, str_ind, 48, cst_precision$1)
               : pad;
      if(2 > pad[1]) return pad;
      var n = pad[2];
      return legacy_behavior$0
              ? [0, 1, n]
              : incompatible_flag(pct_ind, str_ind, 48, cst_precision$0);
     }
     function check_no_0(symb, pad){
      if(typeof pad === "number") return pad;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _I_
                 : incompatible_flag(pct_ind, str_ind, symb, cst_0$1)
               : pad;
      if(2 > pad[1]) return pad;
      var width = pad[2];
      return legacy_behavior$0
              ? [0, 1, width]
              : incompatible_flag(pct_ind, str_ind, symb, cst_0$0);
     }
     function opt_of_pad(c, pad){
      if(typeof pad === "number") return 0;
      if(0 === pad[0])
       switch(pad[1]){
         case 0:
          var width = pad[2];
          return legacy_behavior$0
                  ? [0, width]
                  : incompatible_flag(pct_ind, str_ind, c, cst$24);
         case 1:
          var width$0 = pad[2]; return [0, width$0];
         default:
          var width$1 = pad[2];
          return legacy_behavior$0
                  ? [0, width$1]
                  : incompatible_flag(pct_ind, str_ind, c, cst_0$2);
       }
      return incompatible_flag(pct_ind, str_ind, c, cst$25);
     }
     function get_pad_opt(c){return opt_of_pad(c, get_pad(0));}
     function get_padprec_opt(c){return opt_of_pad(c, get_padprec(0));}
     a:
     {
      if(124 > symb)
       switch(symb){
         case 33:
          var
           fmt_rest$5 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [10, fmt_rest$5]];
          break a;
         case 40:
          var
           sub_end = search_subformat_end(str_ind, end_ind, 41),
           fmt_rest$7 = parse(sub_end + 2 | 0, end_ind)[1],
           sub_fmt = parse(str_ind, sub_end)[1],
           sub_fmtty = fmtty_of_fmt(sub_fmt);
          if(get_ign(0))
           var
            ignored$2 = [9, get_pad_opt(95), sub_fmtty],
            _aJ_ = [0, [23, ignored$2, fmt_rest$7]];
          else
           var _aJ_ = [0, [14, get_pad_opt(40), sub_fmtty, fmt_rest$7]];
          var fmt_result = _aJ_;
          break a;
         case 44:
          var fmt_result = parse(str_ind, end_ind); break a;
         case 67:
          var
           fmt_rest$10 = parse(str_ind, end_ind)[1],
           _aL_ =
             get_ign(0) ? [0, [23, 1, fmt_rest$10]] : [0, [1, fmt_rest$10]],
           fmt_result = _aL_;
          break a;
         case 78:
          var fmt_rest$14 = parse(str_ind, end_ind)[1], counter$0 = 2;
          if(get_ign(0))
           var
            ignored$6 = [11, counter$0],
            _aR_ = [0, [23, ignored$6, fmt_rest$14]];
          else
           var _aR_ = [0, [21, counter$0, fmt_rest$14]];
          var fmt_result = _aR_;
          break a;
         case 83:
          var
           pad$6 = check_no_0(symb, get_padprec(0)),
           fmt_rest$15 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$7 = [1, get_padprec_opt(95)],
            _aS_ = [0, [23, ignored$7, fmt_rest$15]];
          else
           var
            match$5 = make_padding_fmt_ebb(pad$6, fmt_rest$15),
            fmt_rest$16 = match$5[2],
            pad$7 = match$5[1],
            _aS_ = [0, [3, pad$7, fmt_rest$16]];
          var fmt_result = _aS_;
          break a;
         case 91:
          if(str_ind === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          var
           char_set = create_char_set(0),
           add_range =
             function(c$0, c){
              if(c >= c$0){
               var i = c$0;
               for(;;){
                add_in_char_set(char_set, caml_call1(Stdlib[29], i));
                var _a$_ = i + 1 | 0;
                if(c === i) break;
                i = _a$_;
               }
              }
              return;
             },
           fail_single_percent =
             function(str_ind){
              return caml_call2(failwith_message(_R_), str, str_ind);
             },
           parse_char_set_content =
             function(counter, str_ind, end_ind){
              var str_ind$0 = str_ind;
              for(;;){
               if(str_ind$0 === end_ind)
                invalid_format_message(end_ind, cst_unexpected_end_of_format);
               var c = caml_string_get(str, str_ind$0);
               if(45 !== c){
                if(93 === c) return str_ind$0 + 1 | 0;
                var _a__ = str_ind$0 + 1 | 0;
                if(counter >= 50)
                 return caml_trampoline_return
                         (parse_char_set_after_char$0, [0, _a__, end_ind, c]);
                var counter$0 = counter + 1 | 0;
                return parse_char_set_after_char$0
                        (counter$0, _a__, end_ind, c);
               }
               add_in_char_set(char_set, 45);
               var str_ind$1 = str_ind$0 + 1 | 0;
               str_ind$0 = str_ind$1;
              }
             },
           parse_char_set_after_char$0 =
             function(counter, str_ind, end_ind, c){
              var str_ind$0 = str_ind, c$0 = c;
              for(;;){
               if(str_ind$0 === end_ind)
                invalid_format_message(end_ind, cst_unexpected_end_of_format);
               var c$1 = caml_string_get(str, str_ind$0);
               a:
               {
                if(46 <= c$1){
                 if(64 !== c$1){
                  if(93 !== c$1) break a;
                  add_in_char_set(char_set, c$0);
                  return str_ind$0 + 1 | 0;
                 }
                }
                else if(37 !== c$1){
                 if(45 > c$1) break a;
                 var str_ind$2 = str_ind$0 + 1 | 0;
                 if(str_ind$2 === end_ind)
                  invalid_format_message
                   (end_ind, cst_unexpected_end_of_format);
                 var c$2 = caml_string_get(str, str_ind$2);
                 if(37 === c$2){
                  if((str_ind$2 + 1 | 0) === end_ind)
                   invalid_format_message
                    (end_ind, cst_unexpected_end_of_format);
                  var c$3 = caml_string_get(str, str_ind$2 + 1 | 0);
                  if(37 !== c$3 && 64 !== c$3)
                   return fail_single_percent(str_ind$2);
                  add_range(c$0, c$3);
                  var _a8_ = str_ind$2 + 2 | 0;
                  if(counter >= 50)
                   return caml_trampoline_return
                           (parse_char_set_content, [0, _a8_, end_ind]);
                  var counter$1 = counter + 1 | 0;
                  return parse_char_set_content(counter$1, _a8_, end_ind);
                 }
                 if(93 === c$2){
                  add_in_char_set(char_set, c$0);
                  add_in_char_set(char_set, 45);
                  return str_ind$2 + 1 | 0;
                 }
                 add_range(c$0, c$2);
                 var _a9_ = str_ind$2 + 1 | 0;
                 if(counter >= 50)
                  return caml_trampoline_return
                          (parse_char_set_content, [0, _a9_, end_ind]);
                 var counter$0 = counter + 1 | 0;
                 return parse_char_set_content(counter$0, _a9_, end_ind);
                }
                if(37 === c$0){
                 add_in_char_set(char_set, c$1);
                 var _a7_ = str_ind$0 + 1 | 0;
                 if(counter >= 50)
                  return caml_trampoline_return
                          (parse_char_set_content, [0, _a7_, end_ind]);
                 var counter$2 = counter + 1 | 0;
                 return parse_char_set_content(counter$2, _a7_, end_ind);
                }
               }
               if(37 === c$0) fail_single_percent(str_ind$0);
               add_in_char_set(char_set, c$0);
               var str_ind$1 = str_ind$0 + 1 | 0;
               str_ind$0 = str_ind$1;
               c$0 = c$1;
              }
             },
           parse_char_set_after_char =
             function(str_ind, end_ind, c){
              return caml_trampoline
                      (parse_char_set_after_char$0(0, str_ind, end_ind, c));
             };
          if(str_ind === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          if(94 === caml_string_get(str, str_ind))
           var
            str_ind$0 = str_ind + 1 | 0,
            reverse = 1,
            str_ind$1 = str_ind$0;
          else
           var reverse = 0, str_ind$1 = str_ind;
          if(str_ind$1 === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          var
           c = caml_string_get(str, str_ind$1),
           next_ind = parse_char_set_after_char(str_ind$1 + 1 | 0, end_ind, c),
           char_set$0 = freeze_char_set(char_set),
           char_set$1 = reverse ? rev_char_set(char_set$0) : char_set$0,
           fmt_rest$19 = parse(next_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$9 = [10, get_pad_opt(95), char_set$1],
            _aX_ = [0, [23, ignored$9, fmt_rest$19]];
          else
           var _aX_ = [0, [20, get_pad_opt(91), char_set$1, fmt_rest$19]];
          var fmt_result = _aX_;
          break a;
         case 97:
          var
           fmt_rest$20 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [15, fmt_rest$20]];
          break a;
         case 99:
          var
           char_format =
             function(fmt_rest){
              return get_ign(0) ? [0, [23, 0, fmt_rest]] : [0, [0, fmt_rest]];
             },
           fmt_rest$21 = parse(str_ind, end_ind)[1],
           match$7 = get_pad_opt(99);
          if(match$7){
           if(0 === match$7[1])
            var
             _aY_ =
               get_ign(0) ? [0, [23, 3, fmt_rest$21]] : [0, [22, fmt_rest$21]],
             _aZ_ = _aY_;
           else
            var
             _aZ_ =
               legacy_behavior$0
                ? char_format(fmt_rest$21)
                : invalid_format_message
                  (str_ind, cst_non_zero_widths_are_unsupp);
           var _a0_ = _aZ_;
          }
          else
           var _a0_ = char_format(fmt_rest$21);
          var fmt_result = _a0_;
          break a;
         case 114:
          var
           fmt_rest$22 = parse(str_ind, end_ind)[1],
           _a1_ =
             get_ign(0) ? [0, [23, 2, fmt_rest$22]] : [0, [19, fmt_rest$22]],
           fmt_result = _a1_;
          break a;
         case 115:
          var
           pad$9 = check_no_0(symb, get_padprec(0)),
           fmt_rest$23 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$10 = [0, get_padprec_opt(95)],
            _a2_ = [0, [23, ignored$10, fmt_rest$23]];
          else
           var
            match$8 = make_padding_fmt_ebb(pad$9, fmt_rest$23),
            fmt_rest$24 = match$8[2],
            pad$10 = match$8[1],
            _a2_ = [0, [2, pad$10, fmt_rest$24]];
          var fmt_result = _a2_;
          break a;
         case 116:
          var
           fmt_rest$25 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [16, fmt_rest$25]];
          break a;
         case 123:
          var
           sub_end$0 = search_subformat_end(str_ind, end_ind, 125),
           sub_fmt$0 = parse(str_ind, sub_end$0)[1],
           fmt_rest$26 = parse(sub_end$0 + 2 | 0, end_ind)[1],
           sub_fmtty$0 = fmtty_of_fmt(sub_fmt$0);
          if(get_ign(0))
           var
            ignored$11 = [8, get_pad_opt(95), sub_fmtty$0],
            _a3_ = [0, [23, ignored$11, fmt_rest$26]];
          else
           var _a3_ = [0, [13, get_pad_opt(123), sub_fmtty$0, fmt_rest$26]];
          var fmt_result = _a3_;
          break a;
         case 66:
         case 98:
          var
           pad$3 = check_no_0(symb, get_padprec(0)),
           fmt_rest$8 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$3 = [7, get_padprec_opt(95)],
            _aK_ = [0, [23, ignored$3, fmt_rest$8]];
          else
           var
            match$3 = make_padding_fmt_ebb(pad$3, fmt_rest$8),
            fmt_rest$9 = match$3[2],
            pad$4 = match$3[1],
            _aK_ = [0, [9, pad$4, fmt_rest$9]];
          var fmt_result = _aK_;
          break a;
         case 37:
         case 64:
          var
           fmt_rest$6 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [12, symb, fmt_rest$6]];
          break a;
         case 76:
         case 108:
         case 110:
          if(str_ind !== end_ind){
           var symb$0 = caml_string_get(str, str_ind), _a4_ = symb$0 - 88 | 0;
           b:
           {
            if(32 >= _a4_ >>> 0)
             switch(_a4_){
               case 0:
               case 12:
               case 17:
               case 23:
               case 29:
               case 32:
                var _aQ_ = 1; break b;
             }
            var _aQ_ = 0;
           }
           if(_aQ_) break;
          }
          var fmt_rest$13 = parse(str_ind, end_ind)[1];
          b:
          {
           if(108 <= symb){
            if(111 > symb)
             switch(symb - 108 | 0){
               case 0:
                var counter = 0; break b;
               case 1: break;
               default: var counter = 1; break b;
             }
           }
           else if(76 === symb){var counter = 2; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
          }
          if(get_ign(0))
           var
            ignored$5 = [11, counter],
            _aP_ = [0, [23, ignored$5, fmt_rest$13]];
          else
           var _aP_ = [0, [21, counter, fmt_rest$13]];
          var fmt_result = _aP_;
          break a;
         case 32:
         case 35:
         case 43:
         case 45:
         case 95:
          var
           fmt_result = caml_call3(failwith_message(_M_), str, pct_ind, symb);
          break a;
         case 88:
         case 100:
         case 105:
         case 111:
         case 117:
         case 120:
          var
           _aT_ = get_space(0),
           _aU_ = get_hash(0),
           iconv$2 =
             compute_int_conv(pct_ind, str_ind, get_plus(0), _aU_, _aT_, symb),
           fmt_rest$17 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$8 = [2, iconv$2, get_pad_opt(95)],
            _aV_ = [0, [23, ignored$8, fmt_rest$17]];
          else
           var
            _aW_ = get_prec(0),
            match$6 = make_padprec_fmt_ebb(get_int_pad(0), _aW_, fmt_rest$17),
            fmt_rest$18 = match$6[3],
            prec$4 = match$6[2],
            pad$8 = match$6[1],
            _aV_ = [0, [4, iconv$2, pad$8, prec$4, fmt_rest$18]];
          var fmt_result = _aV_;
          break a;
         case 69:
         case 70:
         case 71:
         case 72:
         case 101:
         case 102:
         case 103:
         case 104:
          var
           space$1 = get_space(0),
           hash$1 = get_hash(0),
           plus$2 = get_plus(0),
           flag =
             plus$2
              ? space$1
                ? legacy_behavior$0
                  ? 1
                  : incompatible_flag(pct_ind, str_ind, 32, cst$36)
                : 1
              : space$1 ? 2 : 0;
          b:
          {
           c:
           if(73 <= symb){
            var switcher = symb - 101 | 0;
            if(3 >= switcher >>> 0){
             switch(switcher){
               case 0:
                var _a5_ = 1; break;
               case 1:
                var _a5_ = 0; break;
               case 2:
                var _a5_ = 3; break;
               default: var _a5_ = 6;
             }
             var kind = _a5_;
             break b;
            }
           }
           else if(69 <= symb){
            switch(symb - 69 | 0){
              case 0:
               var _a6_ = 2; break;
              case 1:
               break c;
              case 2:
               var _a6_ = 4; break;
              default: var _a6_ = 7;
            }
            var kind = _a6_;
            break b;
           }
           if(hash$1){
            if(70 === symb){var kind = 8; break b;}
           }
           else if(70 === symb){var kind = 5; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
          }
          var
           fconv = [0, flag, kind],
           fmt_rest$11 = parse(str_ind, end_ind)[1];
          if(get_ign(0)){
           var match = get_prec(0);
           if(typeof match === "number")
            var
             _aM_ =
               match ? incompatible_flag(pct_ind, str_ind, 95, cst$26) : 0;
           else
            var ndec = match[1], _aM_ = [0, ndec];
           var
            ignored$4 = [6, get_pad_opt(95), _aM_],
            _aN_ = [0, [23, ignored$4, fmt_rest$11]];
          }
          else
           var
            _aO_ = get_prec(0),
            match$4 = make_padprec_fmt_ebb(get_pad(0), _aO_, fmt_rest$11),
            fmt_rest$12 = match$4[3],
            prec$3 = match$4[2],
            pad$5 = match$4[1],
            _aN_ = [0, [8, fconv, pad$5, prec$3, fmt_rest$12]];
          var fmt_result = _aN_;
          break a;
       }
      b:
      if(108 <= symb){
       if(111 > symb){
        switch(symb - 108 | 0){
          case 0:
           var
            _at_ = caml_string_get(str, str_ind),
            _au_ = get_space(0),
            _av_ = get_hash(0),
            iconv =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _av_, _au_, _at_),
            fmt_rest = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored = [3, iconv, get_pad_opt(95)],
             _aw_ = [0, [23, ignored, fmt_rest]];
           else
            var
             _ay_ = get_prec(0),
             match$0 = make_padprec_fmt_ebb(get_int_pad(0), _ay_, fmt_rest),
             fmt_rest$0 = match$0[3],
             prec$0 = match$0[2],
             pad$0 = match$0[1],
             _aw_ = [0, [5, iconv, pad$0, prec$0, fmt_rest$0]];
           var _ax_ = _aw_;
           break;
          case 1:
           break b;
          default:
           var
            _az_ = caml_string_get(str, str_ind),
            _aA_ = get_space(0),
            _aB_ = get_hash(0),
            iconv$0 =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _aB_, _aA_, _az_),
            fmt_rest$1 = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored$0 = [4, iconv$0, get_pad_opt(95)],
             _aC_ = [0, [23, ignored$0, fmt_rest$1]];
           else
            var
             _aD_ = get_prec(0),
             match$1 = make_padprec_fmt_ebb(get_int_pad(0), _aD_, fmt_rest$1),
             fmt_rest$2 = match$1[3],
             prec$1 = match$1[2],
             pad$1 = match$1[1],
             _aC_ = [0, [6, iconv$0, pad$1, prec$1, fmt_rest$2]];
           var _ax_ = _aC_;
        }
        var fmt_result = _ax_;
        break a;
       }
      }
      else if(76 === symb){
       var
        _aE_ = caml_string_get(str, str_ind),
        _aF_ = get_space(0),
        _aG_ = get_hash(0),
        iconv$1 =
          compute_int_conv
           (pct_ind, str_ind + 1 | 0, get_plus(0), _aG_, _aF_, _aE_),
        fmt_rest$3 = parse(str_ind + 1 | 0, end_ind)[1];
       if(get_ign(0))
        var
         ignored$1 = [5, iconv$1, get_pad_opt(95)],
         _aH_ = [0, [23, ignored$1, fmt_rest$3]];
       else
        var
         _aI_ = get_prec(0),
         match$2 = make_padprec_fmt_ebb(get_int_pad(0), _aI_, fmt_rest$3),
         fmt_rest$4 = match$2[3],
         prec$2 = match$2[2],
         pad$2 = match$2[1],
         _aH_ = [0, [7, iconv$1, pad$2, prec$2, fmt_rest$4]];
       var fmt_result = _aH_;
       break a;
      }
      var
       fmt_result =
         caml_call3(failwith_message(_J_), str, str_ind - 1 | 0, symb);
     }
     if(1 - legacy_behavior$0){
      var _ak_ = 1 - plus_used[1], plus$0 = _ak_ ? plus : _ak_;
      if(plus$0) incompatible_flag(pct_ind, str_ind, symb, cst$27);
      var _al_ = 1 - hash_used[1], hash$0 = _al_ ? hash : _al_;
      if(hash$0) incompatible_flag(pct_ind, str_ind, symb, cst$28);
      var _am_ = 1 - space_used[1], space$0 = _am_ ? space : _am_;
      if(space$0) incompatible_flag(pct_ind, str_ind, symb, cst$29);
      var
       _an_ = 1 - pad_used[1],
       _ao_ = _an_ ? caml_notequal([0, pad], _K_) : _an_;
      if(_ao_) incompatible_flag(pct_ind, str_ind, symb, cst_padding$0);
      var
       _ap_ = 1 - prec_used[1],
       _aq_ = _ap_ ? caml_notequal([0, prec], _L_) : _ap_;
      if(_aq_){
       var _ar_ = ign ? 95 : symb;
       incompatible_flag(pct_ind, str_ind, _ar_, cst_precision$2);
      }
      var plus$1 = ign ? plus : ign;
      if(plus$1) incompatible_flag(pct_ind, str_ind, 95, cst$30);
     }
     var _as_ = 1 - ign_used[1], ign$0 = _as_ ? ign : _as_;
     a:
     if(ign$0){
      b:
      {
       if(38 <= symb){
        if(44 !== symb && 64 !== symb) break b;
       }
       else if(33 !== symb && 37 > symb) break b;
       if(legacy_behavior$0) break a;
      }
      incompatible_flag(pct_ind, str_ind, symb, cst$31);
     }
     return fmt_result;
    }
    function parse_tag(is_open_tag, str_ind, end_ind){
     try{
      if(str_ind === end_ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      if(60 !== caml_string_get(str, str_ind))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var ind = caml_call3(Stdlib_String[31], str, str_ind + 1 | 0, 62);
      if(end_ind <= ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var
       sub_str =
         caml_call3
          (Stdlib_String[15], str, str_ind, (ind - str_ind | 0) + 1 | 0),
       fmt_rest$0 = parse(ind + 1 | 0, end_ind)[1],
       sub_fmt = parse(str_ind, ind + 1 | 0)[1],
       sub_format$0 = [0, sub_fmt, sub_str],
       formatting$0 = is_open_tag ? [0, sub_format$0] : [1, sub_format$0],
       _ai_ = [0, [18, formatting$0, fmt_rest$0]];
      return _ai_;
     }
     catch(_aj_){
      var _ah_ = caml_wrap_exception(_aj_);
      if(_ah_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ah_, 0);
      var
       fmt_rest = parse(str_ind, end_ind)[1],
       formatting = is_open_tag ? [0, sub_format] : [1, sub_format];
      return [0, [18, formatting, fmt_rest]];
     }
    }
    function parse_spaces(str_ind, end_ind){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      if(32 !== caml_string_get(str, str_ind$0)) return str_ind$0;
      var str_ind$1 = str_ind$0 + 1 | 0;
      str_ind$0 = str_ind$1;
     }
    }
    function parse_positive(str_ind, end_ind, acc){
     var str_ind$0 = str_ind, acc$0 = acc;
     for(;;){
      if(str_ind$0 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var c = caml_string_get(str, str_ind$0);
      if(9 < c - 48 >>> 0) return [0, str_ind$0, acc$0];
      var new_acc = (acc$0 * 10 | 0) + (c - 48 | 0) | 0;
      if(Stdlib_Sys[12] < new_acc){
       var _ag_ = Stdlib_Sys[12];
       return caml_call3(failwith_message(_S_), str, new_acc, _ag_);
      }
      var str_ind$1 = str_ind$0 + 1 | 0;
      str_ind$0 = str_ind$1;
      acc$0 = new_acc;
     }
    }
    function parse_integer(str_ind, end_ind){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var match = caml_string_get(str, str_ind);
     if(48 <= match){
      if(58 > match) return parse_positive(str_ind, end_ind, 0);
     }
     else if(45 === match){
      if((str_ind + 1 | 0) === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var c = caml_string_get(str, str_ind + 1 | 0);
      if(9 < c - 48 >>> 0)
       return expected_character(str_ind + 1 | 0, cst_digit, c);
      var
       match$0 = parse_positive(str_ind + 1 | 0, end_ind, 0),
       n = match$0[2],
       next_ind = match$0[1];
      return [0, next_ind, - n | 0];
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
    }
    function add_literal(lit_start, str_ind, fmt){
     var size = str_ind - lit_start | 0;
     return 0 === size
             ? [0, fmt]
             : 1
               === size
               ? [0, [12, caml_string_get(str, lit_start), fmt]]
               : [0,
                 [11,
                  caml_call3(Stdlib_String[15], str, lit_start, size),
                  fmt]];
    }
    function search_subformat_end(str_ind, end_ind, c){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind)
       caml_call3(failwith_message(_U_), str, c, end_ind);
      if(37 === caml_string_get(str, str_ind$0)){
       if((str_ind$0 + 1 | 0) === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       if(caml_string_get(str, str_ind$0 + 1 | 0) === c) return str_ind$0;
       var match = caml_string_get(str, str_ind$0 + 1 | 0);
       if(95 <= match){
        if(123 <= match){
         if(126 > match)
          switch(match - 123 | 0){
            case 0:
             var
              sub_end = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 125),
              str_ind$2 = sub_end + 2 | 0;
             str_ind$0 = str_ind$2;
             continue;
            case 1: break;
            default:
             return expected_character(str_ind$0 + 1 | 0, cst_character, 125);
          }
        }
        else if(96 > match){
         if((str_ind$0 + 2 | 0) === end_ind)
          invalid_format_message(end_ind, cst_unexpected_end_of_format);
         var match$0 = caml_string_get(str, str_ind$0 + 2 | 0);
         if(40 === match$0){
          var
           sub_end$0 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 41),
           str_ind$3 = sub_end$0 + 2 | 0;
          str_ind$0 = str_ind$3;
          continue;
         }
         if(123 === match$0){
          var
           sub_end$1 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 125),
           str_ind$4 = sub_end$1 + 2 | 0;
          str_ind$0 = str_ind$4;
          continue;
         }
         var str_ind$5 = str_ind$0 + 3 | 0;
         str_ind$0 = str_ind$5;
         continue;
        }
       }
       else{
        if(40 === match){
         var
          sub_end$2 = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 41),
          str_ind$6 = sub_end$2 + 2 | 0;
         str_ind$0 = str_ind$6;
         continue;
        }
        if(41 === match)
         return expected_character(str_ind$0 + 1 | 0, cst_character$0, 41);
       }
       var str_ind$1 = str_ind$0 + 2 | 0;
       str_ind$0 = str_ind$1;
      }
      else{var str_ind$7 = str_ind$0 + 1 | 0; str_ind$0 = str_ind$7;}
     }
    }
    function compute_int_conv(pct_ind, str_ind, plus, hash, space, symb){
     var plus$0 = plus, hash$0 = hash, space$0 = space;
     for(;;){
      a:
      {
       if(plus$0){
        if(! hash$0){
         if(space$0) break a;
         if(100 === symb) return 1;
         if(105 === symb) return 4;
         break a;
        }
       }
       else{
        if(! hash$0){
         if(space$0){
          if(100 === symb) return 2;
          if(105 === symb) return 5;
          break a;
         }
         var switcher$1 = symb - 88 | 0;
         if(32 < switcher$1 >>> 0) break a;
         switch(switcher$1){
           case 0:
            return 8;
           case 12:
            return 0;
           case 17:
            return 3;
           case 23:
            return 10;
           case 29:
            return 12;
           case 32:
            return 6;
           default: break a;
         }
        }
        if(! space$0){
         var switcher$0 = symb - 88 | 0;
         if(32 >= switcher$0 >>> 0)
          switch(switcher$0){
            case 0:
             return 9;
            case 12:
             return 13;
            case 17:
             return 14;
            case 23:
             return 11;
            case 29:
             return 15;
            case 32:
             return 7;
          }
        }
       }
       var switcher = symb - 88 | 0;
       if(32 >= switcher >>> 0)
        switch(switcher){
          case 0:
           if(legacy_behavior$0) return 9; break;
          case 23:
           if(legacy_behavior$0) return 11; break;
          case 32:
           if(legacy_behavior$0) return 7; break;
          case 12:
          case 17:
          case 29:
           if(! legacy_behavior$0)
            return incompatible_flag(pct_ind, str_ind, symb, cst$35);
           hash$0 = 0;
           continue;
        }
      }
      if(plus$0)
       if(space$0){
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, 32, cst$32);
        space$0 = 0;
       }
       else{
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, symb, cst$33);
        plus$0 = 0;
       }
      else{
       if(! space$0)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
       if(! legacy_behavior$0)
        return incompatible_flag(pct_ind, str_ind, symb, cst$34);
       space$0 = 0;
      }
     }
    }
    function incompatible_flag(pct_ind, str_ind, symb, option){
     var
      subfmt =
        caml_call3(Stdlib_String[15], str, pct_ind, str_ind - pct_ind | 0);
     return caml_call5
             (failwith_message(_Y_), str, pct_ind, option, symb, subfmt);
    }
    return parse(0, caml_ml_string_length(str));
   }
   function format_of_string_fmtty(str, fmtty){
    var fmt = fmt_ebb_of_string(0, str)[1];
    try{var _ae_ = [0, type_format(fmt, fmtty), str]; return _ae_;}
    catch(_af_){
     var _ac_ = caml_wrap_exception(_af_);
     if(_ac_ !== Type_mismatch) throw caml_maybe_attach_backtrace(_ac_, 0);
     var _ad_ = string_of_fmtty(fmtty);
     return caml_call2(failwith_message(_Z_), str, _ad_);
    }
   }
   function format_of_string_format(str, param){
    var
     str$0 = param[2],
     fmt = param[1],
     fmt$0 = fmt_ebb_of_string(0, str)[1];
    try{
     var _aa_ = [0, type_format(fmt$0, fmtty_of_fmt(fmt)), str];
     return _aa_;
    }
    catch(_ab_){
     var _$_ = caml_wrap_exception(_ab_);
     if(_$_ === Type_mismatch)
      return caml_call2(failwith_message(___), str, str$0);
     throw caml_maybe_attach_backtrace(_$_, 0);
    }
   }
   var
    CamlinternalFormat =
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
   runtime.caml_register_global(197, CamlinternalFormat, "CamlinternalFormat");
   return;
  }
  (globalThis));

//# 15834 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    CamlinternalFormat = global_data.CamlinternalFormat,
    Stdlib = global_data.Stdlib;
   function kfprintf(k, o, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              caml_call2(CamlinternalFormat[9], o, acc);
              return caml_call1(k, o);
             },
             0,
             fmt);
   }
   function kbprintf(k, b, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              caml_call2(CamlinternalFormat[10], b, acc);
              return caml_call1(k, b);
             },
             0,
             fmt);
   }
   function ikfprintf(k, oc, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], k, oc, fmt);
   }
   function fprintf(oc, fmt){
    return kfprintf(function(_d_){return 0;}, oc, fmt);
   }
   function bprintf(b, fmt){
    return kbprintf(function(_c_){return 0;}, b, fmt);
   }
   function ifprintf(oc, fmt){
    return ikfprintf(function(_b_){return 0;}, oc, fmt);
   }
   function ibprintf(b, fmt){
    return ikfprintf(function(_a_){return 0;}, b, fmt);
   }
   function printf(fmt){return fprintf(Stdlib[39], fmt);}
   function eprintf(fmt){return fprintf(Stdlib[40], fmt);}
   function ksprintf(k, param){
    var fmt = param[1];
    function k$0(acc){
     var buf = caml_call1(Stdlib_Buffer[1], 64);
     caml_call2(CamlinternalFormat[11], buf, acc);
     return caml_call1(k, caml_call1(Stdlib_Buffer[2], buf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function sprintf(fmt){return ksprintf(function(s){return s;}, fmt);}
   var
    Stdlib_Printf =
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
   runtime.caml_register_global(3, Stdlib_Printf, "Stdlib__Printf");
   return;
  }
  (globalThis));

//# 16644 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    CamlinternalAtomic = global_data.CamlinternalAtomic,
    make = CamlinternalAtomic[1],
    get = CamlinternalAtomic[2],
    set = CamlinternalAtomic[3],
    exchange = CamlinternalAtomic[4],
    compare_and_set = CamlinternalAtomic[5],
    fetch_and_add = CamlinternalAtomic[6],
    incr = CamlinternalAtomic[7],
    decr = CamlinternalAtomic[8],
    Stdlib_Atomic =
      [0,
       make,
       get,
       set,
       exchange,
       compare_and_set,
       fetch_and_add,
       incr,
       decr];
   runtime.caml_register_global(1, Stdlib_Atomic, "Stdlib__Atomic");
   return;
  }
  (globalThis));

//# 16676 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_s = "%s\n",
    cst_Program_not_linked_with_g_$0 =
      "(Program not linked with -g, cannot print stack backtrace)\n",
    cst_characters = ", characters ",
    cst_Fatal_error_exception = "Fatal error: exception ",
    cst_Fatal_error_exception_s = "Fatal error: exception %s\n",
    cst_Uncaught_exception = "Uncaught exception: ",
    cst_Uncaught_exception_s = "Uncaught exception: %s\n",
    caml_check_bound = runtime.caml_check_bound,
    caml_get_exception_raw_backtra = runtime.caml_get_exception_raw_backtrace,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$4,
    cst$3 = cst$4,
    partial = [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]],
    cst$1 = cst$4,
    cst$2 = cst$4,
    cst = "_",
    locfmt =
      [0,
       [11,
        'File "',
        [2,
         0,
         [11,
          '", line ',
          [4,
           0,
           0,
           0,
           [11,
            cst_characters,
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [11, ": ", [2, 0, 0]]]]]]]]]],
       'File "%s", line %d, characters %d-%d: %s'],
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Obj = global_data.Stdlib__Obj,
    printers = caml_call1(Stdlib_Atomic[1], 0),
    _a_ = [0, [3, 0, 0], "%S"],
    _b_ = [0, [4, 0, 0, 0, 0], "%d"],
    _c_ = [0, [11, ", ", [2, 0, [2, 0, 0]]], ", %s%s"],
    _d_ = [0, [12, 40, [2, 0, [2, 0, [12, 41, 0]]]], "(%s%s)"],
    _e_ = [0, [12, 40, [2, 0, [12, 41, 0]]], "(%s)"],
    cst_Out_of_memory = "Out of memory",
    cst_Stack_overflow = "Stack overflow",
    cst_Pattern_matching_failed = "Pattern matching failed",
    cst_Assertion_failed = "Assertion failed",
    cst_Undefined_recursive_module = "Undefined recursive module",
    _f_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    _g_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    cst_Raised_at = "Raised at",
    cst_Re_raised_at = "Re-raised at",
    cst_Raised_by_primitive_operat = "Raised by primitive operation at",
    cst_Called_from = "Called from",
    cst_inlined = " (inlined)",
    _h_ =
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           ' in file "',
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11, ", line ", [4, 0, 0, 0, [11, cst_characters, partial]]]]]]]]]],
       '%s %s in file "%s"%s, line %d, characters %d-%d'],
    _i_ = [0, [2, 0, [11, " unknown location", 0]], "%s unknown location"],
    _j_ = [0, [2, 0, [12, 10, 0]], cst_s],
    _k_ =
      [0,
       [11, cst_Program_not_linked_with_g_$0, 0],
       cst_Program_not_linked_with_g_$0],
    _l_ = [0, [2, 0, [12, 10, 0]], cst_s],
    cst_Program_not_linked_with_g_ = cst_Program_not_linked_with_g_$0;
   function field(x, i){
    var f = x[1 + i];
    if(! caml_call1(Stdlib_Obj[1], f))
     return caml_call2(Stdlib_Printf[4], _b_, f);
    var _ag_ = Stdlib_Obj[13];
    if(caml_obj_tag(f) === _ag_) return caml_call2(Stdlib_Printf[4], _a_, f);
    var _ah_ = Stdlib_Obj[14];
    return caml_obj_tag(f) === _ah_ ? caml_call1(Stdlib[35], f) : cst;
   }
   function other_fields(x, i){
    if(x.length - 1 <= i) return cst$0;
    var _ae_ = other_fields(x, i + 1 | 0), _af_ = field(x, i);
    return caml_call3(Stdlib_Printf[4], _c_, _af_, _ae_);
   }
   function use_printers(x){
    var param = caml_call1(Stdlib_Atomic[2], printers);
    for(;;){
     if(! param) return 0;
     var tl = param[2], hd = param[1];
     a:
     {
      try{var val = caml_call1(hd, x);}catch(_ad_){break a;}
      if(val){var s = val[1]; return [0, s];}
     }
     param = tl;
    }
   }
   function to_string_default(x){
    if(x === Stdlib[9]) return cst_Out_of_memory;
    if(x === Stdlib[10]) return cst_Stack_overflow;
    if(x[1] === Stdlib[4]){
     var
      match$0 = x[2],
      char$0 = match$0[3],
      line = match$0[2],
      file = match$0[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file,
              line,
              char$0,
              char$0 + 5 | 0,
              cst_Pattern_matching_failed);
    }
    if(x[1] === Stdlib[5]){
     var
      match$1 = x[2],
      char$1 = match$1[3],
      line$0 = match$1[2],
      file$0 = match$1[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file$0,
              line$0,
              char$1,
              char$1 + 6 | 0,
              cst_Assertion_failed);
    }
    if(x[1] === Stdlib[15]){
     var
      match$2 = x[2],
      char$2 = match$2[3],
      line$1 = match$2[2],
      file$1 = match$2[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file$1,
              line$1,
              char$2,
              char$2 + 6 | 0,
              cst_Undefined_recursive_module);
    }
    if(0 !== caml_obj_tag(x)) return x[1];
    var constructor = x[1][1], match = x.length - 1;
    if(2 < match >>> 0)
     var
      _$_ = other_fields(x, 2),
      _aa_ = field(x, 1),
      _ac_ = caml_call3(Stdlib_Printf[4], _d_, _aa_, _$_);
    else
     switch(match){
       case 0:
        var _ac_ = cst$1; break;
       case 1:
        var _ac_ = cst$2; break;
       default:
        var
         _ab_ = field(x, 1),
         _ac_ = caml_call2(Stdlib_Printf[4], _e_, _ab_);
     }
    return caml_call2(Stdlib[28], constructor, _ac_);
   }
   function to_string(e){
    var match = use_printers(e);
    if(! match) return to_string_default(e);
    var s = match[1];
    return s;
   }
   function print(fct, arg){
    try{var ___ = caml_call1(fct, arg); return ___;}
    catch(x$0){
     var x = caml_wrap_exception(x$0), _Z_ = to_string(x);
     caml_call2(Stdlib_Printf[3], _f_, _Z_);
     caml_call1(Stdlib[63], Stdlib[40]);
     throw caml_maybe_attach_backtrace(x, 0);
    }
   }
   function catch$0(fct, arg){
    try{var _Y_ = caml_call1(fct, arg); return _Y_;}
    catch(x$0){
     var x = caml_wrap_exception(x$0);
     caml_call1(Stdlib[63], Stdlib[39]);
     var _X_ = to_string(x);
     caml_call2(Stdlib_Printf[3], _g_, _X_);
     return caml_call1(Stdlib[99], 2);
    }
   }
   function raw_backtrace_entries(bt){return bt;}
   function convert_raw_backtrace(bt){
    return [0, runtime.caml_convert_raw_backtrace(bt)];
   }
   function format_backtrace_slot(pos, slot){
    function info(is_raise){
     return is_raise
             ? 0 === pos ? cst_Raised_at : cst_Re_raised_at
             : 0 === pos ? cst_Raised_by_primitive_operat : cst_Called_from;
    }
    if(0 === slot[0]){
     var
      _P_ = slot[5],
      _Q_ = slot[4],
      _R_ = slot[3],
      _S_ = slot[6] ? cst_inlined : cst$3,
      _T_ = slot[2],
      _U_ = slot[7],
      _V_ = info(slot[1]);
     return [0,
             caml_call8
              (Stdlib_Printf[4], _h_, _V_, _U_, _T_, _S_, _R_, _Q_, _P_)];
    }
    if(slot[1]) return 0;
    var _W_ = info(0);
    return [0, caml_call2(Stdlib_Printf[4], _i_, _W_)];
   }
   function print_raw_backtrace(outchan, raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return caml_call2(Stdlib_Printf[1], outchan, _k_);
    var a = backtrace[1], _N_ = a.length - 2 | 0, _M_ = 0;
    if(_N_ >= 0){
     var i = _M_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[1], outchan, _j_, str);
      }
      var _O_ = i + 1 | 0;
      if(_N_ === i) break;
      i = _O_;
     }
    }
    return 0;
   }
   function print_backtrace(outchan){
    return print_raw_backtrace(outchan, caml_get_exception_raw_backtra(0));
   }
   function raw_backtrace_to_string(raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return cst_Program_not_linked_with_g_;
    var
     a = backtrace[1],
     b = caml_call1(Stdlib_Buffer[1], 1024),
     _K_ = a.length - 2 | 0,
     _J_ = 0;
    if(_K_ >= 0){
     var i = _J_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[5], b, _l_, str);
      }
      var _L_ = i + 1 | 0;
      if(_K_ === i) break;
      i = _L_;
     }
    }
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function backtrace_slot_is_raise(param){
    return 0 === param[0] ? param[1] : param[1];
   }
   function backtrace_slot_is_inline(param){return 0 === param[0] ? param[6] : 0;
   }
   function backtrace_slot_location(param){
    return 0 === param[0]
            ? [0, [0, param[2], param[3], param[4], param[5]]]
            : 0;
   }
   function backtrace_slot_defname(param){
    if(0 === param[0] && param[7] !== cst$4) return [0, param[7]];
    return 0;
   }
   function backtrace_slots(raw_backtrace){
    var match = convert_raw_backtrace(raw_backtrace);
    if(! match) return 0;
    var backtrace = match[1], i$1 = backtrace.length - 2 | 0, i = i$1;
    for(;;){
     if(-1 === i)
      var _I_ = 0;
     else{
      var _H_ = 0 === caml_check_bound(backtrace, i)[1 + i][0] ? 1 : 0;
      if(! _H_){var i$0 = i - 1 | 0; i = i$0; continue;}
      var _I_ = _H_;
     }
     return _I_ ? [0, backtrace] : 0;
    }
   }
   function backtrace_slots_of_raw_entry(entry){return backtrace_slots([0, entry]);
   }
   function raw_backtrace_length(bt){return bt.length - 1;}
   function get_backtrace(param){
    return raw_backtrace_to_string(caml_get_exception_raw_backtra(0));
   }
   function register_printer(fn){
    for(;;){
     var
      old_printers = caml_call1(Stdlib_Atomic[2], printers),
      new_printers = [0, fn, old_printers],
      success =
        caml_call3(Stdlib_Atomic[5], printers, old_printers, new_printers),
      _G_ = 1 - success;
     if(! _G_) return _G_;
    }
   }
   function exn_slot(x){return 0 === caml_obj_tag(x) ? x[1] : x;}
   function exn_slot_id(x){var slot = exn_slot(x); return slot[2];}
   function exn_slot_name(x){var slot = exn_slot(x); return slot[1];}
   var
    errors =
      [0,
        cst$4,
        "(Cannot print locations:\n bytecode executable program file not found)",
        "(Cannot print locations:\n bytecode executable program file appears to be corrupt)",
        "(Cannot print locations:\n bytecode executable program file has wrong magic number)",
        "(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)"].slice
       (),
    _m_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s];
   function default_uncaught_exception_han(exn, raw_backtrace){
    var _D_ = to_string(exn);
    caml_call2(Stdlib_Printf[3], _m_, _D_);
    print_raw_backtrace(Stdlib[40], raw_backtrace);
    var status = runtime.caml_ml_debug_info_status(0);
    if(status < 0){
     var
      _E_ = caml_call1(Stdlib[18], status),
      _F_ = caml_check_bound(errors, _E_)[1 + _E_];
     caml_call1(Stdlib[53], _F_);
    }
    return caml_call1(Stdlib[63], Stdlib[40]);
   }
   var uncaught_exception_handler = [0, default_uncaught_exception_han];
   function set_uncaught_exception_handler(fn){
    uncaught_exception_handler[1] = fn;
    return 0;
   }
   var
    empty_backtrace = [0],
    cst_Fatal_error_out_of_memory_ =
      "Fatal error: out of memory in uncaught exception handler",
    _n_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s],
    _o_ =
      [0,
       [11,
        "Fatal error in uncaught exception handler: exception ",
        [2, 0, [12, 10, 0]]],
       "Fatal error in uncaught exception handler: exception %s\n"];
   function handle_uncaught_exception(exn$0, debugger_in_use){
    try{
     try{
      var
       raw_backtrace =
         debugger_in_use ? empty_backtrace : caml_get_exception_raw_backtra(0);
      try{caml_call1(Stdlib[103], 0);}catch(_C_){}
      try{
       var
        _y_ = caml_call2(uncaught_exception_handler[1], exn$0, raw_backtrace),
        _x_ = _y_;
      }
      catch(exn$1){
       var
        exn = caml_wrap_exception(exn$1),
        raw_backtrace$0 = caml_get_exception_raw_backtra(0),
        _v_ = to_string(exn$0);
       caml_call2(Stdlib_Printf[3], _n_, _v_);
       print_raw_backtrace(Stdlib[40], raw_backtrace);
       var _w_ = to_string(exn);
       caml_call2(Stdlib_Printf[3], _o_, _w_);
       print_raw_backtrace(Stdlib[40], raw_backtrace$0);
       var _x_ = caml_call1(Stdlib[63], Stdlib[40]);
      }
      var _z_ = _x_;
     }
     catch(_B_){
      var _u_ = caml_wrap_exception(_B_);
      if(_u_ !== Stdlib[9]) throw caml_maybe_attach_backtrace(_u_, 0);
      var _z_ = caml_call1(Stdlib[53], cst_Fatal_error_out_of_memory_);
     }
     return _z_;
    }
    catch(_A_){return 0;}
   }
   runtime.caml_register_named_value
    ("Printexc.handle_uncaught_exception", handle_uncaught_exception);
   var
    Stdlib_Printexc =
      [0,
       to_string,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       runtime.caml_record_backtrace,
       runtime.caml_backtrace_status,
       register_printer,
       use_printers,
       raw_backtrace_entries,
       function(_t_){return caml_get_exception_raw_backtra(_t_);},
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       backtrace_slots_of_raw_entry,
       [0,
        backtrace_slot_is_raise,
        backtrace_slot_is_inline,
        backtrace_slot_location,
        backtrace_slot_defname,
        format_backtrace_slot],
       raw_backtrace_length,
       function(_s_, _r_){return runtime.caml_raw_backtrace_slot(_s_, _r_);},
       function(_q_){return runtime.caml_convert_raw_backtrace_slot(_q_);},
       function(_p_){return runtime.caml_raw_backtrace_next_slot(_p_);},
       exn_slot_id,
       exn_slot_name];
   runtime.caml_register_global(42, Stdlib_Printexc, "Stdlib__Printexc");
   return;
  }
  (globalThis));

//# 17394 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Digest_from_hex$1 = "Digest.from_hex",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_md5_string = runtime.caml_md5_string,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_String = global_data.Stdlib__String,
    compare = Stdlib_String[9],
    equal = Stdlib_String[8],
    cst_Digest_substring = "Digest.substring",
    cst_Digest_to_hex = "Digest.to_hex",
    cst_Digest_from_hex = cst_Digest_from_hex$1,
    cst_Digest_from_hex$0 = cst_Digest_from_hex$1;
   function string(str){
    return caml_md5_string(str, 0, caml_ml_string_length(str));
   }
   function bytes(b){return string(caml_call1(Stdlib_Bytes[48], b));}
   function substring(str, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(str) - len | 0) >= ofs)
     return caml_md5_string(str, ofs, len);
    return caml_call1(Stdlib[1], cst_Digest_substring);
   }
   function subbytes(b, ofs, len){
    return substring(caml_call1(Stdlib_Bytes[48], b), ofs, len);
   }
   function file(filename){
    var ic = caml_call1(Stdlib[80], filename);
    try{var d = runtime.caml_md5_chan(ic, -1);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[93], ic);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    caml_call1(Stdlib[93], ic);
    return d;
   }
   function output(chan, digest){return caml_call2(Stdlib[66], chan, digest);}
   function input(chan){return caml_call2(Stdlib[86], chan, 16);}
   function char_hex(n){var _e_ = 10 <= n ? 87 : 48; return n + _e_ | 0;}
   function to_hex(d){
    if(16 !== caml_ml_string_length(d))
     caml_call1(Stdlib[1], cst_Digest_to_hex);
    var result = caml_create_bytes(32), i = 0;
    for(;;){
     var x = caml_string_get(d, i);
     caml_bytes_unsafe_set(result, i * 2 | 0, char_hex(x >>> 4 | 0));
     caml_bytes_unsafe_set(result, (i * 2 | 0) + 1 | 0, char_hex(x & 15));
     var _d_ = i + 1 | 0;
     if(15 === i) return caml_call1(Stdlib_Bytes[48], result);
     i = _d_;
    }
   }
   function from_hex(s){
    if(32 !== caml_ml_string_length(s))
     caml_call1(Stdlib[1], cst_Digest_from_hex);
    function digit(c){
     if(65 <= c){
      if(97 <= c){
       if(103 > c) return (c - 97 | 0) + 10 | 0;
      }
      else if(71 > c) return (c - 65 | 0) + 10 | 0;
     }
     else if(9 >= c - 48 >>> 0) return c - 48 | 0;
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_Digest_from_hex$0], 1);
    }
    var result = caml_create_bytes(16), i = 0;
    for(;;){
     var
      i$0 = 2 * i | 0,
      _a_ = digit(caml_string_get(s, i$0 + 1 | 0)),
      _b_ = (digit(caml_string_get(s, i$0)) << 4) + _a_ | 0;
     runtime.caml_bytes_set(result, i, caml_call1(Stdlib_Char[1], _b_));
     var _c_ = i + 1 | 0;
     if(15 === i) return caml_call1(Stdlib_Bytes[48], result);
     i = _c_;
    }
   }
   var
    Stdlib_Digest =
      [0,
       compare,
       equal,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output,
       input,
       to_hex,
       from_hex];
   runtime.caml_register_global(8, Stdlib_Digest, "Stdlib__Digest");
   return;
  }
  (globalThis));

//# 17515 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessequal = runtime.caml_lessequal,
    caml_mod = runtime.caml_mod,
    caml_string_get = runtime.caml_string_get,
    caml_sys_random_seed = runtime.caml_sys_random_seed;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Digest = global_data.Stdlib__Digest,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    cst_x = "x",
    cst_Random_int = "Random.int",
    cst_Random_full_int = "Random.full_int",
    cst_Random_int32 = "Random.int32",
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_Random_int64 = "Random.int64";
   function new_state(param){return [0, runtime.caml_make_vect(55, 0), 0];}
   function assign(st1, st2){
    caml_call5(Stdlib_Array[10], st2[1], 0, st1[1], 0, 55);
    st1[2] = st2[2];
    return 0;
   }
   function full_init(s, seed){
    var
     seed$0 = 0 === seed.length - 1 ? [0, 0] : seed,
     l = seed$0.length - 1,
     i$0 = 0;
    for(;;){
     caml_check_bound(s[1], i$0)[1 + i$0] = i$0;
     var _q_ = i$0 + 1 | 0;
     if(54 === i$0) break;
     i$0 = _q_;
    }
    var
     accu = [0, cst_x],
     _n_ = 54 + caml_call2(Stdlib_Int[11], 55, l) | 0,
     _m_ = 0;
    if(_n_ >= 0){
     var i = _m_;
     for(;;){
      var
       j = i % 55 | 0,
       k = caml_mod(i, l),
       x = caml_check_bound(seed$0, k)[1 + k],
       accu$0 = accu[1],
       _g_ = caml_call1(Stdlib_Int[12], x),
       _h_ = caml_call2(Stdlib[28], accu$0, _g_);
      accu[1] = caml_call1(Stdlib_Digest[3], _h_);
      var
       d = accu[1],
       _i_ = caml_string_get(d, 3) << 24,
       _j_ = caml_string_get(d, 2) << 16,
       _k_ = caml_string_get(d, 1) << 8,
       _l_ = ((caml_string_get(d, 0) + _k_ | 0) + _j_ | 0) + _i_ | 0,
       _o_ = (caml_check_bound(s[1], j)[1 + j] ^ _l_) & 1073741823;
      caml_check_bound(s[1], j)[1 + j] = _o_;
      var _p_ = i + 1 | 0;
      if(_n_ === i) break;
      i = _p_;
     }
    }
    s[2] = 0;
    return 0;
   }
   function make(seed){
    var result = new_state(0);
    full_init(result, seed);
    return result;
   }
   function make_self_init(param){return make(caml_sys_random_seed(0));}
   function copy(s){
    var result = new_state(0);
    assign(result, s);
    return result;
   }
   function bits(s){
    s[2] = (s[2] + 1 | 0) % 55 | 0;
    var
     _d_ = s[2],
     curval = caml_check_bound(s[1], _d_)[1 + _d_],
     _e_ = (s[2] + 24 | 0) % 55 | 0,
     newval =
       caml_check_bound(s[1], _e_)[1 + _e_]
       + (curval ^ (curval >>> 25 | 0) & 31)
       | 0,
     newval30 = newval & 1073741823,
     _f_ = s[2];
    caml_check_bound(s[1], _f_)[1 + _f_] = newval30;
    return newval30;
   }
   function intaux(s, n){
    for(;;){
     var r = bits(s), v = caml_mod(r, n);
     if(((1073741823 - n | 0) + 1 | 0) >= (r - v | 0)) return v;
    }
   }
   function int$0(s, bound){
    if(1073741823 >= bound && 0 < bound) return intaux(s, bound);
    return caml_call1(Stdlib[1], cst_Random_int);
   }
   function full_int(s, bound){
    if(0 >= bound) return caml_call1(Stdlib[1], cst_Random_full_int);
    if(1073741823 >= bound) return intaux(s, bound);
    for(;;){
     var b1 = bits(s), b2 = bits(s), max_int_32 = 2147483647;
     if(bound <= 2147483647)
      var
       bpos = (b2 & 1073725440) << 1 | b1 >>> 15 | 0,
       max_int = max_int_32,
       r = bpos;
     else
      var
       b3 = bits(s),
       r$0 = ((b3 & 1073741312) << 12 | b2 >>> 9 | 0) << 20 | b1 >>> 10 | 0,
       max_int$0 = Stdlib[19],
       max_int = max_int$0,
       r = r$0;
     var v = caml_mod(r, bound);
     if(((max_int - bound | 0) + 1 | 0) >= (r - v | 0)) return v;
    }
   }
   function int32(s, bound){
    if(caml_lessequal(bound, 0))
     return caml_call1(Stdlib[1], cst_Random_int32);
    for(;;){
     var
      b1 = bits(s),
      b2 = (bits(s) & 1) << 30,
      r = b1 | b2,
      v = caml_mod(r, bound);
     if(! caml_greaterthan(r - v | 0, (Stdlib_Int32[9] - bound | 0) + 1 | 0))
      return v;
    }
   }
   function int64(s, bound){
    if(caml_lessequal(bound, _b_))
     return caml_call1(Stdlib[1], cst_Random_int64);
    for(;;){
     var
      b1 = caml_int64_of_int32(bits(s)),
      b2 = caml_int64_shift_left(caml_int64_of_int32(bits(s)), 30),
      b3 = caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7), 60),
      r = caml_int64_or(b1, caml_int64_or(b2, b3)),
      v = runtime.caml_int64_mod(r, bound);
     if
      (!
       caml_greaterthan
        (caml_int64_sub(r, v),
         runtime.caml_int64_add(caml_int64_sub(Stdlib_Int64[9], bound), _a_)))
      return v;
    }
   }
   var
    _c_ =
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
    nativeint =
      32 === Stdlib_Nativeint[9]
       ? function(s, bound){return int32(s, bound);}
       : function
        (s, bound){
         return caml_int64_to_int32(int64(s, caml_int64_of_int32(bound)));
        };
   function float$0(s, bound){
    var r1 = bits(s), r2 = bits(s);
    return (r1 / 1073741824. + r2) / 1073741824. * bound;
   }
   function bool(s){return 0 === (bits(s) & 1) ? 1 : 0;}
   function bits32(s){
    var b1 = bits(s) >>> 14 | 0, b2 = bits(s) >>> 14 | 0;
    return b1 | b2 << 16;
   }
   function bits64(s){
    var
     b1 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 9),
     b2 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 9),
     b3 = caml_int64_shift_right_unsigne(caml_int64_of_int32(bits(s)), 8);
    return caml_int64_or
            (b1,
             caml_int64_or
              (caml_int64_shift_left(b2, 21), caml_int64_shift_left(b3, 42)));
   }
   var
    nativebits =
      32 === Stdlib_Nativeint[9]
       ? function(s){return bits32(s);}
       : function(s){return caml_int64_to_int32(bits64(s));},
    default$0 = [0, _c_.slice(), 0];
   function bits$0(param){return bits(default$0);}
   function int$1(bound){return int$0(default$0, bound);}
   function full_int$0(bound){return full_int(default$0, bound);}
   function int32$0(bound){return int32(default$0, bound);}
   function nativeint$0(bound){return nativeint(default$0, bound);}
   function int64$0(bound){return int64(default$0, bound);}
   function float$1(scale){return float$0(default$0, scale);}
   function bool$0(param){return bool(default$0);}
   function bits32$0(param){return bits32(default$0);}
   function bits64$0(param){return bits64(default$0);}
   function nativebits$0(param){return nativebits(default$0);}
   function full_init$0(seed){return full_init(default$0, seed);}
   function init(seed){return full_init(default$0, [0, seed]);}
   function self_init(param){
    var seed = caml_sys_random_seed(0);
    return full_init(default$0, seed);
   }
   function get_state(param){return copy(default$0);}
   function set_state(s){return assign(default$0, s);}
   var
    Stdlib_Random =
      [0,
       init,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       full_int$0,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       bits32$0,
       bits64$0,
       nativebits$0,
       [0,
        make,
        make_self_init,
        copy,
        bits,
        int$0,
        full_int,
        int32,
        nativeint,
        int64,
        float$0,
        bool,
        bits32,
        bits64,
        nativebits],
       get_state,
       set_state];
   runtime.caml_register_global(18, Stdlib_Random, "Stdlib__Random");
   return;
  }
  (globalThis));

//# 17849 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_compare = runtime.caml_compare,
    caml_hash = runtime.caml_hash,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    _d_ = [0, 0],
    cst = "",
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array;
   global_data.Assert_failure;
   var Stdlib_String = global_data.Stdlib__String;
   function ongoing_traversal(h){
    var _aq_ = h.length - 1 < 4 ? 1 : 0, _ar_ = _aq_ || (h[4] < 0 ? 1 : 0);
    return _ar_;
   }
   function flip_ongoing_traversal(h){h[4] = - h[4] | 0; return 0;}
   var
    cst_Hashtbl_unsupported_hash_t = "Hashtbl: unsupported hash table format";
   try{var _f_ = caml_sys_getenv("OCAMLRUNPARAM"), params = _f_;}
   catch(_ao_){
    var _a_ = caml_wrap_exception(_ao_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    try{var _e_ = caml_sys_getenv("CAMLRUNPARAM"), _c_ = _e_;}
    catch(_ap_){
     var _b_ = caml_wrap_exception(_ap_);
     if(_b_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b_, 0);
     var _c_ = cst;
    }
    var params = _c_;
   }
   var
    randomized_default = caml_call2(Stdlib_String[14], params, 82),
    randomized = [0, randomized_default];
   function randomize(param){randomized[1] = 1; return 0;}
   function is_randomized(param){return randomized[1];}
   var
    prng = [246, function(_an_){return caml_call1(Stdlib_Random[15][2], 0);}];
   function power_2_above(x, n){
    var x$0 = x;
    for(;;){
     if(n <= x$0) return x$0;
     if(Stdlib_Sys[13] < (x$0 * 2 | 0)) return x$0;
     var x$1 = x$0 * 2 | 0;
     x$0 = x$1;
    }
   }
   function create(opt, initial_size){
    if(opt) var sth = opt[1], random = sth; else var random = randomized[1];
    var s = power_2_above(16, initial_size);
    if(random)
     var
      _al_ = caml_obj_tag(prng),
      _am_ =
        250 === _al_
         ? prng[1]
         : 246 === _al_ ? caml_call1(CamlinternalLazy[2], prng) : prng,
      seed = caml_call1(Stdlib_Random[15][4], _am_);
    else
     var seed = 0;
    return [0, 0, caml_make_vect(s, 0), seed, s];
   }
   function clear(h){
    var _ak_ = 0 < h[1] ? 1 : 0;
    return _ak_
            ? (h
               [1]
              = 0,
              caml_call4(Stdlib_Array[9], h[2], 0, h[2].length - 1, 0))
            : _ak_;
   }
   function reset(h){
    var len = h[2].length - 1;
    if(4 <= h.length - 1 && len !== caml_call1(Stdlib[18], h[4])){
     h[1] = 0;
     h[2] = caml_make_vect(caml_call1(Stdlib[18], h[4]), 0);
     return 0;
    }
    return clear(h);
   }
   function copy_bucketlist(param){
    if(! param) return 0;
    var
     key = param[1],
     data = param[2],
     next = param[3],
     prec$1 = [0, key, data, next],
     prec = prec$1,
     param$0 = next;
    for(;;){
     if(! param$0) return prec$1;
     var
      key$0 = param$0[1],
      data$0 = param$0[2],
      next$0 = param$0[3],
      prec$0 = [0, key$0, data$0, next$0];
     prec[3] = prec$0;
     prec = prec$0;
     param$0 = next$0;
    }
   }
   function copy(h){
    var
     _ah_ = h[4],
     _ai_ = h[3],
     _aj_ = caml_call2(Stdlib_Array[15], copy_bucketlist, h[2]);
    return [0, h[1], _aj_, _ai_, _ah_];
   }
   function length(h){return h[1];}
   function insert_all_buckets(indexfun, inplace, odata, ndata){
    var
     nsize = ndata.length - 1,
     ndata_tail = caml_make_vect(nsize, 0),
     _ab_ = odata.length - 2 | 0,
     _aa_ = 0;
    if(_ab_ >= 0){
     var i$0 = _aa_;
     for(;;){
      var cell$1 = caml_check_bound(odata, i$0)[1 + i$0], cell = cell$1;
      for(;;){
       if(! cell) break;
       var
        key = cell[1],
        data = cell[2],
        next = cell[3],
        cell$0 = inplace ? cell : [0, key, data, 0],
        nidx = caml_call1(indexfun, key),
        match = caml_check_bound(ndata_tail, nidx)[1 + nidx];
       if(match)
        match[3] = cell$0;
       else
        caml_check_bound(ndata, nidx)[1 + nidx] = cell$0;
       caml_check_bound(ndata_tail, nidx)[1 + nidx] = cell$0;
       cell = next;
      }
      var _ag_ = i$0 + 1 | 0;
      if(_ab_ === i$0) break;
      i$0 = _ag_;
     }
    }
    if(inplace){
     var _ad_ = nsize - 1 | 0, _ac_ = 0;
     if(_ad_ >= 0){
      var i = _ac_;
      for(;;){
       var match$0 = caml_check_bound(ndata_tail, i)[1 + i];
       if(match$0) match$0[3] = 0;
       var _af_ = i + 1 | 0;
       if(_ad_ === i) break;
       i = _af_;
      }
     }
     var _ae_ = 0;
    }
    else
     var _ae_ = inplace;
    return _ae_;
   }
   function resize(indexfun, h){
    var
     odata = h[2],
     osize = odata.length - 1,
     nsize = osize * 2 | 0,
     _$_ = nsize < Stdlib_Sys[13] ? 1 : 0;
    if(! _$_) return _$_;
    var ndata = caml_make_vect(nsize, 0), inplace = 1 - ongoing_traversal(h);
    h[2] = ndata;
    return insert_all_buckets(caml_call1(indexfun, h), inplace, odata, ndata);
   }
   function iter(f, h){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], _X_ = d.length - 2 | 0, _W_ = 0;
     if(_X_ >= 0){
      var i = _W_;
      for(;;){
       var param = caml_check_bound(d, i)[1 + i];
       for(;;){
        if(! param) break;
        var key = param[1], data = param[2], next = param[3];
        caml_call2(f, key, data);
        param = next;
       }
       var ___ = i + 1 | 0;
       if(_X_ === i) break;
       i = ___;
      }
     }
     var _Y_ = 1 - old_trav, _Z_ = _Y_ ? flip_ongoing_traversal(h) : _Y_;
     return _Z_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function filter_map_inplace(f, h){
    var d = h[2], old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var _S_ = d.length - 2 | 0, _R_ = 0;
     if(_S_ >= 0){
      var i = _R_;
      for(;;){
       var slot$0 = caml_check_bound(h[2], i)[1 + i], prec = 0, slot = slot$0;
       for(;;){
        if(! slot) break;
        var
         key = slot[1],
         data = slot[2],
         next = slot[3],
         match = caml_call2(f, key, data);
        if(match){
         var data$0 = match[1];
         if(prec)
          prec[3] = slot;
         else
          caml_check_bound(h[2], i)[1 + i] = slot;
         slot[2] = data$0;
         prec = slot;
         slot = next;
        }
        else{h[1] = h[1] - 1 | 0; slot = next;}
       }
       if(prec) prec[3] = 0; else caml_check_bound(h[2], i)[1 + i] = 0;
       var _V_ = i + 1 | 0;
       if(_S_ === i) break;
       i = _V_;
      }
     }
     var _T_ = 1 - old_trav, _U_ = _T_ ? flip_ongoing_traversal(h) : _T_;
     return _U_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function fold(f, h, init){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], accu$1 = [0, init], _O_ = d.length - 2 | 0, _N_ = 0;
     if(_O_ >= 0){
      var i = _N_;
      for(;;){
       var
        accu$2 = accu$1[1],
        b$0 = caml_check_bound(d, i)[1 + i],
        b = b$0,
        accu = accu$2;
       for(;;){
        if(! b) break;
        var
         key = b[1],
         data = b[2],
         next = b[3],
         accu$0 = caml_call3(f, key, data, accu);
        b = next;
        accu = accu$0;
       }
       accu$1[1] = accu;
       var _Q_ = i + 1 | 0;
       if(_O_ === i) break;
       i = _Q_;
      }
     }
     if(1 - old_trav) flip_ongoing_traversal(h);
     var _P_ = accu$1[1];
     return _P_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function bucket_length(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(! param$0) return accu$0;
     var next = param$0[3], accu$1 = accu$0 + 1 | 0;
     accu$0 = accu$1;
     param$0 = next;
    }
   }
   function stats(h){
    var
     mbl =
       caml_call3
        (Stdlib_Array[17],
         function(m, b){
          var _M_ = bucket_length(0, b);
          return caml_call2(Stdlib_Int[11], m, _M_);
         },
         0,
         h[2]),
     histo = caml_make_vect(mbl + 1 | 0, 0);
    caml_call2
     (Stdlib_Array[13],
      function(b){
       var l = bucket_length(0, b);
       histo[1 + l] = caml_check_bound(histo, l)[1 + l] + 1 | 0;
       return 0;
      },
      h[2]);
    return [0, h[1], h[2].length - 1, mbl, histo];
   }
   function to_seq(tbl){
    var tbl_data = tbl[2];
    function aux(i, buck, param){
     var i$0 = i, buck$0 = buck;
     for(;;){
      if(buck$0){
       var key = buck$0[1], data = buck$0[2], next = buck$0[3];
       return [0, [0, key, data], function(_L_){return aux(i$0, next, _L_);}];
      }
      if(i$0 === tbl_data.length - 1) return 0;
      var
       buck$1 = caml_check_bound(tbl_data, i$0)[1 + i$0],
       i$1 = i$0 + 1 | 0;
      i$0 = i$1;
      buck$0 = buck$1;
     }
    }
    var _I_ = 0, _J_ = 0;
    return function(_K_){return aux(_J_, _I_, _K_);};
   }
   function to_seq_keys(m){
    var _G_ = to_seq(m);
    return caml_call2(Stdlib_Seq[27], function(_H_){return _H_[1];}, _G_);
   }
   function to_seq_values(m){
    var _E_ = to_seq(m);
    return caml_call2(Stdlib_Seq[27], function(_F_){return _F_[2];}, _E_);
   }
   function MakeSeeded(H){
    function key_index(h, key){
     var _D_ = h[2].length - 2 | 0;
     return caml_call2(H[2], h[3], key) & _D_;
    }
    function add(h, key, data){
     var
      i = key_index(h, key),
      bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
     caml_check_bound(h[2], i)[1 + i] = bucket;
     h[1] = h[1] + 1 | 0;
     var _C_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
     return _C_ ? resize(key_index, h) : _C_;
    }
    function remove(h, key){
     var
      i = key_index(h, key),
      c = caml_check_bound(h[2], i)[1 + i],
      prec$0 = 0,
      prec = c;
     for(;;){
      if(! prec) return 0;
      var k = prec[1], next = prec[3];
      if(caml_call2(H[1], k, key)){
       h[1] = h[1] - 1 | 0;
       return prec$0
               ? (prec$0[3] = next, 0)
               : (caml_check_bound(h[2], i)[1 + i] = next, 0);
      }
      prec$0 = prec;
      prec = next;
     }
    }
    function find(h, key){
     var
      _B_ = key_index(h, key),
      match = caml_check_bound(h[2], _B_)[1 + _B_];
     if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return d1;
     if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return d2;
     if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return d3;
     var param = next3;
     for(;;){
      if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return data;
      param = next;
     }
    }
    function find_opt(h, key){
     var
      _A_ = key_index(h, key),
      match = caml_check_bound(h[2], _A_)[1 + _A_];
     if(! match) return 0;
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return [0, d1];
     if(! next1) return 0;
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return [0, d2];
     if(! next2) return 0;
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return [0, d3];
     var param = next3;
     for(;;){
      if(! param) return 0;
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return [0, data];
      param = next;
     }
    }
    function find_all(h, key){
     function find_in_bucket(param){
      var param$0 = param;
      for(;;){
       if(! param$0) return 0;
       var k = param$0[1], d = param$0[2], next = param$0[3];
       if(caml_call2(H[1], k, key)) return [0, d, find_in_bucket(next)];
       param$0 = next;
      }
     }
     var _z_ = key_index(h, key);
     return find_in_bucket(caml_check_bound(h[2], _z_)[1 + _z_]);
    }
    function replace(h, key, data){
     var
      i = key_index(h, key),
      l = caml_check_bound(h[2], i)[1 + i],
      slot = l;
     for(;;){
      if(slot){
       var k = slot[1], next = slot[3];
       if(! caml_call2(H[1], k, key)){slot = next; continue;}
       slot[1] = key;
       slot[2] = data;
       var _w_ = 0;
      }
      else
       var _w_ = 1;
      if(_w_){
       caml_check_bound(h[2], i)[1 + i] = [0, key, data, l];
       h[1] = h[1] + 1 | 0;
       var _x_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
       if(_x_) return resize(key_index, h);
       var _y_ = _x_;
      }
      else
       var _y_ = _w_;
      return _y_;
     }
    }
    function mem(h, key){
     var
      _v_ = key_index(h, key),
      param = caml_check_bound(h[2], _v_)[1 + _v_];
     for(;;){
      if(! param) return 0;
      var k = param[1], next = param[3], _u_ = caml_call2(H[1], k, key);
      if(_u_) return _u_;
      param = next;
     }
    }
    function add_seq(tbl, i){
     return caml_call2
             (Stdlib_Seq[4],
              function(param){
               var v = param[2], k = param[1];
               return add(tbl, k, v);
              },
              i);
    }
    function replace_seq(tbl, i){
     return caml_call2
             (Stdlib_Seq[4],
              function(param){
               var v = param[2], k = param[1];
               return replace(tbl, k, v);
              },
              i);
    }
    function of_seq(i){
     var tbl = create(0, 16);
     replace_seq(tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function Make(H){
    var equal = H[1];
    function hash(seed, x){return caml_call1(H[2], x);}
    var
     include = MakeSeeded([0, equal, hash]),
     _t_ = include[1],
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     iter = include[12],
     filter_map_inplace = include[13],
     fold = include[14],
     length = include[15],
     stats = include[16],
     to_seq = include[17],
     to_seq_keys = include[18],
     to_seq_values = include[19],
     add_seq = include[20],
     replace_seq = include[21];
    function create(sz){return caml_call2(_t_, _d_, sz);}
    function of_seq(i){
     var tbl = caml_call2(_t_, _d_, 16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function hash(x){return caml_hash(10, 100, 0, x);}
   function hash_param(n1, n2, x){return caml_hash(n1, n2, 0, x);}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function key_index(h, key){
    return 4 <= h.length - 1
            ? caml_hash(10, 100, h[3], key) & (h[2].length - 2 | 0)
            : caml_call1(Stdlib[1], cst_Hashtbl_unsupported_hash_t);
   }
   function add(h, key, data){
    var
     i = key_index(h, key),
     bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
    caml_check_bound(h[2], i)[1 + i] = bucket;
    h[1] = h[1] + 1 | 0;
    var _s_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
    return _s_ ? resize(key_index, h) : _s_;
   }
   function remove(h, key){
    var
     i = key_index(h, key),
     c = caml_check_bound(h[2], i)[1 + i],
     prec$0 = 0,
     prec = c;
    for(;;){
     if(! prec) return 0;
     var k = prec[1], next = prec[3];
     if(0 === caml_compare(k, key)){
      h[1] = h[1] - 1 | 0;
      return prec$0
              ? (prec$0[3] = next, 0)
              : (caml_check_bound(h[2], i)[1 + i] = next, 0);
     }
     prec$0 = prec;
     prec = next;
    }
   }
   function find(h, key){
    var _r_ = key_index(h, key), match = caml_check_bound(h[2], _r_)[1 + _r_];
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return d1;
    if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return d2;
    if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return d3;
    var param = next3;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return data;
     param = next;
    }
   }
   function find_opt(h, key){
    var _q_ = key_index(h, key), match = caml_check_bound(h[2], _q_)[1 + _q_];
    if(! match) return 0;
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return [0, d1];
    if(! next1) return 0;
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return [0, d2];
    if(! next2) return 0;
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return [0, d3];
    var param = next3;
    for(;;){
     if(! param) return 0;
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return [0, data];
     param = next;
    }
   }
   function find_all(h, key){
    function find_in_bucket(param){
     var param$0 = param;
     for(;;){
      if(! param$0) return 0;
      var k = param$0[1], data = param$0[2], next = param$0[3];
      if(0 === caml_compare(k, key)) return [0, data, find_in_bucket(next)];
      param$0 = next;
     }
    }
    var _p_ = key_index(h, key);
    return find_in_bucket(caml_check_bound(h[2], _p_)[1 + _p_]);
   }
   function replace(h, key, data){
    var i = key_index(h, key), l = caml_check_bound(h[2], i)[1 + i], slot = l;
    for(;;){
     if(slot){
      var k = slot[1], next = slot[3];
      if(0 !== caml_compare(k, key)){slot = next; continue;}
      slot[1] = key;
      slot[2] = data;
      var _m_ = 0;
     }
     else
      var _m_ = 1;
     if(_m_){
      caml_check_bound(h[2], i)[1 + i] = [0, key, data, l];
      h[1] = h[1] + 1 | 0;
      var _n_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
      if(_n_) return resize(key_index, h);
      var _o_ = _n_;
     }
     else
      var _o_ = _m_;
     return _o_;
    }
   }
   function mem(h, key){
    var _l_ = key_index(h, key), param = caml_check_bound(h[2], _l_)[1 + _l_];
    for(;;){
     if(! param) return 0;
     var
      k = param[1],
      next = param[3],
      _k_ = 0 === caml_compare(k, key) ? 1 : 0;
     if(_k_) return _k_;
     param = next;
    }
   }
   function add_seq(tbl, i){
    return caml_call2
            (Stdlib_Seq[4],
             function(param){
              var v = param[2], k = param[1];
              return add(tbl, k, v);
             },
             i);
   }
   function replace_seq(tbl, i){
    return caml_call2
            (Stdlib_Seq[4],
             function(param){
              var v = param[2], k = param[1];
              return replace(tbl, k, v);
             },
             i);
   }
   function of_seq(i){
    var tbl = create(0, 16);
    replace_seq(tbl, i);
    return tbl;
   }
   function rebuild(opt, h){
    if(opt) var sth = opt[1], random = sth; else var random = randomized[1];
    var s = power_2_above(16, h[2].length - 1);
    if(random)
     var
      _g_ = caml_obj_tag(prng),
      _h_ =
        250 === _g_
         ? prng[1]
         : 246 === _g_ ? caml_call1(CamlinternalLazy[2], prng) : prng,
      seed = caml_call1(Stdlib_Random[15][4], _h_);
    else
     var seed = 4 <= h.length - 1 ? h[3] : 0;
    var
     _i_ = 4 <= h.length - 1 ? h[4] : s,
     h$0 = [0, h[1], caml_make_vect(s, 0), seed, _i_];
    insert_all_buckets
     (function(_j_){return key_index(h$0, _j_);}, 0, h[2], h$0[2]);
    return h$0;
   }
   var
    Stdlib_Hashtbl =
      [0,
       create,
       clear,
       reset,
       copy,
       add,
       find,
       find_opt,
       find_all,
       mem,
       remove,
       replace,
       iter,
       filter_map_inplace,
       fold,
       length,
       randomize,
       is_randomized,
       rebuild,
       stats,
       to_seq,
       to_seq_keys,
       to_seq_values,
       add_seq,
       replace_seq,
       of_seq,
       Make,
       MakeSeeded,
       hash,
       seeded_hash,
       hash_param,
       caml_hash];
   runtime.caml_register_global(15, Stdlib_Hashtbl, "Stdlib__Hashtbl");
   return;
  }
  (globalThis));

//# 22408 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_register_named_value = runtime.caml_register_named_value,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    register = caml_register_named_value;
   function register_exception(name, exn){
    var
     _a_ = Stdlib_Obj[8],
     slot = runtime.caml_obj_tag(exn) === _a_ ? exn : exn[1];
    return caml_register_named_value(name, slot);
   }
   var Stdlib_Callback = [0, register, register_exception];
   runtime.caml_register_global(1, Stdlib_Callback, "Stdlib__Callback");
   return;
  }
  (globalThis));

//# 22431 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_camlinternalOO_ml = "camlinternalOO.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_get_public_method = runtime.caml_get_public_method,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_block = runtime.caml_obj_block,
    caml_set_oo_id = runtime.caml_set_oo_id,
    caml_string_compare = runtime.caml_string_compare,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Map = global_data.Stdlib__Map;
   function copy(o){var o$0 = o.slice(); return caml_set_oo_id(o$0);}
   var params = [0, 1, 1, 1, 3, 16];
   function public_method_label(s){
    var
     accu = [0, 0],
     _al_ = runtime.caml_ml_string_length(s) - 1 | 0,
     _ak_ = 0;
    if(_al_ >= 0){
     var i = _ak_;
     for(;;){
      var _am_ = runtime.caml_string_get(s, i);
      accu[1] = (223 * accu[1] | 0) + _am_ | 0;
      var _an_ = i + 1 | 0;
      if(_al_ === i) break;
      i = _an_;
     }
    }
    accu[1] = accu[1] & 2147483647;
    var tag = 1073741823 < accu[1] ? accu[1] + 2147483648 | 0 : accu[1];
    return tag;
   }
   var
    compare = caml_string_compare,
    Vars = caml_call1(Stdlib_Map[1], [0, compare]),
    compare$0 = caml_string_compare,
    Meths = caml_call1(Stdlib_Map[1], [0, compare$0]),
    compare$1 = runtime.caml_int_compare,
    Labs = caml_call1(Stdlib_Map[1], [0, compare$1]),
    dummy_table = [0, 0, [0, 0], Meths[1], Labs[1], 0, 0, Vars[1], 0],
    table_count = [0, 0],
    dummy_met = caml_obj_block(0, 0),
    initial_object_size = 2;
   function fit_size(n){
    return 2 < n ? fit_size((n + 1 | 0) / 2 | 0) * 2 | 0 : n;
   }
   function new_table(pub_labels){
    table_count[1]++;
    var
     len = pub_labels.length - 1,
     methods = caml_make_vect((len * 2 | 0) + 2 | 0, dummy_met);
    caml_check_bound(methods, 0)[1] = len;
    var
     _ad_ = Stdlib_Sys[9],
     _ae_ = (runtime.caml_mul(fit_size(len), _ad_) / 8 | 0) - 1 | 0;
    caml_check_bound(methods, 1)[2] = _ae_;
    var _ag_ = len - 1 | 0, _af_ = 0;
    if(_ag_ >= 0){
     var i = _af_;
     for(;;){
      var
       _ai_ = (i * 2 | 0) + 3 | 0,
       _ah_ = caml_check_bound(pub_labels, i)[1 + i];
      caml_check_bound(methods, _ai_)[1 + _ai_] = _ah_;
      var _aj_ = i + 1 | 0;
      if(_ag_ === i) break;
      i = _aj_;
     }
    }
    return [0,
            initial_object_size,
            methods,
            Meths[1],
            Labs[1],
            0,
            0,
            Vars[1],
            0];
   }
   function resize(array, new_size){
    var old_size = array[2].length - 1, _ab_ = old_size < new_size ? 1 : 0;
    if(_ab_){
     var new_buck = caml_make_vect(new_size, dummy_met);
     caml_call5(Stdlib_Array[10], array[2], 0, new_buck, 0, old_size);
     array[2] = new_buck;
     var _ac_ = 0;
    }
    else
     var _ac_ = _ab_;
    return _ac_;
   }
   var
    method_count = [0, 0],
    inst_var_count = [0, 0],
    _a_ = [0, cst_camlinternalOO_ml, 281, 50],
    _b_ = [0, cst_camlinternalOO_ml, 409, 13],
    _c_ = [0, cst_camlinternalOO_ml, 412, 13],
    _d_ = [0, cst_camlinternalOO_ml, 415, 13],
    _e_ = [0, cst_camlinternalOO_ml, 418, 13],
    _f_ = [0, cst_camlinternalOO_ml, 421, 13],
    _g_ = [0, cst_camlinternalOO_ml, 439, 17];
   function new_method(table){
    var index = table[2].length - 1;
    resize(table, index + 1 | 0);
    return index;
   }
   function get_method_label(table, name){
    try{var _$_ = caml_call2(Meths[28], name, table[3]); return _$_;}
    catch(_aa_){
     var ___ = caml_wrap_exception(_aa_);
     if(___ !== Stdlib[8]) throw caml_maybe_attach_backtrace(___, 0);
     var label = new_method(table);
     table[3] = caml_call3(Meths[4], name, label, table[3]);
     table[4] = caml_call3(Labs[4], label, 1, table[4]);
     return label;
    }
   }
   function get_method_labels(table, names){
    return caml_call2
            (Stdlib_Array[15],
             function(_Z_){return get_method_label(table, _Z_);},
             names);
   }
   function set_method(table, label, element){
    method_count[1]++;
    return caml_call2(Labs[28], label, table[4])
            ? (resize
               (table, label + 1 | 0),
              caml_check_bound(table[2], label)[1 + label] = element,
              0)
            : (table[6] = [0, [0, label, element], table[6]], 0);
   }
   function get_method(table, label){
    try{var _X_ = caml_call2(Stdlib_List[46], label, table[6]); return _X_;}
    catch(_Y_){
     var _W_ = caml_wrap_exception(_Y_);
     if(_W_ === Stdlib[8])
      return caml_check_bound(table[2], label)[1 + label];
     throw caml_maybe_attach_backtrace(_W_, 0);
    }
   }
   function to_list(arr){
    return 0 === arr ? 0 : caml_call1(Stdlib_Array[11], arr);
   }
   function narrow(table, vars, virt_meths, concr_meths){
    var
     vars$0 = to_list(vars),
     virt_meths$0 = to_list(virt_meths),
     concr_meths$0 = to_list(concr_meths),
     virt_meth_labs =
       caml_call2
        (Stdlib_List[19],
         function(_V_){return get_method_label(table, _V_);},
         virt_meths$0),
     concr_meth_labs =
       caml_call2
        (Stdlib_List[19],
         function(_U_){return get_method_label(table, _U_);},
         concr_meths$0);
    table[5] =
     [0,
      [0, table[3], table[4], table[6], table[7], virt_meth_labs, vars$0],
      table[5]];
    table[7] =
     caml_call3
      (Vars[13],
       function(lab, info, tvars){
        return caml_call2(Stdlib_List[36], lab, vars$0)
                ? caml_call3(Vars[4], lab, info, tvars)
                : tvars;
       },
       table[7],
       Vars[1]);
    var by_name = [0, Meths[1]], by_label = [0, Labs[1]];
    caml_call3
     (Stdlib_List[27],
      function(met, label){
       by_name[1] = caml_call3(Meths[4], met, label, by_name[1]);
       var _P_ = by_label[1];
       try{var _S_ = caml_call2(Labs[28], label, table[4]), _R_ = _S_;}
       catch(_T_){
        var _Q_ = caml_wrap_exception(_T_);
        if(_Q_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_Q_, 0);
        var _R_ = 1;
       }
       by_label[1] = caml_call3(Labs[4], label, _R_, _P_);
       return 0;
      },
      concr_meths$0,
      concr_meth_labs);
    caml_call3
     (Stdlib_List[27],
      function(met, label){
       by_name[1] = caml_call3(Meths[4], met, label, by_name[1]);
       by_label[1] = caml_call3(Labs[4], label, 0, by_label[1]);
       return 0;
      },
      virt_meths$0,
      virt_meth_labs);
    table[3] = by_name[1];
    table[4] = by_label[1];
    table[6] =
     caml_call3
      (Stdlib_List[26],
       function(met, hm){
        var lab = met[1];
        return caml_call2(Stdlib_List[36], lab, virt_meth_labs)
                ? hm
                : [0, met, hm];
       },
       table[6],
       0);
    return 0;
   }
   function widen(table){
    var
     match = caml_call1(Stdlib_List[5], table[5]),
     vars = match[6],
     virt_meths = match[5],
     saved_vars = match[4],
     saved_hidden_meths = match[3],
     by_label = match[2],
     by_name = match[1];
    table[5] = caml_call1(Stdlib_List[6], table[5]);
    table[7] =
     caml_call3
      (Stdlib_List[25],
       function(s, v){
        var _O_ = caml_call2(Vars[28], v, table[7]);
        return caml_call3(Vars[4], v, _O_, s);
       },
       saved_vars,
       vars);
    table[3] = by_name;
    table[4] = by_label;
    table[6] =
     caml_call3
      (Stdlib_List[26],
       function(met, hm){
        var lab = met[1];
        return caml_call2(Stdlib_List[36], lab, virt_meths)
                ? hm
                : [0, met, hm];
       },
       table[6],
       saved_hidden_meths);
    return 0;
   }
   function new_variable(table, name){
    try{var _M_ = caml_call2(Vars[28], name, table[7]); return _M_;}
    catch(_N_){
     var _L_ = caml_wrap_exception(_N_);
     if(_L_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_L_, 0);
     var index = table[1];
     table[1] = index + 1 | 0;
     if(name !== "") table[7] = caml_call3(Vars[4], name, index, table[7]);
     return index;
    }
   }
   function to_array(arr){return runtime.caml_equal(arr, 0) ? [0] : arr;}
   function new_methods_variables(table, meths, vals){
    var
     meths$0 = to_array(meths),
     nmeths = meths$0.length - 1,
     nvals = vals.length - 1,
     res = caml_make_vect(nmeths + nvals | 0, 0),
     _D_ = nmeths - 1 | 0,
     _C_ = 0;
    if(_D_ >= 0){
     var i$0 = _C_;
     for(;;){
      var
       _J_ = get_method_label(table, caml_check_bound(meths$0, i$0)[1 + i$0]);
      caml_check_bound(res, i$0)[1 + i$0] = _J_;
      var _K_ = i$0 + 1 | 0;
      if(_D_ === i$0) break;
      i$0 = _K_;
     }
    }
    var _F_ = nvals - 1 | 0, _E_ = 0;
    if(_F_ >= 0){
     var i = _E_;
     for(;;){
      var
       _H_ = i + nmeths | 0,
       _G_ = new_variable(table, caml_check_bound(vals, i)[1 + i]);
      caml_check_bound(res, _H_)[1 + _H_] = _G_;
      var _I_ = i + 1 | 0;
      if(_F_ === i) break;
      i = _I_;
     }
    }
    return res;
   }
   function get_variable(table, name){
    try{var _A_ = caml_call2(Vars[28], name, table[7]); return _A_;}
    catch(_B_){
     var _z_ = caml_wrap_exception(_B_);
     if(_z_ === Stdlib[8])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     throw caml_maybe_attach_backtrace(_z_, 0);
    }
   }
   function get_variables(table, names){
    return caml_call2
            (Stdlib_Array[15],
             function(_y_){return get_variable(table, _y_);},
             names);
   }
   function add_initializer(table, f){table[8] = [0, f, table[8]]; return 0;}
   function create_table(public_methods){
    if(0 === public_methods) return new_table([0]);
    var
     tags = caml_call2(Stdlib_Array[15], public_method_label, public_methods),
     table = new_table(tags);
    caml_call2
     (Stdlib_Array[14],
      function(i, met){
       var lab = (i * 2 | 0) + 2 | 0;
       table[3] = caml_call3(Meths[4], met, lab, table[3]);
       table[4] = caml_call3(Labs[4], lab, 1, table[4]);
       return 0;
      },
      public_methods);
    return table;
   }
   function init_class(table){
    inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
    table[8] = caml_call1(Stdlib_List[9], table[8]);
    var _x_ = Stdlib_Sys[9];
    return resize
            (table,
             3 + caml_div(caml_check_bound(table[2], 1)[2] * 16 | 0, _x_) | 0);
   }
   function inherits(cla, vals, virt_meths, concr_meths, param, top){
    var env = param[4], super$0 = param[2];
    narrow(cla, vals, virt_meths, concr_meths);
    var init = top ? caml_call2(super$0, cla, env) : caml_call1(super$0, cla);
    widen(cla);
    var
     _s_ = to_array(concr_meths),
     _t_ =
       [0,
        caml_call2
         (Stdlib_Array[15],
          function(nm){return get_method(cla, get_method_label(cla, nm));},
          _s_),
        0],
     _u_ = to_array(vals),
     _v_ =
       [0,
        [0, init],
        [0,
         caml_call2
          (Stdlib_Array[15],
           function(_w_){return get_variable(cla, _w_);},
           _u_),
         _t_]];
    return caml_call1(Stdlib_Array[6], _v_);
   }
   function make_class(pub_meths, class_init){
    var
     table = create_table(pub_meths),
     env_init = caml_call1(class_init, table);
    init_class(table);
    return [0, caml_call1(env_init, 0), class_init, env_init, 0];
   }
   function make_class_store(pub_meths, class_init, init_table){
    var
     table = create_table(pub_meths),
     env_init = caml_call1(class_init, table);
    init_class(table);
    init_table[2] = class_init;
    init_table[1] = env_init;
    return 0;
   }
   function dummy_class(loc){
    function undef(param){
     throw caml_maybe_attach_backtrace([0, Stdlib[15], loc], 1);
    }
    return [0, undef, undef, undef, 0];
   }
   function create_object(table){
    var obj = caml_obj_block(Stdlib_Obj[8], table[1]);
    obj[1] = table[2];
    return caml_set_oo_id(obj);
   }
   function create_object_opt(obj_0, table){
    if(obj_0) return obj_0;
    var obj = caml_obj_block(Stdlib_Obj[8], table[1]);
    obj[1] = table[2];
    return caml_set_oo_id(obj);
   }
   function iter_f(obj, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], f = param$0[1];
     caml_call1(f, obj);
     param$0 = l;
    }
   }
   function run_initializers(obj, table){
    var inits = table[8], _r_ = 0 !== inits ? 1 : 0;
    return _r_ ? iter_f(obj, inits) : _r_;
   }
   function run_initializers_opt(obj_0, obj, table){
    if(obj_0) return obj;
    var inits = table[8];
    if(0 !== inits) iter_f(obj, inits);
    return obj;
   }
   function create_object_and_run_initiali(obj_0, table){
    if(obj_0) return obj_0;
    var obj = create_object(table);
    run_initializers(obj, table);
    return obj;
   }
   function get_data(param){
    if(param) return param[2];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function build_path(n, keys, tables){
    var res = [0, 0, 0, 0], r = [0, res], _o_ = 0;
    if(n >= 0){
     var i = _o_;
     for(;;){
      var _p_ = r[1];
      r[1] = [0, caml_check_bound(keys, i)[1 + i], _p_, 0];
      var _q_ = i + 1 | 0;
      if(n === i) break;
      i = _q_;
     }
    }
    var v = r[1];
    if(! tables)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    tables[2] = v;
    return res;
   }
   function lookup_tables(root, keys){
    var root_data = get_data(root);
    if(! root_data) return build_path(keys.length - 2 | 0, keys, root);
    var i$1 = keys.length - 2 | 0, i = i$1, tables$0 = root_data;
    for(;;){
     if(0 > i) return tables$0;
     var key = caml_check_bound(keys, i)[1 + i], tables$1 = tables$0;
     for(;;){
      if(! tables$1)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      if(tables$1[1] === key) break;
      if(! tables$1)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
      var tables = tables$1[3];
      if(! tables){
       var next = [0, key, 0, 0];
       if(! tables$1)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       tables$1[3] = next;
       return build_path(i - 1 | 0, keys, next);
      }
      tables$1 = tables;
     }
     var tables_data = get_data(tables$1);
     if(! tables_data)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     var i$0 = i - 1 | 0;
     i = i$0;
     tables$0 = tables_data;
    }
   }
   function new_cache(table){
    var n = new_method(table);
    a:
    {
     if(0 !== (n % 2 | 0)){
      var _n_ = Stdlib_Sys[9];
      if
       ((2 + caml_div(caml_check_bound(table[2], 1)[2] * 16 | 0, _n_) | 0)
        >= n){
       var n$0 = new_method(table);
       break a;
      }
     }
     var n$0 = n;
    }
    caml_check_bound(table[2], n$0)[1 + n$0] = 0;
    return n$0;
   }
   function set_methods(table, methods){
    var len = methods.length - 1, i = [0, 0];
    for(;;){
     if(i[1] >= len) return 0;
     var
      _h_ = i[1],
      label = caml_check_bound(methods, _h_)[1 + _h_],
      next =
        function(param){
         i[1]++;
         var _m_ = i[1];
         return caml_check_bound(methods, _m_)[1 + _m_];
        },
      clo = next(0);
     if(typeof clo === "number")
      switch(clo){
        case 0:
         var x = next(0);
         let x$20 = x;
         var clo$0 = function(obj){return x$20;};
         break;
        case 1:
         var n = next(0);
         let n$38 = n;
         var clo$0 = function(obj){return obj[1 + n$38];};
         break;
        case 2:
         var e = next(0), n$0 = next(0);
         let e$10 = e, n$37 = n$0;
         var clo$0 = function(obj){return obj[1 + e$10][1 + n$37];};
         break;
        case 3:
         var n$1 = next(0);
         let n$36 = n$1;
         var clo$0 = function(obj){return caml_call1(obj[1][1 + n$36], obj);};
         break;
        case 4:
         var n$2 = next(0);
         let n$35 = n$2;
         var clo$0 = function(obj, x){obj[1 + n$35] = x; return 0;};
         break;
        case 5:
         var f = next(0), x$0 = next(0);
         let f$20 = f, x$19 = x$0;
         var clo$0 = function(obj){return caml_call1(f$20, x$19);};
         break;
        case 6:
         var f$0 = next(0), n$3 = next(0);
         let f$19 = f$0, n$34 = n$3;
         var clo$0 = function(obj){return caml_call1(f$19, obj[1 + n$34]);};
         break;
        case 7:
         var f$1 = next(0), e$0 = next(0), n$4 = next(0);
         let f$18 = f$1, e$9 = e$0, n$33 = n$4;
         var
          clo$0 =
            function(obj){return caml_call1(f$18, obj[1 + e$9][1 + n$33]);};
         break;
        case 8:
         var f$2 = next(0), n$5 = next(0);
         let f$17 = f$2, n$32 = n$5;
         var
          clo$0 =
            function(obj){
             return caml_call1(f$17, caml_call1(obj[1][1 + n$32], obj));
            };
         break;
        case 9:
         var f$3 = next(0), x$1 = next(0), y = next(0);
         let f$16 = f$3, x$18 = x$1, y$0 = y;
         var clo$0 = function(obj){return caml_call2(f$16, x$18, y$0);};
         break;
        case 10:
         var f$4 = next(0), x$2 = next(0), n$6 = next(0);
         let f$15 = f$4, x$17 = x$2, n$31 = n$6;
         var
          clo$0 = function(obj){return caml_call2(f$15, x$17, obj[1 + n$31]);};
         break;
        case 11:
         var f$5 = next(0), x$3 = next(0), e$1 = next(0), n$7 = next(0);
         let f$14 = f$5, x$16 = x$3, e$8 = e$1, n$30 = n$7;
         var
          clo$0 =
            function(obj){
             return caml_call2(f$14, x$16, obj[1 + e$8][1 + n$30]);
            };
         break;
        case 12:
         var f$6 = next(0), x$4 = next(0), n$8 = next(0);
         let f$13 = f$6, x$15 = x$4, n$29 = n$8;
         var
          clo$0 =
            function(obj){
             return caml_call2(f$13, x$15, caml_call1(obj[1][1 + n$29], obj));
            };
         break;
        case 13:
         var f$7 = next(0), n$9 = next(0), x$5 = next(0);
         let f$12 = f$7, n$28 = n$9, x$14 = x$5;
         var
          clo$0 = function(obj){return caml_call2(f$12, obj[1 + n$28], x$14);};
         break;
        case 14:
         var f$8 = next(0), e$2 = next(0), n$10 = next(0), x$6 = next(0);
         let f$11 = f$8, e$7 = e$2, n$27 = n$10, x$13 = x$6;
         var
          clo$0 =
            function(obj){
             return caml_call2(f$11, obj[1 + e$7][1 + n$27], x$13);
            };
         break;
        case 15:
         var f$9 = next(0), n$11 = next(0), x$7 = next(0);
         let f$10 = f$9, n$26 = n$11, x$12 = x$7;
         var
          clo$0 =
            function(obj){
             return caml_call2(f$10, caml_call1(obj[1][1 + n$26], obj), x$12);
            };
         break;
        case 16:
         var n$12 = next(0), x$8 = next(0);
         let n$25 = n$12, x$11 = x$8;
         var
          clo$0 =
            function(obj){return caml_call2(obj[1][1 + n$25], obj, x$11);};
         break;
        case 17:
         var n$13 = next(0), m = next(0);
         let n$24 = n$13, m$12 = m;
         var
          clo$0 =
            function(obj){
             return caml_call2(obj[1][1 + n$24], obj, obj[1 + m$12]);
            };
         break;
        case 18:
         var n$14 = next(0), e$3 = next(0), m$0 = next(0);
         let n$23 = n$14, e$6 = e$3, m$11 = m$0;
         var
          clo$0 =
            function(obj){
             return caml_call2(obj[1][1 + n$23], obj, obj[1 + e$6][1 + m$11]);
            };
         break;
        case 19:
         var n$15 = next(0), m$1 = next(0);
         let n$22 = n$15, m$10 = m$1;
         var
          clo$0 =
            function(obj){
             var _l_ = caml_call1(obj[1][1 + m$10], obj);
             return caml_call2(obj[1][1 + n$22], obj, _l_);
            };
         break;
        case 20:
         var m$2 = next(0), x$9 = next(0);
         new_cache(table);
         let m$9 = m$2, x$10 = x$9;
         var
          clo$0 =
            function(obj){
             return caml_call1(caml_get_public_method(x$10, m$9, 0), x$10);
            };
         break;
        case 21:
         var m$3 = next(0), n$16 = next(0);
         new_cache(table);
         let m$8 = m$3, n$21 = n$16;
         var
          clo$0 =
            function(obj){
             var _k_ = obj[1 + n$21];
             return caml_call1(caml_get_public_method(_k_, m$8, 0), _k_);
            };
         break;
        case 22:
         var m$4 = next(0), e$4 = next(0), n$17 = next(0);
         new_cache(table);
         let m$7 = m$4, e$5 = e$4, n$20 = n$17;
         var
          clo$0 =
            function(obj){
             var _j_ = obj[1 + e$5][1 + n$20];
             return caml_call1(caml_get_public_method(_j_, m$7, 0), _j_);
            };
         break;
        default:
         var m$5 = next(0), n$18 = next(0);
         new_cache(table);
         let m$6 = m$5, n$19 = n$18;
         var
          clo$0 =
            function(obj){
             var _i_ = caml_call1(obj[1][1 + n$19], obj);
             return caml_call1(caml_get_public_method(_i_, m$6, 0), _i_);
            };
      }
     else
      var clo$0 = clo;
     set_method(table, label, clo$0);
     i[1]++;
    }
   }
   function stats(param){
    return [0, table_count[1], method_count[1], inst_var_count[1]];
   }
   var
    CamlinternalOO =
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initiali,
       lookup_tables,
       params,
       stats];
   runtime.caml_register_global(17, CamlinternalOO, "CamlinternalOO");
   return;
  }
  (globalThis));


//# 1 "../../.js/default/js_of_ocaml-compiler.runtime/jsoo_runtime.cma.js"
// Generated by js_of_ocaml
//# 3 "../../.js/default/js_of_ocaml-compiler.runtime/jsoo_runtime.cma.js"

//# 18 "../../.js/default/js_of_ocaml-compiler.runtime/jsoo_runtime.cma.js"
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    s = "5.8.2",
    git_version = "",
    Jsoo_runtime_Runtime_version = [0, s, git_version];
   runtime.caml_register_global
    (2, Jsoo_runtime_Runtime_version, "Jsoo_runtime__Runtime_version");
   return;
  }
  (globalThis));

//# 33 "../../.js/default/js_of_ocaml-compiler.runtime/jsoo_runtime.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Jsoo_runtime_Runtime_version = global_data.Jsoo_runtime__Runtime_version,
    Stdlib_Callback = global_data.Stdlib__Callback,
    Js = [0],
    Config = [0],
    version = Jsoo_runtime_Runtime_version[1],
    git_version = Jsoo_runtime_Runtime_version[2],
    Sys = [0, Config, version, git_version],
    Exn = [248, "Jsoo_runtime.Error.Exn", runtime.caml_fresh_oo_id(0)];
   caml_call2(Stdlib_Callback[2], "jsError", [0, Exn, [0]]);
   function raise(exn){throw exn;}
   var
    Error =
      [0,
       raise,
       runtime.caml_exn_with_js_backtrace,
       runtime.caml_js_error_option_of_exception,
       Exn],
    For_compatibility_only = [0],
    Bigstring = [0],
    Typed_array = [0, Bigstring],
    Int64 = [0],
    Jsoo_runtime =
      [0, Js, Sys, Error, For_compatibility_only, Typed_array, Int64];
   runtime.caml_register_global(5, Jsoo_runtime, "Jsoo_runtime");
   return;
  }
  (globalThis));


//# 1 "../../.js/default/ojs/ojs.cma.js"
// Generated by js_of_ocaml
//# 3 "../../.js/default/ojs/ojs.cma.js"

//# 6 "../../.js/default/ojs/ojs.cma.js"
(function
  (globalThis){
   "use strict";
   var
    joo_global_object = globalThis,
    runtime = globalThis.jsoo_runtime,
    cst_to_js$0 = "to_js",
    caml_js_from_string = runtime.caml_js_from_string,
    caml_js_get = runtime.caml_js_get,
    caml_js_set = runtime.caml_js_set,
    caml_js_to_bool = runtime.caml_js_to_bool,
    caml_js_to_string = runtime.caml_js_to_string;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    shared = [0, cst_to_js$0],
    CamlinternalOO = global_data.CamlinternalOO,
    Stdlib_Array = global_data.Stdlib__Array;
   function type_of(x){return caml_js_to_string(typeof x);}
   function instance_of(x, constr){return (x instanceof constr ? 1 : 0) | 0;}
   var null$0 = null, undefined$0 = undefined, global = joo_global_object;
   function array_make(n){return new global["Array"](n);}
   var
    array_get = caml_js_get,
    array_set = caml_js_set,
    cst_to_js = cst_to_js$0;
   function array_of_js_from(f, objs, start){
    var n = objs["length"];
    return caml_call2
            (Stdlib_Array[2],
             n - start | 0,
             function(i){
              var i$0 = start + i | 0;
              return caml_call1(f, objs[i$0]);
             });
   }
   function array_of_js(f, objs){return array_of_js_from(f, objs, 0);}
   function array_to_js(f, arr){
    var n = arr.length - 1, a = array_make(n), _C_ = n - 1 | 0, _B_ = 0;
    if(_C_ >= 0){
     var i = _B_;
     for(;;){
      var x = caml_call1(f, runtime.caml_check_bound(arr, i)[1 + i]);
      a[i] = x;
      var _D_ = i + 1 | 0;
      if(_C_ === i) break;
      i = _D_;
     }
    }
    return a;
   }
   function list_of_js_from(f, objs, start){
    var _A_ = array_of_js_from(f, objs, start);
    return caml_call1(Stdlib_Array[11], _A_);
   }
   function list_of_js(f, objs){return list_of_js_from(f, objs, 0);}
   function list_to_js(f, l){
    return array_to_js(f, caml_call1(Stdlib_Array[12], l));
   }
   function option_of_js(f, x){
    if(x != null$0 && x !== undefined$0) return [0, caml_call1(f, x)];
    return 0;
   }
   function option_to_js(f, param){
    if(! param) return null$0;
    var x = param[1];
    return caml_call1(f, x);
   }
   function unit_to_js(param){return undefined$0;}
   function unit_of_js(param){return 0;}
   var
    obj =
      caml_call2
       (CamlinternalOO[19],
        shared,
        function(_t_){
         var
          _u_ = caml_call2(CamlinternalOO[3], _t_, cst),
          _v_ = caml_call2(CamlinternalOO[7], _t_, cst_to_js);
         caml_call3
          (CamlinternalOO[10],
           _t_,
           _v_,
           function(self_1){return self_1[1 + _u_];});
         return function(_y_, _x_, _w_){
          var _z_ = caml_call2(CamlinternalOO[24], _x_, _t_);
          _z_[1 + _u_] = _w_;
          return _z_;};
        });
   function has_property(o, x){
    var _q_ = type_of(o) == "object" ? 1 : 0;
    if(_q_)
     var
      _r_ = o !== null$0 ? 1 : 0,
      _s_ = _r_ ? o[caml_js_from_string(x)] !== undefined$0 ? 1 : 0 : _r_;
    else
     var _s_ = _q_;
    return _s_;
   }
   function empty_obj(param){return new global["Object"];}
   function iter_properties(x, f){
    return runtime.caml_ojs_iterate_properties
            (x,
             runtime.caml_js_wrap_callback_strict
              (1, function(x){return caml_call1(f, caml_js_to_string(x));}));
   }
   function apply_arr(o, arr){return o.apply(null$0, arr);}
   function call_arr(o, s, arr){
    return o[caml_js_from_string(s)].apply(o, arr);
   }
   function is_null(x){return x == null$0 ? 1 : 0;}
   function obj_type(x){
    return caml_js_to_string(Object.prototype.toString.call(x));
   }
   function t_to_js(_p_){return _p_;}
   function t_of_js(_o_){return _o_;}
   var
    Int = [0, t_to_js, t_of_js],
    t_to_js$0 = caml_js_from_string,
    t_of_js$0 = caml_js_to_string,
    String = [0, t_to_js$0, t_of_js$0],
    t_to_js$1 = runtime.caml_js_from_bool,
    t_of_js$1 = caml_js_to_bool,
    Bool = [0, t_to_js$1, t_of_js$1];
   function t_to_js$2(_n_){return _n_;}
   function t_of_js$2(_m_){return _m_;}
   var Float = [0, t_to_js$2, t_of_js$2];
   function Array(A){
    var _i_ = A[1];
    function t_to_js(_l_){return array_to_js(_i_, _l_);}
    var _j_ = A[2];
    function t_of_js(_k_){return array_of_js(_j_, _k_);}
    return [0, t_to_js, t_of_js];
   }
   function List(A){
    var _e_ = A[1];
    function t_to_js(_h_){return list_to_js(_e_, _h_);}
    var _f_ = A[2];
    function t_of_js(_g_){return list_of_js(_f_, _g_);}
    return [0, t_to_js, t_of_js];
   }
   function Option(A){
    var _a_ = A[1];
    function t_to_js(_d_){return option_to_js(_a_, _d_);}
    var _b_ = A[2];
    function t_of_js(_c_){return option_of_js(_b_, _c_);}
    return [0, t_to_js, t_of_js];
   }
   var
    Ojs =
      [0,
       array_of_js,
       array_to_js,
       list_of_js,
       list_to_js,
       array_of_js_from,
       list_of_js_from,
       option_of_js,
       option_to_js,
       unit_of_js,
       unit_to_js,
       empty_obj,
       has_property,
       iter_properties,
       call_arr,
       apply_arr,
       array_make,
       array_get,
       array_set,
       global,
       null$0,
       type_of,
       instance_of,
       obj,
       is_null,
       obj_type,
       Int,
       String,
       Bool,
       Float,
       Array,
       List,
       Option];
   runtime.caml_register_global(16, Ojs, "Ojs");
   return;
  }
  (globalThis));

//# 211 "../../.js/default/ojs/ojs.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_js_to_string = runtime.caml_js_to_string;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ojs = global_data.Ojs,
    Jsoo_runtime = global_data.Jsoo_runtime,
    Stdlib_Printexc = global_data.Stdlib__Printexc;
   function name(x){return caml_js_to_string(x["name"]);}
   function message(x){return caml_js_to_string(x["message"]);}
   function stack(x){
    var _a_ = x["stack"];
    return caml_call2(Ojs[7], caml_js_to_string, _a_);
   }
   function to_string(x){return caml_js_to_string(x.toString());}
   var Error = Jsoo_runtime[3][4];
   caml_call1
    (Stdlib_Printexc[9],
     function(param){
      if(param[1] !== Error) return 0;
      var x = param[2];
      return [0, to_string(x)];
     });
   var Ojs_exn = [0, name, message, stack, to_string, Error];
   runtime.caml_register_global(7, Ojs_exn, "Ojs_exn");
   return;
  }
  (globalThis));


//# 1 "../../.js/default/vdom.base/vdom_base.cma.js"
// Generated by js_of_ocaml
//# 3 "../../.js/default/vdom.base/vdom_base.cma.js"

//# 6 "../../.js/default/vdom.base/vdom_base.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = "",
    cst_altKey = "altKey",
    cst_autofocus$0 = "autofocus",
    cst_change$1 = "change",
    cst_className$1 = "className",
    cst_click$2 = "click",
    cst_ctrlKey = "ctrlKey",
    cst_currentTarget = "currentTarget",
    cst_input$1 = "input",
    cst_keydown$1 = "keydown",
    cst_keyup$1 = "keyup",
    cst_mousedown$1 = "mousedown",
    cst_shiftKey = "shiftKey",
    cst_target = "target",
    cst_target_value = "target.value",
    caml_equal = runtime.caml_equal,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    x = "&quote;",
    cst$0 = ":",
    cst$1 = ";",
    cst$2 = " ",
    cst$3 = "/>",
    cst$4 = "<\/",
    cst = cst$5,
    key$24 = "target.checked",
    key$23 = "target.selectedIndex",
    key$22 = cst_target_value,
    key$21 = cst_target_value,
    key$19 = cst_target,
    key$20 = cst_currentTarget,
    key$17 = cst_target,
    key$18 = cst_currentTarget,
    key$1 = "left",
    key$2 = "top",
    name = "getBoundingClientRect",
    key$3 = cst_currentTarget,
    key = "clientX",
    key$0 = "clientY",
    key$4 = "pageX",
    key$5 = "pageY",
    key$6 = "buttons",
    key$7 = cst_altKey,
    key$8 = cst_ctrlKey,
    key$9 = cst_shiftKey,
    key$10 = "which",
    key$11 = cst_altKey,
    key$12 = cst_ctrlKey,
    key$13 = cst_shiftKey,
    arg = [0, [0, "text"], 0],
    name$0 = "getData",
    key$14 = "clipboardData",
    key$15 = "currentTarget.selectionStart",
    key$16 = "currentTarget.selectionEnd",
    svg_ns = "http://www.w3.org/2000/svg",
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Echo = [248, "Vdom.Cmd.Echo", caml_fresh_oo_id(0)],
    Batch = [248, "Vdom.Cmd.Batch", caml_fresh_oo_id(0)],
    Bind = [248, "Vdom.Cmd.Bind", caml_fresh_oo_id(0)],
    Map = [248, "Vdom.Cmd.Map", caml_fresh_oo_id(0)];
   function echo(msg){return [0, Echo, msg];}
   function batch(l){return [0, Batch, l];}
   function map(f, x){return [0, Map, f, x];}
   function bind(x, f){return [0, Bind, x, f];}
   var
    Cmd = [0, Echo, Batch, Bind, Map, echo, batch, map, bind],
    Custom = [0];
   function field(key, d){return [0, key, d];}
   function method(name, arg, d){return [1, name, arg, d];}
   function bind$0(f, d){return [2, f, d];}
   function let$0(d, f){return [2, f, d];}
   function const$0(msg){return [3, msg];}
   function factor(f){return [4, f];}
   function map$0(f, d){
    function f$0(msg){var msg$0 = caml_call1(f, msg); return [3, msg$0];}
    return [2, f$0, d];
   }
   function let$1(d, f){return map$0(f, d);}
   function pair(d1, d2){
    function f(x1){function f(x2){return [0, x1, x2];} return map$0(f, d2);}
    return [2, f, d1];
   }
   function app(f, d){
    function f$0(ff){return map$0(ff, d);}
    return [2, f$0, f];
   }
   function map2(f, d1, d2){
    function f$0(x1){
     function f$0(x2){return caml_call2(f, x1, x2);}
     return map$0(f$0, d2);
    }
    return [2, f$0, d1];
   }
   function map_some(f){
    function _C_(x){return [0, caml_call1(f, x)];}
    return function(_D_){return map$0(_C_, _D_);};
   }
   var
    string = 0,
    int$0 = 1,
    float$0 = 2,
    bool = 3,
    unit = [3, 0],
    object = 4;
   function list(d){return [5, d];}
   function fail(error){return [6, error];}
   function try$0(d){return [7, d];}
   function f(param){
    var
     shift_key = param[2],
     _v_ = param[1],
     ctrl_key = _v_[2],
     _w_ = _v_[1],
     alt_key = _w_[2],
     _x_ = _w_[1],
     buttons = _x_[2],
     _y_ = _x_[1],
     page_y = _y_[2],
     _z_ = _y_[1],
     page_x = _z_[2],
     _A_ = _z_[1],
     left_top = _A_[2],
     match = _A_[1],
     y = match[2],
     x = match[1],
     left_top$0 = caml_call1(Stdlib_Lazy[6], left_top);
    function get(x){
     var
      _B_ = runtime.caml_obj_tag(x),
      match =
        250 === _B_
         ? x[1]
         : 246 === _B_ ? caml_call1(CamlinternalLazy[2], x) : x;
     if(0 === match[0]){var x$0 = match[1]; return x$0;}
     var err = match[1];
     return caml_call1(Stdlib[2], err);
    }
    var
     element_x = [246, function(param){return x - get(left_top$0)[1];}],
     element_y = [246, function(param){return y - get(left_top$0)[2];}];
    return [0,
            x,
            y,
            page_x,
            page_y,
            element_x,
            element_y,
            buttons,
            alt_key,
            ctrl_key,
            shift_key];
   }
   var left$11 = [0, key, float$0], left = pair(left$11, [0, key$0, float$0]);
   function f$0(param){
    function f(param){
     var top = param[2], left = param[1];
     return [0, left, top];
    }
    var
     left = [0, key$1, float$0],
     d = pair(left, [0, key$2, float$0]),
     d$1 = map$0(f, d),
     d$0 = [1, name, 0, d$1];
    return [0, key$3, d$0];
   }
   var
    left$0 = pair(left, [4, f$0]),
    left$1 = pair(left$0, [0, key$4, float$0]),
    left$2 = pair(left$1, [0, key$5, float$0]),
    left$3 = pair(left$2, [0, key$6, int$0]),
    left$4 = pair(left$3, [0, key$7, bool]),
    left$5 = pair(left$4, [0, key$8, bool]),
    d = pair(left$5, [0, key$9, bool]),
    mouse_event = map$0(f, d);
   function f$1(param){
    var
     shift_key = param[2],
     _u_ = param[1],
     ctrl_key = _u_[2],
     match = _u_[1],
     alt_key = match[2],
     which = match[1];
    return [0, which, alt_key, ctrl_key, shift_key];
   }
   var
    left$10 = [0, key$10, int$0],
    left$6 = pair(left$10, [0, key$11, bool]),
    left$7 = pair(left$6, [0, key$12, bool]),
    d$0 = pair(left$7, [0, key$13, bool]),
    key_event = map$0(f$1, d$0);
   function f$2(param){
    var
     selection_end = param[2],
     match = param[1],
     selection_start = match[2],
     text = match[1];
    return [0, text, selection_start, selection_end];
   }
   var
    d$2 = [1, name$0, arg, string],
    left$9 = [0, key$14, d$2],
    left$8 = pair(left$9, [0, key$15, int$0]),
    d$1 = pair(left$8, [0, key$16, int$0]),
    paste_event = map$0(f$2, d$1),
    cst_mousedown = cst_mousedown$1,
    cst_mousedown$0 = cst_mousedown$1,
    cst_mouseup = "mouseup",
    cst_click = cst_click$2,
    cst_click$0 = cst_click$2,
    cst_dblclick = "dblclick",
    cst_contextmenu = "contextmenu",
    _a_ = [0, 0],
    cst_mousemove = "mousemove",
    cst_mouseenter = "mouseenter",
    cst_mouseleave = "mouseleave",
    cst_mouseover = "mouseover",
    cst_focus = "focus",
    cst_blur = "blur",
    cst_input = cst_input$1,
    cst_change = cst_change$1,
    cst_change$0 = cst_change$1,
    cst_click$1 = cst_click$2,
    cst_keydown = cst_keydown$1,
    cst_keydown$0 = cst_keydown$1,
    cst_keyup = cst_keyup$1,
    cst_keyup$0 = cst_keyup$1,
    cst_paste = "paste",
    cst_scroll_to_show = "scroll-to-show";
   function on_with_options(event_type, decoder){
    return [2, [0, event_type, decoder, function(_t_){return _t_;}]];
   }
   function on(prevent_default, stop_propagation, event_type, decoder){
    var
     prevent_default$0 = prevent_default ? 1 : 0,
     stop_propagation$0 = stop_propagation ? 1 : 0;
    function f(msg){return [0, msg, stop_propagation$0, prevent_default$0];}
    return on_with_options(event_type, map$0(f, decoder));
   }
   function on_cancel(stop_propagation, event_type, decoder){
    var stop_propagation$0 = stop_propagation ? 1 : 0;
    function f(msg){
     return msg
             ? [0, msg, stop_propagation$0, 1]
             : [0, msg, stop_propagation$0, 0];
    }
    return on_with_options(event_type, map$0(f, decoder));
   }
   function on_js_with_options(event_type, handler){
    function f(o){return caml_call1(handler, o);}
    return on_with_options(event_type, map$0(f, object));
   }
   function on_js(prevent_default, stop_propagation, event_type, handler){
    var
     prevent_default$0 = prevent_default ? 1 : 0,
     stop_propagation$0 = stop_propagation ? 1 : 0;
    return on_js_with_options
            (event_type,
             function(e){
              return [0,
                      caml_call1(handler, e),
                      stop_propagation$0,
                      prevent_default$0];
             });
   }
   function onmouseevent(prevent_default, stop_propagation, type, msg){
    return on
            (prevent_default,
             stop_propagation,
             type,
             map_some(msg)(mouse_event));
   }
   function onmouseevent_cancel(stop_propagation, type, msg){
    return on_cancel(stop_propagation, type, map$0(msg, mouse_event));
   }
   function onmousedown(prevent_default, stop_propagation, msg){
    return onmouseevent(prevent_default, stop_propagation, cst_mousedown, msg);
   }
   function onmousedown_cancel(stop_propagation, msg){
    return onmouseevent_cancel(stop_propagation, cst_mousedown$0, msg);
   }
   function onmouseup(prevent_default, stop_propagation, msg){
    return onmouseevent(prevent_default, stop_propagation, cst_mouseup, msg);
   }
   function onclick(prevent_default, stop_propagation, msg){
    return onmouseevent(prevent_default, stop_propagation, cst_click, msg);
   }
   function onclick_cancel(stop_propagation, msg){
    return onmouseevent_cancel(stop_propagation, cst_click$0, msg);
   }
   function ondblclick(prevent_default, stop_propagation, msg){
    return onmouseevent(prevent_default, stop_propagation, cst_dblclick, msg);
   }
   function oncontextmenu(stop_propagation, msg){
    return onmouseevent(_a_, stop_propagation, cst_contextmenu, msg);
   }
   function onmousemove(prevent_default, stop_propagation, msg){
    return onmouseevent(prevent_default, stop_propagation, cst_mousemove, msg);
   }
   function onmouseenter(prevent_default, stop_propagation, msg){
    function f(param){
     var current_target = param[2], target = param[1];
     return caml_equal(target, current_target)
             ? map_some(msg)(mouse_event)
             : [3, 0];
    }
    var left = [0, key$17, object], d = pair(left, [0, key$18, object]);
    return on(prevent_default, stop_propagation, cst_mouseenter, [2, f, d]);
   }
   function onmouseleave(prevent_default, stop_propagation, msg){
    function f(param){
     var current_target = param[2], target = param[1];
     return caml_equal(target, current_target)
             ? map_some(msg)(mouse_event)
             : [3, 0];
    }
    var left = [0, key$19, object], d = pair(left, [0, key$20, object]);
    return on(prevent_default, stop_propagation, cst_mouseleave, [2, f, d]);
   }
   function onmouseover(prevent_default, stop_propagation, msg){
    return onmouseevent(prevent_default, stop_propagation, cst_mouseover, msg);
   }
   function onfocus(prevent_default, stop_propagation, msg){
    var msg$0 = [0, msg];
    return on(prevent_default, stop_propagation, cst_focus, [3, msg$0]);
   }
   function onblur(prevent_default, stop_propagation, msg){
    var msg$0 = [0, msg];
    return on(prevent_default, stop_propagation, cst_blur, [3, msg$0]);
   }
   function oninput(prevent_default, stop_propagation, msg){
    return on
            (prevent_default,
             stop_propagation,
             cst_input,
             map_some(msg)([0, key$21, string]));
   }
   function onchange(prevent_default, stop_propagation, msg){
    return on
            (prevent_default,
             stop_propagation,
             cst_change,
             map_some(msg)([0, key$22, string]));
   }
   function onchange_index(prevent_default, stop_propagation, msg){
    return on
            (prevent_default,
             stop_propagation,
             cst_change$0,
             map_some(msg)([0, key$23, int$0]));
   }
   function onchange_checked(prevent_default, stop_propagation, msg){
    return on
            (prevent_default,
             stop_propagation,
             cst_click$1,
             map_some(msg)([0, key$24, bool]));
   }
   function onkeyevent(prevent_default, stop_propagation, type, msg){
    return on
            (prevent_default,
             stop_propagation,
             type,
             map_some(msg)(key_event));
   }
   function onkeyevent_cancel(stop_propagation, type, msg){
    return on_cancel(stop_propagation, type, map$0(msg, key_event));
   }
   function onkeydown(prevent_default, stop_propagation, msg){
    return onkeyevent(prevent_default, stop_propagation, cst_keydown, msg);
   }
   function onkeydown_cancel(stop_propagation, msg){
    return onkeyevent_cancel(stop_propagation, cst_keydown$0, msg);
   }
   function onkeyup(prevent_default, stop_propagation, msg){
    return onkeyevent(prevent_default, stop_propagation, cst_keyup, msg);
   }
   function onkeyup_cancel(stop_propagation, msg){
    return onkeyevent_cancel(stop_propagation, cst_keyup$0, msg);
   }
   function onpaste(prevent_default, stop_propagation, msg){
    return on
            (prevent_default,
             stop_propagation,
             cst_paste,
             map$0(msg, paste_event));
   }
   function oncustomevent(msg){return [2, [1, msg]];}
   function str_prop(k, v){return [0, k, [0, v]];}
   function int_prop(k, v){return [0, k, [1, v]];}
   function bool_prop(k, v){return [0, k, [3, v]];}
   function float_prop(k, v){return [0, k, [2, v]];}
   function style(k, v){return [1, k, v];}
   function attr(k, v){return [3, k, v];}
   function int_attr(k, v){return [3, k, caml_call1(Stdlib[33], v)];}
   function float_attr(k, v){return [3, k, caml_call1(Stdlib[35], v)];}
   function scroll_to_show(align_top){
    return bool_prop(cst_scroll_to_show, align_top);
   }
   var
    autofocus = bool_prop(cst_autofocus$0, 1),
    cst_autofocus = cst_autofocus$0;
   function autofocus_counter(x){return int_prop(cst_autofocus, x);}
   var
    autofocus_if_visible = str_prop(cst_autofocus$0, "if-visible"),
    autosubmit = bool_prop("autosubmit", 1),
    select = bool_prop("select", 1),
    cst_className = cst_className$1,
    cst_type = "type";
   function class$0(x){return [0, cst_className, [0, x]];}
   function type(x){return [0, cst_type, [0, x]];}
   var
    type_button = type("button"),
    cst_value = "value",
    cst_disabled = "disabled",
    _b_ = [0, [2, 0, [12, 32, [2, 0, 0]]], "%s %s"],
    cst_className$0 = cst_className$1,
    cst_txt = "_txt",
    cst_fragment = "_fragment",
    cst_div = "div",
    cst_input$0 = cst_input$1,
    cst_span = "span",
    cst_map = "_map",
    cst_memo = "_memo",
    _c_ = [0, 0],
    cst_custom = "_custom",
    _d_ = [0, 0, 0],
    cst_class = "class",
    cst_style = "style",
    _e_ = [0, [2, 0, [11, '="', [2, 0, [12, 34, 0]]]], '%s="%s"'],
    cst_xmlns = "xmlns";
   function value(x){return [0, cst_value, [0, x]];}
   function disabled(x){return [0, cst_disabled, [3, x]];}
   function add_class(x, attrs){
    var
     has_className =
       caml_call2
        (Stdlib_List[33],
         function(param){
          if(0 === param[0] && param[1] === cst_className$1) return 1;
          return 0;
         },
         attrs);
    return has_className
            ? caml_call2
              (Stdlib_List[19],
               function(a){
                if(0 === a[0] && a[1] === cst_className$1){
                 var match = a[2];
                 if(0 === match[0]){
                  var s = match[1];
                  return [0,
                          cst_className$0,
                          [0, caml_call3(Stdlib_Printf[4], _b_, s, x)]];
                 }
                }
                return a;
               },
               attrs)
            : [0, class$0(x), attrs];
   }
   function text(opt, txt){
    if(opt) var sth = opt[1], key = sth; else var key = cst_txt;
    return [0, key, txt];
   }
   function fragment(opt, children){
    if(opt) var sth = opt[1], key = sth; else var key = cst_fragment;
    return [1, key, children];
   }
   function elt(opt, tag, key, _s_, l){
    if(opt) var sth = opt[1], ns = sth; else var ns = cst;
    if(_s_) var sth$0 = _s_[1], a = sth$0; else var a = 0;
    if(key) var k = key[1], k$0 = k; else var k$0 = tag;
    return [2, k$0, ns, tag, a, l];
   }
   function svg_elt(tag, key, a, l){return elt([0, svg_ns], tag, key, a, l);}
   function div(key, a, l){return elt(0, cst_div, key, a, l);}
   function input(key, a, l){return elt(0, cst_input$0, key, a, l);}
   function txt_span(key, a, s){
    return elt(0, cst_span, key, a, [0, text(0, s), 0]);
   }
   function map_attr(f, x){
    switch(x[0]){
      case 2:
       var attributes = x[4], _o_ = x[5], _p_ = caml_call1(f, attributes);
       return [2, x[1], x[2], x[3], _p_, _o_];
      case 5:
       var attributes$0 = x[3], _q_ = x[4], _r_ = caml_call1(f, attributes$0);
       return [5, x[1], x[2], _r_, _q_];
      default: return x;
    }
   }
   function map$1(opt, f, child){
    if(opt) var sth = opt[1], key = sth; else var key = cst_map;
    return [3, key, f, child];
   }
   function memo(opt, f, arg){
    if(opt) var sth = opt[1], key = sth; else var key = cst_memo;
    return [4, key, f, arg];
   }
   function custom(opt, _n_, propagate_events, elt){
    if(opt) var sth = opt[1], key = sth; else var key = cst_custom;
    if(_n_) var sth$0 = _n_[1], a = sth$0; else var a = 0;
    return [5, key, elt, a, caml_equal(propagate_events, _c_)];
   }
   function return$0(opt, model){
    if(opt) var sth = opt[1], c = sth; else var c = 0;
    return [0, model, caml_call1(Cmd[6], c)];
   }
   function app$0(init, update, view, param){return [0, init, update, view];}
   function simple_app(init, update, view, param){
    function update$0(model, msg){
     return return$0(0, caml_call2(update, model, msg));
    }
    var init$0 = return$0(0, init);
    return [0, init$0, update$0, view];
   }
   function to_html(vdom){
    var b = caml_call1(Stdlib_Buffer[1], 654);
    function aux(param){
     var param$0 = param;
     for(;;)
      switch(param$0[0]){
        case 0:
         var txt = param$0[2]; return caml_call2(Stdlib_Buffer[16], b, txt);
        case 1:
         var children = param$0[2];
         return caml_call2(Stdlib_List[17], aux, children);
        case 2:
         var
          children$0 = param$0[5],
          attributes = param$0[4],
          tag = param$0[3],
          ns = param$0[2],
          match =
            caml_call3
             (Stdlib_List[25],
              function(param, _l_){
               var styles = param[2], attrs = param[1];
               switch(_l_[0]){
                 case 0:
                  var value = _l_[2], name = _l_[1];
                  switch(value[0]){
                    case 0:
                     var s = value[1], value$0 = s; break;
                    case 1:
                     var i = value[1], value$0 = caml_call1(Stdlib[33], i);
                     break;
                    case 2:
                     var
                      f = value[1],
                      s$0 = caml_call1(Stdlib[35], f),
                      l = [0, caml_ml_string_length(s$0)];
                     for(;;){
                      if(0 >= l[1]) break;
                      if(caml_string_get(s$0, l[1] - 1 | 0) !== 46) break;
                      l[1]--;
                     }
                     var
                      _m_ =
                        l[1] < caml_ml_string_length(s$0)
                         ? caml_call3(Stdlib_String[15], s$0, 0, l[1])
                         : s$0,
                      value$0 = _m_;
                     break;
                    default:
                     var b = value[1], value$0 = caml_call1(Stdlib[30], b);
                  }
                  var name$0 = name !== cst_className$1 ? name : cst_class;
                  return [0, [0, [0, name$0, value$0], attrs], styles];
                 case 1:
                  var value$1 = _l_[2], name$1 = _l_[1];
                  return [0, attrs, [0, [0, name$1, value$1], styles]];
                 case 2:
                  return [0, attrs, styles];
                 default:
                  var value$2 = _l_[2], name$2 = _l_[1];
                  return [0, [0, [0, name$2, value$2], attrs], styles];
               }
              },
              _d_,
              attributes),
          styles = match[2],
          attrs = match[1];
         if(styles)
          var
           _f_ =
             caml_call2
              (Stdlib_List[19],
               function(param){
                var
                 x2 = param[2],
                 x1 = param[1],
                 _k_ = caml_call2(Stdlib[28], cst$0, x2);
                return caml_call2(Stdlib[28], x1, _k_);
               },
               styles),
           styles$0 = caml_call1(caml_call1(Stdlib_String[6], cst$1), _f_),
           attrs$0 = [0, [0, cst_style, styles$0], attrs];
         else
          var attrs$0 = attrs;
         var
          attrs$1 = caml_call1(Stdlib_List[9], attrs$0),
          attrs$2 = ns == cst$5 ? attrs$1 : [0, [0, cst_xmlns, ns], attrs$1],
          _g_ =
            caml_call2
             (Stdlib_List[19],
              function(param){
               var
                v = param[2],
                k = param[1],
                match = caml_call2(Stdlib_String[36], v, 34);
               if(match){
                var
                 i0 = match[1],
                 buf = caml_call1(Stdlib_Buffer[1], caml_ml_string_length(v));
                caml_call4(Stdlib_Buffer[18], buf, v, 0, i0);
                var _h_ = caml_ml_string_length(v) - 1 | 0;
                if(_h_ >= i0){
                 var i = i0;
                 for(;;){
                  var u = caml_string_get(v, i);
                  if(u === 34)
                   caml_call2(Stdlib_Buffer[16], buf, x);
                  else
                   caml_call2(Stdlib_Buffer[12], buf, u);
                  var _i_ = i + 1 | 0;
                  if(_h_ === i) break;
                  i = _i_;
                 }
                }
                var _j_ = caml_call1(Stdlib_Buffer[2], buf);
               }
               else
                var _j_ = v;
               return caml_call3(Stdlib_Printf[4], _e_, k, _j_);
              },
              attrs$2),
          attrs$3 = caml_call1(caml_call1(Stdlib_String[6], cst$2), _g_);
         caml_call2(Stdlib_Buffer[12], b, 60);
         caml_call2(Stdlib_Buffer[16], b, tag);
         if(attrs$3 !== cst$5){
          caml_call2(Stdlib_Buffer[12], b, 32);
          caml_call2(Stdlib_Buffer[16], b, attrs$3);
         }
         return 0 === children$0
                 ? caml_call2(Stdlib_Buffer[16], b, cst$3)
                 : (caml_call2
                    (Stdlib_Buffer[12], b, 62),
                   caml_call2(Stdlib_List[17], aux, children$0),
                   caml_call2(Stdlib_Buffer[16], b, cst$4),
                   caml_call2(Stdlib_Buffer[16], b, tag),
                   caml_call2(Stdlib_Buffer[12], b, 62));
        case 3:
         var child = param$0[3]; param$0 = child; break;
        case 4:
         var arg = param$0[3], f = param$0[2];
         param$0 = caml_call1(f, arg);
         break;
        default: return 0;
      }
    }
    aux(vdom);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   var
    Vdom =
      [0,
       Cmd,
       [0,
        field,
        method,
        app,
        bind$0,
        const$0,
        const$0,
        factor,
        map$0,
        map2,
        pair,
        fail,
        try$0,
        string,
        int$0,
        float$0,
        bool,
        unit,
        object,
        list,
        let$0,
        let$1,
        pair],
       Custom,
       on,
       on_with_options,
       on_js,
       on_js_with_options,
       onmousedown,
       onmousedown_cancel,
       onmouseup,
       onclick,
       onclick_cancel,
       ondblclick,
       oncontextmenu,
       onfocus,
       onblur,
       oninput,
       onchange_checked,
       onchange,
       onchange_index,
       onmousemove,
       onmouseenter,
       onmouseleave,
       onmouseover,
       onkeydown,
       onkeydown_cancel,
       onkeyup,
       onkeyup_cancel,
       onpaste,
       oncustomevent,
       str_prop,
       int_prop,
       bool_prop,
       float_prop,
       style,
       attr,
       int_attr,
       float_attr,
       class$0,
       type,
       type_button,
       value,
       disabled,
       add_class,
       scroll_to_show,
       autofocus,
       autofocus_if_visible,
       autofocus_counter,
       select,
       autosubmit,
       elt,
       svg_elt,
       text,
       fragment,
       map_attr,
       map$1,
       memo,
       custom,
       div,
       input,
       txt_span,
       return$0,
       app$0,
       simple_app,
       to_html];
   runtime.caml_register_global(104, Vdom, "Vdom");
   return;
  }
  (globalThis));


//# 1 "../../.js/default/vdom/vdom_js.cma.js"
// Generated by js_of_ocaml
//# 3 "../../.js/default/vdom/vdom_js.cma.js"

//# 6 "../../.js/default/vdom/vdom_js.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Array = "Array",
    cst_Date = "Date",
    cst_JSON = "JSON",
    cst_URL = "URL",
    cst_Uint8Array = "Uint8Array",
    cst_binaryType = "binaryType",
    cst_blur = "blur",
    cst_bottom = "bottom",
    cst_challenge = "challenge",
    cst_checked = "checked",
    cst_className = "className",
    cst_click = "click",
    cst_clientDataJSON = "clientDataJSON",
    cst_close = "close",
    cst_code = "code",
    cst_cookie = "cookie",
    cst_credentials = "credentials",
    cst_document = "document",
    cst_files = "files",
    cst_firstChild = "firstChild",
    cst_focus = "focus",
    cst_hash = "hash",
    cst_height = "height",
    cst_host = "host",
    cst_hostname = "hostname",
    cst_href = "href",
    cst_id = "id",
    cst_innerHTML = "innerHTML",
    cst_key = "key",
    cst_left = "left",
    cst_length = "length",
    cst_lib_js_browser_ml = "lib/js_browser.ml",
    cst_location = "location",
    cst_name = "name",
    cst_navigator = "navigator",
    cst_nodeValue = "nodeValue",
    cst_onload = "onload",
    cst_open = "open",
    cst_origin = "origin",
    cst_pathname = "pathname",
    cst_port = "port",
    cst_protocol = "protocol",
    cst_publicKey = "publicKey",
    cst_push = "push",
    cst_readyState = "readyState",
    cst_response = "response",
    cst_responseType = "responseType",
    cst_result = "result",
    cst_right = "right",
    cst_scrollTop = "scrollTop",
    cst_search = "search",
    cst_select = "select",
    cst_selectionEnd = "selectionEnd",
    cst_selectionStart = "selectionStart",
    cst_submit = "submit",
    cst_timeout = "timeout",
    cst_top = "top",
    cst_type = "type",
    cst_userVerification = "userVerification",
    cst_value = "value",
    cst_width = "width",
    cst_window = "window",
    caml_js_from_string = runtime.caml_js_from_string,
    caml_js_to_string = runtime.caml_js_to_string,
    caml_js_wrap_callback_strict = runtime.caml_js_wrap_callback_strict,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ojs_new_arr = runtime.caml_ojs_new_arr;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ojs = global_data.Ojs,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List;
   function then(error, success, param){
    var ojs = param[2], alpha_of_js = param[1];
    function x1(x){return caml_call1(success, caml_call1(alpha_of_js, x));}
    ojs.then
     (caml_js_wrap_callback_strict(1, x1),
      caml_call2
       (Ojs[8],
        function(x4){return caml_js_wrap_callback_strict(1, x4);},
        error));
    return 0;
   }
   function t_of_js(x8){return x8;}
   function t_to_js(x7){return x7;}
   function length(x9){return x9[cst_length];}
   function key(x11, x10){
    var _ak_ = x11.key(x10);
    return caml_call2(Ojs[7], caml_js_to_string, _ak_);
   }
   function get_item(x14, x13){
    var _aj_ = x14.getItem(caml_js_from_string(x13));
    return caml_call2(Ojs[7], caml_js_to_string, _aj_);
   }
   function set_item(x18, x16, x17){
    x18.setItem(caml_js_from_string(x16), caml_js_from_string(x17));
    return 0;
   }
   function remove_item(x20, x19){
    x20.removeItem(caml_js_from_string(x19));
    return 0;
   }
   function clear(x21){x21.clear(); return 0;}
   var
    Storage =
      [0,
       t_of_js,
       t_to_js,
       length,
       key,
       get_item,
       set_item,
       remove_item,
       clear];
   function t_of_js$0(x23){return x23;}
   function t_to_js$0(x22){return x22;}
   function new_reg_exp(x24, x25, param){
    var x26 = new Ojs[19][cst_Array];
    x26.push(caml_js_from_string(x24));
    if(x25){var x27 = x25[1]; x26.push(caml_js_from_string(x27));}
    var x23 = caml_ojs_new_arr(Ojs[19]["RegExp"], x26);
    return x23;
   }
   var RegExp = [0, t_of_js$0, t_to_js$0, new_reg_exp];
   function t_of_js$1(x29){return x29;}
   function t_to_js$1(x28){return x28;}
   var of_string = caml_js_from_string, to_string = caml_js_to_string;
   function length$0(x30){return x30[cst_length];}
   function char_code_at(x32, x31){return x32.charCodeAt(x31);}
   function to_lower_case(x33){var x29 = x33.toLowerCase(); return x29;}
   function to_upper_case(x34){var x29 = x34.toUpperCase(); return x29;}
   function concat(x38, x35){
    var x36 = new Ojs[19][cst_Array];
    caml_call2(Stdlib_List[17], function(x37){x36.push(x37); return 0;}, x35);
    var x29 = x38["concat"].apply(x38, x36);
    return x29;
   }
   function includes(x41, x40){return x41.includes(x40) | 0;}
   function ends_with(x43, x42){return x43.endsWith(x42) | 0;}
   function index_of(x45, x44){return x45.indexOf(x44);}
   function repeat(x47, x46){var x29 = x47.repeat(x46); return x29;}
   function search(x49, x48){return x49.search(caml_call1(RegExp[2], x48));}
   function trim(x50){var x29 = x50.trim(); return x29;}
   var
    JsString =
      [0,
       t_of_js$1,
       t_to_js$1,
       of_string,
       to_string,
       length$0,
       char_code_at,
       to_lower_case,
       to_upper_case,
       concat,
       includes,
       ends_with,
       index_of,
       repeat,
       search,
       trim];
   function t_of_js$2(x52){return x52;}
   function t_to_js$2(x51){return x51;}
   function new_date(x53){var x52 = new Ojs[19][cst_Date](x53); return x52;}
   function now(param){return Ojs[19][cst_Date].now();}
   function parse(x54){
    var _ai_ = caml_js_from_string(x54), x52 = Ojs[19][cst_Date].parse(_ai_);
    return x52;
   }
   function get_date(x55){return x55.getDate();}
   function get_day(x56){return x56.getDay();}
   function get_full_year(x57){return x57.getFullYear();}
   function get_hours(x58){return x58.getHours();}
   function get_milliseconds(x59){return x59.getMilliseconds();}
   function get_minutes(x60){return x60.getMinutes();}
   function get_month(x61){return x61.getMonth();}
   function get_seconds(x62){return x62.getSeconds();}
   function get_time(x63){return x63.getTime();}
   function get_timezone_offset(x64){return x64.getTimezoneOffset();}
   function get_UTC_date(x65){return x65.getUTCDate();}
   function get_UTC_day(x66){return x66.getUTCDay();}
   function get_UTC_full_year(x67){return x67.getUTCFullYear();}
   function get_UTC_hours(x68){return x68.getUTCHours();}
   function get_UTC_milliseconds(x69){return x69.getUTCMilliseconds();}
   function get_UTC_minutes(x70){return x70.getUTCMinutes();}
   function get_UTC_month(x71){return x71.getUTCMonth();}
   function get_UTC_seconds(x72){return x72.getUTCSeconds();}
   function get_year(x73){return x73.getYear();}
   function set_date(x75, x74){x75.setDate(x74); return 0;}
   function set_full_year(x77, x76){x77.setFullYear(x76); return 0;}
   function set_hours(x79, x78){x79.setHours(x78); return 0;}
   function set_milliseconds(x81, x80){x81.setMilliseconds(x80); return 0;}
   function set_minutes(x83, x82){x83.setMinutes(x82); return 0;}
   function set_month(x85, x84){x85.setMonth(x84); return 0;}
   function set_seconds(x87, x86){x87.setSeconds(x86); return 0;}
   function set_time(x89, x88){x89.setTime(x88); return 0;}
   function set_UTC_date(x91, x90){x91.setUTCDate(x90); return 0;}
   function set_UTC_full_year(x93, x92){x93.setUTCFullYear(x92); return 0;}
   function set_UTC_hours(x95, x94){x95.setUTCHours(x94); return 0;}
   function set_UTC_milliseconds(x97, x96){x97.setUTCMilliseconds(x96); return 0;
   }
   function set_UTC_minutes(x99, x98){x99.setUTCMinutes(x98); return 0;}
   function set_UTC_month(x101, x100){x101.setUTCMonth(x100); return 0;}
   function set_UTC_seconds(x103, x102){x103.setUTCSeconds(x102); return 0;}
   function set_year(x105, x104){x105.setYear(x104); return 0;}
   function to_date_string(x106){
    return caml_js_to_string(x106.toDateString());
   }
   function to_GMT_string(x107){return caml_js_to_string(x107.toGMTString());}
   function to_ISO_string(x108){return caml_js_to_string(x108.toISOString());}
   function to_locale_string(x109){
    return caml_js_to_string(x109.toLocaleString());
   }
   function to_string$0(x110){return caml_js_to_string(x110.toString());}
   function to_time_string(x111){
    return caml_js_to_string(x111.toTimeString());
   }
   function to_UTC_string(x112){return caml_js_to_string(x112.toUTCString());}
   var
    Date =
      [0,
       t_of_js$2,
       t_to_js$2,
       new_date,
       now,
       parse,
       get_date,
       get_day,
       get_full_year,
       get_hours,
       get_milliseconds,
       get_minutes,
       get_month,
       get_seconds,
       get_time,
       get_timezone_offset,
       get_UTC_date,
       get_UTC_day,
       get_UTC_full_year,
       get_UTC_hours,
       get_UTC_milliseconds,
       get_UTC_minutes,
       get_UTC_month,
       get_UTC_seconds,
       get_year,
       set_date,
       set_full_year,
       set_hours,
       set_milliseconds,
       set_minutes,
       set_month,
       set_seconds,
       set_time,
       set_UTC_date,
       set_UTC_full_year,
       set_UTC_hours,
       set_UTC_milliseconds,
       set_UTC_minutes,
       set_UTC_month,
       set_UTC_seconds,
       set_year,
       to_date_string,
       to_GMT_string,
       to_ISO_string,
       to_locale_string,
       to_string$0,
       to_time_string,
       to_UTC_string];
   function t_of_js$3(x114){return x114;}
   function t_to_js$3(x113){return x113;}
   function create(x115){
    var x114 = new Ojs[19]["ArrayBuffer"](x115);
    return x114;
   }
   var ArrayBuffer = [0, t_of_js$3, t_to_js$3, create];
   function options(x118, x119, param){
    var x120 = caml_call1(Ojs[11], 0);
    if(x118){var x122 = x118[1]; x120[cst_type] = caml_js_from_string(x122);}
    if(x119){var x121 = x119[1]; x120["endings"] = caml_js_from_string(x121);}
    return x120;
   }
   function t_of_js$4(x124){return x124;}
   function t_to_js$4(x123){return x123;}
   function create$0(x125, x126, param){
    var x127 = new Ojs[19][cst_Array];
    x127.push(caml_call2(Ojs[4], function(x129){return x129;}, x125));
    if(x126){var x128 = x126[1]; x127.push(x128);}
    var x124 = caml_ojs_new_arr(Ojs[19]["Blob"], x127);
    return x124;
   }
   function size(x130){return x130["size"];}
   function type(x131){return caml_js_to_string(x131[cst_type]);}
   function text(x132, param){
    var x = x132.text(), f = caml_js_to_string;
    return [0, f, x];
   }
   function t_of_js$5(x135){return x135;}
   function t_to_js$5(x134){return x134;}
   function options$0(x138, x139, param){
    var x140 = caml_call1(Ojs[11], 0);
    if(x138){var x142 = x138[1]; x140[cst_type] = caml_js_from_string(x142);}
    if(x139){var x141 = x139[1]; x140["lastModified"] = x141;}
    return x140;
   }
   function create$1(x143, x145, x146){
    var
     _ag_ = caml_js_from_string(x145),
     _ah_ = caml_call2(Ojs[2], t_to_js$4, x143),
     x135 = new Ojs[19]["File"](_ah_, _ag_, x146);
    return x135;
   }
   function name(x147){return caml_js_to_string(x147[cst_name]);}
   function t_of_js$6(x149){return x149;}
   function t_to_js$6(x148){return x148;}
   function files(x150){
    var _af_ = x150[cst_files];
    return caml_call2(Ojs[3], t_of_js$5, _af_);
   }
   function get_data(x153, x152){
    return caml_js_to_string(x153.getData(caml_js_from_string(x152)));
   }
   var DataTransfer = [0, t_of_js$6, t_to_js$6, files, get_data];
   function t_of_js$7(x155){return x155;}
   function t_to_js$7(x154){return x154;}
   function kind_to_js(x156){
    if(typeof x156 !== "number"){
     var x157 = x156[1];
     return caml_js_from_string(x157);
    }
    var _ae_ = x156;
    if(88 <= _ae_){
     if(132 <= _ae_)
      switch(_ae_){
        case 132:
         return "resume";
        case 133:
         return "scroll";
        case 134:
         return "seeked";
        case 135:
         return "seeking";
        case 136:
         return cst_select;
        case 137:
         return "selectionchange";
        case 138:
         return "selectstart";
        case 139:
         return "show";
        case 140:
         return "slotchange";
        case 141:
         return "soundend";
        case 142:
         return "soundstart";
        case 143:
         return "speechend";
        case 144:
         return "speechstart";
        case 145:
         return "stalled";
        case 146:
         return "start";
        case 147:
         return "storage";
        case 148:
         return cst_submit;
        case 149:
         return "success";
        case 150:
         return "suspend";
        case 151:
         return "SVGAbort";
        case 152:
         return "SVGError";
        case 153:
         return "SVGLoad";
        case 154:
         return "SVGResize";
        case 155:
         return "SVGScroll";
        case 156:
         return "SVGUnload";
        case 157:
         return "SVGZoom";
        case 158:
         return cst_timeout;
        case 159:
         return "timeupdate";
        case 160:
         return "touchcancel";
        case 161:
         return "touchend";
        case 162:
         return "touchmove";
        case 163:
         return "touchstart";
        case 164:
         return "transitionend";
        case 165:
         return "unload";
        case 166:
         return "updateready";
        case 167:
         return "upgradeneeded";
        case 168:
         return "userproximity";
        case 169:
         return "versionchange";
        case 170:
         return "visibilitychange";
        case 171:
         return "voiceschanged";
        case 172:
         return "volumechange";
        case 173:
         return "waiting";
        default: return "wheel";
      }
     switch(_ae_){
       case 88:
        return "message";
       case 89:
        return "messageerror";
       case 90:
        return "mousedown";
       case 91:
        return "mouseenter";
       case 92:
        return "mouseleave";
       case 93:
        return "mousemove";
       case 94:
        return "mouseout";
       case 95:
        return "mouseover";
       case 96:
        return "mouseup";
       case 97:
        return "nomatch";
       case 98:
        return "notificationclick";
       case 99:
        return "noupdate";
       case 100:
        return "obsolete";
       case 101:
        return "offline";
       case 102:
        return "online";
       case 103:
        return cst_open;
       case 104:
        return "orientationchange";
       case 105:
        return "pagehide";
       case 106:
        return "pageshow";
       case 107:
        return "paste";
       case 108:
        return "pause";
       case 109:
        return "play";
       case 110:
        return "playing";
       case 111:
        return "pointercancel";
       case 112:
        return "pointerdown";
       case 113:
        return "pointerenter";
       case 114:
        return "pointerleave";
       case 115:
        return "pointerlockchange";
       case 116:
        return "pointerlockerror";
       case 117:
        return "pointermove";
       case 118:
        return "pointerout";
       case 119:
        return "pointerover";
       case 120:
        return "pointerup";
       case 121:
        return "popstate";
       case 122:
        return "progress";
       case 123:
        return cst_push;
       case 124:
        return "pushsubscriptionchange";
       case 125:
        return "ratechange";
       case 126:
        return "readystatechange";
       case 127:
        return "repeatEvent";
       case 128:
        return "reset";
       case 129:
        return "resize";
       case 130:
        return "resourcetimingbufferfull";
       default: return cst_result;
     }
    }
    if(44 <= _ae_)
     switch(_ae_){
       case 44:
        return "DOMFocusIn";
       case 45:
        return "DOMFocusOut";
       case 46:
        return "DOMNodeInserted";
       case 47:
        return "DOMNodeInsertedIntoDocument";
       case 48:
        return "DOMNodeRemoved";
       case 49:
        return "DOMNodeRemovedFromDocument";
       case 50:
        return "DOMSubtreeModified";
       case 51:
        return "downloading";
       case 52:
        return "drag";
       case 53:
        return "dragend";
       case 54:
        return "dragenter";
       case 55:
        return "dragleave";
       case 56:
        return "dragover";
       case 57:
        return "dragstart";
       case 58:
        return "drop";
       case 59:
        return "durationchange";
       case 60:
        return "emptied";
       case 61:
        return "end";
       case 62:
        return "ended";
       case 63:
        return "endEvent";
       case 64:
        return "error";
       case 65:
        return cst_focus;
       case 66:
        return "focusin";
       case 67:
        return "focusout";
       case 68:
        return "fullscreenchange";
       case 69:
        return "fullscreenerror";
       case 70:
        return "gamepadconnected";
       case 71:
        return "gamepaddisconnected";
       case 72:
        return "gotpointercapture";
       case 73:
        return "hashchange";
       case 74:
        return "input";
       case 75:
        return "invalid";
       case 76:
        return "keydown";
       case 77:
        return "keypress";
       case 78:
        return "keyup";
       case 79:
        return "languagechange";
       case 80:
        return "levelchange";
       case 81:
        return "load";
       case 82:
        return "loadeddata";
       case 83:
        return "loadedmetadata";
       case 84:
        return "loadend";
       case 85:
        return "loadstart";
       case 86:
        return "lostpointercapture";
       default: return "mark";
     }
    switch(_ae_){
      case 0:
       return "abort";
      case 1:
       return "afterprint";
      case 2:
       return "animationend";
      case 3:
       return "animationiteration";
      case 4:
       return "animationstart";
      case 5:
       return "appinstalled";
      case 6:
       return "audioend";
      case 7:
       return "audioprocess";
      case 8:
       return "audiostart";
      case 9:
       return "beforeprint";
      case 10:
       return "beforeunload";
      case 11:
       return "beginEvent";
      case 12:
       return "blocked";
      case 13:
       return cst_blur;
      case 14:
       return "boundary";
      case 15:
       return "cached";
      case 16:
       return "canplay";
      case 17:
       return "canplaythrough";
      case 18:
       return "change";
      case 19:
       return "chargingchange";
      case 20:
       return "chargingtimechange";
      case 21:
       return "checking";
      case 22:
       return cst_click;
      case 23:
       return cst_close;
      case 24:
       return "complete";
      case 25:
       return "compositionend";
      case 26:
       return "compositionstart";
      case 27:
       return "compositionupdate";
      case 28:
       return "contextmenu";
      case 29:
       return "copy";
      case 30:
       return "cut";
      case 31:
       return "dblclick";
      case 32:
       return "devicechange";
      case 33:
       return "devicelight";
      case 34:
       return "devicemotion";
      case 35:
       return "deviceorientation";
      case 36:
       return "deviceproximity";
      case 37:
       return "dischargingtimechange";
      case 38:
       return "DOMActivate";
      case 39:
       return "DOMAttributeNameChanged";
      case 40:
       return "DOMAttrModified";
      case 41:
       return "DOMCharacterDataModified";
      case 42:
       return "DOMContentLoaded";
      default: return "DOMElementNameChanged";
    }
   }
   function target(x161){return x161["target"];}
   function related_target(x162){
    var _ad_ = x162["relatedTarget"];
    return caml_call2(Ojs[7], function(x163){return x163;}, _ad_);
   }
   function prevent_default(x164){x164.preventDefault(); return 0;}
   function stop_propagation(x165){x165.stopPropagation(); return 0;}
   function type$0(x166){return caml_js_to_string(x166[cst_type]);}
   function init_event(x170, x167, x168, x169){
    x170.initEvent(kind_to_js(x167), ! ! x168, ! ! x169);
    return 0;
   }
   function client_x(x171){return x171["clientX"];}
   function client_y(x172){return x172["clientY"];}
   function page_x(x173){return x173["pageX"];}
   function page_y(x174){return x174["pageY"];}
   function screen_x(x175){return x175["screenX"];}
   function screen_y(x176){return x176["screenY"];}
   function movement_x(x177){return x177["movementX"];}
   function movement_y(x178){return x178["movementY"];}
   function buttons(x179){return x179["buttons"];}
   function alt_key(x180){return x180["altKey"] | 0;}
   function ctrl_key(x181){return x181["ctrlKey"] | 0;}
   function shift_key(x182){return x182["shiftKey"] | 0;}
   function which(x183){return x183["which"];}
   function code(x184){return caml_js_to_string(x184[cst_code]);}
   function key$0(x185){return caml_js_to_string(x185[cst_key]);}
   function delta_y(x186){return x186["deltaY"];}
   function delta_x(x187){return x187["deltaX"];}
   function data_transfer(x188){
    var _ac_ = x188["dataTransfer"];
    return caml_call1(DataTransfer[1], _ac_);
   }
   function clipboard_data(x189){
    var _ab_ = x189["clipboardData"];
    return caml_call1(DataTransfer[1], _ab_);
   }
   function data(x190){return x190["data"];}
   function origin(x191){return caml_js_to_string(x191[cst_origin]);}
   function state(x192){return x192["state"];}
   function t_of_js$8(x194){return x194;}
   function t_to_js$8(x193){return x193;}
   function height(x195){return x195[cst_height];}
   function width(x196){return x196[cst_width];}
   function left(x197){return x197[cst_left];}
   function right(x198){return x198[cst_right];}
   function top(x199){return x199[cst_top];}
   function bottom(x200){return x200[cst_bottom];}
   var
    Rect = [0, t_of_js$8, t_to_js$8, height, width, left, right, top, bottom];
   function t_of_js$9(x202){return x202;}
   function t_to_js$9(x201){return x201;}
   function x(x203){return x203["x"];}
   function y(x204){return x204["y"];}
   function height$0(x205){return x205[cst_height];}
   function width$0(x206){return x206[cst_width];}
   var SVGRect = [0, t_of_js$9, t_to_js$9, x, y, height$0, width$0];
   function t_of_js$10(x208){return x208;}
   function t_to_js$10(x207){return x207;}
   function set(style, prop, value){
    return style[prop] = caml_js_from_string(value);
   }
   function set_color(x209, x210){
    return x209["color"] = caml_js_from_string(x210);
   }
   function set_border(x211, x212){
    return x211["border"] = caml_js_from_string(x212);
   }
   function set_background(x213, x214){
    return x213["background"] = caml_js_from_string(x214);
   }
   function set_background_color(x215, x216){
    return x215["backgroundColor"] = caml_js_from_string(x216);
   }
   function set_height(x217, x218){
    return x217[cst_height] = caml_js_from_string(x218);
   }
   function set_width(x219, x220){
    return x219[cst_width] = caml_js_from_string(x220);
   }
   function set_bottom(x221, x222){
    return x221[cst_bottom] = caml_js_from_string(x222);
   }
   function set_left(x223, x224){
    return x223[cst_left] = caml_js_from_string(x224);
   }
   function set_top(x225, x226){
    return x225[cst_top] = caml_js_from_string(x226);
   }
   function set_right(x227, x228){
    return x227[cst_right] = caml_js_from_string(x228);
   }
   function set_position(x229, x230){
    return x229["position"] = caml_js_from_string(x230);
   }
   function set_cursor(x231, x232){
    return x231["cursor"] = caml_js_from_string(x232);
   }
   function set_display(x233, x234){
    return x233["display"] = caml_js_from_string(x234);
   }
   function set_visibility(x235, x236){
    return x235["visibility"] = caml_js_from_string(x236);
   }
   function get(style, prop){return caml_js_to_string(style[prop]);}
   function unset(style, prop){return style[prop] = Ojs[20];}
   var
    Style =
      [0,
       t_of_js$10,
       t_to_js$10,
       set,
       set_color,
       set_border,
       set_background,
       set_background_color,
       set_height,
       set_width,
       set_bottom,
       set_left,
       set_top,
       set_right,
       set_position,
       set_cursor,
       set_display,
       set_visibility,
       get,
       unset];
   function t_of_js$11(x238){return x238;}
   function t_to_js$11(x237){return x237;}
   function add(x240, x239){x240.add(caml_js_from_string(x239)); return 0;}
   function remove(x242, x241){
    x242.remove(caml_js_from_string(x241));
    return 0;
   }
   function contains(x244, x243){
    return x244.contains(caml_js_from_string(x243)) | 0;
   }
   function replace(x247, x245, x246){
    x247.replace(caml_js_from_string(x245), caml_js_from_string(x246));
    return 0;
   }
   function toggle(x250, x248, x249){
    return x250.toggle(caml_js_from_string(x248), ! ! x249) | 0;
   }
   var
    ClassList =
      [0, t_of_js$11, t_to_js$11, add, remove, contains, replace, toggle];
   function t_of_js$12(x252){return x252;}
   function t_to_js$12(x251){return x251;}
   var null$0 = Ojs[20], _a_ = [0, cst_lib_js_browser_ml, 1231, 15];
   function id(x253){return caml_js_to_string(x253[cst_id]);}
   function set_id(x254, x255){
    return x254[cst_id] = caml_js_from_string(x255);
   }
   function node_type(x259){
    var x257 = x259["nodeType"], switcher = x257 - 1 | 0;
    if(10 >= switcher >>> 0)
     switch(switcher){
       case 0:
        return 0;
       case 2:
        return 1;
       case 6:
        return 2;
       case 7:
        return 3;
       case 8:
        return 4;
       case 9:
        return 5;
       case 10:
        return 6;
     }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function clone_node(x261, x260){
    var x252 = x261.cloneNode(! ! x260);
    return x252;
   }
   function contains$0(x263, x262){return x263.contains(x262) | 0;}
   function append_child(x265, x264){x265.appendChild(x264); return 0;}
   function insert_before(x268, x266, x267){
    x268.insertBefore(x266, x267);
    return 0;
   }
   function replace_child(x271, x269, x270){
    x271.replaceChild(x269, x270);
    return 0;
   }
   function remove_child(x273, x272){x273.removeChild(x272); return 0;}
   function first_child(x274){var x252 = x274[cst_firstChild]; return x252;}
   function last_child(x275){var x252 = x275["lastChild"]; return x252;}
   function next_sibling(x276){var x252 = x276["nextSibling"]; return x252;}
   function remove_all_children(x274){
    var child$1 = x274[cst_firstChild], child = child$1;
    for(;;){
     if(runtime.caml_equal(child, null$0)) return 0;
     remove_child(x274, child);
     var child$0 = x274[cst_firstChild];
     child = child$0;
    }
   }
   function has_child_nodes(x277){return x277.hasChildNodes() | 0;}
   function add_event_listener(x282, x278, x279, x281){
    x282.addEventListener
     (kind_to_js(x278),
      caml_js_wrap_callback_strict
       (1, function(x280){return caml_call1(x279, x280);}),
      ! ! x281);
    return 0;
   }
   function add_cancellable_event_listener(x286, x283, f, x285){
    var
     x284 =
       caml_js_wrap_callback_strict
        (1, function(x155){return caml_call1(f, x155);});
    x286.addEventListener(kind_to_js(x283), x284, ! ! x285);
    return function(param){
     x286.removeEventListener(kind_to_js(x283), x284, ! ! x285);
     return 0;};
   }
   function inner_text(x291){return caml_js_to_string(x291["innerText"]);}
   function get_elements_by_tag_name(x293, x292){
    var _aa_ = x293.getElementsByTagName(caml_js_from_string(x292));
    return caml_call2(Ojs[1], t_of_js$12, _aa_);
   }
   function get_elements_by_class_name(x296, x295){
    var _$_ = x296.getElementsByClassName(caml_js_from_string(x295));
    return caml_call2(Ojs[1], t_of_js$12, _$_);
   }
   function has_attribute(x299, x298){
    return x299.hasAttribute(caml_js_from_string(x298)) | 0;
   }
   function get_attribute(x301, x300){
    return caml_js_to_string(x301.getAttribute(caml_js_from_string(x300)));
   }
   function remove_attribute(x303, x302){
    x303.removeAttribute(caml_js_from_string(x302));
    return 0;
   }
   function set_attribute(x306, x304, x305){
    x306.setAttribute(caml_js_from_string(x304), caml_js_from_string(x305));
    return 0;
   }
   function get_bounding_client_rect(x307){
    var ___ = x307.getBoundingClientRect();
    return caml_call1(Rect[1], ___);
   }
   function get_bounding_box(x308){
    var _Z_ = x308.getBBox();
    return caml_call1(SVGRect[1], _Z_);
   }
   function attach_shadow(mode, element){
    var
     _Y_ = mode ? "closed" : cst_open,
     x252 = element.attachShadow({mode: _Y_});
    return x252;
   }
   function normalize(x316){x316.normalize(); return 0;}
   function value(x317){return caml_js_to_string(x317[cst_value]);}
   function set_value(x318, x319){
    return x318[cst_value] = caml_js_from_string(x319);
   }
   function select(x320){x320.select(); return 0;}
   function files$0(x321){
    var _X_ = x321[cst_files];
    return caml_call2(Ojs[3], t_of_js$5, _X_);
   }
   function submit(x323){x323.submit(); return 0;}
   function show_picker(x324){x324.showPicker(); return 0;}
   function selected_index(x325){return x325["selectedIndex"];}
   function checked(x326){return x326[cst_checked] | 0;}
   function set_checked(x327, x328){return x327[cst_checked] = ! ! x328;}
   function node_value(x329){return caml_js_to_string(x329[cst_nodeValue]);}
   function set_node_value(x330, x331){
    return x330[cst_nodeValue] = caml_js_from_string(x331);
   }
   function parent_node(x332){var x252 = x332["parentNode"]; return x252;}
   function node_name(x333){return caml_js_to_string(x333["nodeName"]);}
   function dispatch_event(x335, x334){return x335.dispatchEvent(x334) | 0;}
   function style(x336){
    var _W_ = x336["style"];
    return caml_call1(Style[1], _W_);
   }
   function inner_HTML(x337){return caml_js_to_string(x337[cst_innerHTML]);}
   function outer_HTML(x338){return caml_js_to_string(x338["outerHTML"]);}
   function set_inner_HTML(x339, x340){
    return x339[cst_innerHTML] = caml_js_from_string(x340);
   }
   function set_text_content(x341, x342){
    return x341["textContent"] = caml_js_from_string(x342);
   }
   function set_class_name(x343, x344){
    return x343[cst_className] = caml_js_from_string(x344);
   }
   function class_name(x345){return caml_js_to_string(x345[cst_className]);}
   function client_width(x346){return x346["clientWidth"];}
   function client_height(x347){return x347["clientHeight"];}
   function scroll_width(x348){return x348["scrollWidth"];}
   function scroll_height(x349){return x349["scrollHeight"];}
   function width$1(x350){return x350[cst_width];}
   function height$1(x351){return x351[cst_height];}
   function offset_parent(x352){
    var _V_ = x352["offsetParent"];
    return caml_call2(Ojs[7], t_of_js$12, _V_);
   }
   function offset_top(x354){return x354["offsetTop"];}
   function offset_left(x355){return x355["offsetLeft"];}
   function offset_width(x356){return x356["offsetWidth"];}
   function offset_height(x357){return x357["offsetHeight"];}
   function scroll_top(x358){return x358[cst_scrollTop];}
   function set_scroll_top(x359, x360){return x359[cst_scrollTop] = x360;}
   function scroll_into_view(x362, x361){
    x362.scrollIntoView(! ! x361);
    return 0;
   }
   function focus(x363){x363.focus(); return 0;}
   function blur(x364){x364.blur(); return 0;}
   function behavior_to_js(x369){
    switch(x369){
      case 0:
       return "auto";
      case 1:
       return "instant";
      default: return "smooth";
    }
   }
   function scroll_into_view_options(x373, x372){
    x373.scrollIntoView
     ({behavior: caml_call2(Ojs[8], behavior_to_js, x372[1])});
    return 0;
   }
   function scroll_by(x379, x378){
    var _U_ = caml_call2(Ojs[8], behavior_to_js, x378[3]);
    x379.scrollBy({top: x378[1], left: x378[2], behavior: _U_});
    return 0;
   }
   function selection_start(x380){return x380[cst_selectionStart];}
   function selection_end(x381){return x381[cst_selectionEnd];}
   function set_selection_start(x382, x383){return x382[cst_selectionStart] = x383;
   }
   function set_selection_end(x384, x385){return x384[cst_selectionEnd] = x385;
   }
   function remove$0(x386){x386.remove(); return 0;}
   function click(x387){x387.click(); return 0;}
   function query_selector(x389, x388){
    var x252 = x389.querySelector(caml_js_from_string(x388));
    return x252;
   }
   function query_selector_all(x391, x390){
    var _T_ = x391.querySelectorAll(caml_js_from_string(x390));
    return caml_call2(Ojs[3], t_of_js$12, _T_);
   }
   function class_list(x393){
    var _S_ = x393["classList"];
    return caml_call1(ClassList[1], _S_);
   }
   function t_of_js$13(x395){return x395;}
   function t_to_js$13(x394){return x394;}
   function create_element(x397, x396){
    var x252 = x397.createElement(caml_js_from_string(x396));
    return x252;
   }
   function create_element_ns(x400, x398, x399){
    var
     x252 =
       x400.createElementNS
        (caml_js_from_string(x398), caml_js_from_string(x399));
    return x252;
   }
   function create_text_node(x402, x401){
    var x252 = x402.createTextNode(caml_js_from_string(x401));
    return x252;
   }
   function create_event(x404, x403){
    var x155 = x404.createEvent(caml_js_from_string(x403));
    return x155;
   }
   function get_element_by_id(x406, x405){
    var _R_ = x406.getElementById(caml_js_from_string(x405));
    return caml_call2(Ojs[7], t_of_js$12, _R_);
   }
   function get_elements_by_class_name$0(x409, x408){
    var _Q_ = x409.getElementsByClassName(caml_js_from_string(x408));
    return caml_call2(Ojs[1], t_of_js$12, _Q_);
   }
   function body(x411){var x252 = x411["body"]; return x252;}
   function document_element(x412){
    var x252 = x412["documentElement"];
    return x252;
   }
   function active_element(x413){
    var x252 = x413["activeElement"];
    return x252;
   }
   function cookie(x414){return caml_js_to_string(x414[cst_cookie]);}
   function set_cookie(x415, x416){
    return x415[cst_cookie] = caml_js_from_string(x416);
   }
   function set_title(x417, x418){
    return x417["title"] = caml_js_from_string(x418);
   }
   function open(x424, x419, x420, param){
    var x421 = new Ojs[19][cst_Array];
    if(x419){var x423 = x419[1]; x421.push(caml_js_from_string(x423));}
    if(x420){var x422 = x420[1]; x421.push(caml_js_from_string(x422));}
    x424[cst_open].apply(x424, x421);
    return 0;
   }
   function write(x427, x426){
    x427.write(caml_js_from_string(x426));
    return 0;
   }
   function writeln(x429, x428){
    x429.writeln(caml_js_from_string(x428));
    return 0;
   }
   function close(x430){x430.close(); return 0;}
   function exec_command(x432, x431){
    return x432.execCommand(caml_js_from_string(x431)) | 0;
   }
   function query_selector$0(x434, x433){
    var x252 = x434.querySelector(caml_js_from_string(x433));
    return x252;
   }
   function query_selector_all$0(x436, x435){
    var _P_ = x436.querySelectorAll(caml_js_from_string(x435));
    return caml_call2(Ojs[3], t_of_js$12, _P_);
   }
   function remove_all_selection_ranges(x438){
    runtime.caml_js_meth_call(x438, "getSelection().removeAllRanges", [0]);
    return 0;
   }
   var
    Document =
      [0,
       t_of_js$13,
       t_to_js$13,
       create_element,
       create_element_ns,
       create_text_node,
       create_event,
       get_element_by_id,
       get_elements_by_class_name$0,
       body,
       document_element,
       active_element,
       cookie,
       set_cookie,
       set_title,
       open,
       write,
       writeln,
       close,
       exec_command,
       query_selector$0,
       query_selector_all$0,
       remove_all_selection_ranges];
   function t_of_js$14(x440){return x440;}
   function t_to_js$14(x439){return x439;}
   function length$1(x441){return x441[cst_length];}
   function back(x442){x442.back(); return 0;}
   function forward(x443){x443.forward(); return 0;}
   function go(x447, x444){
    if(349440947 <= x444[1])
     var x445 = x444[2], x445$0 = x445;
    else
     var x446 = x444[2], x445$0 = caml_js_from_string(x446);
    x447.go(x445$0);
    return 0;
   }
   function replace_state(x451, x448, x449, x450){
    x451.replaceState
     (x448, caml_js_from_string(x449), caml_js_from_string(x450));
    return 0;
   }
   function push_state(x455, x452, x453, x454){
    x455.pushState(x452, caml_js_from_string(x453), caml_js_from_string(x454));
    return 0;
   }
   var
    History =
      [0,
       t_of_js$14,
       t_to_js$14,
       length$1,
       back,
       forward,
       go,
       replace_state,
       push_state];
   function t_of_js$15(x457){return x457;}
   function t_to_js$15(x456){return x456;}
   function get_hash(param){
    return caml_js_to_string(Ojs[19][cst_location][cst_hash]);
   }
   function set_hash(x458){
    var _O_ = caml_js_from_string(x458);
    return Ojs[19][cst_location][cst_hash] = _O_;
   }
   function host(x459){return caml_js_to_string(x459[cst_host]);}
   function set_host(x460, x461){
    return x460[cst_host] = caml_js_from_string(x461);
   }
   function hostname(x462){return caml_js_to_string(x462[cst_hostname]);}
   function set_hostname(x463, x464){
    return x463[cst_hostname] = caml_js_from_string(x464);
   }
   function href(param){
    return caml_js_to_string(Ojs[19][cst_location][cst_href]);
   }
   function set_href(x465){
    var _N_ = caml_js_from_string(x465);
    return Ojs[19][cst_location][cst_href] = _N_;
   }
   function pathname(x466){return caml_js_to_string(x466[cst_pathname]);}
   function set_pathname(x467, x468){
    return x467[cst_pathname] = caml_js_from_string(x468);
   }
   function port(x469){return caml_js_to_string(x469[cst_port]);}
   function set_port(x470, x471){
    return x470[cst_port] = caml_js_from_string(x471);
   }
   function protocol(x472){return caml_js_to_string(x472[cst_protocol]);}
   function set_protocol(x473, x474){
    return x473[cst_protocol] = caml_js_from_string(x474);
   }
   function search$0(x475){return caml_js_to_string(x475[cst_search]);}
   function set_search(x476, x477){
    return x476[cst_search] = caml_js_from_string(x477);
   }
   function origin$0(x478){return caml_js_to_string(x478[cst_origin]);}
   function assign(x480, x479){
    x480.assign(caml_js_from_string(x479));
    return 0;
   }
   function reload(x484, x481, param){
    var x482 = new Ojs[19][cst_Array];
    if(x481){var x483 = x481[1]; x482.push(! ! x483);}
    x484["reload"].apply(x484, x482);
    return 0;
   }
   function replace$0(x487, x486){
    x487.replace(caml_js_from_string(x486));
    return 0;
   }
   var
    Location =
      [0,
       t_of_js$15,
       t_to_js$15,
       get_hash,
       set_hash,
       host,
       set_host,
       hostname,
       set_hostname,
       href,
       set_href,
       pathname,
       set_pathname,
       port,
       set_port,
       protocol,
       set_protocol,
       search$0,
       set_search,
       origin$0,
       assign,
       reload,
       replace$0];
   function t_of_js$16(x489){return x489;}
   function t_to_js$16(x488){return x488;}
   function add_event_listener$0(x498, x494, x495, x497){
    x498.addEventListener
     (kind_to_js(x494),
      caml_js_wrap_callback_strict
       (1, function(x496){return caml_call1(x495, x496);}),
      ! ! x497);
    return 0;
   }
   function add_cancellable_event_listener$0(x502, x499, f, x501){
    var
     x500 =
       caml_js_wrap_callback_strict
        (1, function(x155){return caml_call1(f, x155);});
    x502.addEventListener(kind_to_js(x499), x500, ! ! x501);
    return function(param){
     x502.removeEventListener(kind_to_js(x499), x500, ! ! x501);
     return 0;};
   }
   function document(x507){
    var _M_ = x507[cst_document];
    return caml_call1(Document[1], _M_);
   }
   function set_onload(x508, x509){
    return x508[cst_onload] =
            caml_js_wrap_callback_strict
             (1, function(param){return caml_call1(x509, 0);});
   }
   function set_interval(x512, x510, x511){
    var
     x493 =
       x512.setInterval
        (caml_js_wrap_callback_strict
          (1, function(param){return caml_call1(x510, 0);}),
         x511);
    return x493;
   }
   function set_timeout(x515, x513, x514){
    var
     x491 =
       x515.setTimeout
        (caml_js_wrap_callback_strict
          (1, function(param){return caml_call1(x513, 0);}),
         x514);
    return x491;
   }
   function clear_timeout(x517, x516){x517.clearTimeout(x516); return 0;}
   function clear_interval(x519, x518){x519.clearInterval(x518); return 0;}
   function request_animation_frame(x522, x520){
    x522.requestAnimationFrame
     (caml_js_wrap_callback_strict
       (1, function(x521){return caml_call1(x520, x521);}));
    return 0;
   }
   function open$0(x532, x523, x524, x525, x526, param){
    var x527 = new Ojs[19][cst_Array];
    if(x523){var x531 = x523[1]; x527.push(caml_js_from_string(x531));}
    if(x524){var x530 = x524[1]; x527.push(caml_js_from_string(x530));}
    if(x525){var x529 = x525[1]; x527.push(caml_js_from_string(x529));}
    if(x526){var x528 = x526[1]; x527.push(! ! x528);}
    var x489 = x532[cst_open].apply(x532, x527);
    return x489;
   }
   function alert(x535, x534){
    x535.alert(caml_js_from_string(x534));
    return 0;
   }
   function session_storage(x536){
    var _L_ = x536["sessionStorage"];
    return caml_call2(Ojs[7], Storage[1], _L_);
   }
   function local_storage(x538){
    var _K_ = x538["localStorage"];
    return caml_call2(Ojs[7], Storage[1], _K_);
   }
   function inner_width(x540){return x540["innerWidth"];}
   function inner_height(x541){return x541["innerHeight"];}
   function page_x_offset(x542){return x542["pageXOffset"];}
   function page_y_offset(x543){return x543["pageYOffset"];}
   function scroll_by$0(x546, x544, x545){x546.scrollBy(x544, x545); return 0;
   }
   function scroll_to(x549, x547, x548){x549.scrollTo(x547, x548); return 0;}
   function scroll_to_options(x555, x554){
    var _J_ = caml_call2(Ojs[8], behavior_to_js, x554[3]);
    x555.scrollTo({top: x554[1], left: x554[2], behavior: _J_});
    return 0;
   }
   function history(x556){
    var _I_ = x556["history"];
    return caml_call1(History[1], _I_);
   }
   function location(x557){
    var _H_ = x557[cst_location];
    return caml_call1(Location[1], _H_);
   }
   function frame_element(x558){var x252 = x558["frameElement"]; return x252;}
   function get_computed_style(x560, x559){
    var _G_ = x560.getComputedStyle(x559);
    return caml_call1(Style[1], _G_);
   }
   function decode_URI_component(x562, x561){
    return caml_js_to_string
            (x562.decodeURIComponent(caml_js_from_string(x561)));
   }
   function event_source(x563){var x489 = x563["source"]; return x489;}
   function post_message(x566, x564, x565){
    x566.postMessage(x564, caml_js_from_string(x565));
    return 0;
   }
   function content_window(x567){
    var _F_ = x567["contentWindow"];
    return caml_call2(Ojs[7], t_of_js$16, _F_);
   }
   function content_document(x569){
    var _E_ = x569["contentDocument"];
    return caml_call2(Ojs[7], Document[1], _E_);
   }
   var IFrame = [0, content_window, content_document];
   function parse$0(x571){
    var _D_ = caml_js_from_string(x571);
    return Ojs[19][cst_JSON].parse(_D_);
   }
   function stringify(x572){
    return caml_js_to_string(Ojs[19][cst_JSON].stringify(x572));
   }
   var
    JSON = [0, parse$0, stringify],
    _b_ = [0, cst_lib_js_browser_ml, 2161, 15],
    _c_ = [0, cst_lib_js_browser_ml, 2326, 15];
   function t_of_js$17(x577){return x577;}
   function t_to_js$17(x576){return x576;}
   function create$2(param){
    var x577 = new Ojs[19]["FileReader"];
    return x577;
   }
   function ready_state(x578){
    var x574 = x578[cst_readyState];
    if(2 < x574 >>> 0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    switch(x574){case 0: return 0;case 1: return 1;default: return 2;
    }
   }
   function result(x579){return caml_js_to_string(x579[cst_result]);}
   function set_onload$0(x580, x581){
    return x580[cst_onload] =
            caml_js_wrap_callback_strict
             (1, function(param){return caml_call1(x581, 0);});
   }
   function read_as_binary_string(x583, x582){x583.readAsBinaryString(x582); return 0;
   }
   function read_as_text(x585, x584){x585.readAsText(x584); return 0;}
   function read_as_data_url(x587, x586){x587.readAsDataURL(x586); return 0;}
   function t_of_js$18(x589){return x589;}
   function t_to_js$18(x588){return x588;}
   function create$3(param){
    var x589 = new Ojs[19]["XMLHttpRequest"];
    return x589;
   }
   function open$1(x592, x590, x591){
    x592.open(caml_js_from_string(x590), caml_js_from_string(x591));
    return 0;
   }
   function send(x594, x593){x594.send(x593); return 0;}
   function set_request_header(x597, x595, x596){
    x597.setRequestHeader
     (caml_js_from_string(x595), caml_js_from_string(x596));
    return 0;
   }
   function get_response_header(x599, x598){
    var _C_ = x599.getResponseHeader(caml_js_from_string(x598));
    return caml_call2(Ojs[7], caml_js_to_string, _C_);
   }
   function get_all_response_headers(x601){
    return caml_js_to_string(x601.getAllResponseHeaders());
   }
   function set_response_type(x602, x603){
    return x602[cst_responseType] = caml_js_from_string(x603);
   }
   function override_mime_type(x605, x604){
    x605.overrideMimeType(caml_js_from_string(x604));
    return 0;
   }
   function set_with_credentials(x606, x607){
    return x606["withCredentials"] = ! ! x607;
   }
   function status(x613){return x613["status"];}
   function status_text(x614){return caml_js_to_string(x614["statusText"]);}
   function ready_state$0(x615){
    var x610 = x615[cst_readyState];
    if(4 < x610 >>> 0) return [0, x610];
    switch(x610){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      case 3:
       return 3;
      default: return 4;
    }
   }
   function response_type(x616){
    return caml_js_to_string(x616[cst_responseType]);
   }
   function response_text(x617){
    return caml_js_to_string(x617["responseText"]);
   }
   function response(x618){return x618[cst_response];}
   function response_URL(x619){return caml_js_to_string(x619["responseURL"]);}
   function set_onreadystatechange(x620, x621){
    return x620["onreadystatechange"] =
            caml_js_wrap_callback_strict
             (1, function(param){return caml_call1(x621, 0);});
   }
   function t_of_js$19(x623){return x623;}
   function t_to_js$19(x622){return x622;}
   function create$4(x627, x628, param){
    var x629 = new Ojs[19][cst_Array];
    x629.push(caml_js_from_string(x627));
    if(x628){
     var x630 = x628[1];
     x629.push(caml_call2(Ojs[4], caml_js_from_string, x630));
    }
    var x623 = caml_ojs_new_arr(Ojs[19]["WebSocket"], x629);
    return x623;
   }
   function send$0(x633, x632){
    x633.send(caml_js_from_string(x632));
    return 0;
   }
   function close$0(x639, x634, x635, param){
    var x636 = new Ojs[19][cst_Array];
    if(x634){var x638 = x634[1]; x636.push(x638);}
    if(x635){var x637 = x635[1]; x636.push(caml_js_from_string(x637));}
    x639[cst_close].apply(x639, x636);
    return 0;
   }
   function binary_type(x641){return caml_js_to_string(x641[cst_binaryType]);}
   function set_binary_type(x642, x643){
    return x642[cst_binaryType] = caml_js_from_string(x643);
   }
   function ready_state$1(x644){
    var x625 = x644[cst_readyState];
    if(3 < x625 >>> 0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    switch(x625){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      default: return 3;
    }
   }
   function add_event_listener$1(x649, x645, x646, x648){
    x649.addEventListener
     (kind_to_js(x645),
      caml_js_wrap_callback_strict
       (1, function(x647){return caml_call1(x646, x647);}),
      ! ! x648);
    return 0;
   }
   function code$0(x652){return x652[cst_code];}
   var
    window = Ojs[19][cst_window],
    _d_ = Ojs[19][cst_document],
    document$0 = caml_call1(Document[1], _d_);
   function context_of_js(x654){return x654;}
   function context_to_js(x653){return x653;}
   function gradient_of_js(x656){return x656;}
   function gradient_to_js(x655){return x655;}
   function get_context(opt, canvas){
    if(opt) var sth = opt[1], alpha = sth; else var alpha = 1;
    var _B_ = canvas.getContext("2d", {alpha: ! ! alpha});
    return caml_call2(Ojs[7], context_of_js, _B_);
   }
   function to_data_URL(x665){return caml_js_to_string(x665.toDataURL());}
   function set_fill_style(x666, x667){
    if(66123280 <= x667[1])
     var x669 = x667[2], _A_ = x669;
    else
     var x668 = x667[2], _A_ = caml_js_from_string(x668);
    return x666["fillStyle"] = _A_;
   }
   function set_stroke_style(x670, x671){
    if(66123280 <= x671[1])
     var x673 = x671[2], _z_ = x673;
    else
     var x672 = x671[2], _z_ = caml_js_from_string(x672);
    return x670["strokeStyle"] = _z_;
   }
   function set_line_width(x674, x675){return x674["lineWidth"] = x675;}
   function create_linear_gradient(x680, x676, x677, x678, x679){
    var x656 = x680.createLinearGradient(x676, x677, x678, x679);
    return x656;
   }
   function add_color_stop(x683, x681, x682){
    x683.addColorStop(x681, caml_js_from_string(x682));
    return 0;
   }
   function begin_path(x684){x684.beginPath(); return 0;}
   function close_path(x685){x685.closePath(); return 0;}
   function arc(x691, x686, x687, x688, x689, x690){
    x691.arc(x686, x687, x688, x689, x690);
    return 0;
   }
   function move_to(x694, x692, x693){x694.moveTo(x692, x693); return 0;}
   function line_to(x697, x695, x696){x697.lineTo(x695, x696); return 0;}
   function fill(x698){x698.fill(); return 0;}
   function stroke(x699){x699.stroke(); return 0;}
   function stroke_rect(x704, x700, x701, x702, x703){
    x704.strokeRect(x700, x701, x702, x703);
    return 0;
   }
   function fill_rect(x709, x705, x706, x707, x708){
    x709.fillRect(x705, x706, x707, x708);
    return 0;
   }
   function set_font(x710, x711){
    return x710["font"] = caml_js_from_string(x711);
   }
   function fill_text(x715, x712, x713, x714){
    x715.fillText(caml_js_from_string(x712), x713, x714);
    return 0;
   }
   function stroke_text(x719, x716, x717, x718){
    x719.strokeText(caml_js_from_string(x716), x717, x718);
    return 0;
   }
   function t_of_js$20(x721){return x721;}
   function t_to_js$20(x720){return x720;}
   function width$2(x722){return x722[cst_width];}
   var TextMetrics = [0, t_of_js$20, t_to_js$20, width$2];
   function measure_text(x724, x723){
    var _y_ = x724.measureText(caml_js_from_string(x723));
    return caml_call1(TextMetrics[1], _y_);
   }
   function rotate(x726, x725){x726.rotate(x725); return 0;}
   function translate(x729, x727, x728){x729.translate(x727, x728); return 0;}
   function scale(x732, x730, x731){x732.scale(x730, x731); return 0;}
   function clear_rect(x737, x733, x734, x735, x736){
    x737.clearRect(x733, x734, x735, x736);
    return 0;
   }
   function now$0(param){return Ojs[19]["performance"].now();}
   var Performance = [0, now$0];
   function log(x741, x740){x741.log(x740); return 0;}
   function time(x743, x742){x743.time(caml_js_from_string(x742)); return 0;}
   function time_end(x745, x744){
    x745.timeEnd(caml_js_from_string(x744));
    return 0;
   }
   var console = Ojs[19]["console"];
   function t_of_js$21(x747){return caml_call1(ArrayBuffer[1], x747);}
   function t_to_js$21(x746){return caml_call1(ArrayBuffer[2], x746);}
   function from_buffer(x748){
    var _x_ = caml_call1(ArrayBuffer[2], x748);
    return t_of_js$21(new Ojs[19][cst_Uint8Array](_x_));
   }
   function create$5(x749){
    return t_of_js$21(new Ojs[19][cst_Uint8Array](x749));
   }
   function set$0(x753, x750, x752){
    var _v_ = caml_call2(Ojs[2], function(_w_){return _w_;}, x750);
    t_to_js$21(x753).set(_v_, x752);
    return 0;
   }
   function length$2(x754){return t_to_js$21(x754)[cst_length];}
   function random(x755){
    var _u_ = t_to_js$21(x755);
    Ojs[19][cst_window]["crypto"].getRandomValues(_u_);
    return 0;
   }
   function to_array(x756){
    var _s_ = t_to_js$21(x756);
    return caml_call2(Ojs[1], function(_t_){return _t_;}, _s_);
   }
   function get$0(a, i){
    var _r_ = t_to_js$21(a);
    return caml_call2(Ojs[17], _r_, i);
   }
   function from(x758, x759){
    return t_of_js$21
            (Ojs[19][cst_Uint8Array].from
              (x758,
               caml_js_wrap_callback_strict
                (1, function(x760){return caml_call1(x759, x760);})));
   }
   var
    Uint8Array =
      [0,
       t_of_js$21,
       t_to_js$21,
       from_buffer,
       create$5,
       set$0,
       length$2,
       random,
       to_array,
       get$0,
       from];
   function of_blob(x761){
    return caml_js_to_string(Ojs[19][cst_URL].createObjectURL(x761));
   }
   function of_file(x762){
    return caml_js_to_string(Ojs[19][cst_URL].createObjectURL(x762));
   }
   function revoke(x763){
    var _q_ = caml_js_from_string(x763);
    Ojs[19][cst_URL].revokeObjectURL(_q_);
    return 0;
   }
   var ObjectURL = [0, of_blob, of_file, revoke];
   function t_of_js$22(x765){return x765;}
   function t_to_js$22(x764){return x764;}
   function unit_type(x766){return x766["unitType"];}
   function value$0(x767){return x767[cst_value];}
   function value_as_string(x768){
    return caml_js_to_string(x768["valueAsString"]);
   }
   function value_in_specified_units(x769){return x769["valueInSpecifiedUnits"];
   }
   var
    Length =
      [0,
       t_of_js$22,
       t_to_js$22,
       unit_type,
       value$0,
       value_as_string,
       value_in_specified_units];
   function t_of_js$23(x771){return x771;}
   function t_to_js$23(x770){return x770;}
   function anim_val(x772){
    var _p_ = x772["animVal"];
    return caml_call1(Length[1], _p_);
   }
   function base_val(x773){
    var _o_ = x773["baseVal"];
    return caml_call1(Length[1], _o_);
   }
   var
    AnimatedLength = [0, t_of_js$23, t_to_js$23, anim_val, base_val],
    Svg = [0, Length, AnimatedLength];
   function encode(x774){
    var _n_ = caml_call1(JsString[2], x774);
    return caml_js_to_string(Ojs[19][cst_window].btoa(_n_));
   }
   function decode(x775){
    var _l_ = caml_js_from_string(x775), _m_ = Ojs[19][cst_window].atob(_l_);
    return caml_call1(JsString[1], _m_);
   }
   var Base64 = [0, encode, decode];
   function t_of_js$24(x777){return x777;}
   function t_to_js$24(x776){return x776;}
   function blob(x778){
    var x = x778.blob();
    function f(x779){return x779;}
    return [0, f, x];
   }
   var FetchResponse = [0, t_of_js$24, t_to_js$24, blob];
   function fetch(x780){
    var x = Ojs[19].fetch(caml_js_from_string(x780)), f = FetchResponse[1];
    return [0, f, x];
   }
   function t_of_js$25(x783){return x783;}
   function t_to_js$25(x782){return x782;}
   function create$6(x784, param){
    var x785 = new Ojs[19][cst_Array];
    if(x784){var x786 = x784[1]; x785.push(caml_js_from_string(x786));}
    var x783 = caml_ojs_new_arr(Ojs[19]["TextDecoder"], x785);
    return x783;
   }
   function decode$0(x788, x787){
    return caml_js_to_string(x788.decode(caml_call1(ArrayBuffer[2], x787)));
   }
   var TextDecoder = [0, t_of_js$25, t_to_js$25, create$6, decode$0];
   function t_of_js$26(x790){return x790;}
   function t_to_js$26(x789){return x789;}
   function client_data_json(x791){
    var _k_ = x791[cst_clientDataJSON];
    return caml_call1(ArrayBuffer[1], _k_);
   }
   function attestation_object(x792){
    var _j_ = x792["attestationObject"];
    return caml_call1(ArrayBuffer[1], _j_);
   }
   var
    AuthenticatorAttestationRespon =
      [0, t_of_js$26, t_to_js$26, client_data_json, attestation_object];
   function t_of_js$27(x794){return x794;}
   function t_to_js$27(x793){return x793;}
   function client_data_json$0(x795){
    var _i_ = x795[cst_clientDataJSON];
    return caml_call1(ArrayBuffer[1], _i_);
   }
   function authenticator_data(x796){
    var _h_ = x796["authenticatorData"];
    return caml_call1(ArrayBuffer[1], _h_);
   }
   function signature(x797){
    var _g_ = x797["signature"];
    return caml_call1(ArrayBuffer[1], _g_);
   }
   function user_handle(x798){
    var _f_ = x798["userHandle"];
    return caml_call1(ArrayBuffer[1], _f_);
   }
   var
    AuthenticatorAssertionResponse =
      [0,
       t_of_js$27,
       t_to_js$27,
       client_data_json$0,
       authenticator_data,
       signature,
       user_handle];
   function t_of_js$28(x800){return x800;}
   function t_to_js$28(x799){return x799;}
   function type$1(x801){return caml_js_to_string(x801[cst_type]);}
   function id$0(x802){return caml_js_to_string(x802[cst_id]);}
   function raw_id(x803){
    var _e_ = x803["rawId"];
    return caml_call1(ArrayBuffer[1], _e_);
   }
   function response$0(x804){return x804[cst_response];}
   var
    PublicKeyCredential =
      [0, t_of_js$28, t_to_js$28, type$1, id$0, raw_id, response$0];
   function t_of_js$29(x806){return x806;}
   function t_to_js$29(x805){return x805;}
   function rp_options(x809, x810, param){
    var x811 = caml_call1(Ojs[11], 0);
    if(x809){var x813 = x809[1]; x811[cst_id] = caml_js_from_string(x813);}
    if(x810){var x812 = x810[1]; x811[cst_name] = caml_js_from_string(x812);}
    return x811;
   }
   function user_options(x816, x817, x818, param){
    var x819 = caml_call1(Ojs[11], 0);
    if(x816){
     var x822 = x816[1];
     x819[cst_id] = caml_call1(ArrayBuffer[2], x822);
    }
    if(x817){var x821 = x817[1]; x819[cst_name] = caml_js_from_string(x821);}
    if(x818){
     var x820 = x818[1];
     x819["displayName"] = caml_js_from_string(x820);
    }
    return x819;
   }
   function key_param_to_js(x823){return x823;}
   function key_param(x825, x826, param){
    var x827 = caml_call1(Ojs[11], 0);
    if(x825){var x829 = x825[1]; x827[cst_type] = caml_js_from_string(x829);}
    if(x826){var x828 = x826[1]; x827["alg"] = x828;}
    return x827;
   }
   function authenticator_options(x832, x833, x834, x835, param){
    var x836 = caml_call1(Ojs[11], 0);
    if(x832){
     var x840 = x832[1];
     x836["authenticatorAttachment"] = caml_js_from_string(x840);
    }
    if(x833){
     var x839 = x833[1];
     x836["residentKey"] = caml_js_from_string(x839);
    }
    if(x834){var x838 = x834[1]; x836["requireResidentKey"] = ! ! x838;}
    if(x835){
     var x837 = x835[1];
     x836[cst_userVerification] = caml_js_from_string(x837);
    }
    return x836;
   }
   function public_key_options
   (x843, x844, x845, x846, x847, x848, x849, x850, param){
    var x851 = caml_call1(Ojs[11], 0);
    if(x843){var x861 = x843[1]; x851["rp"] = x861;}
    if(x844){var x860 = x844[1]; x851["user"] = x860;}
    if(x845){
     var x859 = x845[1];
     x851[cst_challenge] = caml_call1(ArrayBuffer[2], x859);
    }
    if(x846){
     var x857 = x846[1];
     x851["pubKeyCredParams"] = caml_call2(Ojs[4], key_param_to_js, x857);
    }
    if(x847){var x856 = x847[1]; x851[cst_timeout] = x856;}
    if(x848){
     var x854 = x848[1];
     x851["excludeCredentials"] =
      caml_call2(Ojs[4], function(x855){return x855;}, x854);
    }
    if(x849){var x853 = x849[1]; x851["authenticatorSelection"] = x853;}
    if(x850){
     var x852 = x850[1];
     x851["attestation"] = caml_js_from_string(x852);
    }
    return x851;
   }
   function create_options(x864, param){
    var x865 = caml_call1(Ojs[11], 0);
    if(x864){var x866 = x864[1]; x865[cst_publicKey] = x866;}
    return x865;
   }
   function create$7(x867){
    var x = Ojs[19][cst_navigator][cst_credentials].create(x867);
    function f(x868){return x868;}
    return [0, f, x];
   }
   function credential_descriptor_to_js(x869){return x869;}
   function credential_descriptor(x871, x872, x873, param){
    var x874 = caml_call1(Ojs[11], 0);
    if(x871){var x877 = x871[1]; x874[cst_type] = caml_js_from_string(x877);}
    if(x872){
     var x876 = x872[1];
     x874[cst_id] = caml_call1(ArrayBuffer[2], x876);
    }
    if(x873){var x875 = x873[1]; x874["transports"] = x875;}
    return x874;
   }
   function get_public_key_options(x880, x881, x882, x883, x884, x885, param){
    var x886 = caml_call1(Ojs[11], 0);
    if(x880){
     var x893 = x880[1];
     x886[cst_challenge] = caml_call1(ArrayBuffer[2], x893);
    }
    if(x881){var x892 = x881[1]; x886[cst_timeout] = x892;}
    if(x882){var x891 = x882[1]; x886["rpId"] = caml_js_from_string(x891);}
    if(x883){
     var x889 = x883[1];
     x886["allowCredentials"] =
      caml_call2(Ojs[4], credential_descriptor_to_js, x889);
    }
    if(x884){
     var x888 = x884[1];
     x886[cst_userVerification] = caml_js_from_string(x888);
    }
    if(x885){var x887 = x885[1]; x886["extensions"] = x887;}
    return x886;
   }
   function get_options_to_js(x894){return x894;}
   function get_options(x896, param){
    var x897 = caml_call1(Ojs[11], 0);
    if(x896){var x898 = x896[1]; x897[cst_publicKey] = x898;}
    return x897;
   }
   function get$1(x899){
    var x = Ojs[19][cst_navigator][cst_credentials].get(x899);
    function f(x900){return x900;}
    return [0, f, x];
   }
   var
    Js_browser =
      [0,
       [0, then],
       Storage,
       RegExp,
       JsString,
       Date,
       ArrayBuffer,
       [0, options, t_of_js$4, t_to_js$4, create$0, size, type, text],
       [0, t_of_js$5, t_to_js$5, options$0, create$1, name],
       DataTransfer,
       [0,
        t_of_js$7,
        t_to_js$7,
        target,
        related_target,
        prevent_default,
        stop_propagation,
        type$0,
        init_event,
        client_x,
        client_y,
        page_x,
        page_y,
        screen_x,
        screen_y,
        movement_x,
        movement_y,
        buttons,
        alt_key,
        ctrl_key,
        shift_key,
        which,
        code,
        key$0,
        delta_y,
        delta_x,
        data_transfer,
        clipboard_data,
        data,
        origin,
        state],
       Rect,
       SVGRect,
       Style,
       ClassList,
       [0,
        t_of_js$12,
        t_to_js$12,
        null$0,
        id,
        set_id,
        node_type,
        clone_node,
        contains$0,
        append_child,
        insert_before,
        replace_child,
        remove_child,
        first_child,
        last_child,
        next_sibling,
        remove_all_children,
        has_child_nodes,
        add_event_listener,
        add_cancellable_event_listener,
        inner_text,
        get_elements_by_tag_name,
        get_elements_by_class_name,
        has_attribute,
        get_attribute,
        remove_attribute,
        set_attribute,
        get_bounding_client_rect,
        get_bounding_box,
        attach_shadow,
        normalize,
        value,
        set_value,
        select,
        files$0,
        submit,
        show_picker,
        selected_index,
        checked,
        set_checked,
        node_value,
        set_node_value,
        parent_node,
        node_name,
        dispatch_event,
        style,
        inner_HTML,
        outer_HTML,
        set_inner_HTML,
        set_text_content,
        set_class_name,
        class_name,
        client_width,
        client_height,
        scroll_width,
        scroll_height,
        width$1,
        height$1,
        offset_parent,
        offset_top,
        offset_left,
        offset_width,
        offset_height,
        scroll_top,
        set_scroll_top,
        scroll_into_view,
        focus,
        blur,
        scroll_into_view_options,
        scroll_by,
        selection_start,
        selection_end,
        set_selection_start,
        set_selection_end,
        remove$0,
        click,
        query_selector,
        query_selector_all,
        class_list],
       Document,
       History,
       Location,
       [0,
        t_of_js$16,
        t_to_js$16,
        add_event_listener$0,
        add_cancellable_event_listener$0,
        document,
        set_onload,
        set_interval,
        set_timeout,
        clear_timeout,
        clear_interval,
        request_animation_frame,
        open$0,
        alert,
        session_storage,
        local_storage,
        inner_width,
        inner_height,
        page_x_offset,
        page_y_offset,
        scroll_by$0,
        scroll_to,
        scroll_to_options,
        history,
        location,
        frame_element,
        get_computed_style,
        decode_URI_component,
        event_source,
        post_message],
       IFrame,
       JSON,
       [0,
        t_of_js$17,
        t_to_js$17,
        create$2,
        ready_state,
        result,
        set_onload$0,
        read_as_binary_string,
        read_as_text,
        read_as_data_url],
       [0,
        t_of_js$18,
        t_to_js$18,
        create$3,
        open$1,
        send,
        set_request_header,
        get_response_header,
        get_all_response_headers,
        set_response_type,
        override_mime_type,
        set_with_credentials,
        status,
        status_text,
        ready_state$0,
        response_type,
        response_text,
        response,
        response_URL,
        set_onreadystatechange],
       [0,
        t_of_js$19,
        t_to_js$19,
        create$4,
        send$0,
        close$0,
        binary_type,
        set_binary_type,
        ready_state$1,
        add_event_listener$1,
        [0, code$0]],
       window,
       document$0,
       [0,
        context_of_js,
        context_to_js,
        gradient_of_js,
        gradient_to_js,
        get_context,
        to_data_URL,
        set_fill_style,
        set_stroke_style,
        set_line_width,
        create_linear_gradient,
        add_color_stop,
        begin_path,
        close_path,
        arc,
        move_to,
        line_to,
        fill,
        stroke,
        stroke_rect,
        fill_rect,
        set_font,
        fill_text,
        stroke_text,
        TextMetrics,
        measure_text,
        rotate,
        translate,
        scale,
        clear_rect],
       Performance,
       [0, log, time, time_end],
       console,
       Uint8Array,
       ObjectURL,
       Svg,
       Base64,
       FetchResponse,
       fetch,
       TextDecoder,
       [0,
        AuthenticatorAttestationRespon,
        AuthenticatorAssertionResponse,
        PublicKeyCredential,
        [0,
         t_of_js$29,
         t_to_js$29,
         rp_options,
         user_options,
         key_param,
         authenticator_options,
         public_key_options,
         create_options,
         create$7,
         credential_descriptor,
         get_public_key_options,
         get_options,
         get_options_to_js,
         get$1]]];
   runtime.caml_register_global(853, Js_browser, "Js_browser");
   return;
  }
  (globalThis));

//# 2207 "../../.js/default/vdom/vdom_js.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$3 = "",
    cst_baseVal = "baseVal",
    cst_blur = "blur",
    cst_boolean$0 = "boolean",
    cst_change$1 = "change",
    cst_checked$0 = "checked",
    cst_className = "className",
    cst_http_www_w3_org_2000_svg = "http://www.w3.org/2000/svg",
    cst_input$0 = "input",
    cst_lib_vdom_blit_ml = "lib/vdom_blit.ml",
    cst_number = "number",
    cst_string$0 = "string",
    cst_style = "style",
    cst_target$3 = "target",
    cst_value$1 = "value",
    caml_check_bound = runtime.caml_check_bound,
    caml_js_from_string = runtime.caml_js_from_string,
    caml_js_to_string = runtime.caml_js_to_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_lessthan = runtime.caml_string_lessthan,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$1 = cst$3,
    cst$2 = cst$3,
    cst$0 = "]: ",
    cst = ".",
    blur_event = [1, cst_blur, [5, 0]],
    empty = [0, 0, 0],
    Js_browser = global_data.Js_browser,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Ojs$0 = global_data.Ojs,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Assert_failure = global_data.Assert_failure,
    Stdlib_String = global_data.Stdlib__String,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Vdom = global_data.Vdom,
    Stdlib_Result = global_data.Stdlib__Result,
    Ojs_exn = global_data.Ojs_exn,
    Ojs = [248, "Vdom_blit.Ojs", runtime.caml_fresh_oo_id(0)],
    cst_list = "list",
    cst_string = cst_string$0,
    cst_boolean = cst_boolean$0,
    cst_int = "int",
    cst_float = "float",
    _a_ = [0, [11, "unbound field: ", [3, 0, 0]], "unbound field: %S"],
    _b_ =
      [0,
       [11, "unbound method (or wrong number of arguments): ", [3, 0, 0]],
       "unbound method (or wrong number of arguments): %S"],
    _c_ =
      [0,
       [11, "cannot convert ", [2, 0, [11, " to ", [2, 0, 0]]]],
       "cannot convert %s to %s"],
    cst_At_path = "At path [",
    _d_ = [0, 0],
    cst_Encoded_function_received_ =
      "Encoded function received an argument with unsupported type: ",
    _e_ =
      [0,
       [11, "No command handler found! (", [2, 0, [12, 41, 0]]],
       "No command handler found! (%s)"],
    cst_value = cst_value$1,
    cst_target = cst_target$3,
    cst_input = cst_input$0,
    cst_checked = cst_checked$0,
    cst_target$0 = cst_target$3,
    cst_click = "click",
    cst_value$0 = cst_value$1,
    cst_target$1 = cst_target$3,
    cst_change = cst_change$1,
    cst_selectedIndex = "selectedIndex",
    cst_target$2 = cst_target$3,
    cst_change$0 = cst_change$1,
    _f_ = [0, [11, "scroll: ", [2, 0, [12, 10, [10, 0]]]], "scroll: %s\n%!"];
   function string_of_step(param){
    if(0 === param[0]){var n = param[1]; return caml_call1(Stdlib[33], n);}
    var s = param[1];
    return s;
   }
   function string_of_error_kind(param){
    switch(param[0]){
      case 0:
       var s = param[1]; return caml_call2(Stdlib_Printf[4], _a_, s);
      case 1:
       var s$0 = param[1]; return caml_call2(Stdlib_Printf[4], _b_, s$0);
      case 2:
       var s$1 = param[1]; return s$1;
      default:
       var got = param[2], expected = param[1];
       switch(expected){
         case 0:
          var _bx_ = cst_list; break;
         case 1:
          var _bx_ = cst_string; break;
         case 2:
          var _bx_ = cst_boolean; break;
         case 3:
          var _bx_ = cst_int; break;
         default: var _bx_ = cst_float;
       }
       return caml_call3(Stdlib_Printf[4], _c_, got, _bx_);
    }
   }
   function string_of_error(param){
    var path = param[1];
    if(path){
     var
      errk = param[2],
      _bu_ = string_of_error_kind(errk),
      _bv_ = caml_call2(Stdlib[28], cst$0, _bu_),
      _bs_ = caml_call2(Stdlib_List[21], string_of_step, path),
      _bt_ = caml_call2(Stdlib_String[6], cst, _bs_),
      _bw_ = caml_call2(Stdlib[28], _bt_, _bv_);
     return caml_call2(Stdlib[28], cst_At_path, _bw_);
    }
    var errk$0 = param[2];
    return string_of_error_kind(errk$0);
   }
   function typerr(ty, path, got){return [1, [0, path, [3, ty, got]]];}
   function string(param){
    var obj = param[2], path = param[1], ty = caml_call1(Ojs$0[21], obj);
    return ty !== cst_string$0
            ? typerr(1, path, ty)
            : [0, caml_js_to_string(obj)];
   }
   function int$0(param){
    var obj = param[2], path = param[1], ty = caml_call1(Ojs$0[21], obj);
    return ty !== cst_number ? typerr(3, path, ty) : [0, obj];
   }
   function float$0(param){
    var obj = param[2], path = param[1], ty = caml_call1(Ojs$0[21], obj);
    return ty !== cst_number ? typerr(4, path, ty) : [0, obj];
   }
   function bool(param){
    var obj = param[2], path = param[1], ty = caml_call1(Ojs$0[21], obj);
    return ty !== cst_boolean$0 ? typerr(2, path, ty) : [0, obj | 0];
   }
   function object(param){var obj = param[2]; return [0, [0, Ojs, obj]];}
   function eval$0(opt, param){
    if(opt) var sth = opt[1], extra_fields = sth; else var extra_fields = 0;
    if(typeof param === "number")
     switch(param){
       case 0:
        return string;
       case 1:
        return int$0;
       case 2:
        return float$0;
       case 3:
        return bool;
       default: return object;
     }
    switch(param[0]){
      case 0:
       var
        d = param[2],
        key = param[1],
        match = caml_call2(Stdlib_List[47], key, extra_fields);
       if(match){
        var obj = match[1];
        return function(o){
         var _br_ = [0, [0, [1, key], o[1]], obj];
         return eval$0(0, d)(_br_);};
       }
       var d$0 = eval$0(0, d);
       return function(o$1){
        var
         keys$0 = caml_call2(Stdlib_String[16], 46, key),
         o = o$1,
         param = keys$0;
        for(;;){
         if(param){
          var keys = param[2], key$0 = param[1], obj = o[2][key$0];
          if(! runtime.caml_equal(obj, caml_call1(Ojs$0[10], 0))){
           var o$0 = [0, [0, [1, key$0], o[1]], obj];
           o = o$0;
           param = keys;
           continue;
          }
          var _bq_ = [1, [0, o[1], [0, key$0]]];
         }
         else
          var _bq_ = [0, o];
         return caml_call2(Stdlib_Result[6], _bq_, d$0);
        }};
      case 1:
       var
        d$1 = param[3],
        arg = param[2],
        name = param[1],
        d$2 = eval$0(0, d$1);
       return function(o){
        var
         arg$0 =
           caml_call2
            (Stdlib_List[19],
             function(param){
              switch(param[0]){
                case 0:
                 var s = param[1]; return caml_js_from_string(s);
                case 1:
                 var b = param[1]; return ! ! b;
                case 2:
                 var f = param[1]; return f;
                default: var i = param[1]; return i;
              }
             },
             arg),
         arg$1 = caml_call1(Stdlib_Array[12], arg$0);
        try{
         var
          obj = runtime.caml_js_meth_call(o[2], name, arg$1),
          _bo_ = d$2([0, [0, [1, name], o[1]], obj]);
         return _bo_;
        }
        catch(_bp_){
         var _bn_ = caml_wrap_exception(_bp_);
         if(_bn_[1] === Ojs_exn[5]) return [1, [0, o[1], [1, name]]];
         throw caml_maybe_attach_backtrace(_bn_, 0);
        }};
      case 2:
       var d$3 = param[2], f = param[1], d$4 = eval$0([0, extra_fields], d$3);
       return function(o){
        var match = d$4(o);
        if(0 === match[0]){
         var x = match[1];
         return eval$0([0, extra_fields], caml_call1(f, x))(o);
        }
        var err = match[1];
        return [1, err];};
      case 3:
       var msg = param[1]; return function(_bm_){return [0, msg];};
      case 4:
       var f$0 = param[1];
       return function(o){
        return [0,
                function(x){
                 var _bl_ = eval$0([0, extra_fields], caml_call1(f$0, x))(o);
                 return caml_call2(Stdlib_Result[9], string_of_error, _bl_);
                }];};
      case 5:
       var d$5 = param[1], d$6 = eval$0(0, d$5);
       return function(o){
        var ty = caml_call1(Ojs$0[21], o[2]);
        if(ty !== "object") return typerr(0, o[1], ty);
        var l = caml_call2(Ojs$0[3], function(_bk_){return _bk_;}, o[2]);
        function loop(i, acc, param){
         if(! param) return [0, caml_call1(Stdlib_List[9], acc)];
         var
          xs = param[2],
          obj = param[1],
          _bj_ = d$6([0, [0, [0, i], o[1]], obj]);
         return caml_call2
                 (Stdlib_Result[6],
                  _bj_,
                  function(x){return loop(i + 1 | 0, [0, x, acc], xs);});
        }
        return loop(0, 0, l);};
      case 6:
       var msg$0 = param[1];
       return function(param){
        var path = param[1];
        return [1, [0, path, [2, msg$0]]];};
      default:
       var d$7 = param[1], d$8 = eval$0([0, extra_fields], d$7);
       return function(o){
        var match = d$8(o);
        if(0 !== match[0]) return _d_;
        var x = match[1];
        return [0, [0, x]];};
    }
   }
   function decode(opt, d){
    if(opt) var sth = opt[1], extra_fields = sth; else var extra_fields = 0;
    var d$0 = eval$0([0, extra_fields], d);
    return function(obj){
     var match = d$0([0, 0, obj]);
     if(0 === match[0]){var x = match[1]; return [0, x];}
     var err = match[1];
     return [1, string_of_error(err)];};
   }
   function decode_fail(opt, d, o){
    if(opt) var sth = opt[1], extra_fields = sth; else var extra_fields = 0;
    var match = decode([0, extra_fields], d)(o);
    if(0 === match[0]){var res = match[1]; return res;}
    var err = match[1];
    return caml_call1(Stdlib[2], err);
   }
   function convert_arg(o){
    var ty = caml_call1(Ojs$0[21], o);
    if(ty === cst_boolean$0) return [1, o | 0];
    if(ty === cst_number) return [2, o];
    if(ty === cst_string$0) return [0, caml_js_to_string(o)];
    var _bi_ = caml_call2(Stdlib[28], cst_Encoded_function_received_, ty);
    return caml_call1(Stdlib[2], _bi_);
   }
   function encode(param){
    if(typeof param === "number") return caml_call1(Ojs$0[10], 0);
    switch(param[0]){
      case 0:
       var s = param[1]; return caml_js_from_string(s);
      case 1:
       var i = param[1]; return i;
      case 2:
       var f = param[1]; return f;
      case 3:
       var b = param[1]; return ! ! b;
      case 4:
       var l = param[1]; return caml_call2(Ojs$0[4], encode, l);
      case 5:
       var
        l$0 = param[1],
        _bh_ =
          caml_call2
           (Stdlib_List[19],
            function(param){
             var e = param[2], s = param[1];
             return [0, s, encode(e)];
            },
            l$0);
       return runtime.caml_js_object(caml_call1(Stdlib_Array[12], _bh_));
      default:
       var f$0 = param[1];
       return runtime.caml_ojs_wrap_fun_arguments
               (function(o){
                 return encode
                         (caml_call1(f$0, caml_call2(Ojs$0[3], convert_arg, o)));
                });
    }
   }
   function container(ctx){return ctx[1];}
   function send_msg(ctx){return ctx[2];}
   function after_redraw(ctx){return ctx[3];}
   function run(after, h, p, elt, x){
    var p$0 = p, x$0 = x;
    for(;;){
     if(x$0[1] === Vdom[1][1]){var msg = x$0[2]; return caml_call1(p$0, msg);}
     if(x$0[1] === Vdom[1][2]){
      var l = x$0[2];
      return caml_call2
              (Stdlib_List[17],
               function(_bg_){return run(after, h, p$0, elt, _bg_);},
               l);
     }
     if(x$0[1] === Vdom[1][4]){
      var cmd = x$0[3], f = x$0[2];
      let p = p$0, f$0 = f;
      var p$1 = function(x){return caml_call1(p, caml_call1(f$0, x));};
      p$0 = p$1;
      x$0 = cmd;
     }
     else if(x$0[1] === Vdom[1][3]){
      var f$0 = x$0[3], cmd$0 = x$0[2];
      let p = p$0, f = f$0;
      var p$2 = function(x){return run(after, h, p, elt, caml_call1(f, x));};
      p$0 = p$2;
      x$0 = cmd$0;
     }
     else{
      var ctx = [0, elt, p$0, after], param = h;
      for(;;){
       if(! param){
        var
         _be_ = caml_call1(Stdlib_Obj[22][1], x$0),
         _bf_ = caml_call1(Stdlib_Obj[22][2], _be_);
        return caml_call3(Stdlib_Printf[10], Stdlib[2], _e_, _bf_);
       }
       var tl = param[2], hd = param[1];
       if(caml_call2(hd[1], ctx, x$0)) return 0;
       param = tl;
      }
     }
    }
   }
   function input_event(s){
    return [1,
            cst_input,
            [5, [0, [0, cst_target, [5, [0, [0, cst_value, [0, s]], 0]]], 0]]];
   }
   function checked_event(b){
    return [1,
            cst_click,
            [5,
             [0, [0, cst_target$0, [5, [0, [0, cst_checked, [3, b]], 0]]], 0]]];
   }
   function change_event(s){
    return [1,
            cst_change,
            [5,
             [0, [0, cst_target$1, [5, [0, [0, cst_value$0, [0, s]], 0]]], 0]]];
   }
   function change_index_event(i){
    return [1,
            cst_change$0,
            [5,
             [0,
              [0, cst_target$2, [5, [0, [0, cst_selectedIndex, [1, i]], 0]]],
              0]]];
   }
   function custom_event(e){return [0, e];}
   function make(opt, sync, dom){
    if(opt)
     var sth = opt[1], dispose = sth;
    else
     var dispose = function(_bd_){return 0;};
    return [0, dom, sync, dispose];
   }
   function parent(ctx){return ctx[1];}
   function send_event(ctx){return ctx[2];}
   function after_redraw$0(ctx){return ctx[3];}
   function get_doms(param){
    switch(param[0]){
      case 0:
       return [0, param[2], 0];
      case 1:
       return param[2];
      case 2:
       return [0, param[2], 0];
      case 3:
       return param[2];
      case 4:
       return param[2];
      default: return [0, param[2][1], 0];
    }
   }
   function get_vdom(param){
    switch(param[0]){
      case 0:
       return param[1];
      case 1:
       return param[1];
      case 2:
       return param[1];
      case 3:
       return param[1];
      case 4:
       return param[1];
      default: return param[1];
    }
   }
   function eval_prop(param){
    switch(param[0]){
      case 0:
       var x = param[1]; return caml_js_from_string(x);
      case 1:
       var x$0 = param[1]; return x$0;
      case 2:
       var x$1 = param[1]; return x$1;
      default: var x$2 = param[1]; return ! ! x$2;
    }
   }
   function string_of_prop(param){
    switch(param[0]){
      case 0:
       var s = param[1]; return s;
      case 1:
       var x = param[1]; return caml_call1(Stdlib[33], x);
      case 2:
       var x$0 = param[1]; return caml_call1(Stdlib[35], x$0);
      default: var x$1 = param[1]; return caml_call1(Stdlib[30], x$1);
    }
   }
   function same_prop(v1, v2){
    var _bb_ = v1 === v2 ? 1 : 0;
    if(_bb_)
     var _bc_ = _bb_;
    else{
     switch(v1[0]){
       case 0:
        if(0 === v2[0]){var x2 = v2[1], x1 = v1[1]; return x1 == x2 ? 1 : 0;}
        break;
       case 1:
        if(1 === v2[0]){
         var x2$0 = v2[1], x1$0 = v1[1];
         return x1$0 === x2$0 ? 1 : 0;
        }
        break;
       case 2:
        if(2 === v2[0]){
         var x2$1 = v2[1], x1$1 = v1[1];
         return x1$1 == x2$1 ? 1 : 0;
        }
        break;
       default:
        if(3 === v2[0]){
         var x2$2 = v2[1], x1$2 = v1[1];
         return x1$2 === x2$2 ? 1 : 0;
        }
     }
     var _bc_ = 0;
    }
    return _bc_;
   }
   function bmemo(vdom, child){return [4, vdom, get_doms(child), child];}
   function is_visible(dom){
    var
     bounding = caml_call1(Js_browser[15][27], dom),
     top = caml_call1(Js_browser[11][7], bounding),
     bottom = caml_call1(Js_browser[11][8], bounding),
     _a$_ = 0. <= top ? 1 : 0,
     _ba_ =
       _a$_
        ? bottom <= caml_call1(Js_browser[19][17], Js_browser[25]) ? 1 : 0
        : _a$_;
    return _ba_;
   }
   function custom_attribute(prop){
    return prop !== "autofocus"
            ? prop
              !== "autosubmit"
              ? prop
                !== "scroll-to-show"
                ? prop
                  !== "select"
                  ? 0
                  : [0,
                    function(dom, param){
                     return caml_call1(Js_browser[15][33], dom);
                    }]
                : [0,
                  function(dom, v){
                   try{
                    a:
                    {
                     if(3 === v[0] && ! v[1]){var align_top = 0; break a;}
                     var align_top = 1;
                    }
                    var
                     _a9_ = 1 - is_visible(dom),
                     _a__ =
                       _a9_ ? caml_call2(Js_browser[15][65], dom, align_top) : _a9_;
                    return _a__;
                   }
                   catch(exn$0){
                    var
                     exn = caml_wrap_exception(exn$0),
                     _a8_ = caml_call1(Stdlib_Printexc[1], exn);
                    return caml_call2(Stdlib_Printf[2], _f_, _a8_);
                   }
                  }]
              : [0,
                function(dom, param){
                 return caml_call1(Js_browser[15][35], dom);
                }]
            : [0,
              function(dom, v){
               a:
               {
                if(0 === v[0] && v[1] === "if-visible"){
                 var do_focus = is_visible(dom);
                 break a;
                }
                var do_focus = 1;
               }
               return do_focus
                       ? caml_call1(Js_browser[15][66], dom)
                       : do_focus;
              }];
   }
   function apply_effect_prop(dom, prop, value){
    var match = custom_attribute(prop);
    if(! match) return 0;
    var f = match[1];
    function f$0(param){return f(dom, value);}
    caml_call3(Js_browser[19][8], Js_browser[25], f$0, 0);
    return 1;
   }
   function set_style(dom, k, v){
    if
     (0 < runtime.caml_ml_string_length(k)
      && 45 === runtime.caml_string_get(k, 0)){
     var _a7_ = caml_js_from_string(k);
     caml_call1(Js_browser[15][2], dom)[cst_style].setProperty(_a7_, v);
     return 0;
    }
    return caml_call1(Js_browser[15][2], dom)[cst_style][k] = v;
   }
   function apply_special_prop(ns, dom, k, v){
    if
     (ns === cst_http_www_w3_org_2000_svg && k === cst_className && 0 === v[0]){
     var
      s = v[1],
      class_obj = caml_call1(Js_browser[15][2], dom)[cst_className];
     class_obj[cst_baseVal] = caml_js_from_string(s);
     return 1;
    }
    return 0;
   }
   var js_empty_string = cst$3;
   function cmd(h){return [0, [0, h, 0], empty[2]];}
   function custom(h){return [0, empty[1], [0, h, 0]];}
   function merge(envs){
    var
     _a4_ = caml_call2(Stdlib_List[19], function(e){return e[2];}, envs),
     _a5_ = caml_call1(Stdlib_List[13], _a4_),
     _a6_ = caml_call2(Stdlib_List[19], function(e){return e[1];}, envs);
    return [0, caml_call1(Stdlib_List[13], _a6_), _a5_];
   }
   var
    global = [0, empty],
    cst_Vdom_blit_no_custom_elemen =
      "Vdom_blit: no custom element handler found",
    _h_ =
      [0,
       [11,
        "Error during vdom Custom ",
        [2, 0, [11, " lookup: ", [2, 0, [12, 10, [10, 0]]]]]],
       "Error during vdom Custom %s lookup: %s\n%!"],
    _i_ =
      [0,
       [11, "Error during vdom blit: ", [2, 0, [12, 10, [10, 0]]]],
       "Error during vdom blit: %s\n%!"];
   function register(e){
    global[1] = merge([0, e, [0, global[1], 0]]);
    return 0;
   }
   function apply_attributes(ctx, ns, dom, attributes){
    return caml_call2
            (Stdlib_List[17],
             function(param){
              switch(param[0]){
                case 0:
                 var
                  v = param[2],
                  k = param[1],
                  _a0_ = 1 - apply_special_prop(ns, dom, k, v);
                 if(_a0_){
                  var _a1_ = 1 - apply_effect_prop(dom, k, v);
                  if(_a1_)
                   var
                    _a2_ = eval_prop(v),
                    _a3_ = caml_call1(Js_browser[15][2], dom)[k] = _a2_;
                  else
                   var _a3_ = _a1_;
                 }
                 else
                  var _a3_ = _a0_;
                 return _a3_;
                case 1:
                 var v$0 = param[2], k$0 = param[1];
                 return set_style(dom, k$0, caml_js_from_string(v$0));
                case 2:
                 var match = param[1];
                 if(0 !== match[0]) return 0;
                 var event_type = match[1];
                 return caml_call1(ctx[4], event_type);
                default:
                 var v$1 = param[2], k$1 = param[1];
                 return caml_call3(Js_browser[15][26], dom, k$1, v$1);
              }
             },
             attributes);
   }
   function _g_(parent, ctx, vdom){
    switch(vdom[0]){
      case 0:
       var txt = vdom[2];
       return [0, vdom, caml_call2(Js_browser[16][5], Js_browser[26], txt)];
      case 1:
       var
        children = vdom[2],
        children$0 =
          caml_call2
           (Stdlib_List[19],
            function(_aZ_){return _g_(parent, ctx, _aZ_);},
            children),
        doms = caml_call2(Stdlib_List[23], get_doms, children$0);
       return [1, vdom, doms, children$0];
      case 2:
       var
        children$1 = vdom[5],
        attributes = vdom[4],
        tag = vdom[3],
        ns = vdom[2],
        dom$0 =
          ns == cst$3
           ? caml_call2(Js_browser[16][3], Js_browser[26], tag)
           : caml_call3(Js_browser[16][4], Js_browser[26], ns, tag),
        children$2 =
          caml_call2
           (Stdlib_List[19],
            function(_aY_){return _g_(dom$0, ctx, _aY_);},
            children$1);
       caml_call2
        (Stdlib_List[17],
         function(c){
          var _aW_ = get_doms(c), _aX_ = caml_call1(Js_browser[15][9], dom$0);
          return caml_call2(Stdlib_List[17], _aX_, _aW_);
         },
         children$2);
       apply_attributes(ctx, ns, dom$0, attributes);
       return [2, vdom, dom$0, children$2];
      case 3:
       var child = vdom[3], f = vdom[2], child$0 = _g_(parent, ctx, child);
       return [3, vdom, get_doms(child$0), f, child$0];
      case 4:
       var arg = vdom[3], f$0 = vdom[2];
       return bmemo(vdom, _g_(parent, ctx, caml_call1(f$0, arg)));
      default:
       var propagate_events = vdom[4], attributes$0 = vdom[3], elt = vdom[2];
       try{
        var
         handlers = caml_call2(Stdlib[37], ctx[2], global[1][2]),
         after_redraw = ctx[3],
         process_custom = ctx[1],
         dom = [],
         send_event = function _aV_(_aU_){return _aV_.fun(_aU_);},
         el = [];
        caml_update_dummy
         (dom,
          [246,
           function(_aR_){
            var
             _aS_ = caml_obj_tag(el),
             _aT_ =
               250 === _aS_
                ? el[1]
                : 246 === _aS_ ? caml_call1(CamlinternalLazy[2], el) : el;
            return _aT_[1];
           }]);
        caml_update_dummy
         (send_event,
          function(e){
           var
            _aP_ = caml_obj_tag(dom),
            _aQ_ =
              250 === _aP_
               ? dom[1]
               : 246 === _aP_ ? caml_call1(CamlinternalLazy[2], dom) : dom;
           return caml_call2(process_custom, _aQ_, e);
          });
        caml_update_dummy
         (el,
          [246,
           function(_aO_){
            var ctx = [0, parent, send_event, after_redraw], param = handlers;
            for(;;){
             if(! param)
              return caml_call1(Stdlib[2], cst_Vdom_blit_no_custom_elemen);
             var
              tl = param[2],
              hd = param[1],
              match = caml_call2(hd, ctx, elt);
             if(match){var f = match[1]; return f;}
             param = tl;
            }
           }]);
        var
         _aI_ = caml_obj_tag(el),
         elt$0 =
           250 === _aI_
            ? el[1]
            : 246 === _aI_ ? caml_call1(CamlinternalLazy[2], el) : el;
       }
       catch(exn$0){
        var
         exn = caml_wrap_exception(exn$0),
         _aJ_ = caml_call1(Stdlib_Printexc[1], exn),
         _aK_ = caml_call1(Stdlib_Obj[22][1], elt),
         _aL_ = caml_call1(Stdlib_Obj[22][2], _aK_);
        caml_call3(Stdlib_Printf[2], _h_, _aL_, _aJ_);
        throw caml_maybe_attach_backtrace(exn, 0);
       }
       var
        _aM_ = caml_call1(Js_browser[15][2], elt$0[1])["namespaceURI"],
        _aN_ = caml_call2(Ojs$0[7], caml_js_to_string, _aM_),
        ns$0 = caml_call2(Stdlib_Option[3], _aN_, cst$1);
       apply_attributes(ctx, ns$0, elt$0[1], attributes$0);
       return [5, vdom, elt$0, ns$0, propagate_events];
    }
   }
   function blit(parent, ctx, vdom){
    try{var _aH_ = _g_(parent, ctx, vdom); return _aH_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _aG_ = caml_call1(Stdlib_Printexc[1], exn);
     caml_call2(Stdlib_Printf[2], _i_, _aG_);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function sync_props(to_string, same, set, clear, l1, l2){
    var
     sort =
       caml_call1
        (Stdlib_List[56],
         function(param, _aF_){
          var k2 = _aF_[1], k1 = param[1];
          return caml_call2(Stdlib_String[9], k1, k2);
         }),
     l1$0 = caml_call1(sort, l1),
     l2$0 = caml_call1(sort, l2),
     l1$1 = l1$0,
     l2$1 = l2$0;
    for(;;)
     if(l1$1){
      var tl1 = l1$1[2], _aE_ = l1$1[1], v1 = _aE_[2], k1 = _aE_[1];
      if(l2$1){
       var match = l2$1[1], k2 = match[1], v2 = match[2];
       if(caml_string_lessthan(k1, k2)){
        caml_call2(clear, k1, v1);
        l1$1 = tl1;
       }
       else{
        var tl2 = l2$1[2];
        if(caml_string_lessthan(k2, k1)){
         caml_call2(set, k2, v2);
         l2$1 = tl2;
        }
        else{
         var tl2$0 = l2$1[2], v2$0 = match[2];
         if(1 - caml_call2(same, v1, v2$0)) caml_call2(set, k2, v2$0);
         l1$1 = tl1;
         l2$1 = tl2$0;
        }
       }
      }
      else{caml_call2(clear, k1, v1); l1$1 = tl1; l2$1 = 0;}
     }
     else{
      if(! l2$1) return;
      var
       tl2$1 = l2$1[2],
       match$0 = l2$1[1],
       v2$1 = match$0[2],
       k2$0 = match$0[1];
      caml_call2(set, k2$0, v2$1);
      l1$1 = 0;
      l2$1 = tl2$1;
     }
   }
   function choose(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var tl = param$0[2], hd = param$0[1], match = caml_call1(f, hd);
     if(match){var x = match[1]; return [0, x, choose(f, tl)];}
     param$0 = tl;
    }
   }
   var
    js_false = ! ! 0,
    js_zero = 0,
    _k_ = [0, cst_lib_vdom_blit_ml, 861, 33],
    _l_ = [0, cst_lib_vdom_blit_ml, 890, 13],
    _m_ = [0, cst_lib_vdom_blit_ml, 923, 43],
    _n_ = [0, cst_lib_vdom_blit_ml, 924, 34],
    _o_ =
      [0,
       [11, "Error during vdom view: ", [2, 0, [12, 10, [10, 0]]]],
       "Error during vdom view: %s\n%!"],
    _p_ =
      [0,
       [11,
        "Error in event handler ",
        [3, 0, [11, ": ", [2, 0, [12, 10, [10, 0]]]]]],
       "Error in event handler %S: %s\n%!"],
    cst_currentTarget = "currentTarget",
    _q_ =
      [0,
       [11, "Error during vdom process: ", [2, 0, [12, 10, [10, 0]]]],
       "Error during vdom process: %s\n%!"],
    cst_div = "div";
   function sync_attributes(ctx, ns, dom, a1, a2){
    function props(param){
     if(0 !== param[0]) return 0;
     var v = param[2], k = param[1];
     return [0, [0, k, v]];
    }
    function set(k, v){
     if(k === cst_value$1 && 0 === v[0]){
      var s = v[1];
      if(s == caml_call1(Js_browser[15][31], dom)) return 0;
     }
     var _aA_ = 1 - apply_special_prop(ns, dom, k, v);
     if(_aA_){
      var _aB_ = 1 - apply_effect_prop(dom, k, v);
      if(_aB_)
       var
        _aC_ = eval_prop(v),
        _aD_ = caml_call1(Js_browser[15][2], dom)[k] = _aC_;
      else
       var _aD_ = _aB_;
     }
     else
      var _aD_ = _aA_;
     return _aD_;
    }
    function clear(k, v){
     var _aw_ = 0 === custom_attribute(k) ? 1 : 0;
     if(_aw_){
      var o = caml_call1(Js_browser[15][2], dom);
      if(o.hasOwnProperty(caml_js_from_string(k)) | 0)
       return delete caml_call1(Js_browser[15][2], dom)[k];
      a:
      {
       if(ns === cst_http_www_w3_org_2000_svg && k === cst_className){
        var class_obj = caml_call1(Js_browser[15][2], dom)[cst_className];
        class_obj[cst_baseVal] = cst$3;
        var _ax_ = 1;
        break a;
       }
       var _ax_ = 0;
      }
      var _ay_ = 1 - _ax_;
      if(_ay_){
       switch(v[0]){
         case 0:
          var js_empty_string$0 = js_empty_string; break;
         case 3:
          var js_empty_string$0 = js_false; break;
         default: var js_empty_string$0 = js_zero;
       }
       var _az_ = caml_call1(Js_browser[15][2], dom)[k] = js_empty_string$0;
      }
      else
       var _az_ = _ay_;
     }
     else
      var _az_ = _aw_;
     return _az_;
    }
    var _as_ = choose(props, a2);
    sync_props(string_of_prop, same_prop, set, clear, choose(props, a1), _as_);
    function styles(param){
     if(1 !== param[0]) return 0;
     var v = param[2], k = param[1];
     return [0, [0, k, [0, v]]];
    }
    function set$0(k, v){return set_style(dom, k, eval_prop(v));}
    function clear$0(k, param){return set_style(dom, k, js_empty_string);}
    var _at_ = choose(styles, a2);
    sync_props
     (string_of_prop, same_prop, set$0, clear$0, choose(styles, a1), _at_);
    function attrs(param){
     if(3 !== param[0]) return 0;
     var v = param[2], k = param[1];
     return [0, [0, k, v]];
    }
    function set$1(k, v){return caml_call3(Js_browser[15][26], dom, k, v);}
    function clear$1(k, param){return caml_call2(Js_browser[15][25], dom, k);}
    var _au_ = choose(attrs, a2);
    sync_props
     (function(_av_){return _av_;},
      caml_string_equal,
      set$1,
      clear$1,
      choose(attrs, a1),
      _au_);
    return caml_call2
            (Stdlib_List[17],
             function(param){
              if(2 === param[0]){
               var match = param[1];
               if(0 === match[0]){
                var event_type = match[1];
                return caml_call1(ctx[4], event_type);
               }
              }
              return 0;
             },
             a2);
   }
   function dispose(ctrl){
    var ctrl$0 = ctrl;
    for(;;)
     switch(ctrl$0[0]){
       case 0:
        return 0;
       case 3:
        var child = ctrl$0[4]; ctrl$0 = child; break;
       case 4:
        var child$0 = ctrl$0[3]; ctrl$0 = child$0; break;
       case 5:
        var elt = ctrl$0[2]; return caml_call1(elt[3], 0);
       default:
        var children = ctrl$0[3];
        return caml_call2(Stdlib_List[17], dispose, children);
     }
   }
   function remove_child(parent, child){
    return caml_call2(Js_browser[15][12], parent, child);
   }
   function insert_before(parent, o, n){
    return caml_call3(Js_browser[15][10], parent, o, n);
   }
   function _j_(ctx, parent, prev_move, next, old, vdom){
    if(vdom === get_vdom(old)) return old;
    switch(old[0]){
      case 0:
       var match = old[1];
       if(0 === match[0] && 0 === vdom[0]){
        var s2 = vdom[2], dom = old[2], s1 = match[2];
        if(s1 !== s2) caml_call2(Js_browser[15][41], dom, s2);
        return [0, vdom, dom];
       }
       break;
      case 1:
       var match$0 = old[1];
       if(1 === match$0[0] && 1 === vdom[0]){
        var children = old[3];
        if(match$0[1] == vdom[1]){
         var
          children$0 =
            sync_children(ctx, parent, prev_move, next, children, vdom[2]),
          doms = caml_call2(Stdlib_List[23], get_doms, children$0);
         return [1, vdom, doms, children$0];
        }
       }
       break;
      case 2:
       var e1 = old[1];
       if(2 === e1[0] && 2 === vdom[0]){
        var children$1 = old[3], dom$0 = old[2];
        if(e1[3] == vdom[3] && e1[2] == vdom[2] && e1[1] == vdom[1]){
         var
          children$2 =
            sync_children
             (ctx, dom$0, 0, Js_browser[15][3], children$1, vdom[5]);
         sync_attributes(ctx, e1[2], dom$0, e1[4], vdom[4]);
         return [2, vdom, dom$0, children$2];
        }
       }
       break;
      case 3:
       if(3 === vdom[0]){
        var
         c2 = vdom[3],
         f = vdom[2],
         c1 = old[4],
         child = _j_(ctx, parent, prev_move, next, c1, c2);
        return [3, vdom, get_doms(child), f, child];
       }
       break;
      case 4:
       var match$1 = old[1];
       if(4 === match$1[0] && 4 === vdom[0]){
        var
         a2 = vdom[3],
         f2 = vdom[2],
         c1$0 = old[3],
         a1 = match$1[3],
         f1 = match$1[2];
        if(f1 === f2 && a1 === a2) return bmemo(vdom, c1$0);
        return bmemo
                (vdom,
                 _j_(ctx, parent, prev_move, next, c1$0, caml_call1(f2, a2)));
       }
       break;
      default:
       var match$2 = old[1];
       if(5 === match$2[0] && 5 === vdom[0]){
        var
         propagate_events = vdom[4],
         a2$0 = vdom[3],
         arg2 = vdom[2],
         key2 = vdom[1],
         ns = old[3],
         elt = old[2],
         a1$0 = match$2[3],
         arg1 = match$2[2],
         key1 = match$2[1];
        a:
        if(key1 == key2){
         if(arg1 !== arg2 && ! caml_call1(elt[2], arg2)) break a;
         sync_attributes(ctx, ns, elt[1], a1$0, a2$0);
         return [5, vdom, elt, ns, propagate_events];
        }
       }
    }
    var x = blit(parent, ctx, vdom), l2$0 = get_doms(old), l1$0 = get_doms(x);
    a:
    {
     b:
     {
      var l1 = l1$0, l2 = l2$0;
      for(;;){
       if(! l1) break;
       if(! l2) break b;
       var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
       caml_call3(Js_browser[15][11], parent, h1, h2);
       l1 = t1;
       l2 = t2;
      }
      caml_call2
       (Stdlib_List[17],
        function(_ar_){return remove_child(parent, _ar_);},
        l2);
      break a;
     }
     caml_call2
      (Stdlib_List[17],
       function(c){return insert_before(parent, c, next);},
       l1);
    }
    dispose(old);
    return x;
   }
   function sync_children
   (ctx, dom, prev_move, next, old_children, new_children){
    var
     old_children$0 = caml_call1(Stdlib_Array[12], old_children),
     new_children$0 = caml_call1(Stdlib_Array[12], new_children),
     by_key = caml_call2(Stdlib_Hashtbl[1], 0, 8),
     _$_ = old_children$0.length - 2 | 0;
    if(_$_ >= 0){
     var i$1 = _$_;
     for(;;){
      var key = get_vdom(caml_check_bound(old_children$0, i$1)[1 + i$1])[1];
      caml_call3(Stdlib_Hashtbl[5], by_key, key, i$1);
      var _an_ = i$1 - 1 | 0;
      if(0 === i$1) break;
      i$1 = _an_;
     }
    }
    var
     indices = runtime.caml_make_vect(new_children$0.length - 1, -1),
     _ab_ = indices.length - 2 | 0,
     _aa_ = 0;
    if(_ab_ >= 0){
     var i$0 = _aa_;
     for(;;){
      var key$0 = caml_check_bound(new_children$0, i$0)[1 + i$0][1];
      a:
      {
       try{var idx$0 = caml_call2(Stdlib_Hashtbl[6], by_key, key$0);}
       catch(_aq_){
        var _al_ = caml_wrap_exception(_aq_);
        if(_al_ === Stdlib[8]) break a;
        throw caml_maybe_attach_backtrace(_al_, 0);
       }
       caml_check_bound(indices, i$0)[1 + i$0] = idx$0;
       caml_call2(Stdlib_Hashtbl[10], by_key, key$0);
      }
      var _am_ = i$0 + 1 | 0;
      if(_ab_ === i$0) break;
      i$0 = _am_;
     }
    }
    caml_call2
     (Stdlib_Hashtbl[12],
      function(param, i){
       var
        to_remove = caml_check_bound(old_children$0, i)[1 + i],
        _ao_ = get_doms(to_remove);
       caml_call2
        (Stdlib_List[17],
         function(_ap_){return remove_child(dom, _ap_);},
         _ao_);
       return dispose(to_remove);
      },
      by_key);
    var
     ctrls = [0, 0],
     prev_move$0 = [0, prev_move],
     next$0 = [0, next],
     _ac_ = new_children$0.length - 2 | 0;
    if(_ac_ >= 0){
     var i = _ac_;
     for(;;){
      var idx = caml_check_bound(indices, i)[1 + i];
      if(0 <= idx)
       var
        _ad_ = caml_check_bound(new_children$0, i)[1 + i],
        _ae_ = caml_check_bound(old_children$0, idx)[1 + idx],
        c = _j_(ctx, dom, prev_move$0[1], next$0[1], _ae_, _ad_);
      else
       var c = blit(dom, ctx, caml_check_bound(new_children$0, i)[1 + i]);
      var doms = get_doms(c);
      a:
      {
       b:
       {
        var param = doms;
        for(;;){
         if(! param) break;
         var c_dom = param[1];
         if(! param[2]) break b;
         var tl = param[2];
         param = tl;
        }
        var match = 0;
        break a;
       }
       var match = [0, c_dom];
      }
      if(match){
       var right_most = match[1], _af_ = idx < 0 ? 1 : 0;
       if(_af_)
        var move = _af_;
       else{
        if(i === (new_children$0.length - 2 | 0))
         var _ah_ = idx !== (old_children$0.length - 2 | 0) ? 1 : 0;
        else{
         var _aj_ = prev_move$0[1];
         if(_aj_)
          var _ah_ = _aj_;
         else
          var
           _ak_ = i + 1 | 0,
           _ah_ =
             caml_check_bound(indices, _ak_)[1 + _ak_] !== (idx + 1 | 0)
              ? 1
              : 0;
        }
        if(_ah_)
         var
          _ai_ = next$0[1],
          move = caml_call1(Js_browser[15][15], right_most) !== _ai_ ? 1 : 0;
        else
         var move = _ah_;
       }
       if(move)
        caml_call2
         (Stdlib_List[17],
          function(c_dom){return insert_before(dom, c_dom, next$0[1]);},
          doms);
       prev_move$0[1] = move;
       next$0[1] = caml_call1(Stdlib_List[5], doms);
       ctrls[1] = [0, c, ctrls[1]];
      }
      var _ag_ = i - 1 | 0;
      if(0 === i) break;
      i = _ag_;
     }
    }
    return ctrls[1];
   }
   function found(mapper, parent, dom, inner){
    var mapper$0 = mapper, inner$0 = inner;
    for(;;)
     switch(inner$0[0]){
       case 1:
        var children = inner$0[3];
        try{
         var
          inner$1 =
            caml_call2
             (Stdlib_List[38],
              function(c){
               var ___ = get_doms(c);
               return caml_call2(Stdlib_List[37], dom, ___);
              },
              children);
        }
        catch(_Z_){
         var _Y_ = caml_wrap_exception(_Z_);
         if(_Y_ === Stdlib[8])
          throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
         throw caml_maybe_attach_backtrace(_Y_, 0);
        }
        inner$0 = inner$1;
        break;
       case 3:
        var child = inner$0[4], f = inner$0[3];
        let mapper = mapper$0, f$0 = f;
        var
         mapper$1 =
           function(x){return caml_call1(mapper, caml_call1(f$0, x));};
        mapper$0 = mapper$1;
        inner$0 = child;
        break;
       case 4:
        var child$0 = inner$0[3]; inner$0 = child$0; break;
       default: return [0, mapper$0, inner$0, parent];
     }
   }
   function vdom_of_dom(root, dom){
    var
     _S_ = caml_call1(Js_browser[15][2], dom),
     match = caml_call2(Ojs$0[7], Js_browser[15][1], _S_);
    if(! match) return 0;
    var dom$0 = match[1], _T_ = get_doms(root);
    if(caml_call2(Stdlib_List[37], dom$0, _T_))
     return found(function(_X_){return _X_;}, 0, dom$0, root);
    var parent = vdom_of_dom(root, caml_call1(Js_browser[15][42], dom$0));
    if(! parent) return 0;
    var inner = parent[2], mapper = parent[1];
    switch(inner[0]){
      case 2:
       var children = inner[3];
       try{
        var
         c =
           caml_call2
            (Stdlib_List[38],
             function(c){
              var _W_ = get_doms(c);
              return caml_call2(Stdlib_List[37], dom$0, _W_);
             },
             children);
       }
       catch(_V_){
        var _U_ = caml_wrap_exception(_V_);
        if(_U_ === Stdlib[8]) return 0;
        throw caml_maybe_attach_backtrace(_U_, 0);
       }
       return found(mapper, parent, dom$0, c);
      case 5:
       var parent$0 = parent[3], propagate_events = inner[4];
       return propagate_events ? found(mapper, parent$0, dom$0, inner) : 0;
      default: throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    }
   }
   function dom(x){return x[1];}
   function process(x){return x[2];}
   function get(x){return caml_call1(x[3], 0);}
   function after_redraw$1(x){return x[4];}
   function run$0(opt, container, param){
    if(opt) var sth = opt[1], env = sth; else var env = empty;
    var
     view = param[3],
     update = param[2],
     match = param[1],
     cmd0 = match[2],
     model0 = match[1],
     env$0 = merge([0, env, [0, global[1], 0]]);
    if(container)
     var
      container$0 = container[1],
      container$1 = container$0,
      container_created = 0;
    else
     var
      container$2 = caml_call2(Js_browser[16][3], Js_browser[26], cst_div),
      container$1 = container$2,
      container_created = 1;
    var post_redraw = [0, 0];
    function after_redraw(f){
     post_redraw[1] = [0, f, post_redraw[1]];
     return 0;
    }
    function flush(param){
     var l = caml_call1(Stdlib_List[9], post_redraw[1]);
     post_redraw[1] = 0;
     return caml_call2
             (Stdlib_List[17], function(f){return caml_call1(f, 0);}, l);
    }
    var
     process_custom_fwd =
       [0,
        function(param, _R_){
         throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
        }],
     process_fwd =
       [0,
        function(param){
         throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
        }],
     listeners = caml_call2(Stdlib_Hashtbl[1], 0, 8),
     model = [0, model0],
     current = [0, 0],
     pending_redraw = [0, 0];
    function view$0(model){
     try{var _Q_ = caml_call1(view, model); return _Q_;}
     catch(exn$0){
      var
       exn = caml_wrap_exception(exn$0),
       _P_ = caml_call1(Stdlib_Printexc[1], exn);
      caml_call2(Stdlib_Printf[2], _o_, _P_);
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    }
    function on_event(evt){
     var ty = caml_call1(Js_browser[10][7], evt);
     try{
      var
       _B_ = caml_call1(Js_browser[10][3], evt),
       tgt = caml_call1(Js_browser[15][1], _B_);
      caml_call2
       (Stdlib_Option[9],
        function(root){
         var param = vdom_of_dom(root, tgt);
         for(;;){
          a:
          if(param){
           var _I_ = param[2], mapper = param[1];
           switch(_I_[0]){
             case 2:
              var _J_ = _I_[1];
              if(2 !== _J_[0]) break a;
              var dom = _I_[2], attributes = _J_[4];
              break;
             case 5:
              var _M_ = _I_[1];
              if(5 !== _M_[0]) break a;
              var dom = _I_[2][1], attributes = _M_[3];
              break;
             default: break a;
           }
           var parent = param[3];
           let dom$0 = dom, mapper$0 = mapper;
           var
            _K_ =
              caml_call1
               (caml_call1
                 (Stdlib_List[22],
                  function(attribute){
                   if(2 === attribute[0]){
                    var match = attribute[1];
                    if(0 === match[0]){
                     var
                      map = match[3],
                      decoder = match[2],
                      event_type = match[1];
                     if(ty == event_type){
                      var
                       _O_ = caml_call1(Js_browser[10][2], evt),
                       match$0 =
                         decode_fail
                          ([0,
                            [0,
                             [0, cst_currentTarget, caml_call1(Js_browser[15][2], dom$0)],
                             0]],
                           decoder,
                           _O_),
                       prevent_default = match$0[3],
                       stop_propagation = match$0[2],
                       msg = match$0[1];
                      if(prevent_default) caml_call1(Js_browser[10][5], evt);
                      if(stop_propagation) caml_call1(Js_browser[10][6], evt);
                      var match$1 = caml_call1(map, msg);
                      if(! match$1) return 0;
                      var msg$0 = match$1[1];
                      return [0, [0, msg$0, stop_propagation]];
                     }
                    }
                   }
                   return 0;
                  }),
                attributes),
            stop_propagation =
              caml_call3
               (Stdlib_List[25],
                function(stopped_propagation, param){
                 var
                  stop_propagation = param[2],
                  msg = param[1],
                  _N_ = caml_call1(mapper$0, msg);
                 caml_call1(process_fwd[1], _N_);
                 var
                  stopped_propagation$0 =
                    stopped_propagation || stop_propagation;
                 return stopped_propagation$0;
                },
                0,
                _K_),
            _L_ = 1 - stop_propagation;
           if(! _L_) return _L_;
           param = parent;
           continue;
          }
          return 0;
         }
        },
        current[1]);
      var
       _C_ = ty == cst_input$0 ? 1 : 0,
       _D_ = _C_ || (ty == cst_blur ? 1 : 0);
      if(_D_)
       var
        f =
          function(param){
           return caml_call2
                   (Stdlib_Option[9],
                    function(root){
                     var match = vdom_of_dom(root, tgt);
                     if(match){
                      var _G_ = match[2];
                      if(2 === _G_[0]){
                       var match$0 = _G_[1];
                       if(2 === match$0[0]){
                        var attributes = match$0[4];
                        return caml_call2
                                (Stdlib_List[17],
                                 function(param){
                                  if(0 === param[0]){
                                   var _H_ = param[1];
                                   if(_H_ !== cst_checked$0){
                                    if(_H_ === cst_value$1){
                                     var match = param[2];
                                     if(0 === match[0]){
                                      var s2 = match[1];
                                      if(s2 !== caml_call1(Js_browser[15][31], tgt))
                                       return caml_call2(Js_browser[15][32], tgt, s2);
                                     }
                                    }
                                   }
                                   else{
                                    var match$0 = param[2];
                                    if(3 === match$0[0]){
                                     var s2$0 = match$0[1];
                                     return caml_call2(Js_browser[15][39], tgt, s2$0);
                                    }
                                   }
                                  }
                                  return 0;
                                 },
                                 attributes);
                       }
                      }
                     }
                     return 0;
                    },
                    current[1]);
          },
        _E_ = pending_redraw[1] ? after_redraw(f) : f(0),
        _F_ = _E_;
      else
       var _F_ = _D_;
      return _F_;
     }
     catch(exn$0){
      var
       exn = caml_wrap_exception(exn$0),
       _A_ = caml_call1(Stdlib_Printexc[1], exn);
      return caml_call3(Stdlib_Printf[2], _p_, ty, _A_);
     }
    }
    function add_listener(event_type){
     var _z_ = 1 - caml_call2(Stdlib_Hashtbl[9], listeners, event_type);
     if(! _z_) return _z_;
     var
      remove_listener =
        caml_call4
         (Js_browser[15][19], container$1, [0, event_type], on_event, 1);
     return caml_call3
             (Stdlib_Hashtbl[5], listeners, event_type, remove_listener);
    }
    var
     ctx =
       [0,
        function(elt, evt){
         return caml_call2(process_custom_fwd[1], elt, evt);
        },
        env$0[2],
        after_redraw,
        add_listener],
     x = blit(container$1, ctx, view$0(model0));
    caml_call2(Js_browser[19][11], Js_browser[25], flush);
    current[1] = [0, x];
    function redraw(param){
     var match = current[1];
     if(! match) return 0;
     var root = match[1];
     pending_redraw[1] = 0;
     var
      _y_ = view$0(model[1]),
      vdom = Js_browser[15][3],
      x = _j_(ctx, container$1, 0, vdom, root, _y_);
     current[1] = [0, x];
     return flush(0);
    }
    function process(msg){
     try{
      var
       match = caml_call2(update, model[1], msg),
       cmd = match[2],
       new_model = match[1];
      model[1] = new_model;
      run_cmd(container$1, cmd);
      var
       _w_ = 1 - pending_redraw[1],
       _x_ =
         _w_
          ? (pending_redraw
             [1]
            = 1,
            caml_call2(Js_browser[19][11], Js_browser[25], redraw))
          : _w_;
      return _x_;
     }
     catch(exn$0){
      var
       exn = caml_wrap_exception(exn$0),
       _v_ = caml_call1(Stdlib_Printexc[1], exn);
      caml_call2(Stdlib_Printf[2], _q_, _v_);
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    }
    function run_cmd(parent, cmd){
     return run
             (after_redraw,
              caml_call2(Stdlib[37], env$0[1], global[1][1]),
              process,
              parent,
              cmd);
    }
    process_fwd[1] = process;
    var _r_ = get_doms(x), _s_ = caml_call1(Js_browser[15][9], container$1);
    caml_call2(Stdlib_List[17], _s_, _r_);
    function process_custom(tgt, event){
     return caml_call2
             (Stdlib_Option[9],
              function(root){
               function process$0(mapper, attributes){
                function select_handler(attr){
                 if(2 === attr[0]){
                  var _u_ = attr[1];
                  if(0 === _u_[0]){
                   var map = _u_[3], decoder = _u_[2], et1 = _u_[1];
                   if(0 !== event[0]){
                    var encoder = event[2], et2 = event[1];
                    if(et1 == et2){
                     var msg = decode_fail(0, decoder, encode(encoder))[1];
                     return caml_call1(map, msg);
                    }
                   }
                  }
                  else{
                   var f = _u_[1];
                   if(0 === event[0]){
                    var e = event[1];
                    return caml_call1(f, e);
                   }
                  }
                 }
                 return 0;
                }
                var
                 msgs =
                   caml_call2(Stdlib_List[22], select_handler, attributes);
                return caml_call2
                        (Stdlib_List[17],
                         function(msg){return process(caml_call1(mapper, msg));},
                         msgs);
               }
               var match = vdom_of_dom(root, tgt);
               if(match){
                var _t_ = match[2], mapper = match[1];
                switch(_t_[0]){
                  case 2:
                   var match$0 = _t_[1];
                   if(2 === match$0[0]){
                    var attributes = match$0[4];
                    return process$0(mapper, attributes);
                   }
                   break;
                  case 5:
                   var match$1 = _t_[1];
                   if(5 === match$1[0]){
                    var attributes$0 = match$1[3];
                    return process$0(mapper, attributes$0);
                   }
                   break;
                }
               }
               return 0;
              },
              current[1]);
    }
    process_custom_fwd[1] = process_custom;
    run_cmd(container$1, cmd0);
    function dispose$0(param){
     return caml_call2
             (Stdlib_Option[9],
              function(root){
               current[1] = 0;
               dispose(root);
               caml_call2
                (Stdlib_Hashtbl[12],
                 function(param, f){return caml_call1(f, 0);},
                 listeners);
               return container_created
                       ? caml_call1(Js_browser[15][74], container$1)
                       : caml_call2(Js_browser[15][48], container$1, cst$2);
              },
              current[1]);
    }
    return [0,
            container$1,
            process,
            function(param){return model[1];},
            after_redraw,
            dispose$0];
   }
   function dispose$0(param){
    var dispose = param[5];
    return caml_call1(dispose, 0);
   }
   var
    Vdom_blit =
      [0,
       Ojs,
       [0, decode],
       [0, encode],
       [0, container, send_msg, after_redraw],
       [0,
        blur_event,
        input_event,
        checked_event,
        change_event,
        change_index_event,
        custom_event,
        make,
        parent,
        send_event,
        after_redraw$0],
       cmd,
       custom,
       merge,
       empty,
       register,
       run$0,
       dispose$0,
       dom,
       process,
       get,
       after_redraw$1];
   runtime.caml_register_global(112, Vdom_blit, "Vdom_blit");
   return;
  }
  (globalThis));


//# 1 "../definicije/.definicije.objs/jsoo/default/definicije.cma.js"
// Generated by js_of_ocaml
//# 3 "../definicije/.definicije.objs/jsoo/default/definicije.cma.js"

//# 15 "../definicije/.definicije.objs/jsoo/default/definicije.cma.js"
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function iz_niza(oznaka){return [0, oznaka];}
   function v_niz(param){var oznaka = param[1]; return oznaka;}
   var Definicije_Stanje = [0, iz_niza, v_niz];
   runtime.caml_register_global(0, Definicije_Stanje, "Definicije__Stanje");
   return;
  }
  (globalThis));

//# 28 "../definicije/.definicije.objs/jsoo/default/definicije.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Definicije_Stanje = global_data.Definicije__Stanje;
   function prazen_avtomat(zacetno_stanje){
    return [0, [0, zacetno_stanje, 0], zacetno_stanje, 0, 0];
   }
   function dodaj_nesprejemno_stanje(stanje, avtomat){
    return [0, [0, stanje, avtomat[1]], avtomat[2], avtomat[3], avtomat[4]];
   }
   function dodaj_sprejemno_stanje(stanje, avtomat){
    return [0,
            [0, stanje, avtomat[1]],
            avtomat[2],
            [0, stanje, avtomat[3]],
            avtomat[4]];
   }
   function dodaj_prehod(stanje1, znak, stanje2, avtomat){
    return [0,
            avtomat[1],
            avtomat[2],
            avtomat[3],
            [0, [0, stanje1, znak, stanje2], avtomat[4]]];
   }
   function prehodna_funkcija(avtomat, stanje, znak){
    var
     match =
       caml_call2
        (Stdlib_List[39],
         function(param){
          var
           znak$0 = param[2],
           stanje1 = param[1],
           _b_ = runtime.caml_equal(stanje1, stanje),
           _c_ = _b_ ? znak === znak$0 ? 1 : 0 : _b_;
          return _c_;
         },
         avtomat[4]);
    if(! match) return 0;
    var stanje2 = match[1][3];
    return [0, stanje2];
   }
   function zacetno_stanje(avtomat){return avtomat[2];}
   function seznam_stanj(avtomat){return avtomat[1];}
   function seznam_prehodov(avtomat){return avtomat[4];}
   function je_sprejemno_stanje(avtomat, stanje){
    return caml_call2(Stdlib_List[36], stanje, avtomat[3]);
   }
   var
    q0 = caml_call1(Definicije_Stanje[1], "q0"),
    q1 = caml_call1(Definicije_Stanje[1], "q1"),
    q2 = caml_call1(Definicije_Stanje[1], "q2"),
    enke_1mod3 =
      dodaj_prehod
       (q2,
        49,
        q0,
        dodaj_prehod
         (q1,
          49,
          q2,
          dodaj_prehod
           (q0,
            49,
            q1,
            dodaj_prehod
             (q2,
              48,
              q2,
              dodaj_prehod
               (q1,
                48,
                q1,
                dodaj_prehod
                 (q0,
                  48,
                  q0,
                  dodaj_nesprejemno_stanje
                   (q2, dodaj_sprejemno_stanje(q1, prazen_avtomat(q0)))))))));
   function preberi_niz(avtomat, q, niz){
    function aux(acc, znak){
     if(! acc) return 0;
     var q = acc[1];
     return prehodna_funkcija(avtomat, q, znak);
    }
    var _a_ = caml_call1(Stdlib_String[39], niz);
    return caml_call1(caml_call2(Stdlib_Seq[5], aux, [0, q]), _a_);
   }
   var
    Definicije_Avtomat =
      [0,
       prazen_avtomat,
       dodaj_nesprejemno_stanje,
       dodaj_sprejemno_stanje,
       dodaj_prehod,
       prehodna_funkcija,
       zacetno_stanje,
       seznam_stanj,
       seznam_prehodov,
       je_sprejemno_stanje,
       enke_1mod3,
       preberi_niz];
   runtime.caml_register_global(7, Definicije_Avtomat, "Definicije__Avtomat");
   return;
  }
  (globalThis));

//# 153 "../definicije/.definicije.objs/jsoo/default/definicije.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib_String = global_data.Stdlib__String;
   function trenutni_znak(trak){
    return runtime.caml_string_get(trak[1], trak[2]);
   }
   function je_na_koncu(trak){
    return caml_ml_string_length(trak[1]) === trak[2] ? 1 : 0;
   }
   function premakni_naprej(trak){return [0, trak[1], trak[2] + 1 | 0];}
   function iz_niza(niz){return [0, niz, 0];}
   var prazen = iz_niza(cst);
   function v_niz(trak){return trak[1];}
   function prebrani(trak){
    return caml_call3(Stdlib_String[15], trak[1], 0, trak[2]);
   }
   function neprebrani(trak){
    return caml_call3
            (Stdlib_String[15],
             trak[1],
             trak[2],
             caml_ml_string_length(trak[1]) - trak[2] | 0);
   }
   var
    Definicije_Trak =
      [0,
       prazen,
       trenutni_znak,
       je_na_koncu,
       premakni_naprej,
       iz_niza,
       v_niz,
       prebrani,
       neprebrani];
   runtime.caml_register_global(2, Definicije_Trak, "Definicije__Trak");
   return;
  }
  (globalThis));

//# 206 "../definicije/.definicije.objs/jsoo/default/definicije.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Definicije_Avtomat = global_data.Definicije__Avtomat,
    Definicije_Trak = global_data.Definicije__Trak;
   function pozeni(avtomat, trak){
    return [0, avtomat, trak, caml_call1(Definicije_Avtomat[6], avtomat)];
   }
   function avtomat(param){var avtomat = param[1]; return avtomat;}
   function trak(param){var trak = param[2]; return trak;}
   function stanje(param){var stanje = param[3]; return stanje;}
   function korak_naprej(param){
    var stanje = param[3], trak = param[2], avtomat = param[1];
    if(caml_call1(Definicije_Trak[3], trak)) return 0;
    var
     _a_ = caml_call1(Definicije_Trak[2], trak),
     stanje$0 = caml_call3(Definicije_Avtomat[5], avtomat, stanje, _a_);
    if(! stanje$0) return 0;
    var stanje$1 = stanje$0[1];
    return [0, [0, avtomat, caml_call1(Definicije_Trak[4], trak), stanje$1]];
   }
   function je_v_sprejemnem_stanju(param){
    var stanje = param[3], avtomat = param[1];
    return caml_call2(Definicije_Avtomat[9], avtomat, stanje);
   }
   var
    Definicije_ZagnaniAvtomat =
      [0, pozeni, avtomat, trak, stanje, korak_naprej, je_v_sprejemnem_stanju];
   runtime.caml_register_global
    (2, Definicije_ZagnaniAvtomat, "Definicije__ZagnaniAvtomat");
   return;
  }
  (globalThis));


//# 1 ".spletniVmesnik.eobjs/jsoo/dune__exe.cmo.js"
// Generated by js_of_ocaml
//# 3 ".spletniVmesnik.eobjs/jsoo/dune__exe.cmo.js"

//# 5 ".spletniVmesnik.eobjs/jsoo/dune__exe.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Dune_exe = [0];
   runtime.caml_register_global(0, Dune_exe, "Dune__exe");
   return;
  }
  (globalThis));


//# 1 ".spletniVmesnik.eobjs/jsoo/dune__exe__Vektor.cmo.js"
// Generated by js_of_ocaml
//# 3 ".spletniVmesnik.eobjs/jsoo/dune__exe__Vektor.cmo.js"

//# 6 ".spletniVmesnik.eobjs/jsoo/dune__exe__Vektor.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List;
   function symbol(k, vec){return [254, k * vec[1], k * vec[2]];}
   function symbol$0(vec1, vec2){
    return [254, vec1[1] + vec2[1], vec1[2] + vec2[2]];
   }
   function symbol$1(vec1, vec2){return symbol$0(vec1, symbol(-1., vec2));}
   function dolzina(vec){
    return Math.sqrt(Math.pow(vec[1], 2.) + Math.pow(vec[2], 2.));
   }
   function normiraj(vec){return symbol(1. / dolzina(vec), vec);}
   function sredina(opt, zacetek, konec){
    if(opt) var sth = opt[1], lambda = sth; else var lambda = 0.5;
    var _a_ = symbol(lambda, konec);
    return symbol$0(symbol(1. - lambda, zacetek), _a_);
   }
   function razdalja(zacetek, konec){
    return dolzina(symbol$1(zacetek, konec));
   }
   function koreni_enote(n, sirina, visina){
    var sredisce = [254, sirina / 2., visina / 2.];
    return caml_call2
            (Stdlib_List[10],
             n,
             function(i){
              var
               kot = 6.283185307179586 * i / n,
               polmer = caml_call2(Stdlib[16], sirina, visina) / 2. * 0.9;
              return symbol$0
                      (sredisce,
                       [254, polmer * Math.cos(kot), polmer * Math.sin(kot)]);
             });
   }
   var
    Dune_exe_Vektor =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       dolzina,
       normiraj,
       sredina,
       razdalja,
       koreni_enote];
   runtime.caml_register_global(15, Dune_exe_Vektor, "Dune__exe__Vektor");
   return;
  }
  (globalThis));


//# 1 ".spletniVmesnik.eobjs/jsoo/dune__exe__Model.cmo.js"
// Generated by js_of_ocaml
//# 3 ".spletniVmesnik.eobjs/jsoo/dune__exe__Model.cmo.js"

//# 6 ".spletniVmesnik.eobjs/jsoo/dune__exe__Model.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Definicije_ZagnaniAvtomat = global_data.Definicije__ZagnaniAvtomat,
    Stdlib_List = global_data.Stdlib__List,
    Definicije_Trak = global_data.Definicije__Trak,
    Definicije_Avtomat = global_data.Definicije__Avtomat,
    Dune_exe_Vektor = global_data.Dune__exe__Vektor;
   function init(sirina, visina, avtomat){
    var
     _f_ = caml_call1(Definicije_Avtomat[7], avtomat),
     _g_ = caml_call1(Stdlib_List[1], _f_),
     _h_ = caml_call3(Dune_exe_Vektor[8], _g_, sirina, visina),
     _i_ = caml_call1(Definicije_Avtomat[7], avtomat),
     polozaji = caml_call1(caml_call1(Stdlib_List[55], _i_), _h_);
    return [0,
            caml_call2
             (Definicije_ZagnaniAvtomat[1], avtomat, Definicije_Trak[1]),
            polozaji,
            0,
            sirina,
            visina];
   }
   function polozaj_stanja(model, q){
    return caml_call2(Stdlib_List[46], q, model[2]);
   }
   function update(model, param){
    if(typeof param === "number")
     switch(param){
       case 0:
        var match = caml_call1(Definicije_ZagnaniAvtomat[5], model[1]);
        if(! match) return model;
        var avtomat = match[1];
        return [0, avtomat, model[2], model[3], model[4], model[5]];
       case 1:
        return [0, model[1], model[2], 0, model[4], model[5]];
       default: return [0, model[1], model[2], 1, model[4], model[5]];
     }
    switch(param[0]){
      case 0:
       var q = param[1];
       return [0, model[1], model[2], [0, q], model[4], model[5]];
      case 1:
       var position = param[1], match$0 = model[3];
       if(typeof match$0 === "number") return model;
       var
        q$0 = match$0[1],
        polozaji =
          caml_call2
           (Stdlib_List[19],
            function(param){
             var
              position$0 = param[2],
              q = param[1],
              position$1 = runtime.caml_equal(q$0, q) ? position : position$0;
             return [0, q, position$1];
            },
            model[2]);
       return [0, model[1], polozaji, model[3], model[4], model[5]];
      default:
       var
        vneseni_niz = param[1],
        _a_ = model[5],
        _b_ = model[4],
        _c_ = model[2],
        _d_ = caml_call1(Definicije_Trak[5], vneseni_niz),
        _e_ = caml_call1(Definicije_ZagnaniAvtomat[2], model[1]);
       return [0,
               caml_call2(Definicije_ZagnaniAvtomat[1], _e_, _d_),
               _c_,
               0,
               _b_,
               _a_];
    }
   }
   var Dune_exe_Model = [0, init, polozaj_stanja, update];
   runtime.caml_register_global(5, Dune_exe_Model, "Dune__exe__Model");
   return;
  }
  (globalThis));


//# 1 ".spletniVmesnik.eobjs/jsoo/dune__exe__View.cmo.js"
// Generated by js_of_ocaml
//# 3 ".spletniVmesnik.eobjs/jsoo/dune__exe__View.cmo.js"

//# 6 ".spletniVmesnik.eobjs/jsoo/dune__exe__View.cmo.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_fill$4 = "fill",
    cst_g$3 = "g",
    cst_h2$1 = "h2",
    cst_none$1 = "none",
    cst_stroke$5 = "stroke",
    cst_stroke_width$1 = "stroke-width",
    cst_white$1 = "white",
    caml_equal = runtime.caml_equal,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "#",
    barva_sprejemnega_stanja = "rgb(56, 142, 60)",
    barva_trenutnega_stanja = "rgb(255, 242, 202)",
    barva_zacetnega_stanja = "rgb(8, 118, 155)",
    privzeta_barva_crt = "black",
    privzeta_barva_polnila = cst_white$1,
    Vdom = global_data.Vdom,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_String = global_data.Stdlib__String,
    Dune_exe_Model = global_data.Dune__exe__Model,
    Definicije_ZagnaniAvtomat = global_data.Definicije__ZagnaniAvtomat,
    Definicije_Avtomat = global_data.Definicije__Avtomat,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Definicije_Trak = global_data.Definicije__Trak,
    Dune_exe_Vektor = global_data.Dune__exe__Vektor,
    Definicije_Stanje = global_data.Definicije__Stanje,
    Parametri =
      [0,
       barva_sprejemnega_stanja,
       barva_trenutnega_stanja,
       barva_zacetnega_stanja,
       3.,
       10.,
       20.,
       0.4,
       10.,
       5.,
       20.,
       25.,
       privzeta_barva_crt,
       privzeta_barva_polnila],
    cst_r = "r",
    cst_cy = "cy",
    cst_cx = "cx",
    cst_circle = "circle",
    cst_y2 = "y2",
    cst_x2 = "x2",
    cst_y1 = "y1",
    cst_x1 = "x1",
    cst_line = "line",
    cst_g = cst_g$3,
    cst_central = "central",
    cst_dominant_baseline = "dominant-baseline",
    cst_middle = "middle",
    cst_text_anchor = "text-anchor",
    cst_y = "y",
    cst_x = "x",
    cst_text = "text",
    cst_fill = cst_fill$4,
    cst_stroke = cst_stroke$5,
    cst_stroke$0 = cst_stroke$5,
    cst_none = cst_none$1,
    cst_fill$0 = cst_fill$4,
    cst_stroke$1 = cst_stroke$5,
    _a_ = [0, 0],
    cst_g$0 = cst_g$3,
    cst_white = cst_white$1,
    cst_fill$1 = cst_fill$4,
    cst_none$0 = cst_none$1,
    cst_fill$2 = cst_fill$4,
    cst_stroke$2 = cst_stroke$5,
    cst_stroke$3 = cst_stroke$5,
    cst_g$1 = cst_g$3,
    _b_ = [0, 0.3],
    cst_white$0 = cst_white$1,
    cst_fill$3 = cst_fill$4,
    cst_stroke$4 = cst_stroke$5,
    cst_stroke_width = cst_stroke_width$1,
    cst_g$2 = cst_g$3,
    cst_h2 = cst_h2$1,
    cst_mark = "mark",
    cst_h2$0 = cst_h2$1,
    cst_preberi_naslednji_znak = "preberi naslednji znak",
    cst_href = "href",
    cst_button = "button",
    cst_role = "role",
    cst_a = "a",
    cst_stroke_width$0 = cst_stroke_width$1,
    cst_height = "height",
    cst_width = "width",
    cst_svg = "svg",
    cst_header = "header",
    cst_article = "article";
   function int_of_float_attr(tag, value){
    return caml_call2(Vdom[37], tag, value | 0);
   }
   function svg_krog(opt, sredisce, polmer){
    if(opt) var sth = opt[1], a = sth; else var a = 0;
    var
     _aG_ = [0, int_of_float_attr(cst_r, polmer), 0],
     _aH_ = [0, int_of_float_attr(cst_cy, sredisce[2]), _aG_],
     _aI_ = [0, int_of_float_attr(cst_cx, sredisce[1]), _aH_],
     _aJ_ = [0, caml_call2(Stdlib[37], _aI_, a)];
    return caml_call4(Vdom[52], cst_circle, 0, _aJ_, 0);
   }
   function svg_daljica(opt, zacetek, konec){
    if(opt) var sth = opt[1], a = sth; else var a = 0;
    var
     _aB_ = [0, int_of_float_attr(cst_y2, konec[2]), 0],
     _aC_ = [0, int_of_float_attr(cst_x2, konec[1]), _aB_],
     _aD_ = [0, int_of_float_attr(cst_y1, zacetek[2]), _aC_],
     _aE_ = [0, int_of_float_attr(cst_x1, zacetek[1]), _aD_],
     _aF_ = [0, caml_call2(Stdlib[37], _aE_, a)];
    return caml_call4(Vdom[52], cst_line, 0, _aF_, 0);
   }
   function svg_puscica(opt, zacetek, konec){
    if(opt) var sth = opt[1], a = sth; else var a = 0;
    var
     vektor = caml_call2(Dune_exe_Vektor[3], konec, zacetek),
     normala = [254, - vektor[2], vektor[1]],
     _ar_ = caml_call2(Dune_exe_Vektor[1], -1., vektor),
     vektor_leve_konice =
       caml_call3(Dune_exe_Vektor[6], [0, Parametri[7]], _ar_, normala),
     _as_ = caml_call2(Dune_exe_Vektor[1], -1., normala),
     _at_ = caml_call2(Dune_exe_Vektor[1], -1., vektor),
     vektor_desne_konice =
       caml_call3(Dune_exe_Vektor[6], [0, Parametri[7]], _at_, _as_),
     _au_ = caml_call1(Dune_exe_Vektor[5], vektor_leve_konice),
     _av_ = caml_call2(Dune_exe_Vektor[1], Parametri[5], _au_),
     leva_konica = caml_call2(Dune_exe_Vektor[2], konec, _av_),
     _aw_ = caml_call1(Dune_exe_Vektor[5], vektor_desne_konice),
     _ax_ = caml_call2(Dune_exe_Vektor[1], Parametri[5], _aw_),
     desna_konica = caml_call2(Dune_exe_Vektor[2], konec, _ax_),
     _ay_ = [0, svg_daljica([0, a], konec, desna_konica), 0],
     _az_ = [0, svg_daljica([0, a], konec, leva_konica), _ay_],
     _aA_ = [0, svg_daljica([0, a], zacetek, konec), _az_];
    return caml_call4(Vdom[52], cst_g, 0, 0, _aA_);
   }
   function svg_oznaka(opt, polozaj, besedilo){
    if(opt) var sth = opt[1], a = sth; else var a = 0;
    var
     _al_ = [0, caml_call2(Vdom[53], 0, besedilo), 0],
     _am_ = [0, caml_call2(Vdom[36], cst_dominant_baseline, cst_central), 0],
     _an_ = [0, caml_call2(Vdom[36], cst_text_anchor, cst_middle), _am_],
     _ao_ = [0, int_of_float_attr(cst_y, polozaj[2]), _an_],
     _ap_ = [0, int_of_float_attr(cst_x, polozaj[1]), _ao_],
     _aq_ = [0, caml_call2(Stdlib[37], _ap_, a)];
    return caml_call4(Vdom[52], cst_text, 0, _aq_, _al_);
   }
   function prikaz_stanja(model, q){
    var
     avtomat = caml_call1(Definicije_ZagnaniAvtomat[2], model[1]),
     polozaj = caml_call2(Dune_exe_Model[2], model, q),
     barva_robu =
       caml_equal(q, caml_call1(Definicije_Avtomat[6], avtomat))
        ? Parametri[3]
        : caml_call2
           (Definicije_Avtomat[9], avtomat, q)
          ? Parametri[1]
          : Parametri[12],
     barva_polnila =
       caml_equal(q, caml_call1(Definicije_ZagnaniAvtomat[4], model[1]))
        ? Parametri[2]
        : Parametri[13],
     _ac_ =
       [0, svg_oznaka(0, polozaj, caml_call1(Definicije_Stanje[2], q)), 0],
     _ad_ = Parametri[10],
     _ae_ = [0, caml_call2(Vdom[36], cst_fill, barva_polnila), 0],
     svg_elementi =
       [0,
        svg_krog
         ([0, [0, caml_call2(Vdom[36], cst_stroke, barva_robu), _ae_]],
          polozaj,
          _ad_),
        _ac_];
    if(caml_equal(q, caml_call1(Definicije_Avtomat[6], avtomat)))
     var
      _af_ = caml_call2(Dune_exe_Vektor[3], polozaj, [254, Parametri[10], 0.]),
      _ag_ =
        caml_call2
         (Dune_exe_Vektor[3],
          polozaj,
          [254, Parametri[10] + Parametri[6], 0.]),
      svg_elementi$0 =
        [0,
         svg_puscica
          ([0, [0, caml_call2(Vdom[36], cst_stroke$0, Parametri[3]), 0]],
           _ag_,
           _af_),
         svg_elementi];
    else
     var svg_elementi$0 = svg_elementi;
    if(caml_call2(Definicije_Avtomat[9], avtomat, q))
     var
      _ah_ = Parametri[10] - Parametri[9],
      _ai_ = [0, caml_call2(Vdom[36], cst_fill$0, cst_none), 0],
      _aj_ =
        [0,
         svg_krog
          ([0, [0, caml_call2(Vdom[36], cst_stroke$1, Parametri[1]), _ai_]],
           polozaj,
           _ah_),
         0],
      svg_elementi$1 = caml_call2(Stdlib[37], svg_elementi$0, _aj_);
    else
     var svg_elementi$1 = svg_elementi$0;
    var
     _ak_ =
       [0,
        [0, caml_call3(Vdom[8], _a_, 0, function(param){return [0, q];}), 0]];
    return caml_call4(Vdom[52], cst_g$0, 0, _ak_, svg_elementi$1);
   }
   function prikaz_zanke(zacetek, oznaka){
    var
     polozaj_oznake =
       caml_call2(Dune_exe_Vektor[3], zacetek, [254, 0., 2. * Parametri[11]]),
     _U_ = [0, svg_oznaka(0, polozaj_oznake, oznaka), 0],
     _V_ = Parametri[8],
     _W_ =
       [0,
        svg_krog
         ([0, [0, caml_call2(Vdom[36], cst_fill$1, cst_white), 0]],
          polozaj_oznake,
          _V_),
        _U_],
     _X_ = Parametri[11],
     _Y_ = caml_call2(Dune_exe_Vektor[3], zacetek, [254, 0., Parametri[11]]),
     _Z_ = [0, caml_call2(Vdom[36], cst_fill$2, cst_none$0), 0],
     ___ =
       [0,
        svg_krog
         ([0, [0, caml_call2(Vdom[36], cst_stroke$2, Parametri[12]), _Z_]],
          _Y_,
          _X_),
        _W_],
     _$_ = caml_call2(Dune_exe_Vektor[2], zacetek, [254, Parametri[10], -2.]),
     _aa_ =
       caml_call2(Dune_exe_Vektor[2], zacetek, [254, Parametri[10] + 2., -3.]),
     _ab_ =
       [0,
        svg_puscica
         ([0, [0, caml_call2(Vdom[36], cst_stroke$3, Parametri[12]), 0]],
          _aa_,
          _$_),
        ___];
    return caml_call4(Vdom[52], cst_g$1, 0, 0, _ab_);
   }
   function prikaz_prehoda(zacetek, konec, oznaka){
    var
     _O_ = caml_call2(Dune_exe_Vektor[7], zacetek, konec),
     lambda = Parametri[10] / _O_,
     zacetek_puscice =
       caml_call3(Dune_exe_Vektor[6], [0, lambda], zacetek, konec),
     konec_puscice =
       caml_call3(Dune_exe_Vektor[6], [0, 1. - lambda], zacetek, konec),
     polozaj_oznake = caml_call3(Dune_exe_Vektor[6], _b_, zacetek, konec),
     _P_ = [0, svg_oznaka(0, polozaj_oznake, oznaka), 0],
     _Q_ = Parametri[8],
     _R_ =
       [0,
        svg_krog
         ([0, [0, caml_call2(Vdom[36], cst_fill$3, cst_white$0), 0]],
          polozaj_oznake,
          _Q_),
        _P_],
     _S_ = [0, caml_call2(Vdom[36], cst_stroke$4, Parametri[12]), 0],
     _T_ =
       [0,
        svg_puscica
         ([0, [0, int_of_float_attr(cst_stroke_width, Parametri[4]), _S_]],
          zacetek_puscice,
          konec_puscice),
        _R_];
    return caml_call4(Vdom[52], cst_g$2, 0, 0, _T_);
   }
   function prikaz_traku(model){
    var
     trak = caml_call1(Definicije_ZagnaniAvtomat[3], model[1]),
     _F_ = model[3];
    if(typeof _F_ === "number" && _F_){
     var
      _G_ = caml_call1(Definicije_Trak[6], trak),
      _H_ = [0, caml_call1(Vdom[42], _G_), 0],
      _I_ =
        [0,
         [0, caml_call3(Vdom[19], 0, 0, function(niz){return [2, niz];}), _H_]],
      _J_ = [0, caml_call3(Vdom[60], 0, _I_, 0), 0];
     return caml_call5(Vdom[51], 0, cst_h2, 0, 0, _J_);
    }
    var
     prebrani = caml_call1(Definicije_Trak[7], trak),
     neprebrani = caml_call1(Definicije_Trak[8], trak),
     _K_ = [0, caml_call2(Vdom[53], 0, neprebrani), 0],
     _L_ = [0, caml_call5(Vdom[51], 0, cst_mark, 0, 0, _K_), 0],
     _M_ = [0, caml_call2(Vdom[53], 0, prebrani), _L_],
     _N_ = [0, [0, caml_call3(Vdom[13], 0, 0, function(param){return 2;}), 0]];
    return caml_call5(Vdom[51], 0, cst_h2$0, 0, _N_, _M_);
   }
   function prikaz_gumba_za_naslednji_znak(model){
    var
     _w_ = [0, caml_call2(Vdom[53], 0, cst_preberi_naslednji_znak), 0],
     _y_ = 1 === model[3] ? 1 : 0,
     _x_ = 0;
    if(_y_)
     var _z_ = _y_;
    else
     var
      _E_ = caml_call1(Definicije_ZagnaniAvtomat[3], model[1]),
      _z_ = caml_call1(Definicije_Trak[3], _E_);
    var
     _A_ = [0, caml_call1(Vdom[43], _z_), _x_],
     _B_ = [0, caml_call3(Vdom[11], 0, 0, function(param){return 0;}), _A_],
     _C_ = [0, caml_call2(Vdom[36], cst_href, cst), _B_],
     _D_ = [0, [0, caml_call2(Vdom[36], cst_role, cst_button), _C_]];
    return caml_call5(Vdom[51], 0, cst_a, 0, _D_, _w_);
   }
   function prikaz_avtomata(model){
    var
     avtomat = caml_call1(Definicije_ZagnaniAvtomat[2], model[1]),
     _g_ = caml_call1(Definicije_Avtomat[7], avtomat),
     stanja =
       caml_call2
        (Stdlib_List[19],
         function(_v_){return prikaz_stanja(model, _v_);},
         _g_),
     _h_ = caml_call1(Definicije_Avtomat[8], avtomat),
     prehodi =
       caml_call2
        (Stdlib_List[19],
         function(param){
          var
           dst = param[3],
           chr = param[2],
           src = param[1],
           svg_oznaka = caml_call2(Stdlib_String[1], 1, chr);
          if(caml_equal(src, dst))
           return prikaz_zanke
                   (caml_call2(Dune_exe_Model[2], model, src), svg_oznaka);
          var _u_ = caml_call2(Dune_exe_Model[2], model, dst);
          return prikaz_prehoda
                  (caml_call2(Dune_exe_Model[2], model, src), _u_, svg_oznaka);
         },
         _h_);
    if(typeof model[3] === "number")
     var a = 0;
    else
     var
      _n_ = [0, caml_call3(Vdom[10], 0, 0, function(param){return 1;}), 0],
      a =
        [0,
         caml_call3
          (Vdom[21],
           0,
           0,
           function(ev){
            var
             _o_ = ev[6],
             _p_ = caml_obj_tag(_o_),
             _q_ =
               250 === _p_
                ? _o_[1]
                : 246 === _p_ ? caml_call1(CamlinternalLazy[2], _o_) : _o_,
             _r_ = ev[5],
             _s_ = caml_obj_tag(_r_),
             _t_ =
               250 === _s_
                ? _r_[1]
                : 246 === _s_ ? caml_call1(CamlinternalLazy[2], _r_) : _r_;
            return [1, [254, _t_, _q_]];
           }),
         _n_];
    var
     _i_ = caml_call2(Stdlib[37], prehodi, stanja),
     _j_ = [0, int_of_float_attr(cst_stroke_width$0, Parametri[4]), 0],
     _k_ = [0, int_of_float_attr(cst_height, model[5]), _j_],
     _l_ = [0, int_of_float_attr(cst_width, model[4]), _k_],
     _m_ = [0, caml_call2(Stdlib[37], a, _l_)];
    return caml_call4(Vdom[52], cst_svg, 0, _m_, _i_);
   }
   function view(model){
    var
     _c_ = [0, prikaz_avtomata(model), 0],
     _d_ = [0, prikaz_gumba_za_naslednji_znak(model), 0],
     _e_ = [0, prikaz_traku(model), _d_],
     _f_ = [0, caml_call5(Vdom[51], 0, cst_header, 0, 0, _e_), _c_];
    return caml_call5(Vdom[51], 0, cst_article, 0, 0, _f_);
   }
   var
    Dune_exe_View =
      [0,
       Parametri,
       int_of_float_attr,
       svg_krog,
       svg_daljica,
       svg_puscica,
       svg_oznaka,
       prikaz_stanja,
       prikaz_zanke,
       prikaz_prehoda,
       prikaz_traku,
       prikaz_gumba_za_naslednji_znak,
       prikaz_avtomata,
       view];
   runtime.caml_register_global(89, Dune_exe_View, "Dune__exe__View");
   return;
  }
  (globalThis));


//# 1 ".spletniVmesnik.eobjs/jsoo/dune__exe__SpletniVmesnik.cmo.js"
// Generated by js_of_ocaml
//# 3 ".spletniVmesnik.eobjs/jsoo/dune__exe__SpletniVmesnik.cmo.js"

//# 6 ".spletniVmesnik.eobjs/jsoo/dune__exe__SpletniVmesnik.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Vdom_blit = global_data.Vdom_blit,
    Js_browser = global_data.Js_browser,
    Stdlib_Array = global_data.Stdlib__Array,
    Dune_exe_View = global_data.Dune__exe__View,
    Dune_exe_Model = global_data.Dune__exe__Model,
    Definicije_Avtomat = global_data.Definicije__Avtomat,
    Vdom = global_data.Vdom,
    _a_ = Dune_exe_View[13],
    _b_ = Dune_exe_Model[3],
    _c_ = caml_call3(Dune_exe_Model[1], 500., 500., Definicije_Avtomat[10]),
    app = caml_call4(Vdom[64], _c_, _b_, _a_, 0),
    cst_container = "container";
   function run(param){
    var
     _d_ = caml_call3(Vdom_blit[11], 0, 0, app),
     _e_ = caml_call1(Vdom_blit[13], _d_),
     _f_ = caml_call2(Js_browser[16][8], Js_browser[26], cst_container),
     match = caml_call1(Stdlib_Array[11], _f_);
    if(match)
     var element = match[1], element$0 = element;
    else
     var element$0 = caml_call1(Js_browser[16][10], Js_browser[26]);
    return caml_call1(caml_call1(Js_browser[15][9], element$0), _e_);
   }
   caml_call2(Js_browser[19][6], Js_browser[25], run);
   var Dune_exe_SpletniVmesnik = [0];
   runtime.caml_register_global
    (10, Dune_exe_SpletniVmesnik, "Dune__exe__SpletniVmesnik");
   return;
  }
  (globalThis));


//# 1 "../../.js/default/stdlib/std_exit.cmo.js"
// Generated by js_of_ocaml
//# 3 "../../.js/default/stdlib/std_exit.cmo.js"

//# 6 "../../.js/default/stdlib/std_exit.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib;
   caml_call1(Stdlib[103], 0);
   var Std_exit = [0];
   runtime.caml_register_global(1, Std_exit, "Std_exit");
   return;
  }
  (globalThis));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzcGxldG5pVm1lc25pay5iYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMiLCJhIiwiaSIsImxlbiIsImYiLCJTdHJpbmciLCJudWxsIiwicyIsIk1hdGgiLCJjYW1sX3N0cmluZ19vZl9qc2J5dGVzIiwieCIsImNhbWxfc3RyaW5nX29mX2FycmF5IiwiY2FtbF9iYV9nZXRfMSIsImJhIiwiaTAiLCJCaWdTdHJpbmdSZWFkZXIiLCJicyIsInRoaXMiLCJhcnIiLCJBcnJheSIsImoiLCJvZmZzZXQiLCJjYW1sX3N0cl9yZXBlYXQiLCJuIiwiciIsImwiLCJjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIiwianNvb19pc19hc2NpaSIsImNhbWxfdXRmMTZfb2ZfdXRmOCIsImIiLCJ0IiwiYyIsImMxIiwiYzIiLCJ2IiwiTWxCeXRlcyIsInRhZyIsImNvbnRlbnRzIiwibGVuZ3RoIiwiY29udGVudCIsImNhbWxfdXRmOF9vZl91dGYxNiIsImQiLCJjYW1sX3N0cmluZ19vZl9qc3N0cmluZyIsInVuaXhfZXJyb3IiLCJtYWtlX3VuaXhfZXJyX2FyZ3MiLCJjb2RlIiwic3lzY2FsbCIsInBhdGgiLCJlcnJubyIsInZhcmlhbnQiLCJhcmdzIiwiY2FtbF9uYW1lZF92YWx1ZXMiLCJjYW1sX25hbWVkX3ZhbHVlIiwibm0iLCJqc29vX3N5c19nZXRlbnYiLCJwcm9jZXNzIiwiZ2xvYmFsVGhpcyIsInVuZGVmaW5lZCIsImNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnIiwiY2FtbF9nbG9iYWxfZGF0YSIsImNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlIiwiZXhuIiwiZm9yY2UiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3JhaXNlX3dpdGhfYXJncyIsImNhbWxfaXNfbWxfYnl0ZXMiLCJjYW1sX2lzX21sX3N0cmluZyIsImNhbWxfYnl0ZXNfb2ZfYXJyYXkiLCJVaW50OEFycmF5IiwiY2FtbF9ieXRlc19vZl9qc2J5dGVzIiwiY2FtbF9qc2J5dGVzX29mX3N0cmluZyIsImNhbWxfYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9yYWlzZV93aXRoX2FyZyIsImFyZyIsImNhbWxfcmFpc2Vfd2l0aF9zdHJpbmciLCJtc2ciLCJjYW1sX3JhaXNlX3N5c19lcnJvciIsImNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlIiwibmFtZSIsImNhbWxfY29udmVydF9ieXRlc190b19hcnJheSIsImNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMiLCJjYW1sX2ludmFsaWRfYXJndW1lbnQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfbWxfYnl0ZXNfbGVuZ3RoIiwiY2FtbF9ibGl0X2J5dGVzIiwiczEiLCJpMSIsInMyIiwiaTIiLCJNbEZpbGUiLCJNbEZha2VGaWxlIiwib2xkIiwiYnVmIiwicG9zIiwiY2xlbiIsIm5ld19zdHIiLCJvbGRfZGF0YSIsImRhdGEiLCJNbEZha2VGZCIsImZpbGUiLCJmbGFncyIsIk1sRmFrZURldmljZSIsInJvb3QiLCJjb21wIiwicmVzIiwiU3ltYm9sIiwibmFtZV9zbGFzaCIsIm1vZGUiLCJyYWlzZV91bml4IiwicGFyZW50IiwiUmVnRXhwIiwic2VlbiIsIm0iLCJlbnRyeSIsIm9rIiwiYnl0ZXMiLCJNbEZha2VGZF9vdXQiLCJmZCIsImNvbnNvbGUiLCJzcmMiLCJjYW1sX2ludDY0X29mZnNldCIsImNhbWxfcmFpc2VfY29uc3RhbnQiLCJjYW1sX3JhaXNlX3plcm9fZGl2aWRlIiwiTWxJbnQ2NCIsImxvIiwibWkiLCJoaSIsInhoaSIsImgiLCJzaWduIiwibW9kdWx1cyIsImRpdmlzb3IiLCJxdW90aWVudCIsInkiLCJxIiwiTWxNdXRleCIsIk1sTmF0IiwiSW50MzJBcnJheSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQiLCJjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyIsImNhbWxfYnl0ZXNfYm91bmRfZXJyb3IiLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX2J5dGVzX3NldCIsIk1sTm9kZUZkIiwicmVxdWlyZSIsImVyciIsImJ1Zl9vZmZzZXQiLCJyZWFkIiwiTWxOb2RlRGV2aWNlIiwiY29uc3RzIiwia2V5IiwiaXNDaGFyYWN0ZXJEZXZpY2UiLCJvIiwianNfc3RhdHMiLCJ0b19kaXIiLCJ0YXJnZXQiLCJsaW5rIiwiZmlsZV9raW5kIiwiTWxPYmplY3RUYWJsZSIsIk5haXZlTG9va3VwIiwib2JqcyIsIk1sU3RyaW5nUmVhZGVyIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkiLCJjYW1sX2ludDY0X2hpMzIiLCJjYW1sX2ludDY0X2xvMzIiLCJjYW1sX2FycmF5X2JvdW5kX2Vycm9yIiwiY2FtbF9iYV9jdXN0b21fbmFtZSIsIk1sX0JpZ2FycmF5Iiwia2luZCIsImxheW91dCIsImRpbXMiLCJidWZmZXIiLCJvZnMiLCJpbSIsInJlIiwidG90YWwiLCJrMSIsImsyIiwiTmFOIiwiTWxfQmlnYXJyYXlfY18xXzEiLCJVSW50OEFycmF5UmVhZGVyIiwiaW5jcl9uYXQiLCJuYXQiLCJjYXJyeV9pbiIsImNhcnJ5IiwiYWRkX25hdCIsIm5hdDEiLCJvZnMxIiwibGVuMSIsIm5hdDIiLCJvZnMyIiwibGVuMiIsImNhbWxfYmFfZ2V0X3NpemUiLCJuX2RpbXMiLCJzaXplIiwiY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudCIsImNhbWxfYmFfY3JlYXRlX3Vuc2FmZSIsInNpemVfcGVyX2VsZW1lbnQiLCJiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIiwiYWIiLCJ0YSIsImJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSIsImJpZ3N0cmluZ190b19hcnJheV9idWZmZXIiLCJiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkiLCJibGl0X25hdCIsImNhbWxfTUQ1VHJhbnNmb3JtIiwiYWRkIiwieHgiLCJmZiIsImdnIiwiaGgiLCJpaSIsInciLCJjYW1sX01ENUZpbmFsIiwiY3R4IiwiaW5fYnVmIiwiY2FtbF9NRDVJbml0IiwiQXJyYXlCdWZmZXIiLCJiMzIiLCJVaW50MzJBcnJheSIsImI4IiwiY2FtbF9NRDVVcGRhdGUiLCJpbnB1dCIsImlucHV0X2xlbiIsImlucHV0X3BvcyIsIm1pc3NpbmciLCJjYW1sX2Fjb3NoX2Zsb2F0IiwiY2FtbF9jYWxsX2dlbiIsImFyZ3NMZW4iLCJnIiwibmFyZ3MiLCJleHRyYV9hcmdzIiwiYXJndW1lbnRzIiwiY2FtbF9hbGxvY19kdW1teV9pbmZpeCIsImNhbWxfYWxsb2Nfc3RhY2siLCJodiIsImh4IiwiaGYiLCJjYW1sX2FyZ3YiLCJtYWluIiwiYXJndiIsInAiLCJhcmdzMiIsImNhbWxfYXJyYXlfYXBwZW5kIiwiYTEiLCJhMiIsImwxIiwibDIiLCJjYW1sX2FycmF5X2JsaXQiLCJjYW1sX2FycmF5X2NvbmNhdCIsImNhbWxfYXJyYXlfZmlsbCIsImFycmF5IiwiY2FtbF9hcnJheV9nZXQiLCJpbmRleCIsImNhbWxfYXJyYXlfb2ZfYnl0ZXMiLCJjYW1sX2FycmF5X29mX3N0cmluZyIsImNhbWxfYXJyYXlfc2V0IiwibmV3dmFsIiwiY2FtbF9hcnJheV9zdWIiLCJjYW1sX2FzaW5oX2Zsb2F0IiwiY2FtbF9hdGFuaF9mbG9hdCIsImNhbWxfYXRvbWljX2NhcyIsInJlZiIsImNhbWxfYXRvbWljX2V4Y2hhbmdlIiwiY2FtbF9hdG9taWNfZmV0Y2hfYWRkIiwiY2FtbF9hdG9taWNfbG9hZCIsImNhbWxfYXRvbWljX21ha2VfY29udGVuZGVkIiwiY2FtbF9iYV9ibGl0IiwiZHN0IiwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0IiwibmV3X2RpbXMiLCJjYW1sX2JhX2NvbXBhcmUiLCJjYW1sX2JhX2NyZWF0ZV9idWZmZXIiLCJ2aWV3IiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIlVpbnQxNkFycmF5IiwiY2FtbF9qc19mcm9tX2FycmF5IiwiY2FtbF9iYV9jcmVhdGUiLCJkaW1zX21sIiwiY2FtbF9iYV9jcmVhdGVfZnJvbSIsImRhdGExIiwiZGF0YTIiLCJqc3R5cCIsImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyIsImludDMyYSIsImZsb2F0MzJhIiwiY2FtbF9pbnQ2NF9vZl9ieXRlcyIsImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyIsImV4cCIsIkluZmluaXR5IiwiayIsImNhbWxfZmFpbHdpdGgiLCJjYW1sX2JhX2Rlc2VyaWFsaXplIiwicmVhZGVyIiwic3oiLCJudW1fZGltcyIsInNpemVfZGltIiwic2l6ZV9kaW1faGkiLCJzaXplX2RpbV9sbyIsInNpeHR5IiwiaW50NjQiLCJjYW1sX2JhX2RpbSIsImNhbWxfYmFfZGltXzEiLCJjYW1sX2JhX2RpbV8yIiwiY2FtbF9iYV9kaW1fMyIsImNhbWxfYmFfZmlsbCIsImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5IiwiY2FtbF9iYV9nZXRfMiIsImNhbWxfYmFfZ2V0XzMiLCJjYW1sX2JhX2dldF9nZW5lcmljIiwiY2FtbF9tdWwiLCJjYW1sX2hhc2hfbWl4X2ludCIsImxvZzJfb2siLCJqc29vX2Zsb29yX2xvZzIiLCJjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSIsImNhbWxfaW50NjRfYml0c19vZl9mbG9hdCIsImlzRmluaXRlIiwiaXNOYU4iLCJyMyIsInIyIiwicjEiLCJjYW1sX2hhc2hfbWl4X2ludDY0IiwiY2FtbF9oYXNoX21peF9mbG9hdCIsInYwIiwiY2FtbF9iYV9oYXNoIiwibnVtX2VsdHMiLCJjYW1sX2JhX2luaXQiLCJjYW1sX2JhX2tpbmQiLCJjYW1sX2JhX2xheW91dCIsImNhbWxfYmFfbWFwX2ZpbGUiLCJ2ZmQiLCJzaGFyZWQiLCJjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlIiwiYXJnbiIsImNhbWxfYmFfbnVtX2RpbXMiLCJjYW1sX2JhX3Jlc2hhcGUiLCJ2aW5kIiwibmV3X2RpbSIsImNhbWxfaW50MzJfYml0c19vZl9mbG9hdCIsImNhbWxfaW50NjRfdG9fYnl0ZXMiLCJjYW1sX2JhX3NlcmlhbGl6ZSIsIndyaXRlciIsImNvbXBsZXgiLCJjYW1sX2JhX3NldF8xIiwiY2FtbF9iYV9zZXRfMiIsImNhbWxfYmFfc2V0XzMiLCJjYW1sX2JhX3NldF9nZW5lcmljIiwiY2FtbF9iYV9zbGljZSIsIm51bV9pbmRzIiwic3ViX2RpbXMiLCJuZXdfZGF0YSIsImNhbWxfYmFfc3ViIiwiY2hhbmdlZF9kaW0iLCJtdWwiLCJjYW1sX2JhX3RvX3R5cGVkX2FycmF5IiwiY2FtbF9iYV91aW50OF9nZXQxNiIsImIxIiwiYjIiLCJjYW1sX2JhX3VpbnQ4X2dldDMyIiwiYjMiLCJiNCIsImNhbWxfYmFfdWludDhfZ2V0NjQiLCJiNSIsImI2IiwiYjciLCJjYW1sX2JhX3VpbnQ4X3NldDE2IiwiY2FtbF9iYV91aW50OF9zZXQzMiIsImNhbWxfYmFfdWludDhfc2V0NjQiLCJjYW1sX2JhY2t0cmFjZV9zdGF0dXMiLCJfdW5pdCIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEiLCJiYTEiLCJwb3MxIiwiYmEyIiwicG9zMiIsInNsaWNlIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyIsImJ5dGVzMiIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEiLCJzdHIxIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEiLCJjYW1sX2JpZ3N0cmluZ19tZW1jbXAiLCJjYW1sX2JsaXRfc3RyaW5nIiwiZSIsImNhbWxfYnN3YXAxNiIsImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIiwiY2FtbF9idWlsZF9zeW1ib2xzIiwic3ltYiIsImNhbWxfYnl0ZXNfY29tcGFyZSIsImNhbWxfYnl0ZXNfZXF1YWwiLCJjYW1sX2J5dGVzX3Vuc2FmZV9nZXQiLCJjYW1sX2J5dGVzX2dldCIsImNhbWxfYnl0ZXNfZ2V0MTYiLCJjYW1sX2J5dGVzX2dldDMyIiwiY2FtbF9ieXRlc19nZXQ2NCIsImNhbWxfYnl0ZXNfbGVzc2VxdWFsIiwiY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwiLCJjYW1sX2J5dGVzX2xlc3N0aGFuIiwiY2FtbF9ieXRlc19ncmVhdGVydGhhbiIsImNhbWxfYnl0ZXNfbm90ZXF1YWwiLCJjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nIiwiY2FtbF9ieXRlc19zZXQxNiIsImkxNiIsImNhbWxfYnl0ZXNfc2V0MzIiLCJpMzIiLCJjYW1sX2J5dGVzX3NldDY0IiwiaTY0IiwiY2FtbF9jYWxsYmFjayIsImNhbWxfY2JydF9mbG9hdCIsImNhbWxfbWxfY2hhbm5lbHMiLCJjYW1sX21sX2NoYW5uZWxfZ2V0IiwiaWQiLCJjYW1sX2NoYW5uZWxfZGVzY3JpcHRvciIsImNoYW5pZCIsImNoYW4iLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9jbGFzc2lmeV9mbG9hdCIsImNhbWxfaXNfY29udGludWF0aW9uX3RhZyIsImNhbWxfaW50MzJfdW5tYXJzaGFsIiwiY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X21hcnNoYWwiLCJzaXplcyIsImNhbWxfaW50NjRfY29tcGFyZSIsImNhbWxfaW50NjRfaGFzaCIsImNhbWxfY3VzdG9tX29wcyIsImNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSIsImNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbSIsIm51bSIsImN1c3RvbSIsInN3YXAiLCJjYW1sX2NvbXBhcmVfdmFsX3RhZyIsIk51bWJlciIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX3N0cmluZ19jb21wYXJlIiwiY2FtbF9jb21wYXJlX3ZhbCIsInN0YWNrIiwidGFnX2EiLCJ0YWdfYiIsImNhbWxfY29tcGFyZSIsImNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4YyIsImNvbnQiLCJjYW1sX2NvbnRpbnVhdGlvbl91c2VfYW5kX3VwZGF0ZV9oYW5kbGVyX25vZXhjIiwiaHZhbCIsImhleG4iLCJoZWZmIiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9jb3B5c2lnbl9mbG9hdCIsImNhbWxfY29zaF9mbG9hdCIsImZzX25vZGVfc3VwcG9ydGVkIiwibWFrZV9wYXRoX2lzX2Fic29sdXRlIiwicG9zaXgiLCJ3aW4zMiIsInNwbGl0RGV2aWNlUmUiLCJyZXN1bHQiLCJkZXZpY2UiLCJpc1VuYyIsIkJvb2xlYW4iLCJzZXAiLCJwYXRoX2lzX2Fic29sdXRlIiwiY2FtbF90cmFpbGluZ19zbGFzaCIsImNhbWxfY3VycmVudF9kaXIiLCJjYW1sX21ha2VfcGF0aCIsImNvbXAwIiwibmNvbXAiLCJjYW1sX2dldF9yb290IiwiY2FtbF9yb290IiwianNvb19tb3VudF9wb2ludCIsInJlc29sdmVfZnNfZGV2aWNlIiwiY2FtbF9jcmVhdGVfZmlsZSIsImNhbWxfY3JlYXRlX3N0cmluZyIsImNhbWxfY3VzdG9tX2V2ZW50X2luZGV4IiwiY2FtbF9kZWNvbXByZXNzX2lucHV0IiwiY2FtbF9kaXYiLCJjYW1sX2RvbWFpbl9kbHMiLCJjYW1sX2RvbWFpbl9kbHNfZ2V0IiwidW5pdCIsImNhbWxfZG9tYWluX2Rsc19zZXQiLCJjYW1sX2RvbWFpbl9pZCIsImNhbWxfbWxfbXV0ZXhfdW5sb2NrIiwiY2FtbF9kb21haW5fbGF0ZXN0X2lkeCIsImNhbWxfZG9tYWluX3NwYXduIiwibXV0ZXgiLCJjYW1sX2VwaGVfZGF0YV9vZmZzZXQiLCJjYW1sX2VwaGVfa2V5X29mZnNldCIsImNhbWxfZXBoZV91bnNldF9kYXRhIiwiY2FtbF9lcGhlX3NldF9kYXRhIiwiY2FtbF9lcGhlX2JsaXRfZGF0YSIsImNhbWxfZXBoZV9ibGl0X2tleSIsImNhbWxfZXBoZV9jaGVja19kYXRhIiwiY2FtbF9lcGhlX2NoZWNrX2tleSIsIndlYWsiLCJjYW1sX3dlYWtfY3JlYXRlIiwiY2FtbF9lcGhlX2NyZWF0ZSIsImNhbWxfZXBoZV9nZXRfZGF0YSIsImNhbWxfb2JqX2R1cCIsImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5IiwiY2FtbF9lcGhlX2dldF9rZXkiLCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5IiwieiIsImNhbWxfZXBoZV9zZXRfa2V5IiwiT2JqZWN0IiwiY2FtbF9lcGhlX3Vuc2V0X2tleSIsImNvdW50IiwiY2FtbF9lcXVhbCIsImNhbWxfZXJmX2Zsb2F0IiwiYTMiLCJhNCIsImE1IiwiY2FtbF9lcmZjX2Zsb2F0IiwiY2FtbF9ldmVudGxvZ19wYXVzZSIsImNhbWxfZXZlbnRsb2dfcmVzdW1lIiwiY2FtbF9leGVjdXRhYmxlX25hbWUiLCJjYW1sX2V4cDJfZmxvYXQiLCJjYW1sX2V4cG0xX2Zsb2F0IiwiY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvbiIsImNhbWxfZm9ybWF0X2V4Y2VwdGlvbiIsImJ1Y2tldCIsInN0YXJ0IiwiY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24iLCJoYW5kbGVyIiwiYXRfZXhpdCIsImNhbWxfZmlsbF9ieXRlcyIsImNhbWxfZmluYWxfcmVnaXN0ZXIiLCJhbGxfZmluYWxpemVycyIsImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUiLCJjYiIsImNhbWxfZmluYWxfcmVsZWFzZSIsImNhbWxfZmluaXNoX2Zvcm1hdHRpbmciLCJyYXdidWZmZXIiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX2Zsb2F0X29mX2J5dGVzIiwiY2FtbF9mbG9hdF9vZl9zdHJpbmciLCJtMyIsIm1hbnRpc3NhIiwicGFyc2VJbnQiLCJleHBvbmVudCIsImNhbWxfZmxvYXRhcnJheV9ibGl0IiwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSIsImNhbWxfZm1hX2Zsb2F0IiwiU1BMSVQiLCJNSU5fVkFMVUUiLCJFUFNJTE9OIiwiQyIsIkEiLCJCIiwibXVsdGlwbHkiLCJhdCIsImFoaSIsImFsbyIsImJ0IiwiYmhpIiwiYmxvIiwiYWRqdXN0Iiwic2NhbGUiLCJ4cyIsInlzIiwienMiLCJ4eSIsInUiLCJmcyIsImNhbWxfcGFyc2VfZm9ybWF0IiwiZm10IiwiY2FtbF9mb3JtYXRfZmxvYXQiLCJ0b0ZpeGVkIiwiZHAiLCJwcmVjIiwiY2FtbF9mb3JtYXRfaW50IiwiY2FtbF9vb19sYXN0X2lkIiwiY2FtbF9mcmVzaF9vb19pZCIsImNhbWxfZnJleHBfZmxvYXQiLCJuZWciLCJqc29vX2NyZWF0ZV9maWxlIiwiY2FtbF9mc19pbml0IiwidG1wIiwiY2FtbF9nY19jb21wYWN0aW9uIiwiY2FtbF9nY19jb3VudGVycyIsImNhbWxfZ2NfZnVsbF9tYWpvciIsImNhbWxfZ2NfZ2V0IiwiY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50IiwiY2FtbF9nY19tYWpvciIsImNhbWxfZ2NfbWFqb3Jfc2xpY2UiLCJ3b3JrIiwiY2FtbF9nY19taW5vciIsImNhbWxfZ2NfbWlub3Jfd29yZHMiLCJjYW1sX2djX3F1aWNrX3N0YXQiLCJjYW1sX2djX3NldCIsIl9jb250cm9sIiwiY2FtbF9nY19zdGF0IiwiY2FtbF9nZXRfY29udGludWF0aW9uX2NhbGxzdGFjayIsImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIiwiY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIiwiY2FtbF9nZXRfZ2xvYmFsX2RhdGEiLCJjYW1sX2dldF9tYWpvcl9idWNrZXQiLCJjYW1sX2dldF9tYWpvcl9jcmVkaXQiLCJjYW1sX2dldF9taW5vcl9mcmVlIiwiY2FtbF9tZXRob2RfY2FjaGUiLCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kIiwib2JqIiwiY2FjaGVpZCIsIm1ldGhzIiwibGkiLCJjYW1sX2dyX2FyY19hdXgiLCJjeCIsImN5IiwicnkiLCJyeCIsInJvdCIsInhQb3MiLCJ5UG9zIiwieFBvc19wcmV2IiwieVBvc19wcmV2Iiwic3BhY2UiLCJkZWx0YSIsImNhbWxfZ3Jfc3RhdGUiLCJjYW1sX2dyX3N0YXRlX2dldCIsImNhbWxfZ3JfYmxpdF9pbWFnZSIsImltMiIsImNhbWxfZ3JfY2xlYXJfZ3JhcGgiLCJjYW1sX2dyX2Nsb3NlX2dyYXBoIiwiY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3ciLCJjYW1sX2dyX2NyZWF0ZV9pbWFnZSIsImNhbWxfZ3JfY3VycmVudF94IiwiY2FtbF9ncl9jdXJyZW50X3kiLCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSIsImNhbWxfZ3JfZG9jX29mX3N0YXRlIiwic3RhdGUiLCJjYW1sX2dyX2RyYXdfYXJjIiwiY2FtbF9ncl9kcmF3X3N0ciIsInN0ciIsImR4IiwiY2FtbF9ncl9kcmF3X2NoYXIiLCJjYW1sX2dyX2RyYXdfaW1hZ2UiLCJjYW52YXMiLCJkb2N1bWVudCIsImltYWdlIiwiY2FtbF9ncl9kcmF3X3JlY3QiLCJjYW1sX2dyX2RyYXdfc3RyaW5nIiwiY2FtbF9ncl9kdW1wX2ltYWdlIiwiY2FtbF9ncl9maWxsX2FyYyIsImNhbWxfZ3JfZmlsbF9wb2x5IiwiYXIiLCJjYW1sX2dyX2ZpbGxfcmVjdCIsImNhbWxfZ3JfbGluZXRvIiwiY2FtbF9ncl9tYWtlX2ltYWdlIiwiY2FtbF9ncl9tb3ZldG8iLCJjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUiLCJqc25hbWUiLCJjYW1sX2dyX3NldF9saW5lX3dpZHRoIiwiY2FtbF9ncl9zZXRfdGV4dF9zaXplIiwiY2FtbF9ncl9zZXRfZm9udCIsImNhbWxfZ3Jfc2V0X2NvbG9yIiwiY29sb3IiLCJjb252ZXJ0IiwibnVtYmVyIiwiY19zdHIiLCJjYW1sX2dyX3Jlc2l6ZV93aW5kb3ciLCJjYW1sX2dyX3N0YXRlX2luaXQiLCJjYW1sX2dyX3N0YXRlX3NldCIsImNhbWxfZ3Jfc3RhdGVfY3JlYXRlIiwiY29udGV4dCIsImNhbWxfZ3Jfb3Blbl9ncmFwaCIsImluZm8iLCJnZXQiLCJzcGVjcyIsInN0YXR1cyIsIndpbiIsImRvYyIsInRpdGxlIiwiYm9keSIsImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3ciLCJjYW1sX2dyX3Bsb3QiLCJjYW1sX2dyX3BvaW50X2NvbG9yIiwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIiwiY2FtbF9ncl9zaWdpb19oYW5kbGVyIiwiY2FtbF9ncl9zaWdpb19zaWduYWwiLCJjYW1sX2dyX3NpemVfeCIsImNhbWxfZ3Jfc2l6ZV95IiwiY2FtbF9ncl9zeW5jaHJvbml6ZSIsImNhbWxfZ3JfdGV4dF9zaXplIiwidHh0IiwiY2FtbF9ncl93YWl0X2V2ZW50IiwiX2V2bCIsImNhbWxfZ3Jfd2luZG93X2lkIiwiY2FtbF9ncmVhdGVyZXF1YWwiLCJjYW1sX2dyZWF0ZXJ0aGFuIiwiY2FtbF9oYXNoX21peF9qc2J5dGVzIiwiY2FtbF9oYXNoX21peF9zdHJpbmciLCJjYW1sX2hhc2hfbWl4X2J5dGVzX2FyciIsImNhbWxfbWxfYnl0ZXNfY29udGVudCIsImNhbWxfaGFzaF9taXhfYnl0ZXMiLCJjYW1sX2hhc2hfbWl4X2ZpbmFsIiwiY2FtbF9oYXNoIiwibGltaXQiLCJzZWVkIiwicXVldWUiLCJyZCIsIndyIiwiY2FtbF9oYXNoX21peF9iaWdzdHJpbmciLCJudW1fZGlnaXRzX25hdCIsImNhbWxfaGFzaF9uYXQiLCJjYW1sX2hleHN0cmluZ19vZl9mbG9hdCIsInN0eWxlIiwiZXhwX3NpZ24iLCJzaWduX3N0ciIsImNzdCIsInhfc3RyIiwiaWR4IiwiY2FtbF9oeXBvdF9mbG9hdCIsImNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSIsImNhbWxfcmVmaWxsIiwic3RyX2EiLCJucmVhZCIsImNhbWxfcmFpc2VfZW5kX29mX2ZpbGUiLCJjYW1sX21hcnNoYWxfZGF0YV9zaXplIiwicmVhZHZscSIsIm92ZXJmbG93IiwibjciLCJoZWFkZXJfbGVuIiwiZGF0YV9sZW4iLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIiwibWFnaWMiLCJjb21wcmVzc2VkIiwidW5jb21wcmVzc2VkX2RhdGFfbGVuIiwibnVtX29iamVjdHMiLCJfc2l6ZV8zMiIsIl9zaXplXzY0IiwiaW50ZXJuX29ial90YWJsZSIsIm9ial9jb3VudGVyIiwiaW50ZXJuX3JlYyIsImhlYWRlciIsIm9wcyIsImV4cGVjdGVkX3NpemUiLCJvbGRfcG9zIiwiY2FtbF9zdHJpbmdfb2ZfYnl0ZXMiLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMiLCJjYW1sX2lucHV0X3ZhbHVlIiwiYmxvY2siLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nIiwiY2FtbF9pbnB1dF92YWx1ZV90b19vdXRzaWRlX2hlYXAiLCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIiLCJjYW1sX2ludDMyX2Jzd2FwIiwiY2FtbF9pbnQ2NF9hZGQiLCJjYW1sX2ludDY0X2FuZCIsImNhbWxfaW50NjRfYnN3YXAiLCJjYW1sX2ludDY0X2RpdiIsImNhbWxfaW50NjRfaXNfemVybyIsImNhbWxfaW50NjRfb2ZfaW50MzIiLCJjYW1sX2ludDY0X3RvX2ludDMyIiwiY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSIsImNhbWxfaW50NjRfbmVnIiwiY2FtbF9pbnQ2NF9mb3JtYXQiLCJ3YmFzZSIsImN2dGJsIiwiY2FtbF9pbnQ2NF9tb2QiLCJjYW1sX2ludDY0X211bCIsImNhbWxfaW50NjRfb2ZfZmxvYXQiLCJjYW1sX2ludDY0X3VsdCIsImNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSIsImJhc2UiLCJjYW1sX3BhcnNlX2RpZ2l0IiwiY2FtbF9pbnQ2NF9vZl9zdHJpbmciLCJiYXNlNjQiLCJ0aHJlc2hvbGQiLCJjYW1sX2ludDY0X29yIiwiY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCIsImNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQiLCJjYW1sX2ludDY0X3N1YiIsImNhbWxfaW50NjRfdG9fZmxvYXQiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfaW50X29mX3N0cmluZyIsImNhbWxfaXNfanMiLCJjYW1sX2lzX3ByaW50YWJsZSIsImNhbWxfanNfY2FsbCIsImNhbWxfanNfZGVsZXRlIiwiY2FtbF9qc19lcXVhbHMiLCJjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbiIsImNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvbiIsImNhbWxfanNfZXZhbF9zdHJpbmciLCJldmFsIiwiY2FtbF9qc19leHByIiwiY2FtbF9qc19mcm9tX2Jvb2wiLCJjYW1sX2pzX2Zyb21fZmxvYXQiLCJjYW1sX2pzX2Zyb21fc3RyaW5nIiwiY2FtbF9qc19mdW5fY2FsbCIsImNhbWxfanNfZnVuY3Rpb25fYXJpdHkiLCJjYW1sX2pzX2dldCIsImNhbWxfanNfZ2V0X2NvbnNvbGUiLCJjYW1sX2pzX2h0bWxfZW50aXRpZXMiLCJlbnRpdHkiLCJ0ZW1wIiwiY2FtbF9qc19yZWdleHBzIiwiY2FtbF9qc19odG1sX2VzY2FwZSIsImNhbWxfanNfaW5zdGFuY2VvZiIsImNhbWxfanNfbWV0aF9jYWxsIiwiY2FtbF9qc19uZXciLCJGIiwiY2FtbF9qc19vYmplY3QiLCJjYW1sX2pzX29uX2llIiwidWEiLCJjYW1sX2pzX3B1cmVfZXhwciIsImNhbWxfanNfc2V0IiwiY2FtbF9qc19zdHJpY3RfZXF1YWxzIiwiY2FtbF9qc190b19hcnJheSIsImNhbWxfanNfdG9fYm9vbCIsImNhbWxfanNfdG9fYnl0ZV9zdHJpbmciLCJjYW1sX2pzX3RvX2Zsb2F0IiwiY2FtbF9qc190b19pbnQzMiIsImNhbWxfanNfdG9fc3RyaW5nIiwiY2FtbF9qc190eXBlb2YiLCJjYW1sX2pzX3ZhciIsImNhbWxfanNfd3JhcF9jYWxsYmFjayIsIkZ1bmN0aW9uIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QiLCJhcml0eSIsImNhbWxfanNfd3JhcF9jYWxsYmFja191bnNhZmUiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSIsImNhbWxfanNvb19mbGFnc19lZmZlY3RzIiwiY2FtbF9qc29vX2ZsYWdzX3VzZV9qc19zdHJpbmciLCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkIiwiY2FtbF9vYmpfdGFnIiwiY2FtbF9sYXp5X3JlYWRfcmVzdWx0IiwiY2FtbF9vYmpfdXBkYXRlX3RhZyIsImNhbWxfbGF6eV9yZXNldF90b19sYXp5IiwiY2FtbF9sYXp5X3VwZGF0ZV90b19mb3JjaW5nIiwiY2FtbF9sYXp5X3VwZGF0ZV90b19mb3J3YXJkIiwiY2FtbF9sZGV4cF9mbG9hdCIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9sZXNzdGhhbiIsImNhbWxfbGV4X2FycmF5IiwiY2FtbF9sZXhfZW5naW5lIiwidGJsIiwic3RhcnRfc3RhdGUiLCJsZXhidWYiLCJsZXhfYnVmZmVyIiwibGV4X2J1ZmZlcl9sZW4iLCJsZXhfc3RhcnRfcG9zIiwibGV4X2N1cnJfcG9zIiwibGV4X2xhc3RfcG9zIiwibGV4X2xhc3RfYWN0aW9uIiwibGV4X2VvZl9yZWFjaGVkIiwibGV4X2Jhc2UiLCJsZXhfYmFja3RyayIsImxleF9kZWZhdWx0IiwibGV4X3RyYW5zIiwibGV4X2NoZWNrIiwiYmFja3RyayIsImNhbWxfbGlzdF9tb3VudF9wb2ludCIsInByZXYiLCJjYW1sX2xpc3Rfb2ZfanNfYXJyYXkiLCJjYW1sX2xpc3RfdG9fanNfYXJyYXkiLCJjYW1sX2xvZzEwX2Zsb2F0IiwiY2FtbF9sb2cxcF9mbG9hdCIsImNhbWxfbG9nMl9mbG9hdCIsImNhbWxfbmV3X3N0cmluZyIsImNhbWxfbHhtX25leHQiLCJzaGlmdF9sIiwic2hpZnRfciIsIm9yIiwieG9yIiwicm90bCIsInNldCIsIk0iLCJkYWJhIiwicTAiLCJxMSIsInN0IiwieDAiLCJ4MSIsImNhbWxfbWFrZV9mbG9hdF92ZWN0IiwiY2FtbF9tYWtlX3ZlY3QiLCJpbml0IiwiY2FtbF9tYXJzaGFsX2NvbnN0YW50cyIsImNhbWxfbWF5YmVfcHJpbnRfc3RhdHMiLCJjYW1sX21kNV9ieXRlcyIsImNhbWxfbWxfaW5wdXRfYmxvY2siLCJhdmFpbCIsImNhbWxfbWQ1X2NoYW4iLCJ0b3JlYWQiLCJjYW1sX21kNV9zdHJpbmciLCJjYW1sX21lbXByb2ZfZGlzY2FyZCIsImNhbWxfbWVtcHJvZl9zZXQiLCJjYW1sX21lbXByb2Zfc3RhcnQiLCJyYXRlIiwic3RhY2tfc2l6ZSIsInRyYWNrZXIiLCJjYW1sX21lbXByb2Zfc3RvcCIsImNhbWxfbWxfY2hhbm5lbF9yZWRpcmVjdCIsImNhcHR1cmVkIiwiaW50byIsInRvX3Jlc3RvcmUiLCJuZXdfIiwiY2FtbF9tbF9jaGFubmVsX3Jlc3RvcmUiLCJjYW1sX21sX2NoYW5uZWxfc2l6ZSIsImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0IiwiY2FtbF9zeXNfZmRzIiwiY2FtbF9zeXNfY2xvc2UiLCJjYW1sX21sX2ZsdXNoIiwiY2FtbF9tbF9jbG9zZV9jaGFubmVsIiwiY2FtbF9tbF9jb25kaXRpb25fYnJvYWRjYXN0IiwiY2FtbF9tbF9jb25kaXRpb25fbmV3IiwiY2FtbF9tbF9jb25kaXRpb25fc2lnbmFsIiwiY2FtbF9tbF9jb25kaXRpb25fd2FpdCIsIm11dGV4dCIsImNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMiLCJjYW1sX21sX2RvbWFpbl9jcHVfcmVsYXgiLCJjYW1sX21sX2RvbWFpbl9pZCIsImNhbWxfbWxfZG9tYWluX3NldF9uYW1lIiwiX25hbWUiLCJjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW5fIiwiY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuIiwiY2FtbF9ydW50aW1lX3dhcm5pbmdzIiwiY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyIsImJvb2wiLCJjYW1sX21sX2lucHV0IiwiY2FtbF9tbF9pbnB1dF9iaWdhcnJheSIsImNhbWxfbWxfaW5wdXRfY2hhciIsImNhbWxfbWxfaW5wdXRfaW50IiwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUiLCJwcmV2X21heCIsImNhbWxfbWxfaXNfYnVmZmVyZWQiLCJjYW1sX21sX211dGV4X2xvY2siLCJjYW1sX21sX211dGV4X25ldyIsImNhbWxfbWxfbXV0ZXhfdHJ5X2xvY2siLCJjYW1sX3N5c19vcGVuX2Zvcl9ub2RlIiwiZmQyIiwiY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCIsImNhbWxfc3lzX29wZW4iLCJfcGVybXMiLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiIsInJlZmlsbCIsImNoYW5uZWwiLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQiLCJidWZmZXJlZCIsImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QiLCJjYW1sX21sX291dHB1dF90YSIsImNhbWxfbWxfb3V0cHV0X2J5dGVzIiwiY2FtbF9tbF9vdXRwdXQiLCJjYW1sX21sX291dHB1dF9iaWdhcnJheSIsImNhbWxfbWxfb3V0cHV0X2NoYXIiLCJjYW1sX21sX291dHB1dF9pbnQiLCJjYW1sX3Bvc19pbiIsImNhbWxfbWxfcG9zX2luIiwiY2FtbF9tbF9wb3NfaW5fNjQiLCJjYW1sX3Bvc19vdXQiLCJjYW1sX21sX3Bvc19vdXQiLCJjYW1sX21sX3Bvc19vdXRfNjQiLCJjYW1sX21sX3J1bnRpbWVfZXZlbnRzX3BhdXNlIiwiY2FtbF9tbF9ydW50aW1lX2V2ZW50c19yZXN1bWUiLCJjYW1sX21sX3J1bnRpbWVfZXZlbnRzX3N0YXJ0IiwiY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQiLCJjYW1sX3NlZWtfaW4iLCJjYW1sX21sX3NlZWtfaW4iLCJjYW1sX21sX3NlZWtfaW5fNjQiLCJjYW1sX3NlZWtfb3V0IiwiY2FtbF9tbF9zZWVrX291dCIsImNhbWxfbWxfc2Vla19vdXRfNjQiLCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZSIsImNhbWxfbWxfc2V0X2J1ZmZlcmVkIiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lIiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXQiLCJjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbCIsImNhbWxfbW9kIiwiY2FtbF9tb2RmX2Zsb2F0IiwiY2FtbF9tb3VudF9hdXRvbG9hZCIsImNhbWxfbGV4X3J1bl9tZW0iLCJtZW0iLCJjdXJyX3BvcyIsImNhbWxfbGV4X3J1bl90YWciLCJjYW1sX25ld19sZXhfZW5naW5lIiwibGV4X21lbSIsImxleF9iYXNlX2NvZGUiLCJsZXhfYmFja3Rya19jb2RlIiwibGV4X2RlZmF1bHRfY29kZSIsImxleF90cmFuc19jb2RlIiwibGV4X2NoZWNrX2NvZGUiLCJsZXhfY29kZSIsInBjX29mZiIsInBzdGF0ZSIsImJhc2VfY29kZSIsImNhbWxfbmV4dGFmdGVyX2Zsb2F0IiwiYml0cyIsIm9uZSIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX29ial9hZGRfb2Zmc2V0IiwiY2FtbF9vYmpfYmxvY2siLCJjYW1sX29ial9jb21wYXJlX2FuZF9zd2FwIiwiY2FtbF9vYmpfaXNfYmxvY2siLCJjYW1sX29ial9pc19zaGFyZWQiLCJjYW1sX29ial9tYWtlX2ZvcndhcmQiLCJjYW1sX29ial9yYXdfZmllbGQiLCJjYW1sX29ial9yZWFjaGFibGVfd29yZHMiLCJjYW1sX29ial9zZXRfcmF3X2ZpZWxkIiwiY2FtbF9vYmpfc2V0X3RhZyIsImNhbWxfb2JqX3RydW5jYXRlIiwiY2FtbF9vYmpfd2l0aF90YWciLCJjYW1sX29qc19pdGVyYXRlX3Byb3BlcnRpZXMiLCJjYW1sX29qc19uZXdfYXJyIiwiY2FtbF9vanNfd3JhcF9mdW5fYXJndW1lbnRzIiwiY2FtbF9vdXRwdXRfdmFsIiwiV3JpdGVyIiwidmFsdWUiLCJub19zaGFyaW5nIiwiY2xvc3VyZXMiLCJtZW1vIiwiZXhpc3Rpbmdfb2Zmc2V0IiwiZXh0ZXJuX3JlYyIsInN6XzMyXzY0IiwiaGVhZGVyX3BvcyIsInR5cGVfb2ZfdiIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyIsImNhbWxfb3V0cHV0X3ZhbHVlIiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMiLCJjYW1sX3BhcnNlcl90cmFjZSIsImNhbWxfcGFyc2VfZW5naW5lIiwidGFibGVzIiwiZW52IiwiY21kIiwiRVJSQ09ERSIsImxvb3AiLCJ0ZXN0c2hpZnQiLCJzaGlmdCIsInNoaWZ0X3JlY292ZXIiLCJyZWR1Y2UiLCJSRUFEX1RPS0VOIiwiUkFJU0VfUEFSU0VfRVJST1IiLCJHUk9XX1NUQUNLU18xIiwiR1JPV19TVEFDS1NfMiIsIkNPTVBVVEVfU0VNQU5USUNfQUNUSU9OIiwiQ0FMTF9FUlJPUl9GVU5DVElPTiIsImVudl9zX3N0YWNrIiwiZW52X3Zfc3RhY2siLCJlbnZfc3ltYl9zdGFydF9zdGFjayIsImVudl9zeW1iX2VuZF9zdGFjayIsImVudl9zdGFja3NpemUiLCJlbnZfc3RhY2tiYXNlIiwiZW52X2N1cnJfY2hhciIsImVudl9sdmFsIiwiZW52X3N5bWJfc3RhcnQiLCJlbnZfc3ltYl9lbmQiLCJlbnZfYXNwIiwiZW52X3J1bGVfbGVuIiwiZW52X3J1bGVfbnVtYmVyIiwiZW52X3NwIiwiZW52X3N0YXRlIiwiZW52X2VycmZsYWciLCJ0YmxfdHJhbnNsX2NvbnN0IiwidGJsX3RyYW5zbF9ibG9jayIsInRibF9saHMiLCJ0YmxfbGVuIiwidGJsX2RlZnJlZCIsInRibF9kZ290byIsInRibF9zaW5kZXgiLCJ0YmxfcmluZGV4IiwidGJsX2dpbmRleCIsInRibF90YWJsZXNpemUiLCJ0YmxfdGFibGUiLCJ0YmxfY2hlY2siLCJ0YmxfbmFtZXNfY29uc3QiLCJ0YmxfbmFtZXNfYmxvY2siLCJsb2ciLCJ0b2tlbl9uYW1lIiwibmFtZXMiLCJwcmludF90b2tlbiIsInRvayIsInRva2VuIiwibjEiLCJuMiIsInN0YXRlMSIsInNwIiwiZXJyZmxhZyIsImFzcCIsImNhbWxfcHVyZV9qc19leHByIiwiY2FtbF9yYWlzZV9ub3RfYV9kaXIiLCJjYW1sX3JhaXNlX25vdF9mb3VuZCIsImNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgiLCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IiwiY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3QiLCJjYW1sX3JlYWRfZmlsZV9jb250ZW50IiwiY2FtbF9yZWNvbW1lbmRlZF9kb21haW5fY291bnQiLCJjYW1sX3JlY29yZF9iYWNrdHJhY2UiLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9yZWdpc3Rlcl9nbG9iYWwiLCJuYW1lX29wdCIsIm5pZCIsImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUiLCJjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZSIsImNhbWxfcm91bmRfZmxvYXQiLCJjYW1sX3J1bnRpbWVfZXZlbnRzX2NyZWF0ZV9jdXJzb3IiLCJjYW1sX3J1bnRpbWVfZXZlbnRzX2ZyZWVfY3Vyc29yIiwiY3Vyc29yIiwiY2FtbF9ydW50aW1lX2V2ZW50c19yZWFkX3BvbGwiLCJjYWxsYmFja3MiLCJjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVnaXN0ZXIiLCJldmVudF9uYW1lIiwiZXZlbnRfdGFnIiwiZXZlbnRfdHlwZSIsImNhbWxfcnVudGltZV9ldmVudHNfdXNlcl9yZXNvbHZlIiwiY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3dyaXRlIiwiZXZlbnQiLCJldmVudF9jb250ZW50IiwiY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMiLCJjYW1sX3J1bnRpbWVfdmFyaWFudCIsImNhbWxfc2V0X29vX2lkIiwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlIiwib2xkZmxhZyIsImNhbWxfc2V0X3N0YXRpY19lbnYiLCJjYW1sX3NpZ25iaXRfZmxvYXQiLCJjYW1sX3NpbmhfZmxvYXQiLCJjYW1sX3NwYWNldGltZV9lbmFibGVkIiwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUiLCJjYW1sX3N0cl9pbml0aWFsaXplIiwiY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IiLCJjYW1sX3N0cmluZ19jb25jYXQiLCJjYW1sX3N0cmluZ19lcXVhbCIsImNhbWxfc3RyaW5nX2dldCIsImNhbWxfc3RyaW5nX2dldDE2IiwiY2FtbF9zdHJpbmdfZ2V0MzIiLCJjYW1sX3N0cmluZ19nZXQ2NCIsImNhbWxfc3RyaW5nX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbCIsImNhbWxfc3RyaW5nX2xlc3N0aGFuIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4iLCJjYW1sX3N0cmluZ19oYXNoIiwiY2FtbF9zdHJpbmdfbm90ZXF1YWwiLCJjYW1sX3N0cmluZ19zZXQiLCJjYW1sX3N0cmluZ19zZXQxNiIsImNhbWxfc3RyaW5nX3NldDMyIiwiY2FtbF9zdHJpbmdfc2V0NjQiLCJjYW1sX3N0cmluZ191bnNhZmVfc2V0IiwiY2FtbF9zeXNfYXJndiIsImNhbWxfc3lzX2NoZGlyIiwiZGlyIiwiY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIiwiY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiIsImNhbWxfc3lzX2NvbnN0X2ludF9zaXplIiwiY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSIsImNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQiLCJvc190eXBlIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIiwiY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIiwiY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9zeXNfZXhpdCIsImNhbWxfc3lzX2ZpbGVfZXhpc3RzIiwiY2FtbF9zeXNfZ2V0X2FyZ3YiLCJjYW1sX3N5c19nZXRfY29uZmlnIiwiY2FtbF9zeXNfZ2V0Y3dkIiwiY2FtbF9zeXNfZ2V0ZW52IiwiY2FtbF9zeXNfaXNfZGlyZWN0b3J5IiwiY2FtbF9zeXNfaXNfcmVndWxhcl9maWxlIiwiY2FtbF9zeXNfaXNhdHR5IiwiX2NoYW4iLCJjYW1sX3N5c19ta2RpciIsInBlcm0iLCJjYW1sX3N5c19tb2RpZnlfYXJndiIsImNhbWxfc3lzX3JhbmRvbV9zZWVkIiwibm93IiwiRGF0ZSIsImNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zeXNfcmVuYW1lIiwib19yb290Iiwibl9yb290IiwiY2FtbF9zeXNfcm1kaXIiLCJjYW1sX3N5c19zeXN0ZW1fY29tbWFuZCIsImNoaWxkX3Byb2Nlc3MiLCJjYW1sX2luaXRpYWxfdGltZSIsImNhbWxfc3lzX3RpbWUiLCJjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4iLCJjYW1sX3N5c191bnNhZmVfZ2V0ZW52IiwiY2FtbF90YW5oX2Zsb2F0IiwiY2FtbF90b19qc19zdHJpbmciLCJjYW1sX3RyYW1wb2xpbmUiLCJjYW1sX3RyYW1wb2xpbmVfcmV0dXJuIiwiY2FtbF90cnVuY19mbG9hdCIsImNhbWxfdW5peF9jbGVhbnVwIiwiY2FtbF91bml4X2Nsb3NlZGlyIiwiZGlyX2hhbmRsZSIsImNhbWxfdW5peF9maWxlZGVzY3Jfb2ZfZmQiLCJjYW1sX3VuaXhfZmluZGNsb3NlIiwiY2FtbF91bml4X29wZW5kaXIiLCJjYW1sX3VuaXhfcmVhZGRpciIsImNhbWxfdW5peF9maW5kZmlyc3QiLCJwYXRoX2pzIiwiZmlyc3RfZW50cnkiLCJjYW1sX3VuaXhfZmluZG5leHQiLCJjYW1sX3VuaXhfZ2V0cHd1aWQiLCJjYW1sX3VuaXhfZ2V0dGltZW9mZGF5IiwiY2FtbF91bml4X2dldHVpZCIsImNhbWxfdW5peF9nbXRpbWUiLCJkX251bSIsImphbnVhcnlmaXJzdCIsImRveSIsImNhbWxfdW5peF9oYXNfc3ltbGluayIsImNhbWxfdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nIiwiY2FtbF91bml4X2lzYXR0eSIsImZpbGVEZXNjcmlwdG9yIiwidHR5IiwiY2FtbF91bml4X2xvY2FsdGltZSIsImphbiIsImp1bCIsInN0ZFRpbWV6b25lT2Zmc2V0IiwiY2FtbF91bml4X2xzdGF0IiwiY2FtbF91bml4X2xzdGF0XzY0IiwiY2FtbF91bml4X21rZGlyIiwiY2FtbF91bml4X21rdGltZSIsInRtIiwidG0yIiwiY2FtbF91bml4X3JlYWRsaW5rIiwiY2FtbF91bml4X3Jld2luZGRpciIsIm5ld19kaXJfaGFuZGxlIiwiY2FtbF91bml4X3JtZGlyIiwiY2FtbF91bml4X3N0YXJ0dXAiLCJjYW1sX3VuaXhfc3RhdCIsImNhbWxfdW5peF9zdGF0XzY0IiwiY2FtbF91bml4X3N5bWxpbmsiLCJzcmNfcm9vdCIsImRzdF9yb290IiwiY2FtbF91bml4X3RpbWUiLCJjYW1sX3VuaXhfdW5saW5rIiwiY2FtbF91bm1vdW50IiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlIiwiY29tcGFyZV9kaWdpdHNfbmF0IiwiY29tcGFyZV9uYXQiLCJjb21wYXJlX25hdF9yZWFsIiwiY29tcGxlbWVudF9uYXQiLCJjcmVhdGVfbmF0IiwiZGVjcl9uYXQiLCJib3Jyb3ciLCJkZXNlcmlhbGl6ZV9uYXQiLCJkaXZfaGVscGVyIiwiZGl2X2RpZ2l0X25hdCIsIm5hdHEiLCJvZnNxIiwibmF0ciIsIm9mc3IiLCJyZW0iLCJudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQiLCJzaGlmdF9sZWZ0X25hdCIsIm5iaXRzIiwid3JhcCIsInNoaWZ0X3JpZ2h0X25hdCIsInNldF90b196ZXJvX25hdCIsIm5hdF9vZl9hcnJheSIsIm11bHRfZGlnaXRfbmF0IiwibmF0MyIsIm9mczMiLCJ4MiIsIngzIiwic3ViX25hdCIsImRpdl9uYXQiLCJxdW8iLCJzZXJpYWxpemVfbmF0IiwiaW5pdGlhbGl6ZV9uYXQiLCJpc19kaWdpdF9pbnQiLCJpc19kaWdpdF9vZGQiLCJpc19kaWdpdF96ZXJvIiwianNvb19jcmVhdGVfZmlsZV9leHRlcm4iLCJqc29vX2VmZmVjdF9ub3Rfc3VwcG9ydGVkIiwibGFuZF9kaWdpdF9uYXQiLCJsZW5ndGhfbmF0IiwibG9yX2RpZ2l0X25hdCIsImx4b3JfZGlnaXRfbmF0IiwibXVsdF9uYXQiLCJsZW4zIiwibnRoX2RpZ2l0X25hdCIsIm50aF9kaWdpdF9uYXRfbmF0aXZlIiwicmVfbWF0Y2giLCJyZV93b3JkX2xldHRlcnMiLCJvcGNvZGVzIiwiaXNfd29yZF9sZXR0ZXIiLCJpbl9iaXRzZXQiLCJyZV9tYXRjaF9pbXBsIiwicGFydGlhbCIsInByb2ciLCJjcG9vbCIsIm5vcm10YWJsZSIsIm51bWdyb3VwcyIsIm51bXJlZ2lzdGVycyIsInN0YXJ0Y2hhcnMiLCJwYyIsInF1aXQiLCJncm91cHMiLCJyZV9yZWdpc3RlciIsImJhY2t0cmFjayIsIml0ZW0iLCJwdXNoIiwiYWNjZXB0IiwicHJlZml4X21hdGNoIiwib3AiLCJzYXJnIiwidWFyZyIsImdyb3VwIiwiRXJyb3IiLCJyZV9wYXJ0aWFsX21hdGNoIiwicmVfcmVwbGFjZW1lbnRfdGV4dCIsInJlcGwiLCJvcmlnIiwiY3VyIiwiZW5kIiwicmVfc2VhcmNoX2JhY2t3YXJkIiwicmVfc2VhcmNoX2ZvcndhcmQiLCJyZV9zdHJpbmdfbWF0Y2giLCJzZXRfZGlnaXRfbmF0IiwiZGlnaXQiLCJzZXRfZGlnaXRfbmF0X25hdGl2ZSIsInNxdWFyZV9uYXQiLCJjYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwib3JpZ2luIiwiZXJhc2VfcmVsIiwicmVzdCIsInJlc3QkMCIsInJlc3QkMSIsInJlc3QkMiIsInJlc3QkMyIsInJlc3QkNCIsInJlc3QkNSIsInJlc3QkNiIsInJlc3QkNyIsInR5IiwicmVzdCQ4IiwidHkxIiwicmVzdCQ5IiwicmVzdCQxMCIsInJlc3QkMTEiLCJyZXN0JDEyIiwicmVzdCQxMyIsImNvbmNhdF9mbXR0eSIsImZtdHR5MSIsImZtdHR5MiIsInR5MiIsImNvbmNhdF9mbXQiLCJmbXQxIiwiZm10MiIsInBhZCIsInBhZCQwIiwicHJlYyIsInBhZCQxIiwiaWNvbnYiLCJwcmVjJDAiLCJwYWQkMiIsImljb252JDAiLCJwcmVjJDEiLCJwYWQkMyIsImljb252JDEiLCJwcmVjJDIiLCJwYWQkNCIsImljb252JDIiLCJwcmVjJDMiLCJwYWQkNSIsImZjb252IiwicGFkJDYiLCJzdHIiLCJjaHIiLCJmbXR0eSIsInBhZCQ3IiwiZm10dHkkMCIsInBhZCQ4IiwicmVzdCQxNCIsInJlc3QkMTUiLCJyZXN0JDE2IiwiZm10aW5nX2xpdCIsInJlc3QkMTciLCJmbXRpbmdfZ2VuIiwicmVzdCQxOCIsInJlc3QkMTkiLCJjaGFyX3NldCIsIndpZHRoX29wdCIsInJlc3QkMjAiLCJjb3VudGVyIiwicmVzdCQyMSIsInJlc3QkMjIiLCJpZ24iLCJyZXN0JDIzIiwiZiIsImFyaXR5IiwibWFrZSIsInYiLCJnZXQiLCJyIiwic2V0IiwiZXhjaGFuZ2UiLCJjdXIiLCJjb21wYXJlX2FuZF9zZXQiLCJzZWVuIiwiZmV0Y2hfYW5kX2FkZCIsIm4iLCJpbmNyIiwiZGVjciIsImZhaWx3aXRoIiwicyIsImludmFsaWRfYXJnIiwibWluIiwieCIsInkiLCJtYXgiLCJhYnMiLCJsbm90IiwiaW5maW5pdHkiLCJuZWdfaW5maW5pdHkiLCJuYW4iLCJtYXhfZmxvYXQiLCJtaW5fZmxvYXQiLCJlcHNpbG9uX2Zsb2F0Iiwic3ltYm9sX2NvbmNhdCIsImNoYXJfb2ZfaW50Iiwic3RyaW5nX29mX2Jvb2wiLCJiIiwiYm9vbF9vZl9zdHJpbmciLCJib29sX29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJ2YWxpZF9mbG9hdF9sZXhlbSIsInMxIiwibCIsImkiLCJpJDAiLCJzdHJpbmdfb2ZfZmxvYXQiLCJmbG9hdF9vZl9zdHJpbmdfb3B0Iiwic3ltYm9sIiwibDEiLCJsMiIsInRsIiwiaGQiLCJzdGRpbiIsInN0ZG91dCIsInN0ZGVyciIsIm9wZW5fb3V0X2dlbiIsIm1vZGUiLCJwZXJtIiwibmFtZSIsImMiLCJvcGVuX291dCIsIm9wZW5fb3V0X2JpbiIsImZsdXNoX2FsbCIsImEiLCJvdXRwdXRfYnl0ZXMiLCJvYyIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXQiLCJvZnMiLCJsZW4iLCJvdXRwdXRfc3Vic3RyaW5nIiwib3V0cHV0X3ZhbHVlIiwiY2hhbiIsImNsb3NlX291dCIsImNsb3NlX291dF9ub2VyciIsIm9wZW5faW5fZ2VuIiwib3Blbl9pbiIsIm9wZW5faW5fYmluIiwiaW5wdXQiLCJpYyIsInVuc2FmZV9yZWFsbHlfaW5wdXQiLCJvZnMkMCIsImxlbiQwIiwibGVuJDEiLCJvZnMkMSIsInJlYWxseV9pbnB1dCIsInJlYWxseV9pbnB1dF9zdHJpbmciLCJpbnB1dF9saW5lIiwiYnVpbGRfcmVzdWx0IiwiYnVmIiwicG9zJDAiLCJhY2N1IiwiYmVnIiwiYWNjdSQwIiwicmVzIiwiY2xvc2VfaW5fbm9lcnIiLCJwcmludF9jaGFyIiwicHJpbnRfc3RyaW5nIiwicHJpbnRfYnl0ZXMiLCJwcmludF9pbnQiLCJwcmludF9mbG9hdCIsInByaW50X2VuZGxpbmUiLCJwcmludF9uZXdsaW5lIiwicHJlcnJfY2hhciIsInByZXJyX3N0cmluZyIsInByZXJyX2J5dGVzIiwicHJlcnJfaW50IiwicHJlcnJfZmxvYXQiLCJwcmVycl9lbmRsaW5lIiwicHJlcnJfbmV3bGluZSIsInJlYWRfbGluZSIsInJlYWRfaW50IiwicmVhZF9pbnRfb3B0IiwicmVhZF9mbG9hdCIsInJlYWRfZmxvYXRfb3B0Iiwic3RyaW5nX29mX2Zvcm1hdCIsInN5bWJvbCQwIiwic3RyMiIsInN0cjEiLCJzMiIsImV4aXRfZnVuY3Rpb24iLCJhdF9leGl0IiwiZl95ZXRfdG9fcnVuIiwib2xkX2V4aXQiLCJmX3lldF90b19ydW4kMCIsIm9sZF9leGl0JDAiLCJuZXdfZXhpdCIsInN1Y2Nlc3MiLCJkb19hdF9leGl0IiwiZXhpdCIsInJldGNvZGUiLCJtYXhfaW50IiwibWluX2ludCIsImZsdXNoIiwib3V0cHV0X2NoYXIiLCJvdXRwdXRfYnl0ZSIsIm91dHB1dF9iaW5hcnlfaW50Iiwic2Vla19vdXQiLCJwb3Nfb3V0Iiwib3V0X2NoYW5uZWxfbGVuZ3RoIiwic2V0X2JpbmFyeV9tb2RlX291dCIsImlucHV0X2NoYXIiLCJpbnB1dF9ieXRlIiwiaW5wdXRfYmluYXJ5X2ludCIsImlucHV0X3ZhbHVlIiwic2Vla19pbiIsInBvc19pbiIsImluX2NoYW5uZWxfbGVuZ3RoIiwiY2xvc2VfaW4iLCJzZXRfYmluYXJ5X21vZGVfaW4iLCJsZWZ0IiwicmlnaHQiLCJpc19sZWZ0IiwiaXNfcmlnaHQiLCJmaW5kX2xlZnQiLCJmaW5kX3JpZ2h0IiwibWFwX2xlZnQiLCJlIiwibWFwX3JpZ2h0IiwibWFwIiwidiQwIiwiZm9sZCIsImVxdWFsIiwiZTEiLCJlMiIsInYxIiwidjIiLCJ2MSQwIiwidjIkMCIsImNvbXBhcmUiLCJpc19ibG9jayIsImRvdWJsZV9maWVsZCIsInNldF9kb3VibGVfZmllbGQiLCJjdXN0b21fdGFnIiwiaW5mbyIsIm9iaiIsInN0YXJ0X2VudiIsIm9mX3ZhbCIsInNsb3QiLCJpZCIsImV4dGVuc2lvbl9jb25zdHJ1Y3RvciIsImV4dGVuc2lvbl9uYW1lIiwiZXh0ZW5zaW9uX2lkIiwibWF4X2VwaGVfbGVuZ3RoIiwiY3JlYXRlIiwibGVuZ3RoIiwicmFpc2VfaWZfaW52YWxpZF9vZmZzZXQiLCJvIiwibXNnIiwiZ2V0X2tleSIsImdldF9rZXlfY29weSIsInNldF9rZXkiLCJ1bnNldF9rZXkiLCJjaGVja19rZXkiLCJibGl0X2tleSIsIm8xIiwibzIiLCJyYWlzZV91bmRlZmluZWQiLCJmb3JjZV9sYXp5X2Jsb2NrIiwiYmxrIiwiY2xvc3VyZSIsInJlc3VsdCIsImUkMCIsImZvcmNlX3ZhbF9sYXp5X2Jsb2NrIiwiZm9yY2UiLCJsenYiLCJ0IiwiZm9yY2VfdmFsIiwiZnJvbV9mdW4iLCJmcm9tX3ZhbCIsImlzX3ZhbCIsIm1hcF92YWwiLCJlbXB0eSIsInJldHVybiQwIiwiY29ucyIsIm5leHQiLCJhcHBlbmQiLCJzZXExIiwic2VxMiIsInNlcSIsImZpbHRlcl9tYXAiLCJzZXEkMCIsImZpbHRlciIsImNvbmNhdCIsImZsYXRfbWFwIiwiZm9sZF9sZWZ0IiwiYWNjIiwiYWNjJDAiLCJhY2MkMSIsIml0ZXIiLCJ1bmZvbGQiLCJ1IiwidSQwIiwiaXNfZW1wdHkiLCJ4cyIsInVuY29ucyIsInhzJDAiLCJ4cyQxIiwiaXRlcmkiLCJmb2xkX2xlZnRpIiwiYWNjdSQxIiwiZm9yX2FsbCIsInAiLCJleGlzdHMiLCJmaW5kIiwiZmluZF9tYXAiLCJpdGVyMiIsInlzIiwieXMkMCIsInlzJDEiLCJmb2xkX2xlZnQyIiwiZm9yX2FsbDIiLCJleGlzdHMyIiwiZXEiLCJjbXAiLCJpbml0X2F1eCIsImoiLCJpbml0IiwicmVwZWF0IiwiZm9yZXZlciIsImN5Y2xlX25vbmVtcHR5IiwiY3ljbGUiLCJpdGVyYXRlMSIsIml0ZXJhdGUiLCJtYXBpX2F1eCIsIm1hcGkiLCJ0YWlsX3NjYW4iLCJzJDAiLCJzY2FuIiwidGFrZV9hdXgiLCJ0YWtlIiwiZHJvcCIsIm4kMCIsIm4kMSIsInRha2Vfd2hpbGUiLCJkcm9wX3doaWxlIiwibm9kZSIsImdyb3VwIiwidG9fbGF6eSIsImZhaWx1cmUiLCJtZW1vaXplIiwib25jZSIsImFjdGlvbiIsInppcCIsIm1hcDIiLCJpbnRlcmxlYXZlIiwic29ydGVkX21lcmdlMSIsInNvcnRlZF9tZXJnZSIsIm1hcF9mc3QiLCJ4eXMiLCJ4eXMkMCIsIm1hcF9zbmQiLCJ1bnppcCIsImZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCIsImZpbHRlcl9tYXBfZmluZF9yaWdodF9tYXAiLCJ6IiwicGFydGl0aW9uX21hcCIsInBhcnRpdGlvbiIsInBlZWwiLCJ4c3MiLCJ0cmFuc3Bvc2UiLCJ0YWlscyIsImhlYWRzIiwicmVtYWluZGVycyIsInhzcyQwIiwidGFpbHMkMCIsImhlYWRzJDAiLCJtYXBfcHJvZHVjdCIsInByb2R1Y3QiLCJvZl9kaXNwZW5zZXIiLCJpdCIsInRvX2Rpc3BlbnNlciIsImludHMiLCJzb21lIiwidmFsdWUiLCJkZWZhdWx0JDAiLCJiaW5kIiwiam9pbiIsIm5vbmUiLCJpc19ub25lIiwiaXNfc29tZSIsIm8wIiwidjAiLCJ0b19yZXN1bHQiLCJ0b19saXN0IiwidG9fc2VxIiwib2siLCJlcnJvciIsImdldF9vayIsImdldF9lcnJvciIsIm1hcF9lcnJvciIsIml0ZXJfZXJyb3IiLCJpc19vayIsImlzX2Vycm9yIiwicjAiLCJyMSIsImUwIiwidG9fb3B0aW9uIiwidG9fZmxvYXQiLCJ0b19zdHJpbmciLCJlc2NhcGVkIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibG93ZXJjYXNlX2FzY2lpIiwidXBwZXJjYXNlX2FzY2lpIiwiYzEiLCJjMiIsImVycl9ub19wcmVkIiwiZXJyX25vX3N1Y2MiLCJsb19ib3VuZCIsImhpX2JvdW5kIiwic3VjYyIsInByZWQiLCJpc192YWxpZCIsIm9mX2ludCIsImlzX2NoYXIiLCJvZl9jaGFyIiwidG9fY2hhciIsInVuc2FmZV90b19jaGFyIiwiaGFzaCIsInV0Zl9kZWNvZGVfaXNfdmFsaWQiLCJkIiwidXRmX2RlY29kZV9sZW5ndGgiLCJ1dGZfZGVjb2RlX3VjaGFyIiwidXRmX2RlY29kZSIsInV0Zl9kZWNvZGVfaW52YWxpZCIsInV0Zl84X2J5dGVfbGVuZ3RoIiwidXRmXzE2X2J5dGVfbGVuZ3RoIiwibCQwIiwibnRoIiwibCQxIiwibnRoX29wdCIsInJldl9hcHBlbmQiLCJsMSQwIiwibDIkMCIsImwxJDEiLCJsMiQxIiwicmV2IiwicmV2X2luaXRfdGhyZXNob2xkIiwiZmxhdHRlbiIsInJldl9tYXAiLCJmb2xkX3JpZ2h0IiwiYTIiLCJhMSIsInJldl9tYXAyIiwiZm9sZF9yaWdodDIiLCJtZW0iLCJtZW1xIiwiYXNzb2MiLCJhc3NvY19vcHQiLCJhc3NxIiwiYXNzcV9vcHQiLCJtZW1fYXNzb2MiLCJtZW1fYXNzcSIsInJlbW92ZV9hc3NvYyIsInBhaXIiLCJyZW1vdmVfYXNzcSIsImZpbmRfb3B0IiwiZmluZF9hbGwiLCJmaWx0ZXJpIiwiY29uY2F0X21hcCIsImZvbGRfbGVmdF9tYXAiLCJsX2FjY3UiLCJ4JDAiLCJ5ZXMiLCJubyIsInNwbGl0IiwicnkiLCJyeCIsImNvbWJpbmUiLCJtZXJnZSIsInQyIiwiaDIiLCJ0MSIsImgxIiwic3RhYmxlX3NvcnQiLCJzb3J0IiwieDIiLCJ4MSIsInRsJDEiLCJ4MyIsIngyJDAiLCJ4MSQwIiwibjEiLCJuMiIsInJldl9zb3J0IiwidGwkMCIsInNvcnRfdW5pcSIsImMkMCIsImMkMSIsImMkMiIsImMkMyIsImMkNCIsImMkNSIsImMkNiIsImFjY3UkMiIsImNvbXBhcmVfbGVuZ3RocyIsImNvbXBhcmVfbGVuZ3RoX3dpdGgiLCJhdXgiLCJ0YWlsIiwib2Zfc2VxIiwiZGlyZWN0IiwiZGVwdGgiLCJsb2dub3QiLCJjb3B5Iiwib2Zfc3RyaW5nIiwic3ViIiwic3ViX3N0cmluZyIsImV4dGVuZCIsImRzdG9mZiIsInNyY29mZiIsImNweWxlbiIsImZpbGwiLCJibGl0Iiwib2ZzMSIsIm9mczIiLCJibGl0X3N0cmluZyIsInNlcCIsInNlcGxlbiIsImRzdCIsInBvcyIsImhkJDAiLCJjYXQiLCJpc19zcGFjZSIsInRyaW0iLCJhcHBseTEiLCJjYXBpdGFsaXplX2FzY2lpIiwidW5jYXBpdGFsaXplX2FzY2lpIiwic3RhcnRzX3dpdGgiLCJwcmVmaXgiLCJsZW5fcyIsImxlbl9wcmUiLCJlbmRzX3dpdGgiLCJzdWZmaXgiLCJsZW5fc3VmIiwiZGlmZiIsImluZGV4X3JlYyIsImxpbSIsImkkMSIsImluZGV4IiwiaW5kZXhfcmVjX29wdCIsImluZGV4X29wdCIsImluZGV4X2Zyb20iLCJpbmRleF9mcm9tX29wdCIsInJpbmRleF9yZWMiLCJyaW5kZXgiLCJyaW5kZXhfZnJvbSIsInJpbmRleF9yZWNfb3B0IiwicmluZGV4X29wdCIsInJpbmRleF9mcm9tX29wdCIsImNvbnRhaW5zX2Zyb20iLCJjb250YWlucyIsInJjb250YWluc19mcm9tIiwic3BsaXRfb25fY2hhciIsImNhcGl0YWxpemUiLCJ1bmNhcGl0YWxpemUiLCJ0b19zZXFpIiwibmV3X2xlbiIsIm5ld19idWYiLCJ1bnNhZmVfZ2V0X3VpbnQxNl9sZSIsInVuc2FmZV9nZXRfdWludDE2X2JlIiwiZ2V0X2ludDgiLCJnZXRfdWludDE2X2xlIiwiZ2V0X3VpbnQxNl9iZSIsImdldF9pbnQxNl9uZSIsImdldF9pbnQxNl9sZSIsImdldF9pbnQxNl9iZSIsImdldF9pbnQzMl9sZSIsImdldF9pbnQzMl9iZSIsImdldF9pbnQ2NF9sZSIsImdldF9pbnQ2NF9iZSIsInVuc2FmZV9zZXRfdWludDE2X2xlIiwidW5zYWZlX3NldF91aW50MTZfYmUiLCJzZXRfaW50MTZfbGUiLCJzZXRfaW50MTZfYmUiLCJzZXRfaW50MzJfbGUiLCJzZXRfaW50MzJfYmUiLCJzZXRfaW50NjRfbGUiLCJzZXRfaW50NjRfYmUiLCJzZXRfdWludDgiLCJzZXRfdWludDE2X25lIiwiZGVjX2ludmFsaWQiLCJkZWNfcmV0Iiwibm90X2luX3g4MF90b194QkYiLCJub3RfaW5feEEwX3RvX3hCRiIsIm5vdF9pbl94ODBfdG9feDlGIiwibm90X2luX3g5MF90b194QkYiLCJub3RfaW5feDgwX3RvX3g4RiIsInV0Zl84X3VjaGFyXzMiLCJiMCIsImIxIiwiYjIiLCJ1dGZfOF91Y2hhcl80IiwiYjMiLCJnZXRfdXRmXzhfdWNoYXIiLCJiMSQ0IiwiYjIkMyIsImkkNCIsImIxJDIiLCJpJDUiLCJiMiQxIiwiaSQ2IiwiYjMkMSIsImkkMTAiLCJiMSQwIiwiaSQxMSIsImkkMTIiLCJpJDciLCJiMSQxIiwiaSQ4IiwiYjIkMCIsImkkOSIsImIzJDAiLCJpJDEzIiwiYjEkNSIsImkkMTQiLCJiMiQ0IiwiaSQyIiwiYjEkMyIsImkkMyIsImIyJDIiLCJpJDE1Iiwic2V0X3V0Zl84X3VjaGFyIiwibGFzdCQxIiwibGFzdCQwIiwibGFzdCIsImlzX3ZhbGlkX3V0Zl84IiwibGFzdCQzIiwibGFzdCQyIiwibGFzdCQ0IiwibGFzdCQ1IiwiZ2V0X3V0Zl8xNmJlX3VjaGFyIiwiaGkiLCJsbyIsInNldF91dGZfMTZiZV91Y2hhciIsInUkMSIsImlzX3ZhbGlkX3V0Zl8xNmJlIiwiZ2V0X3V0Zl8xNmxlX3VjaGFyIiwic2V0X3V0Zl8xNmxlX3VjaGFyIiwiaXNfdmFsaWRfdXRmXzE2bGUiLCJidHMiLCJib3MiLCJvZl9ieXRlcyIsInRvX2J5dGVzIiwiZyIsInRvX2J1ZmZlciIsImJ1ZmYiLCJmbGFncyIsImRhdGFfc2l6ZSIsInRvdGFsX3NpemUiLCJmcm9tX2J5dGVzIiwiZnJvbV9zdHJpbmciLCJtYWtlX2Zsb2F0IiwibWFrZV9tYXRyaXgiLCJzeCIsInN5IiwibGEiLCJsYiIsInJlcyQwIiwibGlzdF9sZW5ndGgiLCJvZl9saXN0IiwiaW5wdXRfYXJyYXkiLCJlbHQiLCJvdXRwdXRfYXJyYXkiLCJlbHQkMCIsImFjYyQyIiwiYTAiLCJiaSIsImFpIiwibmEiLCJuYiIsIm1heHNvbiIsImkzMSIsImUkMSIsImokMCIsImZhdGhlciIsInNyYzFvZnMiLCJzcmMxbGVuIiwic3JjMiIsInNyYzJvZnMiLCJzcmMybGVuIiwiZHN0b2ZzIiwic3JjMXIiLCJzcmMyciIsInMyJDEiLCJzMSQxIiwiaTEiLCJpMiIsImkyJDAiLCJkJDAiLCJzMiQwIiwiaTEkMCIsImQkMSIsInMxJDAiLCJpc29ydHRvIiwic3Jjb2ZzIiwic29ydHRvIiwiaXNfZmluaXRlIiwiaXNfaW5maW5pdGUiLCJpc19uYW4iLCJlcHNpbG9uIiwib2Zfc3RyaW5nX29wdCIsImlzX2ludGVnZXIiLCJtaW5fbWF4IiwibWluX251bSIsIm1heF9udW0iLCJtaW5fbWF4X251bSIsInVuc2FmZV9maWxsIiwiY2hlY2siLCJobGVuIiwic3JjIiwic29mcyIsImRvZnMiLCJoIiwibWVtX2llZWUiLCJtYXBfdG9fYXJyYXkiLCJtYXBfZnJvbV9hcnJheSIsInplcm8iLCJvbmUiLCJtaW51c19vbmUiLCJtYXhfaW50JDAiLCJ1bnNpZ25lZF90b19pbnQiLCJ1bnNpZ25lZF9jb21wYXJlIiwibSIsInVuc2lnbmVkX2RpdiIsInEiLCJ1bnNpZ25lZF9yZW0iLCJzaXplIiwiZHVtbXlfcG9zIiwiemVyb19wb3MiLCJlbmdpbmUiLCJ0YmwiLCJzdGF0ZSIsIm5ld19lbmdpbmUiLCJmcm9tX2Z1bmN0aW9uIiwib3B0IiwicmVhZF9mdW4iLCJzdGgiLCJ3aXRoX3Bvc2l0aW9ucyIsImF1eF9idWZmZXIiLCJsZXhidWYiLCJyZWFkIiwibmV3bGVuIiwibmV3YnVmIiwiZnJvbV9jaGFubmVsIiwic2V0X3Bvc2l0aW9uIiwicG9zaXRpb24iLCJzZXRfZmlsZW5hbWUiLCJmbmFtZSIsImxleGVtZSIsInN1Yl9sZXhlbWUiLCJzdWJfbGV4ZW1lX29wdCIsInN1Yl9sZXhlbWVfY2hhciIsInN1Yl9sZXhlbWVfY2hhcl9vcHQiLCJsZXhlbWVfY2hhciIsImxleGVtZV9zdGFydCIsImxleGVtZV9lbmQiLCJsZXhlbWVfc3RhcnRfcCIsImxleGVtZV9lbmRfcCIsIm5ld19saW5lIiwibGNwIiwiZmx1c2hfaW5wdXQiLCJlbnYiLCJncm93X3N0YWNrcyIsIm9sZHNpemUiLCJuZXdzaXplIiwibmV3X3MiLCJuZXdfdiIsIm5ld19zdGFydCIsIm5ld19lbmQiLCJjbGVhcl9wYXJzZXIiLCJjdXJyZW50X2xvb2thaGVhZF9mdW4iLCJ5eXBhcnNlIiwidGFibGVzIiwic3RhcnQiLCJsZXhlciIsImluaXRfYXNwIiwiaW5pdF9zcCIsImluaXRfc3RhY2tiYXNlIiwiaW5pdF9zdGF0ZSIsImluaXRfY3Vycl9jaGFyIiwiaW5pdF9sdmFsIiwiaW5pdF9lcnJmbGFnIiwiY21kIiwiYXJnIiwiYXJnJDAiLCJleG4kMCIsImV4biIsImN1cnJfY2hhciIsInRvayIsInBlZWtfdmFsIiwic3ltYm9sX3N0YXJ0X3BvcyIsInN0IiwiZW4iLCJzeW1ib2xfZW5kX3BvcyIsInJoc19zdGFydF9wb3MiLCJyaHNfZW5kX3BvcyIsInN5bWJvbF9zdGFydCIsInN5bWJvbF9lbmQiLCJyaHNfc3RhcnQiLCJyaHNfZW5kIiwiaXNfY3VycmVudF9sb29rYWhlYWQiLCJwYXJzZV9lcnJvciIsImhlaWdodCIsImhsIiwiaCQwIiwiaHIiLCJiYWwiLCJsciIsImx2IiwibGwiLCJscnIiLCJscnYiLCJscmwiLCJyciIsInJ2IiwicmwiLCJybHIiLCJybHYiLCJybGwiLCJhZGQiLCJzaW5nbGV0b24iLCJhZGRfbWluX2VsZW1lbnQiLCJhZGRfbWF4X2VsZW1lbnQiLCJyaCIsImxoIiwibWluX2VsdCIsIm1pbl9lbHRfb3B0IiwibWF4X2VsdCIsIm1heF9lbHRfb3B0IiwicmVtb3ZlX21pbl9lbHQiLCJyJDAiLCJwcmVzIiwicHJlcyQwIiwicmVtb3ZlIiwidW5pb24iLCJyMiIsInIyJDAiLCJyMSQwIiwiaW50ZXIiLCJzcGxpdF9iaXMiLCJkaXNqb2ludCIsImNvbnNfZW51bSIsImUyJDIiLCJlMSQyIiwiZTIkMCIsImUxJDAiLCJlMiQxIiwiZTEkMSIsInN1YnNldCIsInB2IiwibGYiLCJsdCIsInJmIiwicnQiLCJjYXJkaW5hbCIsImVsZW1lbnRzX2F1eCIsImVsZW1lbnRzIiwiZmluZF9maXJzdCIsInYwJDEiLCJ2MCQwIiwiZmluZF9maXJzdF9vcHQiLCJmaW5kX2xhc3QiLCJmaW5kX2xhc3Rfb3B0IiwidHJ5X2pvaW4iLCJ2JDEiLCJ4MCIsImwkMyIsImwkNCIsIngwJDAiLCJsJDUiLCJ4MCQxIiwibmwiLCJtaWQiLCJsJDIiLCJ4NCIsImFkZF9zZXEiLCJzZXFfb2ZfZW51bSIsInNub2NfZW51bSIsInJldl9zZXFfb2ZfZW51bSIsInRvX3Jldl9zZXEiLCJ0b19zZXFfZnJvbSIsImxvdyIsImxkIiwibHJkIiwicmQiLCJybGQiLCJkYXRhIiwiZDAkMSIsImQwIiwiZDAkMCIsIm1pbl9iaW5kaW5nIiwibWluX2JpbmRpbmdfb3B0IiwibWF4X2JpbmRpbmciLCJtYXhfYmluZGluZ19vcHQiLCJyZW1vdmVfbWluX2JpbmRpbmciLCJ1cGRhdGUiLCJkYXRhJDAiLCJtJDAiLCJhZGRfbWluX2JpbmRpbmciLCJrIiwiYWRkX21heF9iaW5kaW5nIiwiY29uY2F0X29yX2pvaW4iLCJkMSIsImQyIiwiZDIkMCIsImQxJDAiLCJkMiQxIiwiZDEkMSIsInB2ZCIsImZ2ZCIsIm0xIiwibTIiLCJiaW5kaW5nc19hdXgiLCJiaW5kaW5ncyIsImNsZWFyIiwicHVzaCIsInBvcCIsInBvcF9vcHQiLCJ0b3AiLCJ0b3Bfb3B0IiwiY2VsbCIsIm1hdGNoIiwicGVlayIsImNvbnRlbnQiLCJwZWVrX29wdCIsInRha2Vfb3B0IiwiY2VsbCQwIiwicV9yZXMiLCJwcmV2IiwicHJldiQwIiwidHJhbnNmZXIiLCJxMSIsInEyIiwiY291bnQiLCJmaWxsX2J1ZmYiLCJnZXRfZGF0YSIsImQxMSIsImEkMCIsImEkMSIsInBlZWtfZGF0YSIsImp1bmtfZGF0YSIsImp1bmsiLCJuZ2V0X2RhdGEiLCJhbCIsIm5wZWVrIiwic3RybSIsImZyb20iLCJvZl9jaGFubmVsIiwiaWFwcCIsImljb25zIiwiaXNpbmciLCJsYXBwIiwibGNvbnMiLCJsc2luZyIsInNsYXp5IiwiZHVtcCIsImR1bXBfZGF0YSIsImNvbnRlbnRzIiwicmVzZXQiLCJyZXNpemUiLCJtb3JlIiwib2xkX3BvcyIsIm9sZF9sZW4iLCJuZXdfYnVmZmVyIiwiYWRkX2NoYXIiLCJ1Y2hhcl91dGZfOF9ieXRlX2xlbmd0aF9tYXgiLCJ1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4IiwiYWRkX3V0Zl84X3VjaGFyIiwiYWRkX3V0Zl8xNmJlX3VjaGFyIiwiYWRkX3V0Zl8xNmxlX3VjaGFyIiwiYWRkX3N1YnN0cmluZyIsIm9mZnNldCIsIm5ld19wb3NpdGlvbiIsImFkZF9zdWJieXRlcyIsImFkZF9zdHJpbmciLCJhZGRfYnl0ZXMiLCJhZGRfYnVmZmVyIiwiYnMiLCJhZGRfY2hhbm5lbCIsInRvX3JlYWQkMSIsImFscmVhZHlfcmVhZCIsInRvX3JlYWQiLCJhbHJlYWR5X3JlYWQkMCIsInRvX3JlYWQkMCIsIm91dHB1dF9idWZmZXIiLCJhZGRfc3Vic3RpdHV0ZSIsImxpbSQxIiwicHJldmlvdXMiLCJwcmV2aW91cyQwIiwic3RhcnQkMCIsIm9wZW5pbmciLCJsaW0kMCIsInN0b3AkMCIsImskMiIsImNsb3NpbmciLCJzdG9wIiwiayQwIiwiayQxIiwibmV4dF9pIiwiaWRlbnQiLCJ0cnVuY2F0ZSIsImFkZF9pbnQ4IiwiYWRkX2ludDE2X25lIiwiYWRkX2ludDMyX25lIiwiYWRkX2ludDY0X25lIiwiYWRkX2ludDE2X2xlIiwiYWRkX2ludDE2X2JlIiwiYWRkX2ludDMyX2xlIiwiYWRkX2ludDMyX2JlIiwiYWRkX2ludDY0X2xlIiwiYWRkX2ludDY0X2JlIiwic3ViX2Zvcm1hdCIsImZvcm1hdHRpbmdfbGl0IiwiY3JlYXRlX2NoYXJfc2V0IiwiYWRkX2luX2NoYXJfc2V0Iiwic3RyX2luZCIsIm1hc2siLCJmcmVlemVfY2hhcl9zZXQiLCJyZXZfY2hhcl9zZXQiLCJjaGFyX3NldCQwIiwiaXNfaW5fY2hhcl9zZXQiLCJwYWRfb2ZfcGFkX29wdCIsInBhZF9vcHQiLCJ3aWR0aCIsInBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCIsImZtdCIsInBhZF9vcHQkMCIsInBhZF9vcHQkMSIsInBhZF9vcHQkMiIsInBhZF9vcHQkMyIsInBhZF9vcHQkNCIsInByZWNfb3B0IiwicGFkX29wdCQ1IiwibmRlYyIsInBhZF9vcHQkNiIsInBhZF9vcHQkNyIsInBhZF9vcHQkOCIsImRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIiwiYnVmZmVyX2NyZWF0ZSIsImluaXRfc2l6ZSIsImJ1ZmZlcl9jaGVja19zaXplIiwib3ZlcmhlYWQiLCJtaW5fbGVuIiwibmV3X3N0ciIsImJ1ZmZlcl9hZGRfY2hhciIsImJ1ZmZlcl9hZGRfc3RyaW5nIiwic3RyX2xlbiIsImJ1ZmZlcl9jb250ZW50cyIsImNoYXJfb2ZfaWNvbnYiLCJjaGFyX29mX2Zjb252IiwiY0YiLCJicHJpbnRfcGFkdHkiLCJwYWR0eSIsImJwcmludF9pZ25vcmVkX2ZsYWciLCJpZ25fZmxhZyIsImJwcmludF9wYWRfb3B0IiwiYnByaW50X3BhZGRpbmciLCJwYWR0eSQwIiwiYnByaW50X3ByZWNpc2lvbiIsImJwcmludF9pY29udl9mbGFnIiwiYnByaW50X2FsdGludF9mbXQiLCJicHJpbnRfZmNvbnZfZmxhZyIsInN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCIsInN0ciQwIiwiYnByaW50X2NoYXJfbGl0ZXJhbCIsImJwcmludF9zdHJpbmdfbGl0ZXJhbCIsImJwcmludF9mbXR0eSIsImZtdHR5JDEiLCJmbXR0eSQyIiwiZm10dHkkMyIsImZtdHR5JDQiLCJmbXR0eSQ1IiwiZm10dHkkNiIsImZtdHR5JDciLCJmbXR0eSQ4IiwiZm10dHkkOSIsInN1Yl9mbXR0eSIsImZtdHR5JDEwIiwic3ViX2ZtdHR5JDAiLCJmbXR0eSQxMSIsImZtdHR5JDEyIiwiZm10dHkkMTMiLCJmbXR0eSQxNCIsImZtdHR5JDE1IiwiaW50X29mX2N1c3RvbV9hcml0eSIsInN0cmluZ19vZl9mbXQiLCJmbXRpdGVyIiwiZm10JDAiLCJpZ25fZmxhZyQwIiwic3RyJDEiLCJzZXQkMCIsImlzX2Fsb25lIiwiYWZ0ZXIiLCJiZWZvcmUiLCJqJDEiLCJmbXQkMSIsInN5bW0iLCJmbXR0eV9yZWxfZGV0IiwiZGUiLCJlZCIsImFmIiwiZmEiLCJkZSQwIiwiZWQkMCIsImFmJDAiLCJmYSQwIiwiZGUkMSIsImVkJDEiLCJhZiQxIiwiZmEkMSIsImRlJDIiLCJlZCQyIiwiYWYkMiIsImZhJDIiLCJkZSQzIiwiZWQkMyIsImFmJDMiLCJmYSQzIiwiZGUkNCIsImVkJDQiLCJhZiQ0IiwiZmEkNCIsImRlJDUiLCJlZCQ1IiwiYWYkNSIsImZhJDUiLCJkZSQ2IiwiZWQkNiIsImFmJDYiLCJmYSQ2IiwiZGUkNyIsImVkJDciLCJhZiQ3IiwiZmEkNyIsImRlJDgiLCJlZCQ4IiwiYWYkOCIsImZhJDgiLCJ0cmFucyIsImpkIiwiZGoiLCJnYSIsImFnIiwiZGUkOSIsImVkJDkiLCJhZiQ5IiwiZmEkOSIsImRlJDEwIiwiZWQkMTAiLCJhZiQxMCIsImZhJDEwIiwiZGUkMTEiLCJlZCQxMSIsImFmJDExIiwiZmEkMTEiLCJkZSQxMiIsImVkJDEyIiwiYWYkMTIiLCJmYSQxMiIsImRlJDEzIiwiZWQkMTMiLCJhZiQxMyIsImZhJDEzIiwicmVzdDEiLCJyZXN0MiIsInJlc3QxJDAiLCJyZXN0MiQwIiwicmVzdDEkMSIsInJlc3QyJDEiLCJyZXN0MSQyIiwicmVzdDIkMiIsInJlc3QxJDMiLCJyZXN0MiQzIiwicmVzdDEkNCIsInJlc3QyJDQiLCJyZXN0MSQ1IiwicmVzdDIkNSIsInJlc3QxJDYiLCJyZXN0MiQ2IiwicmVzdDEkNyIsInR5MSQwIiwicmVzdDIkNyIsInR5MiQwIiwicmVzdDEkOCIsInR5MTIiLCJ0eTExIiwicmVzdDIkOCIsInR5MjIiLCJ0eTIxIiwiZjQiLCJmMiIsInJlc3QxJDkiLCJyZXN0MiQ5IiwicmVzdDEkMTAiLCJyZXN0MiQxMCIsInJlc3QxJDExIiwicmVzdDIkMTEiLCJyZXN0MSQxMiIsInJlc3QyJDEyIiwicmVzdDEkMTMiLCJyZXN0MiQxMyIsImZtdHR5X29mX2ZtdCIsImZtdHR5X29mX3BhZGRpbmdfZm10dHkiLCJ0eV9yZXN0IiwicHJlY190eSIsImZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSIsInR5X3Jlc3QkMCIsInByZWNfdHkkMCIsInR5X3Jlc3QkMSIsInByZWNfdHkkMSIsInR5X3Jlc3QkMiIsInByZWNfdHkkMiIsInR5X3Jlc3QkMyIsInByZWNfdHkkMyIsInR5JDAiLCJmb3JtYXR0aW5nX2dlbiIsImZtdHR5X29mX2N1c3RvbSIsImFyaXR5JDAiLCJ0eXBlX3BhZGRpbmciLCJ3IiwidHlwZV9wYWRwcmVjIiwidHlwZV9mb3JtYXQiLCJ0eXBlX2Zvcm1hdF9nZW4iLCJmbXR0eTAiLCJmbXR0eV9yZXN0IiwiZm10X3Jlc3QiLCJmbXR0eV9yZXN0JDAiLCJmbXRfcmVzdCQwIiwiZm10X3Jlc3QkMSIsImZtdHR5X3Jlc3QkMSIsImZtdCQyIiwiZm10X3Jlc3QkMiIsImZtdHR5X3Jlc3QkMiIsImZtdCQzIiwiZm10X3Jlc3QkMyIsImZtdHR5X3Jlc3QkMyIsImZtdCQ0IiwiZm10X3Jlc3QkNCIsImZtdHR5X3Jlc3QkNCIsImZtdCQ1IiwiZm10X3Jlc3QkNSIsImZtdHR5X3Jlc3QkNSIsInByZWMkNCIsImZtdCQ2IiwiZm10X3Jlc3QkNiIsInByZWMkNSIsInBhZCQ5IiwicGFkJDEwIiwiZm10dHlfcmVzdCQ2IiwicHJlYyQ2IiwiZm10JDciLCJmbXRfcmVzdCQ3IiwicHJlYyQ3IiwicGFkJDExIiwicGFkJDEyIiwiZm10dHlfcmVzdCQ3IiwicHJlYyQ4IiwiZm10JDgiLCJmbXRfcmVzdCQ4IiwicGFkJDEzIiwicGFkJDE0IiwiZm10dHlfcmVzdCQ4IiwiZm10JDkiLCJmbXRfcmVzdCQ5IiwiZm10JDEwIiwiZm10X3Jlc3QkMTAiLCJmbXQkMTEiLCJmbXRfcmVzdCQxMSIsImZtdCQxMiIsImZtdHR5X3Jlc3QkOSIsImZtdF9yZXN0JDEyIiwiZm10JDEzIiwiZm10dHlfcmVzdCQxMCIsInN1Yl9mbXR0eTEiLCJmbXRfcmVzdCQxMyIsInN1Yl9mbXR0eSQxIiwiZm10JDE0IiwiZm10dHlfcmVzdCQxMSIsImZtdF9yZXN0JDE0IiwiZm10JDE1IiwiZm10dHlfcmVzdCQxMiIsImZtdF9yZXN0JDE1IiwiZm10JDE2IiwiZm10X3Jlc3QkMTYiLCJmbXR0eSQxNiIsImZtdCQxNyIsImZtdF9yZXN0JDE3IiwiZm10dHkzIiwiZm10MyIsImZtdDEkMCIsImZtdHR5MiQwIiwiZm10MiQwIiwiZm10dHkzJDAiLCJmbXQzJDAiLCJmbXR0eV9yZXN0JDEzIiwiZm10X3Jlc3QkMTgiLCJmbXR0eSQxNyIsImZtdCQxOCIsImZtdHR5X3Jlc3QkMTQiLCJmbXRfcmVzdCQxOSIsImZtdHR5JDE4IiwiZm10JDE5IiwiZm10dHlfcmVzdCQxNSIsImZtdF9yZXN0JDIwIiwiZm10dHkkMTkiLCJmbXQkMjAiLCJ0eXBlX2lnbm9yZWRfcGFyYW1fb25lIiwic3ViX2ZtdHR5JDIiLCJzdWJfZm10dHkkMyIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aSIsImZtdHR5JDIxIiwiZm10JDIyIiwic3ViX2ZtdHR5JDQiLCJmbXR0eV9yZXN0JDE2IiwiZm10dHkkMjAiLCJmbXQkMjEiLCJzdWJfZm10dHlfcmVzdCIsInN1Yl9mbXR0eV9yZXN0JDAiLCJzdWJfZm10dHlfcmVzdCQxIiwic3ViX2ZtdHR5X3Jlc3QkMiIsInN1Yl9mbXR0eV9yZXN0JDMiLCJzdWJfZm10dHlfcmVzdCQ0Iiwic3ViX2ZtdHR5X3Jlc3QkNSIsInN1Yl9mbXR0eV9yZXN0JDYiLCJzdWJfZm10dHlfcmVzdCQ3Iiwic3ViX2ZtdHR5X3Jlc3QkOCIsInN1Yl9mbXR0eV9yZXN0JDkiLCJzdWJfZm10dHlfcmVzdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDExIiwic3ViX2ZtdHR5X3Jlc3QkMTIiLCJzdWJfZm10dHlfcmVzdCQxMyIsInN1Yl9mbXR0eV9yZXN0JDE0Iiwic3ViMl9mbXR0eSIsInN1Yl9mbXR0eV9yZXN0JDE1Iiwic3ViMl9mbXR0eSQwIiwic3ViX2ZtdHR5X3Jlc3QkMTYiLCJzdWIyX2ZtdHR5JDEiLCJzdWIxX2ZtdHR5Iiwic3ViX2ZtdHR5X3Jlc3QkMTciLCJzdWIyX2ZtdHR5JDIiLCJzdWIxX2ZtdHR5JDAiLCJzdWJfZm10dHlfcmVzdCQxOCIsInN1Yl9mbXR0eV9yZXN0JDE5Iiwic3ViX2ZtdHR5X3Jlc3QkMjAiLCJzdWJfZm10dHlfcmVzdCQyMSIsInN1Yl9mbXR0eV9yZXN0JDIyIiwic3ViX2ZtdHR5X3Jlc3QkMjMiLCJzdWJfZm10dHlfcmVzdCQyNCIsInN1Yl9mbXR0eV9yZXN0JDI1Iiwic3ViX2ZtdHR5X3Jlc3QkMjYiLCJyZWNhc3QiLCJmaXhfcGFkZGluZyIsIndpZHRoJDAiLCJmaXhfaW50X3ByZWNpc2lvbiIsInJlcyQxIiwic3RyaW5nX3RvX2NhbWxfc3RyaW5nIiwiZm9ybWF0X29mX2Zjb252Iiwic3ltYiIsInRyYW5zZm9ybV9pbnRfYWx0IiwiZGlnaXRzIiwicHV0IiwiY29udmVydF9pbnQiLCJjb252ZXJ0X2ludDMyIiwiY29udmVydF9uYXRpdmVpbnQiLCJjb252ZXJ0X2ludDY0IiwiY29udmVydF9mbG9hdCIsImhleCIsInNpZ24iLCJjYW1sX3NwZWNpYWxfdmFsIiwic3RyaW5nX29mX2ZtdHR5IiwibWFrZV9wcmludGYkMCIsIm5ld19hY2MiLCJtYWtlX3ByaW50ZiIsIm1ha2VfcGFkZGluZyIsIm1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIiwicCQwIiwicCQxIiwiYWNjJDMiLCJhY2MkNCIsImthY2MiLCJtYWtlX2lnbm9yZWRfcGFyYW0kMCIsIm1ha2VfY3VzdG9tJDAiLCJtYWtlX2ludmFsaWRfYXJnIiwibWFrZV9mcm9tX2ZtdHR5JDAiLCJtYWtlX2lnbm9yZWRfcGFyYW0iLCJtYWtlX2Zyb21fZm10dHkiLCJtYWtlX2N1c3RvbSIsIm1ha2VfaXByaW50ZiQwIiwibWFrZV9pcHJpbnRmIiwieCQxIiwieCQyIiwieCQzIiwieCQ0IiwieCQ1IiwieCQ2IiwieCQ3IiwieCQ4IiwiZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24iLCJ4JDkiLCJ4JDEwIiwieCQxMSIsIngkMTIiLCJ4JDEzIiwieCQxNCIsIngkMTUiLCJ4JDE2Iiwia29jIiwicmVzdCQyNCIsInJlc3QkMjUiLCJ4JDE3IiwicmVzdCQyNiIsIngkMTgiLCJyZXN0JDI3IiwieCQxOSIsInJlc3QkMjgiLCJyZXN0JDI5IiwiZm5fb2ZfY3VzdG9tX2FyaXR5JDAiLCJmbl9vZl9jdXN0b21fYXJpdHkiLCJvdXRwdXRfYWNjIiwicCQzIiwicCQ0IiwicCQ1IiwicCQyIiwiYnVmcHV0X2FjYyIsInN0cnB1dF9hY2MiLCJmYWlsd2l0aF9tZXNzYWdlIiwib3Blbl9ib3hfb2Zfc3RyaW5nIiwiaW52YWxpZF9ib3giLCJwYXJzZV9zcGFjZXMiLCJ3c3RhcnQiLCJ3ZW5kIiwiYm94X25hbWUiLCJuc3RhcnQiLCJuZW5kIiwiaW5kZW50IiwiZXhwX2VuZCIsImJveF90eXBlIiwibWFrZV9wYWRkaW5nX2ZtdF9lYmIiLCJtYWtlX3BhZHByZWNfZm10X2ViYiIsImZtdF9lYmJfb2Zfc3RyaW5nIiwibGVnYWN5X2JlaGF2aW9yIiwiZmxhZyIsImxlZ2FjeV9iZWhhdmlvciQwIiwiaW52YWxpZF9mb3JtYXRfbWVzc2FnZSIsImludmFsaWRfZm9ybWF0X3dpdGhvdXQiLCJleHBlY3RlZF9jaGFyYWN0ZXIiLCJleHBlY3RlZCIsInBhcnNlIiwibGl0X3N0YXJ0IiwiZW5kX2luZCIsImFkZF9saXRlcmFsIiwic3RyX2luZCQxIiwic3RyX2luZCQyIiwicGFyc2VfZmxhZ3MiLCJzdHJfaW5kJDAiLCJwYXJzZV90YWciLCJzdHJfaW5kJDMiLCJzdHJfaW5kXzEiLCJwYXJzZV9pbnRlZ2VyIiwic3RyX2luZF8yIiwic3RyX2luZF8zIiwiZm9ybWF0dGluZ19saXQkMCIsIm5leHRfaW5kIiwic3RyX2luZF80Iiwic3RyX2luZF81Iiwic3RyX2luZCQ0Iiwic3RyX2luZF8xJDAiLCJzdHJfaW5kXzIkMCIsInN0cl9pbmRfMyQwIiwicyQxIiwiZm9ybWF0dGluZ19saXQkMSIsIm5leHRfaW5kJDAiLCJwY3RfaW5kIiwibWludXMiLCJwbHVzIiwic3BhY2UiLCJzZXRfZmxhZyIsInN0cl9pbmQkNSIsInNwYWNlJDAiLCJoYXNoJDAiLCJwbHVzJDAiLCJtaW51cyQwIiwiemVybyQwIiwiaW5jb21wYXRpYmxlX2ZsYWciLCJwYXJzZV9wb3NpdGl2ZSIsIm5ld19pbmQiLCJwYXJzZV9hZnRlcl9wYWRkaW5nIiwicGFyc2VfY29udmVyc2lvbiIsInBhcnNlX2xpdGVyYWwiLCJwYXJzZV9hZnRlcl9wcmVjaXNpb24iLCJzeW1iJDAiLCJwYXJzZV9jb252IiwicGFkcHJlYyIsInBsdXNfdXNlZCIsImhhc2hfdXNlZCIsInNwYWNlX3VzZWQiLCJpZ25fdXNlZCIsInBhZF91c2VkIiwicHJlY191c2VkIiwiZ2V0X3BsdXMiLCJnZXRfaGFzaCIsImdldF9zcGFjZSIsImdldF9pZ24iLCJnZXRfcGFkIiwiZ2V0X3ByZWMiLCJnZXRfcGFkcHJlYyIsImdldF9pbnRfcGFkIiwiY2hlY2tfbm9fMCIsIm9wdF9vZl9wYWQiLCJ3aWR0aCQxIiwiZ2V0X3BhZF9vcHQiLCJnZXRfcGFkcHJlY19vcHQiLCJmbXRfcmVzdWx0Iiwic3ViX2VuZCIsInNlYXJjaF9zdWJmb3JtYXRfZW5kIiwic3ViX2ZtdCIsImlnbm9yZWQkMiIsImNvdW50ZXIkMCIsImlnbm9yZWQkNiIsImlnbm9yZWQkNyIsImFkZF9yYW5nZSIsImZhaWxfc2luZ2xlX3BlcmNlbnQiLCJwYXJzZV9jaGFyX3NldF9jb250ZW50IiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciQwIiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciIsInJldmVyc2UiLCJjaGFyX3NldCQxIiwiaWdub3JlZCQ5IiwiY2hhcl9mb3JtYXQiLCJmbXRfcmVzdCQyMSIsImZtdF9yZXN0JDIyIiwiZm10X3Jlc3QkMjMiLCJpZ25vcmVkJDEwIiwiZm10X3Jlc3QkMjQiLCJmbXRfcmVzdCQyNSIsInN1Yl9lbmQkMCIsInN1Yl9mbXQkMCIsImZtdF9yZXN0JDI2IiwiaWdub3JlZCQxMSIsImlnbm9yZWQkMyIsImlnbm9yZWQkNSIsImNvbXB1dGVfaW50X2NvbnYiLCJpZ25vcmVkJDgiLCJzcGFjZSQxIiwiaGFzaCQxIiwicGx1cyQyIiwia2luZCIsImlnbm9yZWQkNCIsImlnbm9yZWQiLCJpZ25vcmVkJDAiLCJpZ25vcmVkJDEiLCJwbHVzJDEiLCJpZ24kMCIsImlzX29wZW5fdGFnIiwiaW5kIiwic3ViX3N0ciIsInN1Yl9mb3JtYXQkMCIsImZvcm1hdHRpbmckMCIsImZvcm1hdHRpbmciLCJzdWJfZW5kJDEiLCJzdWJfZW5kJDIiLCJzdHJfaW5kJDYiLCJzdHJfaW5kJDciLCJvcHRpb24iLCJzdWJmbXQiLCJmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IiwiZm9ybWF0X29mX3N0cmluZ19mb3JtYXQiLCJrZnByaW50ZiIsImticHJpbnRmIiwiaWtmcHJpbnRmIiwiZnByaW50ZiIsImJwcmludGYiLCJpZnByaW50ZiIsImlicHJpbnRmIiwicHJpbnRmIiwiZXByaW50ZiIsImtzcHJpbnRmIiwic3ByaW50ZiIsImFzc29jMyIsInkyIiwieTEiLCJtYWtlX3N5bWxpc3QiLCJoZWxwX2FjdGlvbiIsImFkZF9oZWxwIiwic3BlY2xpc3QiLCJhZGQxIiwiYWRkMiIsInVzYWdlX2IiLCJlcnJtc2ciLCJkb2MiLCJzcGVjIiwia2V5IiwidXNhZ2Vfc3RyaW5nIiwidXNhZ2UiLCJjdXJyZW50IiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfIiwiYWxsb3dfZXhwYW5kIiwiYXJndiIsImFub25mdW4iLCJpbml0cG9zIiwiY29udmVydF9lcnJvciIsInByb2duYW1lIiwiZm9sbG93JDAiLCJrZXl3b3JkIiwiZm9sbG93JDIiLCJub19hcmciLCJnZXRfYXJnIiwiY29uc3VtZV9hcmciLCJ0cmVhdF9hY3Rpb24iLCJub19hcmckMCIsImYkMCIsImdldF9hcmckMCIsImNvbnN1bWVfYXJnJDAiLCJmJDEiLCJyJDEiLCJmJDIiLCJhcmckMSIsInIkMiIsImFyZyQyIiwiZiQzIiwiYXJnJDMiLCJyJDMiLCJhcmckNCIsInNwZWNzIiwidHJlYXRfYWN0aW9uJDAiLCJmJDQiLCJhcmckNSIsImYkNSIsImYkNiIsImYkNyIsImFyZyQ2IiwibmV3YXJnIiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMiLCJwYXJzZV9hcmd2X2R5bmFtaWMiLCJjdXJyZW50JDAiLCJwYXJzZV9hcmd2IiwibXNnJDAiLCJtc2ckMSIsInBhcnNlX2R5bmFtaWMiLCJwYXJzZV9leHBhbmQiLCJzZWNvbmRfd29yZCIsImxvb3AiLCJtYXhfYXJnX2xlbiIsImt3ZCIsInJlcGxhY2VfbGVhZGluZ190YWIiLCJhbGlnbiIsImxpbWl0IiwiY29tcGxldGVkIiwia3NkIiwiY3V0Y29sJDAiLCJzcGFjZXMkMCIsInNwZWMkMCIsImN1dGNvbCIsImt3ZF9sZW4iLCJzcGFjZXMiLCJyZWFkX2F1eCIsImZpbGUiLCJ3b3JkcyIsInN0YXNoIiwid29yZCIsIndvcmQkMCIsInJlYWRfYXJnIiwicmVhZF9hcmcwIiwid3JpdGVfYXV4IiwiYXJncyIsIndyaXRlX2FyZyIsIndyaXRlX2FyZzAiLCJsb2NmbXQiLCJwcmludGVycyIsImZpZWxkIiwib3RoZXJfZmllbGRzIiwidXNlX3ByaW50ZXJzIiwidG9fc3RyaW5nX2RlZmF1bHQiLCJjaGFyJDAiLCJsaW5lIiwiY2hhciQxIiwibGluZSQwIiwiZmlsZSQwIiwiY2hhciQyIiwibGluZSQxIiwiZmlsZSQxIiwiY29uc3RydWN0b3IiLCJwcmludCIsImZjdCIsImNhdGNoJDAiLCJyYXdfYmFja3RyYWNlX2VudHJpZXMiLCJidCIsImNvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImZvcm1hdF9iYWNrdHJhY2Vfc2xvdCIsImlzX3JhaXNlIiwicHJpbnRfcmF3X2JhY2t0cmFjZSIsIm91dGNoYW4iLCJyYXdfYmFja3RyYWNlIiwiYmFja3RyYWNlIiwicHJpbnRfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZV90b19zdHJpbmciLCJiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSIsInBhcmFtIiwiYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lIiwiYmFja3RyYWNlX3Nsb3RfbG9jYXRpb24iLCJiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lIiwiYmFja3RyYWNlX3Nsb3RzIiwiYmFja3RyYWNlX3Nsb3RzX29mX3Jhd19lbnRyeSIsImVudHJ5IiwicmF3X2JhY2t0cmFjZV9sZW5ndGgiLCJnZXRfYmFja3RyYWNlIiwicmVnaXN0ZXJfcHJpbnRlciIsImZuIiwib2xkX3ByaW50ZXJzIiwibmV3X3ByaW50ZXJzIiwiZXhuX3Nsb3QiLCJleG5fc2xvdF9pZCIsImV4bl9zbG90X25hbWUiLCJlcnJvcnMiLCJkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW4iLCJzdGF0dXMiLCJ1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsInNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsImVtcHR5X2JhY2t0cmFjZSIsImhhbmRsZV91bmNhdWdodF9leGNlcHRpb24iLCJkZWJ1Z2dlcl9pbl91c2UiLCJleG4kMSIsInJhd19iYWNrdHJhY2UkMCIsImNvbnN0JDAiLCJmbGlwIiwibmVnYXRlIiwicHJvdGVjdCIsImZpbmFsbHkkMCIsIndvcmsiLCJmaW5hbGx5X25vX2V4biIsIndvcmtfZXhuJDAiLCJ3b3JrX2V4biIsIndvcmtfYnQiLCJwcmludF9zdGF0IiwiYWxsb2NhdGVkX2J5dGVzIiwibWEiLCJwcm8iLCJtaSIsImNyZWF0ZV9hbGFybSIsImRlbGV0ZV9hbGFybSIsIm51bGxfdHJhY2tlciIsInNhbXBsaW5nX3JhdGUiLCJ0cmFja2VyIiwiY2FsbHN0YWNrX3NpemUiLCJzdHJpbmciLCJieXRlcyIsInN1YnN0cmluZyIsInN1YmJ5dGVzIiwiZmlsZW5hbWUiLCJkaWdlc3QiLCJjaGFyX2hleCIsInRvX2hleCIsImZyb21faGV4IiwiZGlnaXQiLCJuZXdfc3RhdGUiLCJhc3NpZ24iLCJzdDEiLCJzdDIiLCJmdWxsX2luaXQiLCJzZWVkIiwic2VlZCQwIiwibWFrZV9zZWxmX2luaXQiLCJiaXRzIiwiY3VydmFsIiwibmV3dmFsIiwibmV3dmFsMzAiLCJpbnRhdXgiLCJpbnQkMCIsImJvdW5kIiwiZnVsbF9pbnQiLCJtYXhfaW50XzMyIiwiYnBvcyIsImludDMyIiwiaW50NjQiLCJuYXRpdmVpbnQiLCJmbG9hdCQwIiwiYm9vbCIsImJpdHMzMiIsImJpdHM2NCIsIm5hdGl2ZWJpdHMiLCJiaXRzJDAiLCJpbnQkMSIsImZ1bGxfaW50JDAiLCJpbnQzMiQwIiwibmF0aXZlaW50JDAiLCJpbnQ2NCQwIiwiZmxvYXQkMSIsInNjYWxlIiwiYm9vbCQwIiwiYml0czMyJDAiLCJiaXRzNjQkMCIsIm5hdGl2ZWJpdHMkMCIsImZ1bGxfaW5pdCQwIiwic2VsZl9pbml0IiwiZ2V0X3N0YXRlIiwic2V0X3N0YXRlIiwib25nb2luZ190cmF2ZXJzYWwiLCJmbGlwX29uZ29pbmdfdHJhdmVyc2FsIiwicGFyYW1zIiwicmFuZG9taXplZF9kZWZhdWx0IiwicmFuZG9taXplZCIsInJhbmRvbWl6ZSIsImlzX3JhbmRvbWl6ZWQiLCJwcm5nIiwicG93ZXJfMl9hYm92ZSIsImluaXRpYWxfc2l6ZSIsInJhbmRvbSIsImNvcHlfYnVja2V0bGlzdCIsImtleSQwIiwibmV4dCQwIiwiaW5zZXJ0X2FsbF9idWNrZXRzIiwiaW5kZXhmdW4iLCJpbnBsYWNlIiwib2RhdGEiLCJuZGF0YSIsIm5zaXplIiwibmRhdGFfdGFpbCIsIm5pZHgiLCJtYXRjaCQwIiwib3NpemUiLCJvbGRfdHJhdiIsImZpbHRlcl9tYXBfaW5wbGFjZSIsImIkMCIsImJ1Y2tldF9sZW5ndGgiLCJzdGF0cyIsIm1ibCIsImhpc3RvIiwidGJsX2RhdGEiLCJidWNrIiwiYnVjayQwIiwiYnVjayQxIiwidG9fc2VxX2tleXMiLCJ0b19zZXFfdmFsdWVzIiwia2V5X2luZGV4IiwiYnVja2V0IiwiazEiLCJuZXh0MSIsImsyIiwibmV4dDIiLCJrMyIsImQzIiwibmV4dDMiLCJmaW5kX2luX2J1Y2tldCIsInJlcGxhY2UiLCJyZXBsYWNlX3NlcSIsInN6IiwiaGFzaF9wYXJhbSIsInNlZWRlZF9oYXNoIiwicmVidWlsZCIsImdldF9jb3B5IiwiYXIiLCJlbXB0eWJ1Y2tldCIsImdldF9pbmRleCIsImNyZWF0ZSQwIiwic3okMCIsInN6JDEiLCJjb3VudF9idWNrZXQiLCJhZGRfYXV4Iiwic2V0dGVyIiwiYnVja2V0JDAiLCJoYXNoZXMiLCJuZXdzeiIsIm5ld2J1Y2tldCQwIiwibmV3aGFzaGVzIiwiaGJ1Y2tldCIsInByZXZfbGVuIiwibGl2ZSIsImokMiIsIm5ld2J1Y2tldCIsIm9sZGxlbiIsIm5ld3QiLCJvYiIsIm9pIiwib2giLCJvaSQwIiwibmkiLCJmaW5kX29yIiwiaWZub3Rmb3VuZCIsImZpbmRfc2hhZG93IiwiaWZmb3VuZCIsImxlbnMiLCJ0b3RsZW4iLCJ1bmtub3duIiwicHBfZW5xdWV1ZSIsInRva2VuIiwicHBfaW5maW5pdHkiLCJwcF9vdXRwdXRfc3RyaW5nIiwicHBfb3V0cHV0X25ld2xpbmUiLCJmb3JtYXRfcHBfdGV4dCIsInRleHQiLCJmb3JtYXRfc3RyaW5nIiwiYnJlYWtfbmV3X2xpbmUiLCJyZWFsX2luZGVudCIsImJyZWFrX3NhbWVfbGluZSIsImZvcm1hdF9wcF90b2tlbiIsInNpemUkMCIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJ0YWdfbmFtZSIsIm1hcmtlciIsImJyZWFrcyIsImZpdHMiLCJvZmYiLCJib3hfdHlwZSQwIiwib2ZmJDAiLCJpbnNlcnRpb25fcG9pbnQiLCJ0YWJzJDAiLCJmaXJzdCIsImhlYWQiLCJ0YWIiLCJvZmYkMSIsImluc2VydGlvbl9wb2ludCQwIiwid2lkdGgkMiIsImJveF90eXBlJDEiLCJ0Ym94IiwidGFnX25hbWUkMCIsIm1hcmtlciQwIiwiYWR2YW5jZV9sZWZ0IiwicGVuZGluZ19jb3VudCIsImVucXVldWVfYWR2YW5jZSIsImVucXVldWVfc3RyaW5nX2FzIiwiaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIiwic3RhY2siLCJxdWV1ZV9lbGVtIiwic2V0X3NpemUiLCJsZWZ0X3RvdGFsIiwic2Nhbl9wdXNoIiwiZWxlbSIsInBwX29wZW5fYm94X2dlbiIsImJyX3R5IiwicHBfY2xvc2VfYm94IiwicHBfb3Blbl9zdGFnIiwicHBfY2xvc2Vfc3RhZyIsInBwX29wZW5fdGFnIiwicHBfY2xvc2VfdGFnIiwicHBfc2V0X3ByaW50X3RhZ3MiLCJwcF9zZXRfbWFya190YWdzIiwicHBfZ2V0X3ByaW50X3RhZ3MiLCJwcF9nZXRfbWFya190YWdzIiwicHBfc2V0X3RhZ3MiLCJwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb24iLCJwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb24iLCJwY3QiLCJwb3QiLCJtY3QiLCJtb3QiLCJwcF9yaW5pdCIsInBwX2ZsdXNoX3F1ZXVlIiwicHBfcHJpbnRfYXNfc2l6ZSIsInBwX3ByaW50X2FzIiwiaXNpemUiLCJwcF9wcmludF9zdHJpbmciLCJwcF9wcmludF9ieXRlcyIsInBwX3ByaW50X2ludCIsInBwX3ByaW50X2Zsb2F0IiwicHBfcHJpbnRfYm9vbCIsInBwX3ByaW50X2NoYXIiLCJwcF9vcGVuX2hib3giLCJwcF9vcGVuX3Zib3giLCJwcF9vcGVuX2h2Ym94IiwicHBfb3Blbl9ob3Zib3giLCJwcF9vcGVuX2JveCIsInBwX3ByaW50X25ld2xpbmUiLCJwcF9wcmludF9mbHVzaCIsInBwX2ZvcmNlX25ld2xpbmUiLCJwcF9wcmludF9pZl9uZXdsaW5lIiwicHBfcHJpbnRfY3VzdG9tX2JyZWFrIiwicHBfcHJpbnRfYnJlYWsiLCJwcF9wcmludF9zcGFjZSIsInBwX3ByaW50X2N1dCIsInBwX29wZW5fdGJveCIsInBwX2Nsb3NlX3Rib3giLCJwcF9wcmludF90YnJlYWsiLCJwcF9wcmludF90YWIiLCJwcF9zZXRfdGFiIiwicHBfc2V0X21heF9ib3hlcyIsInBwX2dldF9tYXhfYm94ZXMiLCJwcF9vdmVyX21heF9ib3hlcyIsInBwX3NldF9lbGxpcHNpc190ZXh0IiwicHBfZ2V0X2VsbGlwc2lzX3RleHQiLCJwcF9saW1pdCIsInBwX3NldF9tYXhfaW5kZW50IiwicHBfZ2V0X21heF9pbmRlbnQiLCJwcF9zZXRfbWFyZ2luIiwibmV3X21heF9pbmRlbnQiLCJ2YWxpZGF0ZV9nZW9tZXRyeSIsIm1hcmdpbiIsIm1heF9pbmRlbnQiLCJjaGVja19nZW9tZXRyeSIsImdlb21ldHJ5IiwicHBfZ2V0X21hcmdpbiIsInBwX3NldF9mdWxsX2dlb21ldHJ5IiwicHBfc2V0X2dlb21ldHJ5IiwicHBfc2FmZV9zZXRfZ2VvbWV0cnkiLCJwcF9nZXRfZ2VvbWV0cnkiLCJwcF91cGRhdGVfZ2VvbWV0cnkiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJkaXNwbGF5X25ld2xpbmUiLCJibGFua19saW5lIiwiZGlzcGxheV9ibGFua3MiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwiZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnIiwiZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWciLCJkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyIsInBwX21ha2VfZm9ybWF0dGVyIiwicHBfcXVldWUiLCJzeXNfdG9rIiwic2Nhbl9zdGFjayIsInBwX21hcmdpbiIsImZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIiwib3V0X2Z1bnMiLCJtYWtlX2Zvcm1hdHRlciIsInBwZiIsImZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCIsImZvcm1hdHRlcl9vZl9idWZmZXIiLCJwcF9idWZmZXJfc2l6ZSIsInBwX21ha2VfYnVmZmVyIiwic3RkYnVmIiwic3RkX2Zvcm1hdHRlciIsImVycl9mb3JtYXR0ZXIiLCJzdHJfZm9ybWF0dGVyIiwiZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciIsImZsdXNoX3N0cl9mb3JtYXR0ZXIiLCJtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwic29iIiwiZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiaXRlbXMiLCJhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0iLCJpdGVtIiwiZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9iIiwib3Blbl9oYm94Iiwib3Blbl92Ym94Iiwib3Blbl9odmJveCIsIm9wZW5faG92Ym94Iiwib3Blbl9ib3giLCJjbG9zZV9ib3giLCJvcGVuX3RhZyIsImNsb3NlX3RhZyIsIm9wZW5fc3RhZyIsImNsb3NlX3N0YWciLCJwcmludF9hcyIsInByaW50X2Jvb2wiLCJwcmludF9icmVhayIsInByaW50X2N1dCIsInByaW50X3NwYWNlIiwiZm9yY2VfbmV3bGluZSIsInByaW50X2ZsdXNoIiwicHJpbnRfaWZfbmV3bGluZSIsIm9wZW5fdGJveCIsImNsb3NlX3Rib3giLCJwcmludF90YnJlYWsiLCJzZXRfdGFiIiwicHJpbnRfdGFiIiwic2V0X21hcmdpbiIsImdldF9tYXJnaW4iLCJzZXRfbWF4X2luZGVudCIsImdldF9tYXhfaW5kZW50Iiwic2V0X2dlb21ldHJ5Iiwic2FmZV9zZXRfZ2VvbWV0cnkiLCJnZXRfZ2VvbWV0cnkiLCJ1cGRhdGVfZ2VvbWV0cnkiLCJzZXRfbWF4X2JveGVzIiwiZ2V0X21heF9ib3hlcyIsIm92ZXJfbWF4X2JveGVzIiwic2V0X2VsbGlwc2lzX3RleHQiLCJnZXRfZWxsaXBzaXNfdGV4dCIsInNldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwiLCJzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJzZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJzZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyIsInNldF9wcmludF90YWdzIiwiZ2V0X3ByaW50X3RhZ3MiLCJzZXRfbWFya190YWdzIiwiZ2V0X21hcmtfdGFncyIsInNldF90YWdzIiwicHBfcHJpbnRfbGlzdCIsInBwX3YiLCJvcHQkMCIsInBwX3NlcCIsIm9wdCQxIiwicHBfcHJpbnRfc2VxIiwic2VxJDEiLCJzZXEkMiIsInBwX3ByaW50X3RleHQiLCJwcF9wcmludF9vcHRpb24iLCJwcF9wcmludF9yZXN1bHQiLCJwcF9wcmludF9laXRoZXIiLCJjb21wdXRlX3RhZyIsInRhZ19hY2MiLCJvdXRwdXRfZm9ybWF0dGluZ19saXQiLCJidHkiLCJwJDYiLCJwJDciLCJzaXplJDEiLCJwJDgiLCJrZHByaW50ZiIsImRwcmludGYiLCJrYXNwcmludGYiLCJhc3ByaW50ZiIsImZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnMiLCJwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnUiLCJwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnUiLCJzZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3QiLCJnZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3QiLCJwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJzdHJpbmdpZnkiLCJwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJmdW5zIiwibWFya19vcGVuX3RhZyIsIm1hcmtfY2xvc2VfdGFnIiwicHJpbnRfb3Blbl90YWciLCJwcmludF9jbG9zZV90YWciLCJzZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJudWxsX2NoYXIiLCJuZXh0X2NoYXIiLCJpYiIsInBlZWtfY2hhciIsImNoZWNrZWRfcGVla19jaGFyIiwiZW5kX29mX2lucHV0IiwiYmVnaW5uaW5nX29mX2lucHV0IiwibmFtZV9vZl9pbnB1dCIsImNoYXJfY291bnQiLCJpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciIsInRva2VuX3N0cmluZyIsInRva2VuX2J1ZmZlciIsImlnbm9yZV9jaGFyIiwic3RvcmVfY2hhciIsImRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUiLCJpbmFtZSIsInNjYW5fY2xvc2VfYXRfZW5kIiwic2Nhbl9yYWlzZV9hdF9lbmQiLCJmcm9tX2ljIiwic2Nhbl9jbG9zZV9pYyIsImVvZiIsIm9wZW5faW5fZmlsZSIsImljJDAiLCJtZW1vIiwibWVtb19mcm9tX2NoYW5uZWwiLCJiYWRfaW5wdXQiLCJiYWRfaW5wdXRfZXNjYXBlIiwiYmFkX3Rva2VuX2xlbmd0aCIsIm1lc3NhZ2UiLCJiYWRfaGV4X2Zsb2F0IiwiY2hhcmFjdGVyX21pc21hdGNoIiwiY2kiLCJjaGVja19jaGFyIiwiY2hlY2tfdGhpc19jaGFyIiwidG9rZW5fY2hhciIsInRva2VuX2Jvb2wiLCJpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciIsInRva2VuX2ludF9saXRlcmFsIiwiY29udiIsInRva2VuX2Zsb2F0Iiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIiLCJzY2FuX2RlY2ltYWxfZGlnaXRfcGx1cyIsInNjYW5fZGlnaXRfcGx1cyIsImJhc2lzIiwiZGlnaXRwIiwid2lkdGgkMyIsImlzX2JpbmFyeV9kaWdpdCIsImlzX29jdGFsX2RpZ2l0IiwiaXNfaGV4YV9kaWdpdCIsInNjYW5fc2lnbiIsInNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbCIsInNjYW5faW50X2NvbnZlcnNpb24iLCJzY2FuX2ZyYWN0aW9uYWxfcGFydCIsInNjYW5fZXhwb25lbnRfcGFydCIsInNjYW5fZmxvYXQiLCJwcmVjaXNpb24iLCJwcmVjaXNpb24kMCIsImNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIiwic2Nhbl9oZXhfZmxvYXQiLCJ3aWR0aCQ0Iiwid2lkdGgkNSIsIndpZHRoJDYiLCJ3aWR0aCQxMCIsIndpZHRoJDciLCJ3aWR0aCQ4Iiwid2lkdGgkOSIsInNjYW5fY2FtbF9mbG9hdF9yZXN0Iiwid2lkdGhfcHJlY2lzaW9uIiwiZnJhY193aWR0aCIsInNjYW5fY2FtbF9mbG9hdCIsInNjYW5fc3RyaW5nIiwic3RwIiwiaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciIsImNoZWNrX25leHRfY2hhciIsInNjYW5fYmFja3NsYXNoX2NoYXIiLCJjMCIsImdldF9kaWdpdCQwIiwiYzEkMCIsImMyJDAiLCJnZXRfZGlnaXQiLCJzY2FuX2NhbWxfc3RyaW5nIiwiZmluZF9zdG9wJDAiLCJza2lwX3NwYWNlcyIsImZpbmRfc3RvcCIsInNjYW5fY2hhcnNfaW5fY2hhcl9zZXQiLCJzY2FuX2luZGljIiwic2Nhbl9jaGFycyIsInNjYW5mX2JhZF9pbnB1dCIsIndpZHRoX29mX3BhZF9vcHQiLCJzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IiwiZm10aW5nIiwidGFrZV9mb3JtYXRfcmVhZGVycyQwIiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyQwIiwicmVhZGVyIiwibmV3X2siLCJyZWFkZXJzX3Jlc3QiLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzIiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyIsIm1ha2Vfc2NhbmYiLCJyZWFkZXJzIiwic2NhbiQwIiwic3RyX3Jlc3QiLCJwYWRfcHJlY19zY2FuZiIsInNjYW4kMSIsInNjYW4kMiIsInNjYW4kMyIsInNjYW4kNCIsImNvbnYkMCIsInNjYW4kNSIsImNvbnYkMSIsInNjYW4kNiIsImNvbnYkMiIsInNjYW4kNyIsInNjYW4kOCIsImZtdGluZ19saXQkMCIsInN0cCQwIiwicyQyIiwic3RyX3Jlc3QkMCIsImFyZ19yZXN0Iiwia3NjYW5mIiwiZWYiLCJleGMkMCIsImV4YyIsImFyZ3MkMSIsImFyZ3MkMCIsImJzY2FuZiIsImtzc2NhbmYiLCJzc2NhbmYiLCJzY2FuZiIsImJzY2FuZl9mb3JtYXQiLCJmb3JtYXQiLCJzc2NhbmZfZm9ybWF0IiwiZm9ybWF0X2Zyb21fc3RyaW5nIiwidW5lc2NhcGVkIiwia2ZzY2FuZiIsImZzY2FuZiIsInJlZ2lzdGVyIiwicmVnaXN0ZXJfZXhjZXB0aW9uIiwibyQwIiwicHVibGljX21ldGhvZF9sYWJlbCIsInRhZyIsImNvbXBhcmUkMCIsImNvbXBhcmUkMSIsImR1bW15X3RhYmxlIiwidGFibGVfY291bnQiLCJkdW1teV9tZXQiLCJpbml0aWFsX29iamVjdF9zaXplIiwiZml0X3NpemUiLCJuZXdfdGFibGUiLCJwdWJfbGFiZWxzIiwibWV0aG9kcyIsImFycmF5IiwibmV3X3NpemUiLCJvbGRfc2l6ZSIsIm5ld19idWNrIiwibWV0aG9kX2NvdW50IiwiaW5zdF92YXJfY291bnQiLCJuZXdfbWV0aG9kIiwidGFibGUiLCJnZXRfbWV0aG9kX2xhYmVsIiwibGFiZWwiLCJnZXRfbWV0aG9kX2xhYmVscyIsIm5hbWVzIiwic2V0X21ldGhvZCIsImVsZW1lbnQiLCJnZXRfbWV0aG9kIiwiYXJyIiwibmFycm93IiwidmFycyIsInZpcnRfbWV0aHMiLCJjb25jcl9tZXRocyIsInZhcnMkMCIsInZpcnRfbWV0aHMkMCIsImNvbmNyX21ldGhzJDAiLCJ2aXJ0X21ldGhfbGFicyIsImNvbmNyX21ldGhfbGFicyIsImxhYiIsInR2YXJzIiwiYnlfbmFtZSIsImJ5X2xhYmVsIiwibWV0IiwiaG0iLCJ3aWRlbiIsInNhdmVkX3ZhcnMiLCJzYXZlZF9oaWRkZW5fbWV0aHMiLCJuZXdfdmFyaWFibGUiLCJ0b19hcnJheSIsIm5ld19tZXRob2RzX3ZhcmlhYmxlcyIsIm1ldGhzIiwidmFscyIsIm1ldGhzJDAiLCJubWV0aHMiLCJudmFscyIsImdldF92YXJpYWJsZSIsImdldF92YXJpYWJsZXMiLCJhZGRfaW5pdGlhbGl6ZXIiLCJjcmVhdGVfdGFibGUiLCJwdWJsaWNfbWV0aG9kcyIsInRhZ3MiLCJpbml0X2NsYXNzIiwiaW5oZXJpdHMiLCJjbGEiLCJzdXBlciQwIiwibm0iLCJtYWtlX2NsYXNzIiwicHViX21ldGhzIiwiY2xhc3NfaW5pdCIsImVudl9pbml0IiwibWFrZV9jbGFzc19zdG9yZSIsImluaXRfdGFibGUiLCJkdW1teV9jbGFzcyIsImxvYyIsInVuZGVmIiwiY3JlYXRlX29iamVjdCIsImNyZWF0ZV9vYmplY3Rfb3B0Iiwib2JqXzAiLCJpdGVyX2YiLCJydW5faW5pdGlhbGl6ZXJzIiwiaW5pdHMiLCJydW5faW5pdGlhbGl6ZXJzX29wdCIsImNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaSIsImJ1aWxkX3BhdGgiLCJrZXlzIiwibG9va3VwX3RhYmxlcyIsInJvb3QiLCJyb290X2RhdGEiLCJ0YWJsZXMkMCIsInRhYmxlcyQxIiwidGFibGVzX2RhdGEiLCJuZXdfY2FjaGUiLCJzZXRfbWV0aG9kcyIsImNsbyIsIngkMjAiLCJjbG8kMCIsIm4kMzgiLCJlJDEwIiwibiQzNyIsIm4kMzYiLCJuJDIiLCJuJDM1IiwiZiQyMCIsIm4kMyIsImYkMTkiLCJuJDM0IiwibiQ0IiwiZiQxOCIsImUkOSIsIm4kMzMiLCJuJDUiLCJmJDE3IiwibiQzMiIsImYkMTYiLCJ5JDAiLCJuJDYiLCJmJDE1IiwibiQzMSIsIm4kNyIsImYkMTQiLCJlJDgiLCJuJDMwIiwibiQ4IiwiZiQxMyIsIm4kMjkiLCJuJDkiLCJmJDEyIiwibiQyOCIsImYkOCIsImUkMiIsIm4kMTAiLCJmJDExIiwiZSQ3IiwibiQyNyIsImYkOSIsIm4kMTEiLCJmJDEwIiwibiQyNiIsIm4kMTIiLCJuJDI1IiwibiQxMyIsIm4kMjQiLCJtJDEyIiwibiQxNCIsImUkMyIsIm4kMjMiLCJlJDYiLCJtJDExIiwibiQxNSIsIm0kMSIsIm4kMjIiLCJtJDEwIiwibSQyIiwibSQ5IiwibSQzIiwibiQxNiIsIm0kOCIsIm4kMjEiLCJtJDQiLCJlJDQiLCJuJDE3IiwibSQ3IiwiZSQ1IiwibiQyMCIsIm0kNSIsIm4kMTgiLCJtJDYiLCJuJDE5IiwiaW5pdF9tb2RfYmxvY2siLCJjb21wcyQwIiwibW9kdSIsInNoYXBlIiwiZm4kMCIsImNvbXBzIiwiaW5pdF9tb2QiLCJ1cGRhdGVfbW9kX2Jsb2NrIiwiY2wiLCJ1cGRhdGVfbW9kIiwiaW5pdGlhbF9idWZmZXIiLCJidWZmZXIiLCJidWZwb3MiLCJyZXNldF9idWZmZXIiLCJzdG9yZSIsIm5ld2J1ZmZlciIsImdldF9zdHJpbmciLCJtYWtlX2xleGVyIiwia2V5d29yZHMiLCJrd2RfdGFibGUiLCJpZGVudF9vcl9rZXl3b3JkIiwia2V5d29yZF9vcl9lcnJvciIsIm5leHRfdG9rZW4iLCJlc2NhcGUiLCJjb21tZW50IiwibnVtYmVyIiwiaWRlbnQyIiwiZXhwb25lbnRfcGFydCIsImVuZF9leHBvbmVudF9wYXJ0IiwiYzMiLCJoa2V5IiwiY2xlYW4iLCJkb19idWNrZXQiLCJpbnNlcnRfYnVja2V0IiwiY29udGFpbmVyIiwicmVtb3ZlX2J1Y2tldCIsImhrIiwibmV3X2QiLCJidWNrZXRfbGVuZ3RoX2FsaXZlIiwic3RhdHNfYWxpdmUiLCJnZXRfZGF0YV9jb3B5Iiwic2V0X2RhdGEiLCJ1bnNldF9kYXRhIiwiY2hlY2tfZGF0YSIsImJsaXRfZGF0YSIsImVwaCIsInF1ZXJ5Iiwic2V0X2tleV9kYXRhIiwibWFrZSQwIiwidGVzdF9rZXkiLCJ0JDAiLCJnZXRfa2V5MSIsImdldF9rZXkxX2NvcHkiLCJzZXRfa2V5MSIsInVuc2V0X2tleTEiLCJjaGVja19rZXkxIiwiZ2V0X2tleTIiLCJnZXRfa2V5Ml9jb3B5Iiwic2V0X2tleTIiLCJ1bnNldF9rZXkyIiwiY2hlY2tfa2V5MiIsImJsaXRfa2V5MSIsImJsaXRfa2V5MiIsImJsaXRfa2V5MTIiLCJnZXRfZGF0YSQwIiwiZ2V0X2RhdGFfY29weSQwIiwic2V0X2RhdGEkMCIsInVuc2V0X2RhdGEkMCIsImNoZWNrX2RhdGEkMCIsImJsaXRfZGF0YSQwIiwibWFrZSQxIiwia2V5MSIsImtleTIiLCJxdWVyeSQwIiwiazIkMCIsImsxJDAiLCJlcXVhbCQwIiwibWFrZSQyIiwiYWRkJDAiLCJ0ZXN0X2tleXMiLCJyZW1vdmUkMCIsImZpbmQkMCIsImxlbmd0aCQwIiwiY2xlYXIkMCIsImNyZWF0ZSQxIiwibGVuZ3RoJDEiLCJnZXRfa2V5JDAiLCJnZXRfa2V5X2NvcHkkMCIsInNldF9rZXkkMCIsInVuc2V0X2tleSQwIiwiY2hlY2tfa2V5JDAiLCJibGl0X2tleSQwIiwiZ2V0X2RhdGEkMSIsImdldF9kYXRhX2NvcHkkMSIsInNldF9kYXRhJDEiLCJ1bnNldF9kYXRhJDEiLCJjaGVja19kYXRhJDEiLCJibGl0X2RhdGEkMSIsIm1ha2UkMyIsInF1ZXJ5JDEiLCJraSIsImswIiwibWFrZSQ0IiwiYWRkJDEiLCJ0ZXN0X2tleXMkMCIsInJlbW92ZSQxIiwiZmluZCQxIiwibGVuZ3RoJDIiLCJjbGVhciQxIiwibnVsbCQwIiwiY3VycmVudF9kaXJfbmFtZSIsInBhcmVudF9kaXJfbmFtZSIsImRpcl9zZXAiLCJxdW90ZXF1b3RlIiwibnVsbCQxIiwiY3VycmVudF9kaXJfbmFtZSQwIiwicGFyZW50X2Rpcl9uYW1lJDAiLCJkaXJfc2VwJDAiLCJudWxsJDIiLCJjdXJyZW50X2Rpcl9uYW1lJDEiLCJwYXJlbnRfZGlyX25hbWUkMSIsImRpcl9zZXAkMSIsImdlbmVyaWNfYmFzZW5hbWUiLCJpc19kaXJfc2VwIiwiZ2VuZXJpY19kaXJuYW1lIiwiaXNfcmVsYXRpdmUiLCJpc19pbXBsaWNpdCIsImNoZWNrX3N1ZmZpeCIsInN1ZmYiLCJjaG9wX3N1ZmZpeF9vcHQiLCJsZW5fZiIsInRlbXBfZGlyX25hbWUiLCJxdW90ZSIsInF1b3RlX2NvbW1hbmQiLCJiYXNlbmFtZSIsImRpcm5hbWUiLCJpc19kaXJfc2VwJDAiLCJpc19yZWxhdGl2ZSQwIiwiaXNfaW1wbGljaXQkMCIsImNoZWNrX3N1ZmZpeCQwIiwiY2hvcF9zdWZmaXhfb3B0JDAiLCJ0ZW1wX2Rpcl9uYW1lJDAiLCJxdW90ZSQwIiwibG9vcCQwIiwibG9vcF9icyIsImFkZF9icyIsInF1b3RlX2NtZF9maWxlbmFtZSIsInF1b3RlX2NvbW1hbmQkMCIsImRyaXZlX2FuZF9wYXRoIiwiZGlybmFtZSQwIiwicGF0aCIsImRyaXZlIiwiZGlyIiwiYmFzZW5hbWUkMCIsImJhc2VuYW1lJDEiLCJkaXJuYW1lJDEiLCJudWxsJDMiLCJjdXJyZW50X2Rpcl9uYW1lJDIiLCJwYXJlbnRfZGlyX25hbWUkMiIsImRpcl9zZXAkMiIsImlzX2Rpcl9zZXAkMSIsImlzX3JlbGF0aXZlJDEiLCJpc19pbXBsaWNpdCQxIiwiY2hlY2tfc3VmZml4JDEiLCJjaG9wX3N1ZmZpeF9vcHQkMSIsInRlbXBfZGlyX25hbWUkMSIsInF1b3RlJDEiLCJxdW90ZV9jb21tYW5kJDEiLCJiYXNlbmFtZSQyIiwiZGlybmFtZSQyIiwiY2hvcF9zdWZmaXgiLCJleHRlbnNpb25fbGVuIiwiaTAiLCJleHRlbnNpb24iLCJjaG9wX2V4dGVuc2lvbiIsInJlbW92ZV9leHRlbnNpb24iLCJ0ZW1wX2ZpbGVfbmFtZSIsInRlbXBfZGlyIiwicm5kIiwiY3VycmVudF90ZW1wX2Rpcl9uYW1lIiwic2V0X3RlbXBfZGlyX25hbWUiLCJnZXRfdGVtcF9kaXJfbmFtZSIsInRlbXBfZmlsZSIsIm9wZW5fdGVtcF9maWxlIiwic3RoJDAiLCJwZXJtcyIsInN0aCQxIiwibmVnIiwiY29uaiIsIm11bCIsImRpdiIsImludiIsIm5vcm0yIiwibm9ybSIsInEkMCIsInBvbGFyIiwic3FydCIsInckMCIsImV4cCIsImxvZyIsInBvdyIsImtpbmRfc2l6ZV9pbl9ieXRlcyIsImNsb29wIiwiaWR4IiwiY29sIiwiZmxvb3AiLCJsYXlvdXQiLCJkaW1zIiwic2l6ZV9pbl9ieXRlcyIsInNpemVfaW5fYnl0ZXMkMCIsIm9mX3ZhbHVlIiwiZGltIiwic2l6ZV9pbl9ieXRlcyQxIiwic2xpY2UiLCJpbml0JDAiLCJvZl9hcnJheSIsImJhIiwiZGltMSIsImRpbTIiLCJzaXplX2luX2J5dGVzJDIiLCJzbGljZV9sZWZ0Iiwic2xpY2VfcmlnaHQiLCJpbml0JDEiLCJvZl9hcnJheSQwIiwicm93IiwiY3JlYXRlJDIiLCJkaW0zIiwic2l6ZV9pbl9ieXRlcyQzIiwic2xpY2VfbGVmdF8xIiwic2xpY2VfcmlnaHRfMSIsInNsaWNlX2xlZnRfMiIsInNsaWNlX3JpZ2h0XzIiLCJpbml0JDIiLCJvZl9hcnJheSQxIiwiYXJyYXkwX29mX2dlbmFycmF5IiwiYXJyYXkxX29mX2dlbmFycmF5IiwiYXJyYXkyX29mX2dlbmFycmF5IiwiYXJyYXkzX29mX2dlbmFycmF5IiwicmVzaGFwZV8wIiwicmVzaGFwZV8xIiwicmVzaGFwZV8yIiwicmVzaGFwZV8zIiwib3Blbl9iaW4iLCJvcGVuX3RleHQiLCJvcGVuX2dlbiIsIndpdGhfb3BlbiIsIm9wZW5mdW4iLCJ3aXRoX29wZW5fYmluIiwid2l0aF9vcGVuX3RleHQiLCJ3aXRoX29wZW5fZ2VuIiwic2VlayIsImNsb3NlIiwiY2xvc2Vfbm9lcnIiLCJyZWFkX3VwdG8iLCJlbnN1cmUiLCJuZXdfbGVuJDAiLCJuZXdfbGVuJDEiLCJpbnB1dF9hbGwiLCJjaHVua19zaXplIiwiaW5pdGlhbF9zaXplJDAiLCJpbml0aWFsX3NpemUkMSIsIm5yZWFkIiwiYnVmJDIiLCJidWYkMCIsImJ1ZiQxIiwicmVtIiwic2V0X2JpbmFyeV9tb2RlIiwidmVyc2lvbiIsImdpdF92ZXJzaW9uIiwicmFpc2UiLCJ0eXBlX29mIiwieCIsImluc3RhbmNlX29mIiwiY29uc3RyIiwibnVsbCQwIiwidW5kZWZpbmVkJDAiLCJnbG9iYWwiLCJhcnJheV9tYWtlIiwibiIsImFycmF5X2dldCIsImFycmF5X3NldCIsImFycmF5X29mX2pzX2Zyb20iLCJmIiwib2JqcyIsInN0YXJ0IiwiaSIsImkkMCIsImFycmF5X29mX2pzIiwiYXJyYXlfdG9fanMiLCJhcnIiLCJhIiwibGlzdF9vZl9qc19mcm9tIiwibGlzdF9vZl9qcyIsImxpc3RfdG9fanMiLCJsIiwib3B0aW9uX29mX2pzIiwib3B0aW9uX3RvX2pzIiwidW5pdF90b19qcyIsInVuaXRfb2ZfanMiLCJzZWxmXzEiLCJoYXNfcHJvcGVydHkiLCJvIiwiZW1wdHlfb2JqIiwiaXRlcl9wcm9wZXJ0aWVzIiwiYXBwbHlfYXJyIiwiY2FsbF9hcnIiLCJzIiwiaXNfbnVsbCIsIm9ial90eXBlIiwidF90b19qcyIsInRfb2ZfanMiLCJ0X3RvX2pzJDAiLCJ0X29mX2pzJDAiLCJ0X3RvX2pzJDEiLCJ0X29mX2pzJDEiLCJ0X3RvX2pzJDIiLCJ0X29mX2pzJDIiLCJuYW1lIiwibWVzc2FnZSIsInN0YWNrIiwidG9fc3RyaW5nIiwieCIsImNzdCQwIiwia2V5JDI0Iiwia2V5JDIzIiwia2V5JDIyIiwia2V5JDIxIiwia2V5JDE5Iiwia2V5JDIwIiwia2V5JDE3Iiwia2V5JDE4Iiwia2V5JDEiLCJrZXkkMiIsIm5hbWUiLCJrZXkkMyIsImtleSIsImtleSQwIiwia2V5JDQiLCJrZXkkNSIsImtleSQ2Iiwia2V5JDciLCJrZXkkOCIsImtleSQ5Iiwia2V5JDEwIiwia2V5JDExIiwia2V5JDEyIiwia2V5JDEzIiwiYXJnIiwibmFtZSQwIiwia2V5JDE0Iiwia2V5JDE1Iiwia2V5JDE2Iiwic3ZnX25zIiwiZWNobyIsIm1zZyIsImJhdGNoIiwibCIsIm1hcCIsImYiLCJiaW5kIiwiZmllbGQiLCJkIiwibWV0aG9kIiwiYmluZCQwIiwibGV0JDAiLCJjb25zdCQwIiwiZmFjdG9yIiwibWFwJDAiLCJmJDAiLCJtc2ckMCIsImxldCQxIiwicGFpciIsImQxIiwiZDIiLCJ4MSIsIngyIiwiYXBwIiwiZmYiLCJtYXAyIiwibWFwX3NvbWUiLCJzdHJpbmciLCJpbnQkMCIsImZsb2F0JDAiLCJib29sIiwidW5pdCIsIm9iamVjdCIsImxpc3QiLCJmYWlsIiwiZXJyb3IiLCJ0cnkkMCIsInNoaWZ0X2tleSIsImN0cmxfa2V5IiwiYWx0X2tleSIsImJ1dHRvbnMiLCJwYWdlX3kiLCJwYWdlX3giLCJsZWZ0X3RvcCIsInkiLCJsZWZ0X3RvcCQwIiwiZ2V0IiwieCQwIiwiZXJyIiwiZWxlbWVudF94IiwiZWxlbWVudF95IiwidG9wIiwibGVmdCIsImQkMSIsImQkMCIsIm1vdXNlX2V2ZW50IiwiZiQxIiwid2hpY2giLCJrZXlfZXZlbnQiLCJmJDIiLCJzZWxlY3Rpb25fZW5kIiwic2VsZWN0aW9uX3N0YXJ0IiwidGV4dCIsImQkMiIsInBhc3RlX2V2ZW50Iiwib25fd2l0aF9vcHRpb25zIiwiZXZlbnRfdHlwZSIsImRlY29kZXIiLCJvbiIsInByZXZlbnRfZGVmYXVsdCIsInN0b3BfcHJvcGFnYXRpb24iLCJwcmV2ZW50X2RlZmF1bHQkMCIsInN0b3BfcHJvcGFnYXRpb24kMCIsIm9uX2NhbmNlbCIsIm9uX2pzX3dpdGhfb3B0aW9ucyIsImhhbmRsZXIiLCJvIiwib25fanMiLCJlIiwib25tb3VzZWV2ZW50IiwidHlwZSIsIm9ubW91c2VldmVudF9jYW5jZWwiLCJvbm1vdXNlZG93biIsIm9ubW91c2Vkb3duX2NhbmNlbCIsIm9ubW91c2V1cCIsIm9uY2xpY2siLCJvbmNsaWNrX2NhbmNlbCIsIm9uZGJsY2xpY2siLCJvbmNvbnRleHRtZW51Iiwib25tb3VzZW1vdmUiLCJvbm1vdXNlZW50ZXIiLCJjdXJyZW50X3RhcmdldCIsInRhcmdldCIsIm9ubW91c2VsZWF2ZSIsIm9ubW91c2VvdmVyIiwib25mb2N1cyIsIm9uYmx1ciIsIm9uaW5wdXQiLCJvbmNoYW5nZSIsIm9uY2hhbmdlX2luZGV4Iiwib25jaGFuZ2VfY2hlY2tlZCIsIm9ua2V5ZXZlbnQiLCJvbmtleWV2ZW50X2NhbmNlbCIsIm9ua2V5ZG93biIsIm9ua2V5ZG93bl9jYW5jZWwiLCJvbmtleXVwIiwib25rZXl1cF9jYW5jZWwiLCJvbnBhc3RlIiwib25jdXN0b21ldmVudCIsInN0cl9wcm9wIiwiayIsInYiLCJpbnRfcHJvcCIsImJvb2xfcHJvcCIsImZsb2F0X3Byb3AiLCJzdHlsZSIsImF0dHIiLCJpbnRfYXR0ciIsImZsb2F0X2F0dHIiLCJzY3JvbGxfdG9fc2hvdyIsImFsaWduX3RvcCIsImF1dG9mb2N1cyIsImF1dG9mb2N1c19jb3VudGVyIiwiYXV0b2ZvY3VzX2lmX3Zpc2libGUiLCJhdXRvc3VibWl0Iiwic2VsZWN0IiwiY2xhc3MkMCIsInR5cGVfYnV0dG9uIiwidmFsdWUiLCJkaXNhYmxlZCIsImFkZF9jbGFzcyIsImF0dHJzIiwiaGFzX2NsYXNzTmFtZSIsImEiLCJzIiwib3B0IiwidHh0Iiwic3RoIiwiZnJhZ21lbnQiLCJjaGlsZHJlbiIsImVsdCIsInRhZyIsIm5zIiwic3RoJDAiLCJrJDAiLCJzdmdfZWx0IiwiZGl2IiwiaW5wdXQiLCJ0eHRfc3BhbiIsIm1hcF9hdHRyIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZXMkMCIsIm1hcCQxIiwiY2hpbGQiLCJtZW1vIiwiY3VzdG9tIiwicHJvcGFnYXRlX2V2ZW50cyIsInJldHVybiQwIiwibW9kZWwiLCJjIiwiYXBwJDAiLCJpbml0IiwidXBkYXRlIiwidmlldyIsInNpbXBsZV9hcHAiLCJ1cGRhdGUkMCIsImluaXQkMCIsInRvX2h0bWwiLCJ2ZG9tIiwiYiIsImF1eCIsImNoaWxkcmVuJDAiLCJzdHlsZXMiLCJ2YWx1ZSQwIiwiaSIsInMkMCIsInZhbHVlJDEiLCJuYW1lJDEiLCJ2YWx1ZSQyIiwibmFtZSQyIiwic3R5bGVzJDAiLCJhdHRycyQwIiwiYXR0cnMkMSIsImF0dHJzJDIiLCJpMCIsImJ1ZiIsInUiLCJhdHRycyQzIiwidGhlbiIsImVycm9yIiwic3VjY2VzcyIsIm9qcyIsImFscGhhX29mX2pzIiwieDEiLCJ4IiwieDQiLCJ0X29mX2pzIiwieDgiLCJ0X3RvX2pzIiwieDciLCJsZW5ndGgiLCJ4OSIsImtleSIsIngxMSIsIngxMCIsImdldF9pdGVtIiwieDE0IiwieDEzIiwic2V0X2l0ZW0iLCJ4MTgiLCJ4MTYiLCJ4MTciLCJyZW1vdmVfaXRlbSIsIngyMCIsIngxOSIsImNsZWFyIiwieDIxIiwidF9vZl9qcyQwIiwieDIzIiwidF90b19qcyQwIiwieDIyIiwibmV3X3JlZ19leHAiLCJ4MjQiLCJ4MjUiLCJ4MjYiLCJ4MjciLCJ0X29mX2pzJDEiLCJ4MjkiLCJ0X3RvX2pzJDEiLCJ4MjgiLCJvZl9zdHJpbmciLCJ0b19zdHJpbmciLCJsZW5ndGgkMCIsIngzMCIsImNoYXJfY29kZV9hdCIsIngzMiIsIngzMSIsInRvX2xvd2VyX2Nhc2UiLCJ4MzMiLCJ0b191cHBlcl9jYXNlIiwieDM0IiwiY29uY2F0IiwieDM4IiwieDM1IiwieDM2IiwieDM3IiwiaW5jbHVkZXMiLCJ4NDEiLCJ4NDAiLCJlbmRzX3dpdGgiLCJ4NDMiLCJ4NDIiLCJpbmRleF9vZiIsIng0NSIsIng0NCIsInJlcGVhdCIsIng0NyIsIng0NiIsInNlYXJjaCIsIng0OSIsIng0OCIsInRyaW0iLCJ4NTAiLCJ0X29mX2pzJDIiLCJ4NTIiLCJ0X3RvX2pzJDIiLCJ4NTEiLCJuZXdfZGF0ZSIsIng1MyIsIm5vdyIsInBhcnNlIiwieDU0IiwiZ2V0X2RhdGUiLCJ4NTUiLCJnZXRfZGF5IiwieDU2IiwiZ2V0X2Z1bGxfeWVhciIsIng1NyIsImdldF9ob3VycyIsIng1OCIsImdldF9taWxsaXNlY29uZHMiLCJ4NTkiLCJnZXRfbWludXRlcyIsIng2MCIsImdldF9tb250aCIsIng2MSIsImdldF9zZWNvbmRzIiwieDYyIiwiZ2V0X3RpbWUiLCJ4NjMiLCJnZXRfdGltZXpvbmVfb2Zmc2V0IiwieDY0IiwiZ2V0X1VUQ19kYXRlIiwieDY1IiwiZ2V0X1VUQ19kYXkiLCJ4NjYiLCJnZXRfVVRDX2Z1bGxfeWVhciIsIng2NyIsImdldF9VVENfaG91cnMiLCJ4NjgiLCJnZXRfVVRDX21pbGxpc2Vjb25kcyIsIng2OSIsImdldF9VVENfbWludXRlcyIsIng3MCIsImdldF9VVENfbW9udGgiLCJ4NzEiLCJnZXRfVVRDX3NlY29uZHMiLCJ4NzIiLCJnZXRfeWVhciIsIng3MyIsInNldF9kYXRlIiwieDc1IiwieDc0Iiwic2V0X2Z1bGxfeWVhciIsIng3NyIsIng3NiIsInNldF9ob3VycyIsIng3OSIsIng3OCIsInNldF9taWxsaXNlY29uZHMiLCJ4ODEiLCJ4ODAiLCJzZXRfbWludXRlcyIsIng4MyIsIng4MiIsInNldF9tb250aCIsIng4NSIsIng4NCIsInNldF9zZWNvbmRzIiwieDg3IiwieDg2Iiwic2V0X3RpbWUiLCJ4ODkiLCJ4ODgiLCJzZXRfVVRDX2RhdGUiLCJ4OTEiLCJ4OTAiLCJzZXRfVVRDX2Z1bGxfeWVhciIsIng5MyIsIng5MiIsInNldF9VVENfaG91cnMiLCJ4OTUiLCJ4OTQiLCJzZXRfVVRDX21pbGxpc2Vjb25kcyIsIng5NyIsIng5NiIsInNldF9VVENfbWludXRlcyIsIng5OSIsIng5OCIsInNldF9VVENfbW9udGgiLCJ4MTAxIiwieDEwMCIsInNldF9VVENfc2Vjb25kcyIsIngxMDMiLCJ4MTAyIiwic2V0X3llYXIiLCJ4MTA1IiwieDEwNCIsInRvX2RhdGVfc3RyaW5nIiwieDEwNiIsInRvX0dNVF9zdHJpbmciLCJ4MTA3IiwidG9fSVNPX3N0cmluZyIsIngxMDgiLCJ0b19sb2NhbGVfc3RyaW5nIiwieDEwOSIsInRvX3N0cmluZyQwIiwieDExMCIsInRvX3RpbWVfc3RyaW5nIiwieDExMSIsInRvX1VUQ19zdHJpbmciLCJ4MTEyIiwidF9vZl9qcyQzIiwieDExNCIsInRfdG9fanMkMyIsIngxMTMiLCJjcmVhdGUiLCJ4MTE1Iiwib3B0aW9ucyIsIngxMTgiLCJ4MTE5IiwieDEyMCIsIngxMjIiLCJ4MTIxIiwidF9vZl9qcyQ0IiwieDEyNCIsInRfdG9fanMkNCIsIngxMjMiLCJjcmVhdGUkMCIsIngxMjUiLCJ4MTI2IiwieDEyNyIsIngxMjkiLCJ4MTI4Iiwic2l6ZSIsIngxMzAiLCJ0eXBlIiwieDEzMSIsInRleHQiLCJ4MTMyIiwiZiIsInRfb2ZfanMkNSIsIngxMzUiLCJ0X3RvX2pzJDUiLCJ4MTM0Iiwib3B0aW9ucyQwIiwieDEzOCIsIngxMzkiLCJ4MTQwIiwieDE0MiIsIngxNDEiLCJjcmVhdGUkMSIsIngxNDMiLCJ4MTQ1IiwieDE0NiIsIm5hbWUiLCJ4MTQ3IiwidF9vZl9qcyQ2IiwieDE0OSIsInRfdG9fanMkNiIsIngxNDgiLCJmaWxlcyIsIngxNTAiLCJnZXRfZGF0YSIsIngxNTMiLCJ4MTUyIiwidF9vZl9qcyQ3IiwieDE1NSIsInRfdG9fanMkNyIsIngxNTQiLCJraW5kX3RvX2pzIiwieDE1NiIsIngxNTciLCJ0YXJnZXQiLCJ4MTYxIiwicmVsYXRlZF90YXJnZXQiLCJ4MTYyIiwieDE2MyIsInByZXZlbnRfZGVmYXVsdCIsIngxNjQiLCJzdG9wX3Byb3BhZ2F0aW9uIiwieDE2NSIsInR5cGUkMCIsIngxNjYiLCJpbml0X2V2ZW50IiwieDE3MCIsIngxNjciLCJ4MTY4IiwieDE2OSIsImNsaWVudF94IiwieDE3MSIsImNsaWVudF95IiwieDE3MiIsInBhZ2VfeCIsIngxNzMiLCJwYWdlX3kiLCJ4MTc0Iiwic2NyZWVuX3giLCJ4MTc1Iiwic2NyZWVuX3kiLCJ4MTc2IiwibW92ZW1lbnRfeCIsIngxNzciLCJtb3ZlbWVudF95IiwieDE3OCIsImJ1dHRvbnMiLCJ4MTc5IiwiYWx0X2tleSIsIngxODAiLCJjdHJsX2tleSIsIngxODEiLCJzaGlmdF9rZXkiLCJ4MTgyIiwid2hpY2giLCJ4MTgzIiwiY29kZSIsIngxODQiLCJrZXkkMCIsIngxODUiLCJkZWx0YV95IiwieDE4NiIsImRlbHRhX3giLCJ4MTg3IiwiZGF0YV90cmFuc2ZlciIsIngxODgiLCJjbGlwYm9hcmRfZGF0YSIsIngxODkiLCJkYXRhIiwieDE5MCIsIm9yaWdpbiIsIngxOTEiLCJzdGF0ZSIsIngxOTIiLCJ0X29mX2pzJDgiLCJ4MTk0IiwidF90b19qcyQ4IiwieDE5MyIsImhlaWdodCIsIngxOTUiLCJ3aWR0aCIsIngxOTYiLCJsZWZ0IiwieDE5NyIsInJpZ2h0IiwieDE5OCIsInRvcCIsIngxOTkiLCJib3R0b20iLCJ4MjAwIiwidF9vZl9qcyQ5IiwieDIwMiIsInRfdG9fanMkOSIsIngyMDEiLCJ4MjAzIiwieSIsIngyMDQiLCJoZWlnaHQkMCIsIngyMDUiLCJ3aWR0aCQwIiwieDIwNiIsInRfb2ZfanMkMTAiLCJ4MjA4IiwidF90b19qcyQxMCIsIngyMDciLCJzZXQiLCJzdHlsZSIsInByb3AiLCJ2YWx1ZSIsInNldF9jb2xvciIsIngyMDkiLCJ4MjEwIiwic2V0X2JvcmRlciIsIngyMTEiLCJ4MjEyIiwic2V0X2JhY2tncm91bmQiLCJ4MjEzIiwieDIxNCIsInNldF9iYWNrZ3JvdW5kX2NvbG9yIiwieDIxNSIsIngyMTYiLCJzZXRfaGVpZ2h0IiwieDIxNyIsIngyMTgiLCJzZXRfd2lkdGgiLCJ4MjE5IiwieDIyMCIsInNldF9ib3R0b20iLCJ4MjIxIiwieDIyMiIsInNldF9sZWZ0IiwieDIyMyIsIngyMjQiLCJzZXRfdG9wIiwieDIyNSIsIngyMjYiLCJzZXRfcmlnaHQiLCJ4MjI3IiwieDIyOCIsInNldF9wb3NpdGlvbiIsIngyMjkiLCJ4MjMwIiwic2V0X2N1cnNvciIsIngyMzEiLCJ4MjMyIiwic2V0X2Rpc3BsYXkiLCJ4MjMzIiwieDIzNCIsInNldF92aXNpYmlsaXR5IiwieDIzNSIsIngyMzYiLCJnZXQiLCJ1bnNldCIsInRfb2ZfanMkMTEiLCJ4MjM4IiwidF90b19qcyQxMSIsIngyMzciLCJhZGQiLCJ4MjQwIiwieDIzOSIsInJlbW92ZSIsIngyNDIiLCJ4MjQxIiwiY29udGFpbnMiLCJ4MjQ0IiwieDI0MyIsInJlcGxhY2UiLCJ4MjQ3IiwieDI0NSIsIngyNDYiLCJ0b2dnbGUiLCJ4MjUwIiwieDI0OCIsIngyNDkiLCJ0X29mX2pzJDEyIiwieDI1MiIsInRfdG9fanMkMTIiLCJ4MjUxIiwibnVsbCQwIiwiaWQiLCJ4MjUzIiwic2V0X2lkIiwieDI1NCIsIngyNTUiLCJub2RlX3R5cGUiLCJ4MjU5IiwieDI1NyIsImNsb25lX25vZGUiLCJ4MjYxIiwieDI2MCIsImNvbnRhaW5zJDAiLCJ4MjYzIiwieDI2MiIsImFwcGVuZF9jaGlsZCIsIngyNjUiLCJ4MjY0IiwiaW5zZXJ0X2JlZm9yZSIsIngyNjgiLCJ4MjY2IiwieDI2NyIsInJlcGxhY2VfY2hpbGQiLCJ4MjcxIiwieDI2OSIsIngyNzAiLCJyZW1vdmVfY2hpbGQiLCJ4MjczIiwieDI3MiIsImZpcnN0X2NoaWxkIiwieDI3NCIsImxhc3RfY2hpbGQiLCJ4Mjc1IiwibmV4dF9zaWJsaW5nIiwieDI3NiIsInJlbW92ZV9hbGxfY2hpbGRyZW4iLCJjaGlsZCQxIiwiY2hpbGQiLCJjaGlsZCQwIiwiaGFzX2NoaWxkX25vZGVzIiwieDI3NyIsImFkZF9ldmVudF9saXN0ZW5lciIsIngyODIiLCJ4Mjc4IiwieDI3OSIsIngyODEiLCJ4MjgwIiwiYWRkX2NhbmNlbGxhYmxlX2V2ZW50X2xpc3RlbmVyIiwieDI4NiIsIngyODMiLCJ4Mjg1IiwieDI4NCIsImlubmVyX3RleHQiLCJ4MjkxIiwiZ2V0X2VsZW1lbnRzX2J5X3RhZ19uYW1lIiwieDI5MyIsIngyOTIiLCJnZXRfZWxlbWVudHNfYnlfY2xhc3NfbmFtZSIsIngyOTYiLCJ4Mjk1IiwiaGFzX2F0dHJpYnV0ZSIsIngyOTkiLCJ4Mjk4IiwiZ2V0X2F0dHJpYnV0ZSIsIngzMDEiLCJ4MzAwIiwicmVtb3ZlX2F0dHJpYnV0ZSIsIngzMDMiLCJ4MzAyIiwic2V0X2F0dHJpYnV0ZSIsIngzMDYiLCJ4MzA0IiwieDMwNSIsImdldF9ib3VuZGluZ19jbGllbnRfcmVjdCIsIngzMDciLCJnZXRfYm91bmRpbmdfYm94IiwieDMwOCIsImF0dGFjaF9zaGFkb3ciLCJtb2RlIiwiZWxlbWVudCIsIm5vcm1hbGl6ZSIsIngzMTYiLCJ4MzE3Iiwic2V0X3ZhbHVlIiwieDMxOCIsIngzMTkiLCJzZWxlY3QiLCJ4MzIwIiwiZmlsZXMkMCIsIngzMjEiLCJzdWJtaXQiLCJ4MzIzIiwic2hvd19waWNrZXIiLCJ4MzI0Iiwic2VsZWN0ZWRfaW5kZXgiLCJ4MzI1IiwiY2hlY2tlZCIsIngzMjYiLCJzZXRfY2hlY2tlZCIsIngzMjciLCJ4MzI4Iiwibm9kZV92YWx1ZSIsIngzMjkiLCJzZXRfbm9kZV92YWx1ZSIsIngzMzAiLCJ4MzMxIiwicGFyZW50X25vZGUiLCJ4MzMyIiwibm9kZV9uYW1lIiwieDMzMyIsImRpc3BhdGNoX2V2ZW50IiwieDMzNSIsIngzMzQiLCJ4MzM2IiwiaW5uZXJfSFRNTCIsIngzMzciLCJvdXRlcl9IVE1MIiwieDMzOCIsInNldF9pbm5lcl9IVE1MIiwieDMzOSIsIngzNDAiLCJzZXRfdGV4dF9jb250ZW50IiwieDM0MSIsIngzNDIiLCJzZXRfY2xhc3NfbmFtZSIsIngzNDMiLCJ4MzQ0IiwiY2xhc3NfbmFtZSIsIngzNDUiLCJjbGllbnRfd2lkdGgiLCJ4MzQ2IiwiY2xpZW50X2hlaWdodCIsIngzNDciLCJzY3JvbGxfd2lkdGgiLCJ4MzQ4Iiwic2Nyb2xsX2hlaWdodCIsIngzNDkiLCJ3aWR0aCQxIiwieDM1MCIsImhlaWdodCQxIiwieDM1MSIsIm9mZnNldF9wYXJlbnQiLCJ4MzUyIiwib2Zmc2V0X3RvcCIsIngzNTQiLCJvZmZzZXRfbGVmdCIsIngzNTUiLCJvZmZzZXRfd2lkdGgiLCJ4MzU2Iiwib2Zmc2V0X2hlaWdodCIsIngzNTciLCJzY3JvbGxfdG9wIiwieDM1OCIsInNldF9zY3JvbGxfdG9wIiwieDM1OSIsIngzNjAiLCJzY3JvbGxfaW50b192aWV3IiwieDM2MiIsIngzNjEiLCJmb2N1cyIsIngzNjMiLCJibHVyIiwieDM2NCIsImJlaGF2aW9yX3RvX2pzIiwieDM2OSIsInNjcm9sbF9pbnRvX3ZpZXdfb3B0aW9ucyIsIngzNzMiLCJ4MzcyIiwic2Nyb2xsX2J5IiwieDM3OSIsIngzNzgiLCJzZWxlY3Rpb25fc3RhcnQiLCJ4MzgwIiwic2VsZWN0aW9uX2VuZCIsIngzODEiLCJzZXRfc2VsZWN0aW9uX3N0YXJ0IiwieDM4MiIsIngzODMiLCJzZXRfc2VsZWN0aW9uX2VuZCIsIngzODQiLCJ4Mzg1IiwicmVtb3ZlJDAiLCJ4Mzg2IiwiY2xpY2siLCJ4Mzg3IiwicXVlcnlfc2VsZWN0b3IiLCJ4Mzg5IiwieDM4OCIsInF1ZXJ5X3NlbGVjdG9yX2FsbCIsIngzOTEiLCJ4MzkwIiwiY2xhc3NfbGlzdCIsIngzOTMiLCJ0X29mX2pzJDEzIiwieDM5NSIsInRfdG9fanMkMTMiLCJ4Mzk0IiwiY3JlYXRlX2VsZW1lbnQiLCJ4Mzk3IiwieDM5NiIsImNyZWF0ZV9lbGVtZW50X25zIiwieDQwMCIsIngzOTgiLCJ4Mzk5IiwiY3JlYXRlX3RleHRfbm9kZSIsIng0MDIiLCJ4NDAxIiwiY3JlYXRlX2V2ZW50IiwieDQwNCIsIng0MDMiLCJnZXRfZWxlbWVudF9ieV9pZCIsIng0MDYiLCJ4NDA1IiwiZ2V0X2VsZW1lbnRzX2J5X2NsYXNzX25hbWUkMCIsIng0MDkiLCJ4NDA4IiwiYm9keSIsIng0MTEiLCJkb2N1bWVudF9lbGVtZW50IiwieDQxMiIsImFjdGl2ZV9lbGVtZW50IiwieDQxMyIsImNvb2tpZSIsIng0MTQiLCJzZXRfY29va2llIiwieDQxNSIsIng0MTYiLCJzZXRfdGl0bGUiLCJ4NDE3IiwieDQxOCIsIm9wZW4iLCJ4NDI0IiwieDQxOSIsIng0MjAiLCJ4NDIxIiwieDQyMyIsIng0MjIiLCJ3cml0ZSIsIng0MjciLCJ4NDI2Iiwid3JpdGVsbiIsIng0MjkiLCJ4NDI4IiwiY2xvc2UiLCJ4NDMwIiwiZXhlY19jb21tYW5kIiwieDQzMiIsIng0MzEiLCJxdWVyeV9zZWxlY3RvciQwIiwieDQzNCIsIng0MzMiLCJxdWVyeV9zZWxlY3Rvcl9hbGwkMCIsIng0MzYiLCJ4NDM1IiwicmVtb3ZlX2FsbF9zZWxlY3Rpb25fcmFuZ2VzIiwieDQzOCIsInRfb2ZfanMkMTQiLCJ4NDQwIiwidF90b19qcyQxNCIsIng0MzkiLCJsZW5ndGgkMSIsIng0NDEiLCJiYWNrIiwieDQ0MiIsImZvcndhcmQiLCJ4NDQzIiwiZ28iLCJ4NDQ3IiwieDQ0NCIsIng0NDUiLCJ4NDQ1JDAiLCJ4NDQ2IiwicmVwbGFjZV9zdGF0ZSIsIng0NTEiLCJ4NDQ4IiwieDQ0OSIsIng0NTAiLCJwdXNoX3N0YXRlIiwieDQ1NSIsIng0NTIiLCJ4NDUzIiwieDQ1NCIsInRfb2ZfanMkMTUiLCJ4NDU3IiwidF90b19qcyQxNSIsIng0NTYiLCJnZXRfaGFzaCIsInNldF9oYXNoIiwieDQ1OCIsImhvc3QiLCJ4NDU5Iiwic2V0X2hvc3QiLCJ4NDYwIiwieDQ2MSIsImhvc3RuYW1lIiwieDQ2MiIsInNldF9ob3N0bmFtZSIsIng0NjMiLCJ4NDY0IiwiaHJlZiIsInNldF9ocmVmIiwieDQ2NSIsInBhdGhuYW1lIiwieDQ2NiIsInNldF9wYXRobmFtZSIsIng0NjciLCJ4NDY4IiwicG9ydCIsIng0NjkiLCJzZXRfcG9ydCIsIng0NzAiLCJ4NDcxIiwicHJvdG9jb2wiLCJ4NDcyIiwic2V0X3Byb3RvY29sIiwieDQ3MyIsIng0NzQiLCJzZWFyY2gkMCIsIng0NzUiLCJzZXRfc2VhcmNoIiwieDQ3NiIsIng0NzciLCJvcmlnaW4kMCIsIng0NzgiLCJhc3NpZ24iLCJ4NDgwIiwieDQ3OSIsInJlbG9hZCIsIng0ODQiLCJ4NDgxIiwieDQ4MiIsIng0ODMiLCJyZXBsYWNlJDAiLCJ4NDg3IiwieDQ4NiIsInRfb2ZfanMkMTYiLCJ4NDg5IiwidF90b19qcyQxNiIsIng0ODgiLCJhZGRfZXZlbnRfbGlzdGVuZXIkMCIsIng0OTgiLCJ4NDk0IiwieDQ5NSIsIng0OTciLCJ4NDk2IiwiYWRkX2NhbmNlbGxhYmxlX2V2ZW50X2xpc3RlbmVyJDAiLCJ4NTAyIiwieDQ5OSIsIng1MDEiLCJ4NTAwIiwiZG9jdW1lbnQiLCJ4NTA3Iiwic2V0X29ubG9hZCIsIng1MDgiLCJ4NTA5Iiwic2V0X2ludGVydmFsIiwieDUxMiIsIng1MTAiLCJ4NTExIiwieDQ5MyIsInNldF90aW1lb3V0IiwieDUxNSIsIng1MTMiLCJ4NTE0IiwieDQ5MSIsImNsZWFyX3RpbWVvdXQiLCJ4NTE3IiwieDUxNiIsImNsZWFyX2ludGVydmFsIiwieDUxOSIsIng1MTgiLCJyZXF1ZXN0X2FuaW1hdGlvbl9mcmFtZSIsIng1MjIiLCJ4NTIwIiwieDUyMSIsIm9wZW4kMCIsIng1MzIiLCJ4NTIzIiwieDUyNCIsIng1MjUiLCJ4NTI2IiwieDUyNyIsIng1MzEiLCJ4NTMwIiwieDUyOSIsIng1MjgiLCJhbGVydCIsIng1MzUiLCJ4NTM0Iiwic2Vzc2lvbl9zdG9yYWdlIiwieDUzNiIsImxvY2FsX3N0b3JhZ2UiLCJ4NTM4IiwiaW5uZXJfd2lkdGgiLCJ4NTQwIiwiaW5uZXJfaGVpZ2h0IiwieDU0MSIsInBhZ2VfeF9vZmZzZXQiLCJ4NTQyIiwicGFnZV95X29mZnNldCIsIng1NDMiLCJzY3JvbGxfYnkkMCIsIng1NDYiLCJ4NTQ0IiwieDU0NSIsInNjcm9sbF90byIsIng1NDkiLCJ4NTQ3IiwieDU0OCIsInNjcm9sbF90b19vcHRpb25zIiwieDU1NSIsIng1NTQiLCJoaXN0b3J5IiwieDU1NiIsImxvY2F0aW9uIiwieDU1NyIsImZyYW1lX2VsZW1lbnQiLCJ4NTU4IiwiZ2V0X2NvbXB1dGVkX3N0eWxlIiwieDU2MCIsIng1NTkiLCJkZWNvZGVfVVJJX2NvbXBvbmVudCIsIng1NjIiLCJ4NTYxIiwiZXZlbnRfc291cmNlIiwieDU2MyIsInBvc3RfbWVzc2FnZSIsIng1NjYiLCJ4NTY0IiwieDU2NSIsImNvbnRlbnRfd2luZG93IiwieDU2NyIsImNvbnRlbnRfZG9jdW1lbnQiLCJ4NTY5IiwicGFyc2UkMCIsIng1NzEiLCJzdHJpbmdpZnkiLCJ4NTcyIiwidF9vZl9qcyQxNyIsIng1NzciLCJ0X3RvX2pzJDE3IiwieDU3NiIsImNyZWF0ZSQyIiwicmVhZHlfc3RhdGUiLCJ4NTc4IiwieDU3NCIsInJlc3VsdCIsIng1NzkiLCJzZXRfb25sb2FkJDAiLCJ4NTgwIiwieDU4MSIsInJlYWRfYXNfYmluYXJ5X3N0cmluZyIsIng1ODMiLCJ4NTgyIiwicmVhZF9hc190ZXh0IiwieDU4NSIsIng1ODQiLCJyZWFkX2FzX2RhdGFfdXJsIiwieDU4NyIsIng1ODYiLCJ0X29mX2pzJDE4IiwieDU4OSIsInRfdG9fanMkMTgiLCJ4NTg4IiwiY3JlYXRlJDMiLCJvcGVuJDEiLCJ4NTkyIiwieDU5MCIsIng1OTEiLCJzZW5kIiwieDU5NCIsIng1OTMiLCJzZXRfcmVxdWVzdF9oZWFkZXIiLCJ4NTk3IiwieDU5NSIsIng1OTYiLCJnZXRfcmVzcG9uc2VfaGVhZGVyIiwieDU5OSIsIng1OTgiLCJnZXRfYWxsX3Jlc3BvbnNlX2hlYWRlcnMiLCJ4NjAxIiwic2V0X3Jlc3BvbnNlX3R5cGUiLCJ4NjAyIiwieDYwMyIsIm92ZXJyaWRlX21pbWVfdHlwZSIsIng2MDUiLCJ4NjA0Iiwic2V0X3dpdGhfY3JlZGVudGlhbHMiLCJ4NjA2IiwieDYwNyIsInN0YXR1cyIsIng2MTMiLCJzdGF0dXNfdGV4dCIsIng2MTQiLCJyZWFkeV9zdGF0ZSQwIiwieDYxNSIsIng2MTAiLCJyZXNwb25zZV90eXBlIiwieDYxNiIsInJlc3BvbnNlX3RleHQiLCJ4NjE3IiwicmVzcG9uc2UiLCJ4NjE4IiwicmVzcG9uc2VfVVJMIiwieDYxOSIsInNldF9vbnJlYWR5c3RhdGVjaGFuZ2UiLCJ4NjIwIiwieDYyMSIsInRfb2ZfanMkMTkiLCJ4NjIzIiwidF90b19qcyQxOSIsIng2MjIiLCJjcmVhdGUkNCIsIng2MjciLCJ4NjI4IiwieDYyOSIsIng2MzAiLCJzZW5kJDAiLCJ4NjMzIiwieDYzMiIsImNsb3NlJDAiLCJ4NjM5IiwieDYzNCIsIng2MzUiLCJ4NjM2IiwieDYzOCIsIng2MzciLCJiaW5hcnlfdHlwZSIsIng2NDEiLCJzZXRfYmluYXJ5X3R5cGUiLCJ4NjQyIiwieDY0MyIsInJlYWR5X3N0YXRlJDEiLCJ4NjQ0IiwieDYyNSIsImFkZF9ldmVudF9saXN0ZW5lciQxIiwieDY0OSIsIng2NDUiLCJ4NjQ2IiwieDY0OCIsIng2NDciLCJjb2RlJDAiLCJ4NjUyIiwid2luZG93IiwiZG9jdW1lbnQkMCIsImNvbnRleHRfb2ZfanMiLCJ4NjU0IiwiY29udGV4dF90b19qcyIsIng2NTMiLCJncmFkaWVudF9vZl9qcyIsIng2NTYiLCJncmFkaWVudF90b19qcyIsIng2NTUiLCJnZXRfY29udGV4dCIsIm9wdCIsImNhbnZhcyIsInN0aCIsImFscGhhIiwidG9fZGF0YV9VUkwiLCJ4NjY1Iiwic2V0X2ZpbGxfc3R5bGUiLCJ4NjY2IiwieDY2NyIsIng2NjkiLCJ4NjY4Iiwic2V0X3N0cm9rZV9zdHlsZSIsIng2NzAiLCJ4NjcxIiwieDY3MyIsIng2NzIiLCJzZXRfbGluZV93aWR0aCIsIng2NzQiLCJ4Njc1IiwiY3JlYXRlX2xpbmVhcl9ncmFkaWVudCIsIng2ODAiLCJ4Njc2IiwieDY3NyIsIng2NzgiLCJ4Njc5IiwiYWRkX2NvbG9yX3N0b3AiLCJ4NjgzIiwieDY4MSIsIng2ODIiLCJiZWdpbl9wYXRoIiwieDY4NCIsImNsb3NlX3BhdGgiLCJ4Njg1IiwiYXJjIiwieDY5MSIsIng2ODYiLCJ4Njg3IiwieDY4OCIsIng2ODkiLCJ4NjkwIiwibW92ZV90byIsIng2OTQiLCJ4NjkyIiwieDY5MyIsImxpbmVfdG8iLCJ4Njk3IiwieDY5NSIsIng2OTYiLCJmaWxsIiwieDY5OCIsInN0cm9rZSIsIng2OTkiLCJzdHJva2VfcmVjdCIsIng3MDQiLCJ4NzAwIiwieDcwMSIsIng3MDIiLCJ4NzAzIiwiZmlsbF9yZWN0IiwieDcwOSIsIng3MDUiLCJ4NzA2IiwieDcwNyIsIng3MDgiLCJzZXRfZm9udCIsIng3MTAiLCJ4NzExIiwiZmlsbF90ZXh0IiwieDcxNSIsIng3MTIiLCJ4NzEzIiwieDcxNCIsInN0cm9rZV90ZXh0IiwieDcxOSIsIng3MTYiLCJ4NzE3IiwieDcxOCIsInRfb2ZfanMkMjAiLCJ4NzIxIiwidF90b19qcyQyMCIsIng3MjAiLCJ3aWR0aCQyIiwieDcyMiIsIm1lYXN1cmVfdGV4dCIsIng3MjQiLCJ4NzIzIiwicm90YXRlIiwieDcyNiIsIng3MjUiLCJ0cmFuc2xhdGUiLCJ4NzI5IiwieDcyNyIsIng3MjgiLCJzY2FsZSIsIng3MzIiLCJ4NzMwIiwieDczMSIsImNsZWFyX3JlY3QiLCJ4NzM3IiwieDczMyIsIng3MzQiLCJ4NzM1IiwieDczNiIsIm5vdyQwIiwibG9nIiwieDc0MSIsIng3NDAiLCJ0aW1lIiwieDc0MyIsIng3NDIiLCJ0aW1lX2VuZCIsIng3NDUiLCJ4NzQ0IiwiY29uc29sZSIsInRfb2ZfanMkMjEiLCJ4NzQ3IiwidF90b19qcyQyMSIsIng3NDYiLCJmcm9tX2J1ZmZlciIsIng3NDgiLCJjcmVhdGUkNSIsIng3NDkiLCJzZXQkMCIsIng3NTMiLCJ4NzUwIiwieDc1MiIsImxlbmd0aCQyIiwieDc1NCIsInJhbmRvbSIsIng3NTUiLCJ0b19hcnJheSIsIng3NTYiLCJnZXQkMCIsImEiLCJpIiwiZnJvbSIsIng3NTgiLCJ4NzU5IiwieDc2MCIsIm9mX2Jsb2IiLCJ4NzYxIiwib2ZfZmlsZSIsIng3NjIiLCJyZXZva2UiLCJ4NzYzIiwidF9vZl9qcyQyMiIsIng3NjUiLCJ0X3RvX2pzJDIyIiwieDc2NCIsInVuaXRfdHlwZSIsIng3NjYiLCJ2YWx1ZSQwIiwieDc2NyIsInZhbHVlX2FzX3N0cmluZyIsIng3NjgiLCJ2YWx1ZV9pbl9zcGVjaWZpZWRfdW5pdHMiLCJ4NzY5IiwidF9vZl9qcyQyMyIsIng3NzEiLCJ0X3RvX2pzJDIzIiwieDc3MCIsImFuaW1fdmFsIiwieDc3MiIsImJhc2VfdmFsIiwieDc3MyIsImVuY29kZSIsIng3NzQiLCJkZWNvZGUiLCJ4Nzc1IiwidF9vZl9qcyQyNCIsIng3NzciLCJ0X3RvX2pzJDI0IiwieDc3NiIsImJsb2IiLCJ4Nzc4IiwieDc3OSIsImZldGNoIiwieDc4MCIsInRfb2ZfanMkMjUiLCJ4NzgzIiwidF90b19qcyQyNSIsIng3ODIiLCJjcmVhdGUkNiIsIng3ODQiLCJ4Nzg1IiwieDc4NiIsImRlY29kZSQwIiwieDc4OCIsIng3ODciLCJ0X29mX2pzJDI2IiwieDc5MCIsInRfdG9fanMkMjYiLCJ4Nzg5IiwiY2xpZW50X2RhdGFfanNvbiIsIng3OTEiLCJhdHRlc3RhdGlvbl9vYmplY3QiLCJ4NzkyIiwidF9vZl9qcyQyNyIsIng3OTQiLCJ0X3RvX2pzJDI3IiwieDc5MyIsImNsaWVudF9kYXRhX2pzb24kMCIsIng3OTUiLCJhdXRoZW50aWNhdG9yX2RhdGEiLCJ4Nzk2Iiwic2lnbmF0dXJlIiwieDc5NyIsInVzZXJfaGFuZGxlIiwieDc5OCIsInRfb2ZfanMkMjgiLCJ4ODAwIiwidF90b19qcyQyOCIsIng3OTkiLCJ0eXBlJDEiLCJ4ODAxIiwiaWQkMCIsIng4MDIiLCJyYXdfaWQiLCJ4ODAzIiwicmVzcG9uc2UkMCIsIng4MDQiLCJ0X29mX2pzJDI5IiwieDgwNiIsInRfdG9fanMkMjkiLCJ4ODA1IiwicnBfb3B0aW9ucyIsIng4MDkiLCJ4ODEwIiwieDgxMSIsIng4MTMiLCJ4ODEyIiwidXNlcl9vcHRpb25zIiwieDgxNiIsIng4MTciLCJ4ODE4IiwieDgxOSIsIng4MjIiLCJ4ODIxIiwieDgyMCIsImtleV9wYXJhbV90b19qcyIsIng4MjMiLCJrZXlfcGFyYW0iLCJ4ODI1IiwieDgyNiIsIng4MjciLCJ4ODI5IiwieDgyOCIsImF1dGhlbnRpY2F0b3Jfb3B0aW9ucyIsIng4MzIiLCJ4ODMzIiwieDgzNCIsIng4MzUiLCJ4ODM2IiwieDg0MCIsIng4MzkiLCJ4ODM4IiwieDgzNyIsInB1YmxpY19rZXlfb3B0aW9ucyIsIng4NDMiLCJ4ODQ0IiwieDg0NSIsIng4NDYiLCJ4ODQ3IiwieDg0OCIsIng4NDkiLCJ4ODUwIiwieDg1MSIsIng4NjEiLCJ4ODYwIiwieDg1OSIsIng4NTciLCJ4ODU2IiwieDg1NCIsIng4NTUiLCJ4ODUzIiwieDg1MiIsImNyZWF0ZV9vcHRpb25zIiwieDg2NCIsIng4NjUiLCJ4ODY2IiwiY3JlYXRlJDciLCJ4ODY3IiwieDg2OCIsImNyZWRlbnRpYWxfZGVzY3JpcHRvcl90b19qcyIsIng4NjkiLCJjcmVkZW50aWFsX2Rlc2NyaXB0b3IiLCJ4ODcxIiwieDg3MiIsIng4NzMiLCJ4ODc0IiwieDg3NyIsIng4NzYiLCJ4ODc1IiwiZ2V0X3B1YmxpY19rZXlfb3B0aW9ucyIsIng4ODAiLCJ4ODgxIiwieDg4MiIsIng4ODMiLCJ4ODg0IiwieDg4NSIsIng4ODYiLCJ4ODkzIiwieDg5MiIsIng4OTEiLCJ4ODg5IiwieDg4OCIsIng4ODciLCJnZXRfb3B0aW9uc190b19qcyIsIng4OTQiLCJnZXRfb3B0aW9ucyIsIng4OTYiLCJ4ODk3IiwieDg5OCIsImdldCQxIiwieDg5OSIsIng5MDAiLCJibHVyX2V2ZW50IiwiZW1wdHkiLCJzdHJpbmdfb2Zfc3RlcCIsIm4iLCJzIiwic3RyaW5nX29mX2Vycm9yX2tpbmQiLCJzJDAiLCJzJDEiLCJnb3QiLCJleHBlY3RlZCIsInN0cmluZ19vZl9lcnJvciIsInBhdGgiLCJlcnJrIiwiZXJyayQwIiwidHlwZXJyIiwidHkiLCJzdHJpbmciLCJvYmoiLCJpbnQkMCIsImZsb2F0JDAiLCJib29sIiwib2JqZWN0IiwiZXZhbCQwIiwiZXh0cmFfZmllbGRzIiwiZCIsIm8iLCJkJDAiLCJvJDEiLCJrZXlzJDAiLCJrZXlzIiwiZCQxIiwiYXJnIiwiZCQyIiwiYXJnJDAiLCJiIiwiYXJnJDEiLCJkJDMiLCJkJDQiLCJlcnIiLCJtc2ciLCJmJDAiLCJkJDUiLCJkJDYiLCJsIiwibG9vcCIsImFjYyIsInhzIiwibXNnJDAiLCJkJDciLCJkJDgiLCJkZWNvZGVfZmFpbCIsInJlcyIsImNvbnZlcnRfYXJnIiwibCQwIiwiZSIsImNvbnRhaW5lciIsImN0eCIsInNlbmRfbXNnIiwiYWZ0ZXJfcmVkcmF3IiwicnVuIiwiYWZ0ZXIiLCJoIiwiZWx0IiwicCQwIiwieCQwIiwiY21kIiwicCIsImNtZCQwIiwidGwiLCJoZCIsImlucHV0X2V2ZW50IiwiY2hlY2tlZF9ldmVudCIsImNoYW5nZV9ldmVudCIsImNoYW5nZV9pbmRleF9ldmVudCIsImN1c3RvbV9ldmVudCIsIm1ha2UiLCJzeW5jIiwiZG9tIiwiZGlzcG9zZSIsInBhcmVudCIsInNlbmRfZXZlbnQiLCJhZnRlcl9yZWRyYXckMCIsImdldF9kb21zIiwicGFyYW0iLCJnZXRfdmRvbSIsImV2YWxfcHJvcCIsIngkMSIsIngkMiIsInN0cmluZ19vZl9wcm9wIiwic2FtZV9wcm9wIiwidjEiLCJ2MiIsIngyIiwieDIkMCIsIngxJDAiLCJ4MiQxIiwieDEkMSIsIngyJDIiLCJ4MSQyIiwiYm1lbW8iLCJ2ZG9tIiwiaXNfdmlzaWJsZSIsImJvdW5kaW5nIiwiY3VzdG9tX2F0dHJpYnV0ZSIsInYiLCJhbGlnbl90b3AiLCJleG4kMCIsImV4biIsImRvX2ZvY3VzIiwiYXBwbHlfZWZmZWN0X3Byb3AiLCJzZXRfc3R5bGUiLCJrIiwiYXBwbHlfc3BlY2lhbF9wcm9wIiwibnMiLCJjbGFzc19vYmoiLCJqc19lbXB0eV9zdHJpbmciLCJjdXN0b20iLCJtZXJnZSIsImVudnMiLCJnbG9iYWwiLCJyZWdpc3RlciIsImFwcGx5X2F0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwidiQwIiwiayQwIiwiZXZlbnRfdHlwZSIsInYkMSIsImskMSIsInR4dCIsImNoaWxkcmVuIiwiY2hpbGRyZW4kMCIsImRvbXMiLCJjaGlsZHJlbiQxIiwidGFnIiwiZG9tJDAiLCJjaGlsZHJlbiQyIiwiYyIsInByb3BhZ2F0ZV9ldmVudHMiLCJhdHRyaWJ1dGVzJDAiLCJoYW5kbGVycyIsInByb2Nlc3NfY3VzdG9tIiwiZWwiLCJlbHQkMCIsIm5zJDAiLCJibGl0Iiwic3luY19wcm9wcyIsInNhbWUiLCJsMSIsImwyIiwic29ydCIsImsyIiwiazEiLCJsMSQwIiwibDIkMCIsImwxJDEiLCJsMiQxIiwidGwxIiwidGwyIiwidGwyJDAiLCJ2MiQwIiwidGwyJDEiLCJ2MiQxIiwiazIkMCIsImNob29zZSIsImpzX2ZhbHNlIiwianNfemVybyIsInN5bmNfYXR0cmlidXRlcyIsImExIiwiYTIiLCJwcm9wcyIsImpzX2VtcHR5X3N0cmluZyQwIiwic3R5bGVzIiwiY2xlYXIkMCIsImF0dHJzIiwic2V0JDEiLCJjbGVhciQxIiwiY3RybCIsImN0cmwkMCIsInByZXZfbW92ZSIsIm5leHQiLCJvbGQiLCJzMiIsInMxIiwibWF0Y2gkMCIsInN5bmNfY2hpbGRyZW4iLCJlMSIsImMyIiwiYzEiLCJmMiIsImMxJDAiLCJmMSIsImEyJDAiLCJhcmcyIiwia2V5MiIsImExJDAiLCJhcmcxIiwia2V5MSIsInQyIiwiaDIiLCJ0MSIsImgxIiwib2xkX2NoaWxkcmVuIiwibmV3X2NoaWxkcmVuIiwib2xkX2NoaWxkcmVuJDAiLCJuZXdfY2hpbGRyZW4kMCIsImJ5X2tleSIsImkkMSIsImluZGljZXMiLCJpJDAiLCJpZHgkMCIsInRvX3JlbW92ZSIsImN0cmxzIiwicHJldl9tb3ZlJDAiLCJuZXh0JDAiLCJpZHgiLCJjX2RvbSIsInJpZ2h0X21vc3QiLCJtb3ZlIiwiZm91bmQiLCJtYXBwZXIkMCIsImlubmVyJDAiLCJpbm5lciQxIiwibWFwcGVyIiwidmRvbV9vZl9kb20iLCJyb290IiwiaW5uZXIiLCJwYXJlbnQkMCIsInByb2Nlc3MiLCJhZnRlcl9yZWRyYXckMSIsInJ1biQwIiwiZW52IiwidmlldyIsInVwZGF0ZSIsImNtZDAiLCJtb2RlbDAiLCJlbnYkMCIsImNvbnRhaW5lciQwIiwiY29udGFpbmVyJDEiLCJjb250YWluZXJfY3JlYXRlZCIsImNvbnRhaW5lciQyIiwicG9zdF9yZWRyYXciLCJmbHVzaCIsInByb2Nlc3NfY3VzdG9tX2Z3ZCIsInByb2Nlc3NfZndkIiwibGlzdGVuZXJzIiwibW9kZWwiLCJjdXJyZW50IiwicGVuZGluZ19yZWRyYXciLCJ2aWV3JDAiLCJvbl9ldmVudCIsImV2dCIsInRndCIsImF0dHJpYnV0ZSIsIm1hcCIsImRlY29kZXIiLCJzdG9wcGVkX3Byb3BhZ2F0aW9uIiwic3RvcHBlZF9wcm9wYWdhdGlvbiQwIiwiczIkMCIsImFkZF9saXN0ZW5lciIsInJlbW92ZV9saXN0ZW5lciIsInJlZHJhdyIsIm5ld19tb2RlbCIsInJ1bl9jbWQiLCJldmVudCIsInByb2Nlc3MkMCIsInNlbGVjdF9oYW5kbGVyIiwiYXR0ciIsImV0MSIsImVuY29kZXIiLCJldDIiLCJtc2dzIiwiZGlzcG9zZSQwIiwiaXpfbml6YSIsIm96bmFrYSIsInZfbml6IiwicHJhemVuX2F2dG9tYXQiLCJ6YWNldG5vX3N0YW5qZSIsImRvZGFqX25lc3ByZWplbW5vX3N0YW5qZSIsInN0YW5qZSIsImF2dG9tYXQiLCJkb2Rhal9zcHJlamVtbm9fc3RhbmplIiwiZG9kYWpfcHJlaG9kIiwic3RhbmplMSIsInpuYWsiLCJzdGFuamUyIiwicHJlaG9kbmFfZnVua2NpamEiLCJ6bmFrJDAiLCJzZXpuYW1fc3RhbmoiLCJzZXpuYW1fcHJlaG9kb3YiLCJqZV9zcHJlamVtbm9fc3RhbmplIiwicTAiLCJxMSIsInEyIiwiZW5rZV8xbW9kMyIsInByZWJlcmlfbml6IiwicSIsIm5peiIsImF1eCIsImFjYyIsInRyZW51dG5pX3puYWsiLCJ0cmFrIiwiamVfbmFfa29uY3UiLCJwcmVtYWtuaV9uYXByZWoiLCJwcmF6ZW4iLCJwcmVicmFuaSIsIm5lcHJlYnJhbmkiLCJwb3plbmkiLCJrb3Jha19uYXByZWoiLCJzdGFuamUkMCIsInN0YW5qZSQxIiwiamVfdl9zcHJlamVtbmVtX3N0YW5qdSIsInphY2V0bmFwcmF2aWxhIiwic2VzdGVqbGlzdCIsInNlem5hbSIsInNlem5hbSQwIiwidGFpbCIsInNlem5hbSQxIiwic3ByZW1lbmlfc3RhbmplIiwic29zZWRpbGlzdCIsInRyZW51dG5vX3N0YW5qZSIsInppdmlzb3NlZGkiLCJzcHJlbWVuaV9zdGFuamVfeml2aSIsIm1hdHJpa2FzZXN0ZWppemxvY2VuaSIsIml6bG9jaSIsIm1hdHJpa2EiLCJtIiwibiIsImkiLCJqIiwia29waXJham1hdHJpa28iLCJrb3JhayIsInphY2V0bmFtYXRyaWthIiwibm90cmkiLCJlbGVtZW50IiwibW5vemljYSIsIm1ub3ppY2EkMCIsIm1ub3ppY2EkMSIsImgiLCJwcmF2aWxvIiwicHJhdmlsYW1ydHZpIiwicHJhdmlsYXppdmkiLCJzdHNvc2VkIiwidHJlbnV0bm9zdGFuamUiLCJpbml0X21hdHJpeCIsInJvd3MiLCJjb2xzIiwiZiIsIm5hcmVkaWtvcmFrIiwibWF0cmlrYXNvc2Vkb3YiLCJ6YWNldG5pc29zZWRpIiwicmFuZG9tYXJyYXkiLCJyYW5kb21tYXRyaWthIiwic3ltYm9sIiwieCIsInkiLCJpenBpc2ltYXRyaWtvaW50IiwidnJzdGljYSIsIm1hcG1hdHJpeCIsIm1hdCIsImludG9mYm9vbCIsImJvb2xvZmludCIsIml6cGlzaXNvc2VkZWludCIsInNvc2VkaSIsImRldmV0aSIsIm9zbWkiLCJzZWRtaSIsInNlc3RpIiwicGV0aSIsImNldHJ0aSIsInRyZXRqaSIsImRydWdpIiwicHJ2aSIsIml6bG9jaXNvc2VkZSIsImRvdHByb2QiLCJtYXRyaWthYSIsIm1hdHJpa2FiIiwidnNvdGEiLCJtb2ptb2QiLCJpemxvY2lzb3NlZHNrb21hdHJpa28iLCJjZWxhbWF0cmlrYSIsImsiLCJwcnZpaW5kZWtzIiwiZHJ1Z2lpbmRla3MiLCJuYXJlZGltYXRyaWtvdnNvdCIsIm1hdHJpa2Fzb3Nlc2NpbmUiLCJzeW1ib2wiLCJrIiwidmVjIiwic3ltYm9sJDAiLCJ2ZWMxIiwidmVjMiIsInN5bWJvbCQxIiwiZG9semluYSIsIm5vcm1pcmFqIiwic3JlZGluYSIsIm9wdCIsInphY2V0ZWsiLCJrb25lYyIsInN0aCIsImxhbWJkYSIsInJhemRhbGphIiwia29yZW5pX2Vub3RlIiwibiIsInNpcmluYSIsInZpc2luYSIsInNyZWRpc2NlIiwiaSIsImtvdCIsInBvbG1lciIsImluaXQiLCJzaXJpbmEiLCJ2aXNpbmEiLCJhdnRvbWF0IiwicG9sb3phamkiLCJwb2xvemFqX3N0YW5qYSIsIm1vZGVsIiwicSIsInVwZGF0ZSIsInBvc2l0aW9uIiwicSQwIiwicG9zaXRpb24kMCIsInBvc2l0aW9uJDEiLCJ2bmVzZW5pX25peiIsImJhcnZhX3NwcmVqZW1uZWdhX3N0YW5qYSIsImJhcnZhX3RyZW51dG5lZ2Ffc3RhbmphIiwiYmFydmFfemFjZXRuZWdhX3N0YW5qYSIsInByaXZ6ZXRhX2JhcnZhX2NydCIsInByaXZ6ZXRhX2JhcnZhX3BvbG5pbGEiLCJpbnRfb2ZfZmxvYXRfYXR0ciIsInRhZyIsInZhbHVlIiwic3ZnX2tyb2ciLCJvcHQiLCJzcmVkaXNjZSIsInBvbG1lciIsInN0aCIsImEiLCJzdmdfZGFsamljYSIsInphY2V0ZWsiLCJrb25lYyIsInN2Z19wdXNjaWNhIiwidmVrdG9yIiwibm9ybWFsYSIsInZla3Rvcl9sZXZlX2tvbmljZSIsInZla3Rvcl9kZXNuZV9rb25pY2UiLCJsZXZhX2tvbmljYSIsImRlc25hX2tvbmljYSIsInN2Z19vem5ha2EiLCJwb2xvemFqIiwiYmVzZWRpbG8iLCJwcmlrYXpfc3RhbmphIiwibW9kZWwiLCJxIiwiYXZ0b21hdCIsImJhcnZhX3JvYnUiLCJiYXJ2YV9wb2xuaWxhIiwic3ZnX2VsZW1lbnRpIiwic3ZnX2VsZW1lbnRpJDAiLCJzdmdfZWxlbWVudGkkMSIsInByaWthel96YW5rZSIsIm96bmFrYSIsInBvbG96YWpfb3puYWtlIiwicHJpa2F6X3ByZWhvZGEiLCJsYW1iZGEiLCJ6YWNldGVrX3B1c2NpY2UiLCJrb25lY19wdXNjaWNlIiwicHJpa2F6X3RyYWt1IiwidHJhayIsIm5peiIsInByZWJyYW5pIiwibmVwcmVicmFuaSIsInByaWthel9ndW1iYV96YV9uYXNsZWRuamlfem5hayIsInByaWthel9hdnRvbWF0YSIsInN0YW5qYSIsInByZWhvZGkiLCJkc3QiLCJjaHIiLCJzcmMiLCJldiIsInZpZXciLCJhcHAiLCJydW4iLCJlbGVtZW50IiwiZWxlbWVudCQwIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vK21sQnl0ZXMuanMiLCIvYnVpbHRpbi8rYmlnYXJyYXkuanMiLCIvYnVpbHRpbi8rbWFyc2hhbC5qcyIsIi9idWlsdGluLyt1bml4LmpzIiwiL2J1aWx0aW4vK3N0ZGxpYi5qcyIsIi9idWlsdGluLytzeXMuanMiLCIvYnVpbHRpbi8rYmFja3RyYWNlLmpzIiwiL2J1aWx0aW4vK2pzbGliLmpzIiwiL2J1aWx0aW4vK2ZhaWwuanMiLCIvYnVpbHRpbi8rZnMuanMiLCIvYnVpbHRpbi8rZnNfZmFrZS5qcyIsIi9idWlsdGluLytpbnQ2NC5qcyIsIi9idWlsdGluLytzeW5jLmpzIiwiL2J1aWx0aW4vK25hdC5qcyIsIi9idWlsdGluLytmc19ub2RlLmpzIiwiL2J1aWx0aW4vK2JpZ3N0cmluZy5qcyIsIi9idWlsdGluLyttZDUuanMiLCIvYnVpbHRpbi8raWVlZV83NTQuanMiLCIvYnVpbHRpbi8rb2JqLmpzIiwiL2J1aWx0aW4vK2VmZmVjdC5qcyIsIi9idWlsdGluLythcnJheS5qcyIsIi9idWlsdGluLytkb21haW4uanMiLCIvYnVpbHRpbi8raW50cy5qcyIsIi9idWlsdGluLytoYXNoLmpzIiwiL2J1aWx0aW4vK2lvLmpzIiwiL2J1aWx0aW4vK2NvbXBhcmUuanMiLCIvYnVpbHRpbi8rcnVudGltZV9ldmVudHMuanMiLCIvYnVpbHRpbi8renN0ZC5qcyIsIi9idWlsdGluLyt3ZWFrLmpzIiwiL2J1aWx0aW4vK2djLmpzIiwiL2J1aWx0aW4vK2Zvcm1hdC5qcyIsIi9idWlsdGluLytncmFwaGljcy5qcyIsIi9idWlsdGluLytqc2xpYl9qc19vZl9vY2FtbC5qcyIsIi9idWlsdGluLytsZXhpbmcuanMiLCIvYnVpbHRpbi8rcHJuZy5qcyIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vanMvb2pzX3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rcGFyc2luZy5qcyIsIi9idWlsdGluLytzdHIuanMiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0QmFzaWNzLm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbEF0b21pYy5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9zdGRsaWIubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvcGVydmFzaXZlcy5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9laXRoZXIubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvb2JqLm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbExhenkubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvbGF6eS5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9zZXEubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvb3B0aW9uLm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL29jYW1sL3Jlc3VsdC5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9ib29sLm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL29jYW1sL2NoYXIubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvdWNoYXIubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvbGlzdC5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9pbnQubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvYnl0ZXMubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvc3RyaW5nLm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL29jYW1sL3VuaXQubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvbWFyc2hhbC5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9hcnJheS5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9mbG9hdC5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9pbnQzMi5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9pbnQ2NC5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9uYXRpdmVpbnQubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvbGV4aW5nLm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL29jYW1sL3BhcnNpbmcubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvc2V0Lm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL29jYW1sL21hcC5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9zdGFjay5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9xdWV1ZS5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9zdHJlYW0ubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvYnVmZmVyLm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdC5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9wcmludGYubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvYXJnLm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL29jYW1sL3ByaW50ZXhjLm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL29jYW1sL2Z1bi5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9nYy5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9kaWdlc3QubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvcmFuZG9tLm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL29jYW1sL2hhc2h0YmwubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvd2Vhay5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9mb3JtYXQubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvc2NhbmYubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvY2FsbGJhY2subWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvY2FtbGludGVybmFsT08ubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvY2FtbGludGVybmFsTW9kLm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL29jYW1sL2dlbmxleC5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9lcGhlbWVyb24ubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvZmlsZW5hbWUubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvY29tcGxleC5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9iaWdhcnJheS5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vY2FtbC9pbl9jaGFubmVsLm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL29jYW1sL291dF9jaGFubmVsLm1sIiwiL2hvbWUvdXNlci8ub3BhbS80LjE0LjAvbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL3J1bnRpbWUvanNvb19ydW50aW1lX18ubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvcnVudGltZS9qc29vX3J1bnRpbWUubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2pzL29qcy5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi9vanMvb2pzX2V4bi5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi92ZG9tL2Jhc2UvdmRvbS5tbCIsIi9ob21lL3VzZXIvLm9wYW0vNC4xNC4wL2xpYi92ZG9tL2pzX2Jyb3dzZXIubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvdmRvbS92ZG9tX2JsaXQubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2RlZmluaWNpamUvc3RhbmplLm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9kZWZpbmljaWplL2F2dG9tYXQubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL2RlZmluaWNpamUvdHJhay5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZGVmaW5pY2lqZS96YWduYW5pQXZ0b21hdC5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvZGVmaW5pY2lqZS9wcmF2aWxhLm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9kZWZpbmljaWplL2l6bG9jaXNvc2VkZS5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvc3BsZXRuaVZtZXNuaWsvdmVrdG9yLm1sIiwiL3dvcmtzcGFjZV9yb290L3NyYy9zcGxldG5pVm1lc25pay9tb2RlbC5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvc3BsZXRuaVZtZXNuaWsvdmlldy5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zcmMvc3BsZXRuaVZtZXNuaWsvc3BsZXRuaVZtZXNuaWsubWwiLCIvaG9tZS91c2VyLy5vcGFtLzQuMTQuMC9saWIvb2NhbWwvc3RkX2V4aXQubWwiXSwibWFwcGluZ3MiOiI7Ozs7OztBLEM7O0c7OztRO1M7OztHO0k7STtJO0c7RTs7OztHQXdFQSxTQUFTQSx5QkFBMEJDLEdBQUdDLEdBQUdDO0lBQ2pDLElBQUZDLElBQUlDO0lBQ1IsR0FBSUgsVUFBVUMsZUFBZUEsT0FBT0YsVUFBVSxPQUFPRyxRQUFTRSxNQUFNTDtJQUM5RCxJQUFGTTtJQUNKLFVBQVdKLEtBQUtELFdBQVVDO0tBQ3hCSSxLQUFLSCxRQUFTRSxNQUFNTCxRQUFRQyxHQUFFQSxJQUFJTSxTQUFTTDtJQUM3QyxPQUFPSTtHQUNUO0dBbW9CQSxTQUFTRSx1QkFBdUJDLEdBQUssT0FBT0EsRUFBRTtHQXpOOUMsU0FBU0MscUJBQXNCVjtJQUM3QixPQUFPUSx1QkFBdUJULHlCQUF5QkMsTUFBSUE7R0FDN0Q7R0NsRkEsU0FBU1csY0FBY0MsSUFBSUMsSUFDekIsT0FBT0QsT0FBT0EsVUFBVUMsS0FDMUI7R0NsU0EsU0FBU0MsZ0JBQWlCQyxJQUFJZCxHQUFLZSxTQUFTRCxJQUFJQyxTQUFTZixFQUFHO0dBQzVEYTt3QkFDdUIsT0FBT0gsY0FBY0ssUUFBT0EsVUFBMUM7d0JBQ2MsT0FBT0wsY0FBY0ssUUFBT0Esc0JBQTFDOzs7TUFFTCxJQUFJVixJQUFJVSxRQUFRZixJQUFJZTtNQUNwQkEsU0FBU2Y7TUFDVCxPQUFRVSxjQUFjTCxHQUFFTCxVQUFXVSxjQUFjTCxHQUFFTDtLQUg3Qzs7O01BTU4sSUFBSUssSUFBSVUsUUFBUWYsSUFBSWU7TUFDcEJBLFNBQVNmO01BQ1QsT0FBUVUsY0FBY0wsR0FBRUwsaUJBQWtCVSxjQUFjTCxHQUFFTDtLQUhwRDs7O01BTU4sSUFBSUssSUFBSVUsUUFBUWYsSUFBSWU7TUFDcEJBLFNB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QUFDLFlBQ007SUFSYixPQUFBLFdBQ0csOEJBTUlBO0dBQytEO0dBRXhFLDhDQVhJRjs7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7Ozs7OztHQ1VFO0dBQUE7OztFIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQW4gT0NhbWwgc3RyaW5nIGlzIGFuIG9iamVjdCB3aXRoIHRocmVlIGZpZWxkczpcbi8vIC0gdGFnICd0J1xuLy8gLSBsZW5ndGggJ2wnXG4vLyAtIGNvbnRlbnRzICdjJ1xuLy9cbi8vIFRoZSBjb250ZW50cyBvZiB0aGUgc3RyaW5nIGNhbiBiZSBlaXRoZXIgYSBKYXZhU2NyaXB0IGFycmF5IG9yXG4vLyBhIEphdmFTY3JpcHQgc3RyaW5nLiBUaGUgbGVuZ3RoIG9mIHRoaXMgc3RyaW5nIGNhbiBiZSBsZXNzIHRoYW4gdGhlXG4vLyBsZW5ndGggb2YgdGhlIE9DYW1sIHN0cmluZy4gSW4gdGhpcyBjYXNlLCByZW1haW5pbmcgYnl0ZXMgYXJlXG4vLyBhc3N1bWVkIHRvIGJlIHplcm9lcy4gQXJyYXlzIGFyZSBtdXRhYmxlIGJ1dCBjb25zdW1lcyBtb3JlIG1lbW9yeVxuLy8gdGhhbiBzdHJpbmdzLiBBIGNvbW1vbiBwYXR0ZXJuIGlzIHRvIHN0YXJ0IGZyb20gYW4gZW1wdHkgc3RyaW5nIGFuZFxuLy8gcHJvZ3Jlc3NpdmVseSBmaWxsIGl0IGZyb20gdGhlIHN0YXJ0LiBQYXJ0aWFsIHN0cmluZ3MgbWFrZXMgaXRcbi8vIHBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGVmZmljaWVudGx5LlxuLy9cbi8vIFdoZW4gY29udmVydGluZyB0byBhbmQgZnJvbSBVVEYtMTYsIHdlIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGVcbi8vIHN0cmluZyBpcyBjb21wb3NlZCBvbmx5IG9mIEFTQ0lJIGNoYXJhY3RlcnMgKGluIHdoaWNoIGNhc2UsIG5vXG4vLyBjb252ZXJzaW9uIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCkgb3Igbm90LlxuLy9cbi8vIFRoZSBzdHJpbmcgdGFnIGNhbiB0aHVzIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4vLyAgIGZ1bGwgc3RyaW5nICAgICBCWVRFIHwgVU5LTk9XTjogICAgICAwXG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgQVNDSUk6ICAgICAgICA5XG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgTk9UX0FTQ0lJOiAgICA4XG4vLyAgIHN0cmluZyBwcmVmaXggICBQQVJUSUFMOiAgICAgICAgICAgICAyXG4vLyAgIGFycmF5ICAgICAgICAgICBBUlJBWTogICAgICAgICAgICAgICA0XG4vL1xuLy8gT25lIGNhbiB1c2UgYml0IG1hc2tpbmcgdG8gZGlzY3JpbWluYXRlIHRoZXNlIGRpZmZlcmVudCBjYXNlczpcbi8vICAga25vd25fZW5jb2RpbmcoeCkgPSB4Jjhcbi8vICAgaXNfYXNjaWkoeCkgPSAgICAgICB4JjFcbi8vICAga2luZCh4KSA9ICAgICAgICAgICB4JjZcblxuLy9Qcm92aWRlczogY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX3N0cl9yZXBlYXQobiwgcykge1xuICBpZihuID09IDApIHJldHVybiBcIlwiO1xuICBpZiAocy5yZXBlYXQpIHtyZXR1cm4gcy5yZXBlYXQobik7fSAvLyBFQ01Bc2NyaXB0IDYgYW5kIEZpcmVmb3ggMjQrXG4gIHZhciByID0gXCJcIiwgbCA9IDA7XG4gIGZvcig7Oykge1xuICAgIGlmIChuICYgMSkgciArPSBzO1xuICAgIG4gPj49IDE7XG4gICAgaWYgKG4gPT0gMCkgcmV0dXJuIHI7XG4gICAgcyArPSBzO1xuICAgIGwrKztcbiAgICBpZiAobCA9PSA5KSB7XG4gICAgICBzLnNsaWNlKDAsMSk7IC8vIGZsYXR0ZW4gdGhlIHN0cmluZ1xuICAgICAgLy8gdGhlbiwgdGhlIGZsYXR0ZW5pbmcgb2YgdGhlIHdob2xlIHN0cmluZyB3aWxsIGJlIGZhc3RlcixcbiAgICAgIC8vIGFzIGl0IHdpbGwgYmUgY29tcG9zZWQgb2YgbGFyZ2VyIHBpZWNlc1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbi8vV2Vha2RlZlxuLy8gUHJlIEVDTUFTY3JpcHQgNSwgW2FwcGx5XSB3b3VsZCBub3Qgc3VwcG9ydCBhcnJheS1saWtlIG9iamVjdC5cbi8vIEluIHN1Y2ggc2V0dXAsIFR5cGVkX2FycmF5IHdvdWxkIGJlIGltcGxlbWVudGVkIGFzIHBvbHlmaWxsLCBhbmQgW2YuYXBwbHldIHdvdWxkXG4vLyBmYWlsIGhlcmUuIE1hcmsgdGhlIHByaW1pdGl2ZSBhcyBXZWFrZGVmLCBzbyB0aGF0IHBlb3BsZSBjYW4gb3ZlcnJpZGUgaXQgZWFzaWx5LlxuZnVuY3Rpb24gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChhLCBpLCBsZW4pIHtcbiAgdmFyIGYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICBpZiAoaSA9PSAwICYmIGxlbiA8PSA0MDk2ICYmIGxlbiA9PSBhLmxlbmd0aCkgcmV0dXJuIGYuYXBwbHkgKG51bGwsIGEpO1xuICB2YXIgcyA9IFwiXCI7XG4gIGZvciAoOyAwIDwgbGVuOyBpICs9IDEwMjQsbGVuLT0xMDI0KVxuICAgIHMgKz0gZi5hcHBseSAobnVsbCwgYS5zbGljZShpLGkgKyBNYXRoLm1pbihsZW4sIDEwMjQpKSk7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0Zjhfb2ZfdXRmMTZcbmZ1bmN0aW9uIGNhbWxfdXRmOF9vZl91dGYxNihzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gYiwgYywgZCwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YzAgfCAoYyA+PiA2KSk7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZGZmZikge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTAgfCAoYyA+PiAxMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPj0gMHhkYmZmIHx8IGkgKyAxID09IGwgfHxcbiAgICAgICAgICAgICAgIChkID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgZCA+IDB4ZGZmZikge1xuICAgICAgLy8gVW5tYXRjaGVkIHN1cnJvZ2F0ZSBwYWlyLCByZXBsYWNlZCBieSBcXHVmZmZkIChyZXBsYWNlbWVudCBjaGFyYWN0ZXIpXG4gICAgICB0ICs9IFwiXFx4ZWZcXHhiZlxceGJkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICAgIGMgPSAoYyA8PCAxMCkgKyBkIC0gMHgzNWZkYzAwO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZjAgfCAoYyA+PiAxOCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiAxMikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH1cbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gY2FtbF91dGYxNl9vZl91dGY4KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBcIlwiLCBjLCBjMSwgYzIsIHYsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjMSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYzEgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMxID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIHYgPSAxO1xuICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICBjID0gYzIgKyAoYzEgPDwgNik7XG4gICAgICBpZiAoYzEgPCAweGUwKSB7XG4gICAgICAgIHYgPSBjIC0gMHgzMDgwO1xuICAgICAgICBpZiAodiA8IDB4ODApIHYgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IDI7XG4gICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICAgICAgYyA9IGMyICsgKGMgPDwgNik7XG4gICAgICAgICAgaWYgKGMxIDwgMHhmMCkge1xuICAgICAgICAgICAgdiA9IGMgLSAweGUyMDgwO1xuICAgICAgICAgICAgaWYgKCh2IDwgMHg4MDApIHx8ICgodiA+PSAweGQ3ZmYpICYmICh2IDwgMHhlMDAwKSkpIHYgPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gMztcbiAgICAgICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpICYmXG4gICAgICAgICAgICAgICAgKGMxIDwgMHhmNSkpIHtcbiAgICAgICAgICAgICAgdiA9IGMyIC0gMHgzYzgyMDgwICsgKGMgPDwgNik7XG4gICAgICAgICAgICAgIGlmICh2IDwgMHgxMDAwMCB8fCB2ID4gMHgxMGZmZmYpIHYgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodiA8IDQpIHsgLy8gSW52YWxpZCBzZXF1ZW5jZVxuICAgICAgaSAtPSB2O1xuICAgICAgdCArPSBcIlxcdWZmZmRcIjtcbiAgICB9IGVsc2UgaWYgKHYgPiAweGZmZmYpXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkN2MwICsgKHYgPj4gMTApLCAweGRjMDAgKyAodiAmIDB4M0ZGKSlcbiAgICBlbHNlXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodik7XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2lzX2FzY2lpXG5mdW5jdGlvbiBqc29vX2lzX2FzY2lpIChzKSB7XG4gIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2V0cyBiZXR0ZXIgYXQgYXJvdW5kIHRoaXMgcG9pbnQgZm9yIGFsbCBicm93c2Vyc1xuICBpZiAocy5sZW5ndGggPCAyNCkge1xuICAgIC8vIFNwaWRlcm1vbmtleSBnZXRzIG11Y2ggc2xvd2VyIHdoZW4gcy5sZW5ndGggPj0gMjQgKG9uIDY0IGJpdCBhcmNocylcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIGlmIChzLmNoYXJDb2RlQXQoaSkgPiAxMjcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuICEvW15cXHgwMC1cXHg3Zl0vLnRlc3Qocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBpZiAoaSA+PSBzLmMubGVuZ3RoKSByZXR1cm4gMDtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmMuY2hhckNvZGVBdChpKTtcbiAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgIHJldHVybiBzLmNbaV1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIC8vIFRoZSBPQ2FtbCBjb21waWxlciB1c2VzIENoYXIudW5zYWZlX2NociBvbiBpbnRlZ2VycyBsYXJnZXIgdGhhbiAyNTUhXG4gIGMgJj0gMHhmZjtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSB7XG4gICAgaWYgKGkgPT0gcy5jLmxlbmd0aCkge1xuICAgICAgcy5jICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgaWYgKGkgKyAxID09IHMubCkgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKTtcbiAgfVxuICBzLmNbaV0gPSBjO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDEpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDcpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNil7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIyID0gMHhGRiAmIGkxNiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTE2O1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MTYocyxpLGkxNil7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQxNlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiNCA9IDB4RkYgJiBpMzIgPj4gMjQsXG4gICAgICBiMyA9IDB4RkYgJiBpMzIgPj4gMTYsXG4gICAgICBiMiA9IDB4RkYgJiBpMzIgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkzMjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDIsIGIzKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMywgYjQpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDMyXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQzMlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCl7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGk2NCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyA3IC0gaiwgYVtqXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQ2NFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcgKHMpIHtcbiAgdmFyIHRhZyA9IDkgLyogQllURVMgfCBBU0NJSSAqLztcbiAgaWYgKCFqc29vX2lzX2FzY2lpKHMpKVxuICAgIHRhZyA9IDggLyogQllURVMgfCBOT1RfQVNDSUkgKi8sIHMgPSBjYW1sX3V0Zjhfb2ZfdXRmMTYocyk7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0YWcsIHMsIHMubGVuZ3RoKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBqc29vX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIE1sQnl0ZXMgKHRhZywgY29udGVudHMsIGxlbmd0aCkge1xuICB0aGlzLnQ9dGFnOyB0aGlzLmM9Y29udGVudHM7IHRoaXMubD1sZW5ndGg7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHN3aXRjaCAodGhpcy50KSB7XG4gIGNhc2UgOTogLypCWVRFUyB8IEFTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICBkZWZhdWx0OlxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXModGhpcyk7XG4gIGNhc2UgMDogLypCWVRFUyB8IFVOS09XTiovXG4gICAgaWYgKGpzb29faXNfYXNjaWkodGhpcy5jKSkge1xuICAgICAgdGhpcy50ID0gOTsgLypCWVRFUyB8IEFTQ0lJKi9cbiAgICAgIHJldHVybiB0aGlzLmM7XG4gICAgfVxuICAgIHRoaXMudCA9IDg7IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICBjYXNlIDg6IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICAgIHJldHVybiB0aGlzLmM7XG4gIH1cbn07XG5NbEJ5dGVzLnByb3RvdHlwZS50b1V0ZjE2ID0gZnVuY3Rpb24gKCl7XG4gIHZhciByID0gdGhpcy50b1N0cmluZygpO1xuICBpZih0aGlzLnQgPT0gOSkgcmV0dXJuIHJcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChyKTtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKCl7XG4gIHZhciBjb250ZW50ID0gdGhpcy50ID09IDQgPyB0aGlzLmMuc2xpY2UoKSA6IHRoaXMuYztcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRoaXMudCxjb250ZW50LHRoaXMubCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEJZVEVTICovXG4gIGlmIChzLnQgPT0gMiAvKiBQQVJUSUFMICovKVxuICAgIHMuYyArPSBjYW1sX3N0cl9yZXBlYXQocy5sIC0gcy5jLmxlbmd0aCwgJ1xcMCcpXG4gIGVsc2VcbiAgICBzLmMgPSBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKHMuYywgMCwgcy5jLmxlbmd0aCk7XG4gIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocykge1xuICAvKiBBc3N1bWVzIG5vdCBBUlJBWSAqL1xuICB2YXIgYSA9IG5ldyBVaW50OEFycmF5KHMubCk7XG4gIHZhciBiID0gcy5jLCBsID0gYi5sZW5ndGgsIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgZm9yIChsID0gcy5sOyBpIDwgbDsgaSsrKSBhW2ldID0gMDtcbiAgcy5jID0gYTtcbiAgcy50ID0gNDsgLyogQVJSQVkgKi9cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzIChzKSB7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICByZXR1cm4gcy5jO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIGwgPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciBhID0gbmV3IFVpbnQ4QXJyYXkobCk7XG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsaSk7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBpZihsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJ5dGVzLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9hcnJheSAoYSkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoYSwwLGEubGVuZ3RoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGEpIHtcbiAgaWYoISAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgYSA9IG5ldyBVaW50OEFycmF5KGEpO1xuICB9XG4gIHJldHVybiBuZXcgTWxCeXRlcyg0LGEsYS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2NvbXBhcmUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA9PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczIsczEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMyLHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vQWxpYXM6IGNhbWxfZmlsbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmlsbF9ieXRlcyhzLCBpLCBsLCBjKSB7XG4gIGlmIChsID4gMCkge1xuICAgIGlmIChpID09IDAgJiYgKGwgPj0gcy5sIHx8IChzLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGwgPj0gcy5jLmxlbmd0aCkpKSB7XG4gICAgICBpZiAoYyA9PSAwKSB7XG4gICAgICAgIHMuYyA9IFwiXCI7XG4gICAgICAgIHMudCA9IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuYyA9IGNhbWxfc3RyX3JlcGVhdCAobCwgU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgIHMudCA9IChsID09IHMubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSBzLmNbaV0gPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ibGl0X2J5dGVzKHMxLCBpMSwgczIsIGkyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgaWYgKChpMiA9PSAwKSAmJlxuICAgICAgKGxlbiA+PSBzMi5sIHx8IChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsZW4gPj0gczIuYy5sZW5ndGgpKSkge1xuICAgIHMyLmMgPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIGlmIChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBpMiA9PSBzMi5jLmxlbmd0aCkge1xuICAgIHMyLmMgKz0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSB7XG4gICAgaWYgKHMyLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMyKTtcbiAgICB2YXIgYzEgPSBzMS5jLCBjMiA9IHMyLmM7XG4gICAgaWYgKHMxLnQgPT0gNCAvKiBBUlJBWSAqLykge1xuICAgICAgaWYgKGkyIDw9IGkxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsID0gTWF0aC5taW4gKGxlbiwgYzEubGVuZ3RoIC0gaTEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGMyIFtpMiArIGldID0gYzEuY2hhckNvZGVBdChpMSArIGkpO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ibGl0X3N0cmluZyhhLGIsYyxkLGUpIHtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGEpLGIsYyxkLGUpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19sZW5ndGgocykgeyByZXR1cm4gcy5sIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29uY2F0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbmNhdChhLGIpIHsgcmV0dXJuIGEgKyBiIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29uY2F0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBNbEJ5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb25jYXQoczEsczIpe1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMoczEudCxzMS5jK3MyLmMsczEubCtzMi5sKVxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICByZXR1cm4gcy5jaGFyQ29kZUF0KGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gcy5sZW5ndGhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZSBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPy0xOihzMSA+IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8PSBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhbiBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHtcbiAgKHMudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMuYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNhbWxfanNieXRlc19vZl9zdHJpbmcocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoeCkgeyByZXR1cm4geCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSB7XG4gIGlmKGpzb29faXNfYXNjaWkocykpXG4gICAgcmV0dXJuIHM7XG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICBpZiAoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKVxuICBlbHNlIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfdXRmOF9vZl91dGYxNihzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIG5ldyBNbEJ5dGVzKDAscyxzLmxlbmd0aCk7IH1cblxuXG4vLyBUaGUgc2VjdGlvbiBiZWxvdyBzaG91bGQgYmUgdXNlZCB3aGVuIHVzZS1qcy1zdHJpbmc9ZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocyxpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocyxpLGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19jb21wYXJlXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19jb21wYXJlKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19lcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHsgcmV0dXJuIHMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB7IHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIChzLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICByZXR1cm4gcy5jIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKXtcbiAgcmV0dXJuIHMudG9VdGYxNigpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyhzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9pc19tbF9ieXRlcyhzKSB7XG4gIHJldHVybiAocyBpbnN0YW5jZW9mIE1sQnl0ZXMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2NvbnRlbnRcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfYnl0ZXNfY29udGVudChzKSB7XG4gIHN3aXRjaCAocy50ICYgNikge1xuICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmM7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcy5jXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWlcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gKHR5cGVvZiBzID09PSBcInN0cmluZ1wiICYmICEvW15cXHgwMC1cXHhmZl0vLnRlc3QocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9pc19tbF9ieXRlcyhzKTtcbn1cblxuLy8gVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgZGVwcmVjYXRlZFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nKHMpIHsgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbmV3X3N0cmluZyAocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19mcm9tX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RvX2pzX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3RvX2pzX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdG9fc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2Zfc3RyaW5nKHgpIHsgcmV0dXJuIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9ieXRlcyh4KSB7IHJldHVybiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKHgpIH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkLCBBbmR5IFJheVxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuLy9cbi8vIEJpZ2FycmF5LlxuLy9cbi8vIC0gYWxsIGJpZ2FycmF5IHR5cGVzIGluY2x1ZGluZyBJbnQ2NCBhbmQgQ29tcGxleC5cbi8vIC0gZm9ydHJhbiArIGMgbGF5b3V0c1xuLy8gLSBzdWIvc2xpY2UvcmVzaGFwZVxuLy8gLSByZXRhaW4gZmFzdCBwYXRoIGZvciAxZCBhcnJheSBhY2Nlc3NcblxuLy9Qcm92aWRlczogY2FtbF9iYV9pbml0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhX2luaXQoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemUoZGltcykge1xuICB2YXIgbl9kaW1zID0gZGltcy5sZW5ndGg7XG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKykge1xuICAgIGlmIChkaW1zW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIHNpemUgPSBzaXplICogZGltc1tpXTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKXtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDc6IGNhc2UgMTA6IGNhc2UgMTE6IHJldHVybiAyO1xuICBkZWZhdWx0OiByZXR1cm4gMTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpe1xuICB2YXIgdmlldztcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDA6ICB2aWV3ID0gRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxOiAgdmlldyA9IEZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMjogIHZpZXcgPSBJbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDM6ICB2aWV3ID0gVWludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgNDogIHZpZXcgPSBJbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA1OiAgdmlldyA9IFVpbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA2OiAgdmlldyA9IEludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDc6ICB2aWV3ID0gSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgODogIHZpZXcgPSBJbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA5OiAgdmlldyA9IEludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDEwOiB2aWV3ID0gRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMTogdmlldyA9IEZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTI6IHZpZXcgPSBVaW50OEFycmF5OyBicmVhaztcbiAgfVxuICBpZiAoIXZpZXcpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgdmFyIGRhdGEgPSBuZXcgdmlldyhzaXplICogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246IDwgNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnJheVwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPj0gNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnIwMlwiXG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpLCBjYW1sX2ludDY0X2hpMzIsIGNhbWxfaW50NjRfbG8zMlxuZnVuY3Rpb24gTWxfQmlnYXJyYXkgKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG5cbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBjYW1sX2JhX2N1c3RvbV9uYW1lO1xuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICB2YXIgb2ZzID0gMDtcbiAgaWYodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikgYXJnID0gW2FyZ107XG4gIGlmICghIChhcmcgaW5zdGFuY2VvZiBBcnJheSkpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ2FycmF5LmpzOiBpbnZhbGlkIG9mZnNldFwiKTtcbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYXJnLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5nZXQvc2V0OiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIGlmKHRoaXMubGF5b3V0ID09IDAgLyogY19sYXlvdXQgKi8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFyZ1tpXSA8IDAgfHwgYXJnW2ldID49IHRoaXMuZGltc1tpXSlcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyBhcmdbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmRpbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChhcmdbaV0gPCAxIHx8IGFyZ1tpXSA+IHRoaXMuZGltc1tpXSl7XG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgKGFyZ1tpXSAtIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2ZzO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGwgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBoID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobCxoKTtcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciByID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaSA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIFsyNTQsIHIsIGldO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiB0aGlzLmRhdGFbb2ZzXVxuICB9XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSB2WzFdO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSB2WzJdO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMFxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBhID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHZhciBiID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGlmKGEgPT0gYil7XG4gICAgICB0aGlzLmRhdGEuZmlsbChhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBhIDogYjtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgaW0gPSB2WzFdO1xuICAgIHZhciByZSA9IHZbMl07XG4gICAgaWYoaW0gPT0gcmUpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoaW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGltIDogcmU7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YS5maWxsKHYpO1xuICAgIGJyZWFrO1xuICB9XG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYiwgdG90YWwpIHtcbiAgaWYgKHRoaXMubGF5b3V0ICE9IGIubGF5b3V0IHx8IHRoaXMua2luZCAhPSBiLmtpbmQpIHtcbiAgICB2YXIgazEgPSB0aGlzLmtpbmQgfCAodGhpcy5sYXlvdXQgPDwgOCk7XG4gICAgdmFyIGsyID0gICAgYi5raW5kIHwgKGIubGF5b3V0IDw8IDgpO1xuICAgIHJldHVybiBrMiAtIGsxO1xuICB9XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGIuZGltcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYi5kaW1zLmxlbmd0aCAtIHRoaXMuZGltcy5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKHRoaXMuZGltc1tpXSAhPSBiLmRpbXNbaV0pXG4gICAgICByZXR1cm4gKHRoaXMuZGltc1tpXSA8IGIuZGltc1tpXSkgPyAtMSA6IDE7XG4gIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICBjYXNlIDEwOlxuICBjYXNlIDExOlxuICAgIC8vIEZsb2F0c1xuICAgIHZhciB4LCB5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB4ID0gdGhpcy5kYXRhW2ldO1xuICAgICAgeSA9IGIuZGF0YVtpXTtcbiAgICAgIGlmICh4IDwgeSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHggPiB5KVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICh4ICE9IHkpIHtcbiAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgaWYgKHggPT0geCkgcmV0dXJuIDE7XG4gICAgICAgIGlmICh5ID09IHkpIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSs9Mikge1xuICAgICAgLy8gQ2hlY2sgaGlnaGVzdCBiaXRzIGZpcnN0XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPCBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdID4gYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApIDwgKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA+IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMjpcbiAgY2FzZSAzOlxuICBjYXNlIDQ6XG4gIGNhc2UgNTpcbiAgY2FzZSA2OlxuICBjYXNlIDg6XG4gIGNhc2UgOTpcbiAgY2FzZSAxMjpcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA8IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA+IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheV9jXzFfMVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhICAgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZSA9IG5ldyBNbF9CaWdhcnJheSgpXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICBpZih0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKXtcbiAgICBpZigoYXJnIGluc3RhbmNlb2YgQXJyYXkpICYmIGFyZy5sZW5ndGggPT0gMSlcbiAgICAgIGFyZyA9IGFyZ1swXTtcbiAgICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIk1sX0JpZ2FycmF5X2NfMV8xLm9mZnNldFwiKTtcbiAgfVxuICBpZiAoYXJnIDwgMCB8fCBhcmcgPj0gdGhpcy5kaW1zWzBdKVxuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFyZztcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgcmV0dXJuIDBcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jb21wYXJlXG5mdW5jdGlvbiBjYW1sX2JhX2NvbXBhcmUoYSxiLHRvdGFsKXtcbiAgcmV0dXJuIGEuY29tcGFyZShiLHRvdGFsKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBNbF9CaWdhcnJheV9jXzFfMSwgY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKXtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpO1xuICBpZihjYW1sX2JhX2dldF9zaXplKGRpbXMpICogc2l6ZV9wZXJfZWxlbWVudCAhPSBkYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImxlbmd0aCBkb2Vzbid0IG1hdGNoIGRpbXNcIik7XG4gIH1cbiAgaWYobGF5b3V0ID09IDAgJiYgLy8gY19sYXlvdXRcbiAgICAgZGltcy5sZW5ndGggPT0gMSAmJiAvLyBBcnJheTFcbiAgICAgc2l6ZV9wZXJfZWxlbWVudCA9PSAxKSAvLyAxLXRvLTEgbWFwcGluZ1xuICAgIHJldHVybiBuZXcgTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlKGtpbmQsIGxheW91dCwgZGltc19tbCkge1xuICB2YXIgZGltcyA9IGNhbWxfanNfZnJvbV9hcnJheShkaW1zX21sKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGNhbWxfYmFfY2hhbmdlX2xheW91dChiYSwgbGF5b3V0KSB7XG4gIGlmKGJhLmxheW91dCA9PSBsYXlvdXQpIHJldHVybiBiYTtcbiAgdmFyIG5ld19kaW1zID0gW11cbiAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIG5ld19kaW1zW2ldID0gYmEuZGltc1tiYS5kaW1zLmxlbmd0aCAtIGkgLSAxXTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBsYXlvdXQsIG5ld19kaW1zLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kXG5mdW5jdGlvbiBjYW1sX2JhX2tpbmQoYmEpIHtcbiAgcmV0dXJuIGJhLmtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbGF5b3V0XG5mdW5jdGlvbiBjYW1sX2JhX2xheW91dChiYSkge1xuICByZXR1cm4gYmEubGF5b3V0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX251bV9kaW1zXG5mdW5jdGlvbiBjYW1sX2JhX251bV9kaW1zKGJhKSB7XG4gIHJldHVybiBiYS5kaW1zLmxlbmd0aDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1cbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9kaW0oYmEsIGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZGltXCIpO1xuICByZXR1cm4gYmEuZGltc1tpXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMVxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzEoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMlxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzIoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fM1xuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzMoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9nZW5lcmljKGJhLCBpKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKTtcbiAgcmV0dXJuIGJhLmdldChvZnMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDE2KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcyArIDEpO1xuICByZXR1cm4gKGIxIHwgKGIyIDw8IDgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQzMihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgcmV0dXJuICggKGIxIDw8IDApICB8XG4gICAgICAgICAgIChiMiA8PCA4KSAgfFxuICAgICAgICAgICAoYjMgPDwgMTYpIHxcbiAgICAgICAgICAgKGI0IDw8IDI0KSApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDY0KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICB2YXIgYjUgPSBiYS5nZXQob2ZzKzQpO1xuICB2YXIgYjYgPSBiYS5nZXQob2ZzKzUpO1xuICB2YXIgYjcgPSBiYS5nZXQob2ZzKzYpO1xuICB2YXIgYjggPSBiYS5nZXQob2ZzKzcpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbYjgsYjcsYjYsYjUsYjQsYjMsYjIsYjFdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMShiYSwgaTApIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoaTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMihiYSwgaTAsIGkxKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMV0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMyhiYSwgaTAsIGkxLCBpMikge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfZ2VuZXJpYyhiYSwgaSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDE2KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQzMihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzIsICh2ID4+PiAxNikgJiAweGZmKTtcbiAgYmEuc2V0KG9mcyszLCAodiA+Pj4gMjQpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDY0KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgdiA9IGNhbWxfaW50NjRfdG9fYnl0ZXModik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpKyspIGJhLnNldChvZnMraSwgdls3LWldKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMShiYSwgaTAsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChpMCksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8yXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8yKGJhLCBpMCwgaTEsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTFdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8zXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8zKGJhLCBpMCwgaTEsIGkyLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxLGkyXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9maWxsXG5mdW5jdGlvbiBjYW1sX2JhX2ZpbGwoYmEsIHYpIHtcbiAgYmEuZmlsbCh2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2JsaXQoc3JjLCBkc3QpIHtcbiAgaWYgKGRzdC5kaW1zLmxlbmd0aCAhPSBzcmMuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRzdC5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmIChkc3QuZGltc1tpXSAhPSBzcmMuZGltc1tpXSlcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZHN0LmRhdGEuc2V0KHNyYy5kYXRhKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc3ViXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zdWIoYmEsIG9mcywgbGVuKSB7XG4gIHZhciBjaGFuZ2VkX2RpbTtcbiAgdmFyIG11bCA9IDE7XG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSAwO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGJhLmRpbXMubGVuZ3RoIC0gMSk7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSBiYS5kaW1zLmxlbmd0aCAtIDE7XG4gICAgb2ZzID0gb2ZzIC0gMTtcbiAgfVxuICBpZiAob2ZzIDwgMCB8fCBsZW4gPCAwIHx8IChvZnMgKyBsZW4pID4gYmEuZGltc1tjaGFuZ2VkX2RpbV0pe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnN1YjogYmFkIHN1Yi1hcnJheVwiKTtcbiAgfVxuICB2YXIgbmV3X2RpbXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIG5ld19kaW1zW2ldID0gYmEuZGltc1tpXTtcbiAgbmV3X2RpbXNbY2hhbmdlZF9kaW1dID0gbGVuO1xuICBtdWwgKj0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBtdWwsIChvZnMgKyBsZW4pICogbXVsKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2xpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc2xpY2UoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG51bV9pbmRzID0gdmluZC5sZW5ndGg7XG4gIHZhciBpbmRleCA9IFtdO1xuICB2YXIgc3ViX2RpbXMgPSBbXTtcbiAgdmFyIG9mcztcblxuICBpZiAobnVtX2luZHMgPiBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zbGljZTogdG9vIG1hbnkgaW5kaWNlc1wiKTtcblxuICAvLyBDb21wdXRlIG9mZnNldCBhbmQgY2hlY2sgYm91bmRzXG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gdmluZFtpXTtcbiAgICBmb3IgKDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDA7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKG51bV9pbmRzKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzICsgaV0gPSB2aW5kW2ldO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAxO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZSgwLCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzKTtcbiAgfVxuICBvZnMgPSBiYS5vZmZzZXQoaW5kZXgpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoc3ViX2RpbXMpO1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogc2l6ZV9wZXJfZWxlbWVudCwgKG9mcyArIHNpemUpICogc2l6ZV9wZXJfZWxlbWVudCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBzdWJfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3Jlc2hhcGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbmZ1bmN0aW9uIGNhbWxfYmFfcmVzaGFwZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbmV3X2RpbSA9IFtdO1xuICB2YXIgbnVtX2RpbXMgPSB2aW5kLmxlbmd0aDtcblxuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgfVxuICB2YXIgbnVtX2VsdHMgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICBuZXdfZGltW2ldID0gdmluZFtpXTtcbiAgICBpZiAobmV3X2RpbVtpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgbnVtX2VsdHMgPSBudW1fZWx0cyAqIG5ld19kaW1baV07XG4gIH1cblxuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIC8vIENoZWNrIHRoYXQgc2l6ZXMgYWdyZWVcbiAgaWYgKG51bV9lbHRzICE9IHNpemUpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogc2l6ZSBtaXNtYXRjaFwiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW0sIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfc2VyaWFsaXplKHdyaXRlciwgYmEsIHN6KSB7XG4gIHdyaXRlci53cml0ZSgzMiwgYmEuZGltcy5sZW5ndGgpO1xuICB3cml0ZXIud3JpdGUoMzIsIChiYS5raW5kIHwgKGJhLmxheW91dCA8PCA4KSkpO1xuICBpZihiYS5jYW1sX2N1c3RvbSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihiYS5kaW1zW2ldIDwgMHhmZmZmKVxuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRpbXNbaV0pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHdyaXRlci53cml0ZSgxNiwgMHhmZmZmKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCAwKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIGVsc2VcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgd3JpdGVyLndyaXRlKDMyLGJhLmRpbXNbaV0pXG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSg4LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHdyaXRlci53cml0ZSg4LDApO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGJhLmdldChpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGIpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBqID0gYmEuZ2V0KGkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsxXSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsyXSkpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBjb21wbGV4ID0gYmEuZ2V0KGkpO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzFdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsyXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHN6WzBdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA0O1xuICBzelsxXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kZXNlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzLCBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2Rlc2VyaWFsaXplKHJlYWRlciwgc3osIG5hbWUpe1xuICB2YXIgbnVtX2RpbXMgPSByZWFkZXIucmVhZDMycygpO1xuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB3cm9uZyBudW1iZXIgb2YgYmlnYXJyYXkgZGltZW5zaW9uc1wiKTtcbiAgdmFyIHRhZyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBraW5kID0gdGFnICYgMHhmZlxuICB2YXIgbGF5b3V0ID0gKHRhZyA+PiA4KSAmIDE7XG4gIHZhciBkaW1zID0gW11cbiAgaWYobmFtZSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgICAgdmFyIHNpemVfZGltID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICAgIGlmKHNpemVfZGltID09IDB4ZmZmZil7XG4gICAgICAgIHZhciBzaXplX2RpbV9oaSA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIHZhciBzaXplX2RpbV9sbyA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIGlmKHNpemVfZGltX2hpICE9IDApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBiaWdhcnJheSBkaW1lbnNpb24gb3ZlcmZsb3cgaW4gMzJiaXRcIik7XG4gICAgICAgIHNpemVfZGltID0gc2l6ZV9kaW1fbG87XG4gICAgICB9XG4gICAgICBkaW1zLnB1c2goc2l6ZV9kaW0pO1xuICAgIH1cbiAgZWxzZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykgZGltcy5wdXNoKHJlYWRlci5yZWFkMzJ1KCkpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoZGltcyk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpO1xuICB2YXIgYmEgPSBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB2YXIgc2l4dHkgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgaWYoc2l4dHkpIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogY2Fubm90IHJlYWQgYmlnYXJyYXkgd2l0aCA2NC1iaXQgT0NhbWwgaW50c1wiKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAvLyAoaW50NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGludDY0ID0gY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KTtcbiAgICAgIGJhLnNldChpLGludDY0KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWtcbiAgfVxuICBzelswXSA9ICg0ICsgbnVtX2RpbXMpICogNDtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL0RlcHJlY2F0ZWRcbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2Zyb21cbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRhdGExLCBkYXRhMiwganN0eXAsIGtpbmQsIGxheW91dCwgZGltcyl7XG4gIGlmKGRhdGEyIHx8IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkgPT0gMil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9jcmVhdGVfZnJvbTogdXNlIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcIik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGExKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9oYXNoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9oYXNoKGJhKXtcbiAgdmFyIG51bV9lbHRzID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgdmFyIGggPSAwO1xuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDI1NikgbnVtX2VsdHMgPSAyNTY7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDQgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTQpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgOCkgfCAoYmEuZGF0YVtpKzJdIDw8IDE2KSB8IChiYS5kYXRhW2krM10gPDwgMjQpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIHcgPSAwO1xuICAgIHN3aXRjaCAobnVtX2VsdHMgJiAzKSB7XG4gICAgY2FzZSAzOiB3ICA9IGJhLmRhdGFbaSsyXSA8PCAxNjsgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDI6IHcgfD0gYmEuZGF0YVtpKzFdIDw8IDg7ICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMTogdyB8PSBiYS5kYXRhW2krMF07XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAxMjgpIG51bV9lbHRzID0gMTI4O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyAyIDw9IGJhLmRhdGEubGVuZ3RoOyBpKz0yKXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDE2KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICBpZiAoKG51bV9lbHRzICYgMSkgIT0gMClcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBudW1fZWx0cyAqPSAyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV90b190eXBlZF9hcnJheSBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJhKXtcbiAgcmV0dXJuIGJhLmRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSl7XG4gIHZhciBraW5kO1xuICBpZiAgICAgICh0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkga2luZCA9IDA7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSBraW5kID0gMTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpIGtpbmQgPSAyO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIGtpbmQgPSAzO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSBraW5kID0gMztcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSBraW5kID0gNDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkga2luZCA9IDU7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgSW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgcmV0dXJuIGtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGtpbmQgPSBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpO1xuICB2YXIgdGEgPVxuICAgICAgLyogTmVlZGVkIHRvIGF2b2lkIHVuc2lnbmVkIHNldHRlcnMgb3ZlcmZsb3dpbmdcbiAgICAgICAgIHRoZSByYW5nZSBvZiBPQ2FtbCBbaW50MzJdIHZhbHVlcy4gKi9cbiAgICAgIHRhIGluc3RhbmNlb2YgVWludDMyQXJyYXkgP1xuICAgICAgbmV3IEludDMyQXJyYXkodGEuYnVmZmVyICx0YS5ieXRlT2Zmc2V0LCB0YS5sZW5ndGgpIDogdGE7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfY29uc3RhbnRzXG52YXIgY2FtbF9tYXJzaGFsX2NvbnN0YW50cyA9IHtcbiAgUFJFRklYX1NNQUxMX0JMT0NLOiAgICAgICAgIDB4ODAsXG4gIFBSRUZJWF9TTUFMTF9JTlQ6ICAgICAgICAgICAweDQwLFxuICBQUkVGSVhfU01BTExfU1RSSU5HOiAgICAgICAgMHgyMCxcbiAgQ09ERV9JTlQ4OiAgICAgICAgICAgICAgICAgIDB4MDAsXG4gIENPREVfSU5UMTY6ICAgICAgICAgICAgICAgICAweDAxLFxuICBDT0RFX0lOVDMyOiAgICAgICAgICAgICAgICAgMHgwMixcbiAgQ09ERV9JTlQ2NDogICAgICAgICAgICAgICAgIDB4MDMsXG4gIENPREVfU0hBUkVEODogICAgICAgICAgICAgICAweDA0LFxuICBDT0RFX1NIQVJFRDE2OiAgICAgICAgICAgICAgMHgwNSxcbiAgQ09ERV9TSEFSRUQzMjogICAgICAgICAgICAgIDB4MDYsXG4gIENPREVfQkxPQ0szMjogICAgICAgICAgICAgICAweDA4LFxuICBDT0RFX0JMT0NLNjQ6ICAgICAgICAgICAgICAgMHgxMyxcbiAgQ09ERV9TVFJJTkc4OiAgICAgICAgICAgICAgIDB4MDksXG4gIENPREVfU1RSSU5HMzI6ICAgICAgICAgICAgICAweDBBLFxuICBDT0RFX0RPVUJMRV9CSUc6ICAgICAgICAgICAgMHgwQixcbiAgQ09ERV9ET1VCTEVfTElUVExFOiAgICAgICAgIDB4MEMsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9CSUc6ICAgICAweDBELFxuICBDT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOiAgMHgwRSxcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6ICAgIDB4MEYsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOiAweDA3LFxuICBDT0RFX0NPREVQT0lOVEVSOiAgICAgICAgICAgMHgxMCxcbiAgQ09ERV9JTkZJWFBPSU5URVI6ICAgICAgICAgIDB4MTEsXG4gIENPREVfQ1VTVE9NOiAgICAgICAgICAgICAgICAweDEyLFxuICBDT0RFX0NVU1RPTV9MRU46ICAgICAgICAgICAgMHgxOCxcbiAgQ09ERV9DVVNUT01fRklYRUQ6ICAgICAgICAgIDB4MTlcbn1cblxuXG4vL1Byb3ZpZGVzOiBVSW50OEFycmF5UmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gVUludDhBcnJheVJlYWRlciAocywgaSkgeyB0aGlzLnMgPSBzOyB0aGlzLmkgPSBpOyB9XG5VSW50OEFycmF5UmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc1t0aGlzLmkrK107IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNbdGhpcy5pKytdIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHNbaV0gPDwgOCkgfCBzW2kgKyAxXVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHNbaV0gPDwgMjQgPj4gMTYpIHwgc1tpICsgMV07XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKHNbaV0gPDwgMjQpIHwgKHNbaSsxXSA8PCAxNikgfFxuICAgICAgICAgICAgKHNbaSsyXSA8PCA4KSB8IHNbaSszXSkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoc1tpXSA8PCAyNCkgfCAoc1tpKzFdIDw8IDE2KSB8XG4gICAgICAoc1tpKzJdIDw8IDgpIHwgc1tpKzNdO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheSh0aGlzLnMuc3ViYXJyYXkoaSwgaSArIGxlbikpO1xuICB9LFxuICByZWFkdWludDhhcnJheTpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gdGhpcy5zLnN1YmFycmF5KGksIGkgKyBsZW4pO1xuICB9XG59XG5cblxuLy9Qcm92aWRlczogTWxTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIE1sU3RyaW5nUmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7IHRoaXMuaSA9IGk7IH1cbk1sU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0ID4+IDE2KSB8IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnMuc3Vic3RyaW5nKGksIGkgKyBsZW4pKTtcbiAgfSxcbiAgcmVhZHVpbnQ4YXJyYXk6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICB2YXIgcyA9IHRoaXMucztcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIGJbal0gPSBzLmNoYXJDb2RlQXQoaSArIGopO1xuICAgIH1cbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBiO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IEJpZ1N0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIEJpZ1N0cmluZ1JlYWRlciAoYnMsIGkpIHsgdGhpcy5zID0gYnM7IHRoaXMuaSA9IGk7IH1cbkJpZ1N0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDgpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCAyNCA+PiAxNikgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKSAgICAgICAgICkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobGVuKVxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBsZW47IGorKyl7XG4gICAgICBhcnJbal0gPSBjYW1sX2JhX2dldF8xKHRoaXMucywgaStqKTtcbiAgICB9XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgfSxcbiAgcmVhZHVpbnQ4YXJyYXk6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldChpKTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiB0aGlzLnMuZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIH1cbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9ieXRlcyAoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIChjYW1sX2ludDY0X29mX2J5dGVzIChhKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAocywgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciwgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSwgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgc2l6ZVswXSA9IDg7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzICh0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X21hcnNoYWwod3JpdGVyLCB2LCBzaXplcykge1xuICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKHYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgd3JpdGVyLndyaXRlICg4LCBiW2ldKTtcbiAgc2l6ZXNbMF0gPSA4OyBzaXplc1sxXSA9IDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsXG5mdW5jdGlvbiBjYW1sX2ludDMyX3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzaXplWzBdID0gNDtcbiAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzd2l0Y2ggKHJlYWRlci5yZWFkOHUgKCkpIHtcbiAgY2FzZSAxOlxuICAgIHNpemVbMF0gPSA0O1xuICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgY2FzZSAyOlxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogbmF0aXZlIGludGVnZXIgdmFsdWUgdG9vIGxhcmdlXCIpO1xuICBkZWZhdWx0OiBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbmF0aXZlIGludGVnZXJcIik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3VubWFyc2hhbCwgY2FtbF9pbnQ2NF9tYXJzaGFsLCBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50NjRfaGFzaFxuLy9SZXF1aXJlczogY2FtbF9pbnQzMl91bm1hcnNoYWwsIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXJpYWxpemUsIGNhbWxfYmFfZGVzZXJpYWxpemUsIGNhbWxfYmFfY29tcGFyZSwgY2FtbF9iYV9oYXNoXG52YXIgY2FtbF9jdXN0b21fb3BzID1cbiAgICB7XCJfalwiOiB7XG4gICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50NjRfdW5tYXJzaGFsLFxuICAgICAgc2VyaWFsaXplICA6IGNhbWxfaW50NjRfbWFyc2hhbCxcbiAgICAgIGZpeGVkX2xlbmd0aCA6IDgsXG4gICAgICBjb21wYXJlIDogY2FtbF9pbnQ2NF9jb21wYXJlLFxuICAgICAgaGFzaCA6IGNhbWxfaW50NjRfaGFzaFxuICAgIH0sXG4gICAgIFwiX2lcIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQzMl91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfblwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyYXlcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycmF5XCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycjAyXCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnIwMlwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9XG4gICAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogVUludDhBcnJheVJlYWRlclxuLy9SZXF1aXJlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKSB7XG4gIGZ1bmN0aW9uIHJlYWR2bHEob3ZlcmZsb3cpIHtcbiAgICB2YXIgYyA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICB2YXIgbiA9IGMgJiAweDdGO1xuICAgIHdoaWxlICgoYyAmIDB4ODApICE9IDApIHtcbiAgICAgIGMgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgbjcgPSBuIDw8IDc7XG4gICAgICBpZiAobiAhPSBuNyA+PiA3KSBvdmVyZmxvd1swXSA9IHRydWU7XG4gICAgICBuID0gbjcgfCAoYyAmIDB4N0YpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICB2YXIgbWFnaWMgPSByZWFkZXIucmVhZDMydSAoKVxuICBzd2l0Y2gobWFnaWMpe1xuICBjYXNlIDB4ODQ5NUE2QkU6IC8qIEludGV4dF9tYWdpY19udW1iZXJfc21hbGwgKi9cbiAgICB2YXIgaGVhZGVyX2xlbiA9IDIwO1xuICAgIHZhciBjb21wcmVzc2VkID0gMDtcbiAgICB2YXIgZGF0YV9sZW4gPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICB2YXIgdW5jb21wcmVzc2VkX2RhdGFfbGVuID0gZGF0YV9sZW47XG4gICAgdmFyIG51bV9vYmplY3RzID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgdmFyIF9zaXplXzMyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgdmFyIF9zaXplXzY0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgYnJlYWtcbiAgY2FzZSAweDg0OTVBNkJEOiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2NvbXByZXNzZWQgKi9cbiAgICB2YXIgaGVhZGVyX2xlbiA9IHJlYWRlci5yZWFkOHUoKSAmIDB4M0Y7XG4gICAgdmFyIGNvbXByZXNzZWQgPSAxO1xuICAgIHZhciBvdmVyZmxvdyA9IFtmYWxzZV07XG4gICAgdmFyIGRhdGFfbGVuID0gcmVhZHZscShvdmVyZmxvdyk7XG4gICAgdmFyIHVuY29tcHJlc3NlZF9kYXRhX2xlbiA9IHJlYWR2bHEob3ZlcmZsb3cpO1xuICAgIHZhciBudW1fb2JqZWN0cyA9IHJlYWR2bHEob3ZlcmZsb3cpO1xuICAgIHZhciBfc2l6ZV8zMiA9IHJlYWR2bHEgKG92ZXJmbG93KTtcbiAgICB2YXIgX3NpemVfNjQgPSByZWFkdmxxIChvdmVyZmxvdyk7XG4gICAgaWYob3ZlcmZsb3dbMF0pe1xuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcjogb2JqZWN0IHRvbyBsYXJnZSB0byBiZSByZWFkIGJhY2sgb24gdGhpcyBwbGF0Zm9ybVwiKTtcbiAgICB9XG4gICAgYnJlYWtcbiAgY2FzZSAweDg0OTVBNkJGOiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2JpZyAqL1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyOiBvYmplY3QgdG9vIGxhcmdlIHRvIGJlIHJlYWQgYmFjayBvbiBhIDMyLWJpdCBwbGF0Zm9ybVwiKTtcbiAgICBicmVha1xuICBkZWZhdWx0OlxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyOiBiYWQgb2JqZWN0XCIpO1xuICAgIGJyZWFrO1xuICB9XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgaW50ZXJuX29ial90YWJsZSA9IChudW1fb2JqZWN0cyA+IDApP1tdOm51bGw7XG4gIHZhciBvYmpfY291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIGludGVybl9yZWMgKHJlYWRlcikge1xuICAgIHZhciBjb2RlID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICBpZiAoY29kZSA+PSAweDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLykge1xuICAgICAgaWYgKGNvZGUgPj0gMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLykge1xuICAgICAgICB2YXIgdGFnID0gY29kZSAmIDB4RjtcbiAgICAgICAgdmFyIHNpemUgPSAoY29kZSA+PiA0KSAmIDB4NztcbiAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuIChjb2RlICYgMHgzRik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb2RlID49IDB4MjAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HICovKSB7XG4gICAgICAgIHZhciBsZW4gPSBjb2RlICYgMHgxRjtcbiAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaChjb2RlKSB7XG4gICAgICAgIGNhc2UgMHgwMDogLy9jc3QuQ09ERV9JTlQ4OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDhzICgpO1xuICAgICAgICBjYXNlIDB4MDE6IC8vY3N0LkNPREVfSU5UMTY6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMTZzICgpO1xuICAgICAgICBjYXNlIDB4MDI6IC8vY3N0LkNPREVfSU5UMzI6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICAgICAgICBjYXNlIDB4MDM6IC8vY3N0LkNPREVfSU5UNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbnRlZ2VyIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA0OiAvL2NzdC5DT0RFX1NIQVJFRDg6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgaWYoY29tcHJlc3NlZCA9PSAwKSBvZmZzZXQgPSBvYmpfY291bnRlciAtIG9mZnNldDtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDU6IC8vY3N0LkNPREVfU0hBUkVEMTY6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMTZ1ICgpO1xuICAgICAgICAgIGlmKGNvbXByZXNzZWQgPT0gMCkgb2Zmc2V0ID0gb2JqX2NvdW50ZXIgLSBvZmZzZXQ7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA2OiAvL2NzdC5DT0RFX1NIQVJFRDMyOlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICBpZihjb21wcmVzc2VkID09IDApIG9mZnNldCA9IG9ial9jb3VudGVyIC0gb2Zmc2V0O1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29mZnNldF07XG4gICAgICAgIGNhc2UgMHgwODogLy9jc3QuQ09ERV9CTE9DSzMyOlxuICAgICAgICAgIHZhciBoZWFkZXIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICB2YXIgdGFnID0gaGVhZGVyICYgMHhGRjtcbiAgICAgICAgICB2YXIgc2l6ZSA9IGhlYWRlciA+PiAxMDtcbiAgICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTM6IC8vY3N0LkNPREVfQkxPQ0s2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBkYXRhIGJsb2NrIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA5OiAvL2NzdC5DT0RFX1NUUklORzg6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBBOiAvL2NzdC5DT0RFX1NUUklORzMyOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEM6IC8vY3N0LkNPREVfRE9VQkxFX0xJVFRMRTpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0WzcgLSBpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQjogLy9jc3QuQ09ERV9ET1VCTEVfQklHOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEU6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRDogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDA3OiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRjogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMDogLy9jc3QuQ09ERV9DT0RFUE9JTlRFUjpcbiAgICAgICAgY2FzZSAweDExOiAvL2NzdC5DT0RFX0lORklYUE9JTlRFUjpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBjb2RlIHBvaW50ZXJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxMjogLy9jc3QuQ09ERV9DVVNUT006XG4gICAgICAgIGNhc2UgMHgxODogLy9jc3QuQ09ERV9DVVNUT01fTEVOOlxuICAgICAgICBjYXNlIDB4MTk6IC8vY3N0LkNPREVfQ1VTVE9NX0ZJWEVEOlxuICAgICAgICAgIHZhciBjLCBzID0gXCJcIjtcbiAgICAgICAgICB3aGlsZSAoKGMgPSByZWFkZXIucmVhZDh1ICgpKSAhPSAwKSBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbc107XG4gICAgICAgICAgdmFyIGV4cGVjdGVkX3NpemU7XG4gICAgICAgICAgaWYoIW9wcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdW5rbm93biBjdXN0b20gYmxvY2sgaWRlbnRpZmllclwiKTtcbiAgICAgICAgICBzd2l0Y2goY29kZSl7XG4gICAgICAgICAgY2FzZSAweDEyOiAvLyBjc3QuQ09ERV9DVVNUT00gKGRlcHJlY2F0ZWQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTk6IC8vIGNzdC5DT0RFX0NVU1RPTV9GSVhFRFxuICAgICAgICAgICAgaWYoIW9wcy5maXhlZF9sZW5ndGgpXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogZXhwZWN0ZWQgYSBmaXhlZC1zaXplIGN1c3RvbSBibG9ja1wiKTtcbiAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSBvcHMuZml4ZWRfbGVuZ3RoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE4OiAvLyBjc3QuQ09ERV9DVVNUT01fTEVOXG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgICAvLyBTa2lwIHNpemU2NFxuICAgICAgICAgICAgcmVhZGVyLnJlYWQzMnMoKTsgcmVhZGVyLnJlYWQzMnMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHJlYWRlci5pO1xuICAgICAgICAgIHZhciBzaXplID0gWzBdO1xuICAgICAgICAgIHZhciB2ID0gb3BzLmRlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSk7XG4gICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSBzaXplWzBdKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGluY29ycmVjdCBsZW5ndGggb2Ygc2VyaWFsaXplZCBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYoY29tcHJlc3NlZCkge1xuICAgIGlmKGNhbWxfZGVjb21wcmVzc19pbnB1dCkge1xuICAgICAgdmFyIGRhdGEgPSByZWFkZXIucmVhZHVpbnQ4YXJyYXkoZGF0YV9sZW4pO1xuICAgICAgdmFyIHJlcyA9IG5ldyBVaW50OEFycmF5KHVuY29tcHJlc3NlZF9kYXRhX2xlbik7XG4gICAgICB2YXIgcmVzID0gY2FtbF9kZWNvbXByZXNzX2lucHV0KGRhdGEsIHJlcyk7XG4gICAgICB2YXIgcmVhZGVyID0gbmV3IFVJbnQ4QXJyYXlSZWFkZXIocmVzLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBjb21wcmVzc2VkIG9iamVjdCwgY2Fubm90IGRlY29tcHJlc3NcIik7XG4gICAgfVxuICB9XG4gIHZhciByZXMgPSBpbnRlcm5fcmVjIChyZWFkZXIpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBzaXplID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZCA9IHYubGVuZ3RoO1xuICAgIGlmIChkIDwgc2l6ZSkgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICB2W2RdID0gaW50ZXJuX3JlYyAocmVhZGVyKTtcbiAgfVxuICBpZiAodHlwZW9mIG9mcyE9XCJudW1iZXJcIikgb2ZzWzBdID0gcmVhZGVyLmk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZVxuLy9WZXJzaW9uOiA8IDUuMS4wXG52YXIgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplID0gMjBcblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplXG4vL1ZlcnNpb246ID49IDUuMS4wXG52YXIgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplID0gMTZcblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBVSW50OEFycmF5UmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemVcbmZ1bmN0aW9uIGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKHMsIG9mcykge1xuICB2YXIgciA9IG5ldyBVSW50OEFycmF5UmVhZGVyKGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMocyksIG9mcyk7XG4gIGZ1bmN0aW9uIHJlYWR2bHEob3ZlcmZsb3cpIHtcbiAgICB2YXIgYyA9IHIucmVhZDh1KCk7XG4gICAgdmFyIG4gPSBjICYgMHg3RjtcbiAgICB3aGlsZSAoKGMgJiAweDgwKSAhPSAwKSB7XG4gICAgICBjID0gci5yZWFkOHUoKTtcbiAgICAgIHZhciBuNyA9IG4gPDwgNztcbiAgICAgIGlmIChuICE9IG43ID4+IDcpIG92ZXJmbG93WzBdID0gdHJ1ZTtcbiAgICAgIG4gPSBuNyB8IChjICYgMHg3Rik7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG5cbiAgc3dpdGNoKHIucmVhZDMydSgpKXtcbiAgY2FzZSAweDg0OTVBNkJFOiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX3NtYWxsICovXG4gICAgdmFyIGhlYWRlcl9sZW4gPSAyMDtcbiAgICB2YXIgZGF0YV9sZW4gPSByLnJlYWQzMnUoKTtcbiAgICBicmVhaztcbiAgY2FzZSAweDg0OTVBNkJEOiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2NvbXByZXNzZWQgKi9cbiAgICB2YXIgaGVhZGVyX2xlbiA9IHIucmVhZDh1KCkgJiAweDNGO1xuICAgIHZhciBvdmVyZmxvdyA9IFtmYWxzZV07XG4gICAgdmFyIGRhdGFfbGVuID0gcmVhZHZscShvdmVyZmxvdyk7XG4gICAgaWYob3ZlcmZsb3dbMF0pe1xuICAgICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBvYmplY3QgdG9vIGxhcmdlIHRvIGJlIHJlYWQgYmFjayBvbiB0aGlzIHBsYXRmb3JtXCIpO1xuICAgIH1cbiAgICBicmVha1xuICBjYXNlIDB4ODQ5NUE2QkY6IC8qIEludGV4dF9tYWdpY19udW1iZXJfYmlnICovXG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBiYWQgb2JqZWN0XCIpO1xuICAgIGJyZWFrXG4gIH1cbiAgcmV0dXJuIGhlYWRlcl9sZW4gLSBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUgKyBkYXRhX2xlbjtcbn1cblxuLy9Qcm92aWRlczogTWxPYmplY3RUYWJsZVxudmFyIE1sT2JqZWN0VGFibGU7XG5pZiAodHlwZW9mIGdsb2JhbFRoaXMuTWFwID09PSAndW5kZWZpbmVkJykge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgLyogcG9seWZpbGwgKHVzaW5nIGxpbmVhciBzZWFyY2gpICovXG4gICAgZnVuY3Rpb24gTmFpdmVMb29rdXAob2JqcykgeyB0aGlzLm9ianMgPSBvYmpzOyB9XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLm9ianNbaV0gPT09IHYpIHJldHVybiBpO1xuICAgICAgfVxuICAgIH07XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRG8gbm90aGluZyBoZXJlLiBbTWxPYmplY3RUYWJsZS5zdG9yZV0gd2lsbCBwdXNoIHRvIFt0aGlzLm9ianNdIGRpcmVjdGx5LlxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBOYWl2ZUxvb2t1cCh0aGlzLm9ianMpO1xuICAgIH07XG4gIH0oKTtcbn1cbmVsc2Uge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICB0aGlzLm9ianMgPSBbXTsgdGhpcy5sb29rdXAgPSBuZXcgZ2xvYmFsVGhpcy5NYXAoKTtcbiAgfTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMubG9va3VwLnNldCh2LCB0aGlzLm9ianMubGVuZ3RoKTtcbiAgdGhpcy5vYmpzLnB1c2godik7XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnJlY2FsbCA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIGkgPSB0aGlzLmxvb2t1cC5nZXQodik7XG4gIHJldHVybiAoaSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkIDogdGhpcy5vYmpzLmxlbmd0aCAtIGk7ICAgLyogaW5kZXggaXMgcmVsYXRpdmUgKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IE1sT2JqZWN0VGFibGUsIGNhbWxfbGlzdF90b19qc19hcnJheSwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9pc19jb250aW51YXRpb25fdGFnXG52YXIgY2FtbF9vdXRwdXRfdmFsID0gZnVuY3Rpb24gKCl7XG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7IHRoaXMuY2h1bmsgPSBbXTsgfVxuICBXcml0ZXIucHJvdG90eXBlID0ge1xuICAgIGNodW5rX2lkeDoyMCwgYmxvY2tfbGVuOjAsIG9ial9jb3VudGVyOjAsIHNpemVfMzI6MCwgc2l6ZV82NDowLFxuICAgIHdyaXRlOmZ1bmN0aW9uIChzaXplLCB2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfYXQ6ZnVuY3Rpb24gKHBvcywgc2l6ZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwb3MgPSBwb3M7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1twb3MrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfY29kZTpmdW5jdGlvbiAoc2l6ZSwgY29kZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSBjb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfc2hhcmVkOmZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIGlmIChvZmZzZXQgPCAoMSA8PCA4KSkgdGhpcy53cml0ZV9jb2RlKDgsIDB4MDQgLypjc3QuQ09ERV9TSEFSRUQ4Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIGlmIChvZmZzZXQgPCAoMSA8PCAxNikpIHRoaXMud3JpdGVfY29kZSgxNiwgMHgwNSAvKmNzdC5DT0RFX1NIQVJFRDE2Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIHRoaXMud3JpdGVfY29kZSgzMiwgMHgwNiAvKmNzdC5DT0RFX1NIQVJFRDMyKi8sIG9mZnNldCk7XG4gICAgfSxcbiAgICBwb3M6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jaHVua19pZHggfSxcbiAgICBmaW5hbGl6ZTpmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJsb2NrX2xlbiA9IHRoaXMuY2h1bmtfaWR4IC0gMjA7XG4gICAgICB0aGlzLmNodW5rX2lkeCA9IDA7XG4gICAgICB0aGlzLndyaXRlICgzMiwgMHg4NDk1QTZCRSk7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5ibG9ja19sZW4pO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMub2JqX2NvdW50ZXIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV8zMik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzY0KTtcbiAgICAgIHJldHVybiB0aGlzLmNodW5rO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKHYsIGZsYWdzKSB7XG4gICAgZmxhZ3MgPSBjYW1sX2xpc3RfdG9fanNfYXJyYXkoZmxhZ3MpO1xuXG4gICAgdmFyIG5vX3NoYXJpbmcgPSAoZmxhZ3MuaW5kZXhPZigwIC8qTWFyc2hhbC5Ob19zaGFyaW5nKi8pICE9PSAtMSksXG4gICAgICAgIGNsb3N1cmVzID0gIChmbGFncy5pbmRleE9mKDEgLypNYXJzaGFsLkNsb3N1cmVzKi8pICE9PSAtMSk7XG4gICAgLyogTWFyc2hhbC5Db21wYXRfMzIgaXMgcmVkdW5kYW50IHNpbmNlIGludGVnZXJzIGFyZSAzMi1iaXQgYW55d2F5ICovXG5cbiAgICBpZiAoY2xvc3VyZXMpXG4gICAgICBjb25zb2xlLndhcm4oXCJpbiBjYW1sX291dHB1dF92YWw6IGZsYWcgTWFyc2hhbC5DbG9zdXJlcyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcblxuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyICgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gbm9fc2hhcmluZyA/IG51bGwgOiBuZXcgTWxPYmplY3RUYWJsZSgpO1xuXG4gICAgZnVuY3Rpb24gbWVtbyh2KSB7XG4gICAgICBpZiAobm9fc2hhcmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGV4aXN0aW5nX29mZnNldCA9IGludGVybl9vYmpfdGFibGUucmVjYWxsKHYpO1xuICAgICAgaWYgKGV4aXN0aW5nX29mZnNldCkgeyB3cml0ZXIud3JpdGVfc2hhcmVkKGV4aXN0aW5nX29mZnNldCk7IHJldHVybiB0cnVlOyB9XG4gICAgICBlbHNlIHsgaW50ZXJuX29ial90YWJsZS5zdG9yZSh2KTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZXJuX3JlYyAodikge1xuICAgICAgaWYgKHYuY2FtbF9jdXN0b20pIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIG5hbWUgPSB2LmNhbWxfY3VzdG9tO1xuICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW25hbWVdO1xuICAgICAgICB2YXIgc3pfMzJfNjQgPSBbMCwwXTtcbiAgICAgICAgaWYoIW9wcy5zZXJpYWxpemUpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQ3VzdG9tKVwiKTtcbiAgICAgICAgaWYob3BzLmZpeGVkX2xlbmd0aCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOCAvKmNzdC5DT0RFX0NVU1RPTV9MRU4qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgaGVhZGVyX3BvcyA9IHdyaXRlci5wb3MgKCk7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcywgMzIsIHN6XzMyXzY0WzBdKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDQsIDMyLCAwKTsgLy8gemVyb1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgOCwgMzIsIHN6XzMyXzY0WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTkgLypjc3QuQ09ERV9DVVNUT01fRklYRUQqLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHdyaXRlci5wb3MoKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoICE9IHdyaXRlci5wb3MoKSAtIG9sZF9wb3MpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBpbmNvcnJlY3QgZml4ZWQgc2l6ZXMgc3BlY2lmaWVkIGJ5IFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMiArICgoc3pfMzJfNjRbMF0gKyAzKSA+PiAyKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMiArICgoc3pfMzJfNjRbMV0gKyA3KSA+PiAzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgICBpZiAodlswXSA9PSAyNTEpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQWJzdHJhY3QpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodlswXSkpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBjb250aW51YXRpb24gdmFsdWVcIik7XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEgJiYgbWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICBpZiAodlswXSA8IDE2ICYmIHYubGVuZ3RoIC0gMSA8IDgpXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovICsgdlswXSArICgodi5sZW5ndGggLSAxKTw8NCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDggLypjc3QuQ09ERV9CTE9DSzMyKi8sICgodi5sZW5ndGgtMSkgPDwgMTApIHwgdlswXSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IHYubGVuZ3RoO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSB2Lmxlbmd0aDtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkgc3RhY2sucHVzaCAodiwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgICAgaWYoIShjYW1sX2lzX21sX2J5dGVzKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIikpKSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IFtCeXRlcy50XSBjYW5ub3Qgc2FmZWx5IGJlIG1hcnNoYWxlZCB3aXRoIFstLWVuYWJsZSB1c2UtanMtc3RyaW5nXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9ieXRlc19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoOCwgMHgwOS8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDMyLCAweDBBIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxlbjtpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICE9ICh2fDApKXtcbiAgICAgICAgICB2YXIgdHlwZV9vZl92ID0gdHlwZW9mIHY7XG4gICAgICAgICAgaWYodHlwZV9vZl92ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoXCIrdHlwZV9vZl92K1wiKVwiKTtcbiAgICAgICAgICAvLyBJZiBhIGZsb2F0IGhhcHBlbnMgdG8gYmUgYW4gaW50ZWdlciBpdCBpcyBzZXJpYWxpemVkIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAvLyAoSnNfb2Zfb2NhbWwgY2Fubm90IHRlbGwgd2hldGhlciB0aGUgdHlwZSBvZiBhbiBpbnRlZ2VyIG51bWJlciBpc1xuICAgICAgICAgIC8vIGZsb2F0IG9yIGludGVnZXIuKSBUaGlzIGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCBjcmFzaGVzIHdoZW5cbiAgICAgICAgICAvLyB1bm1hcnNoYWxsaW5nIHVzaW5nIHRoZSBzdGFuZGFyZCBydW50aW1lLlxuICAgICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgICAgdmFyIHQgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh2KSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDBDIC8qY3N0LkNPREVfRE9VQkxFX0xJVFRMRSovKTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPDg7IGkrKyl7d3JpdGVyLndyaXRlKDgsdFs3IC0gaV0pfVxuICAgICAgICAgIHdyaXRlci5zaXplXzMyICs9IDNcbiAgICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAyXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA+PSAwICYmIHYgPCAweDQwKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAwWDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLyArIHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2ID49IC0oMSA8PCA3KSAmJiB2IDwgKDEgPDwgNykpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSg4LCAweDAwIC8qY3N0LkNPREVfSU5UOCovLCB2KTtcbiAgICAgICAgICBlbHNlIGlmICh2ID49IC0oMSA8PCAxNSkgJiYgdiA8ICgxIDw8IDE1KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDE2LCAweDAxIC8qY3N0LkNPREVfSU5UMTYqLywgdik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDIgLypjc3QuQ09ERV9JTlQzMiovLCB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBleHRlcm5fcmVjICh2KTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGkgPSBzdGFjay5wb3AgKCk7XG4gICAgICB2YXIgdiA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIGlmIChpICsgMSA8IHYubGVuZ3RoKSBzdGFjay5wdXNoICh2LCBpICsgMSk7XG4gICAgICBleHRlcm5fcmVjICh2W2ldKTtcbiAgICB9XG4gICAgaWYgKGludGVybl9vYmpfdGFibGUpIHdyaXRlci5vYmpfY291bnRlciA9IGludGVybl9vYmpfdGFibGUub2Jqcy5sZW5ndGg7XG4gICAgd3JpdGVyLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHdyaXRlci5jaHVuaztcbiAgfVxufSAoKTtcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9ieXRlc19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX2JsaXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciAocywgb2ZzLCBsZW4sIHYsIGZsYWdzKSB7XG4gIHZhciB0ID0gY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncyk7XG4gIGlmICh0Lmxlbmd0aCA+IGxlbikgY2FtbF9mYWlsd2l0aCAoXCJNYXJzaGFsLnRvX2J1ZmZlcjogYnVmZmVyIG92ZXJmbG93XCIpO1xuICBjYW1sX2JsaXRfYnl0ZXModCwgMCwgcywgb2ZzLCB0Lmxlbmd0aCk7XG4gIHJldHVybiAwO1xufVxuIiwiLy9Qcm92aWRlczogY2FtbF91bml4X2dldHRpbWVvZmRheVxuLy9BbGlhczogdW5peF9nZXR0aW1lb2ZkYXlcbmZ1bmN0aW9uIGNhbWxfdW5peF9nZXR0aW1lb2ZkYXkgKCkge1xuICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAvIDEwMDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF90aW1lXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfZ2V0dGltZW9mZGF5XG4vL0FsaWFzOiB1bml4X3RpbWVcbmZ1bmN0aW9uIGNhbWxfdW5peF90aW1lICgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoY2FtbF91bml4X2dldHRpbWVvZmRheSAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nbXRpbWVcbi8vQWxpYXM6IHVuaXhfZ210aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfZ210aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0VVRDU2Vjb25kcygpLCBkLmdldFVUQ01pbnV0ZXMoKSwgZC5nZXRVVENIb3VycygpLFxuICAgICAgICAgICAgICAgZC5nZXRVVENEYXRlKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICAgICAgIGQuZ2V0VVRDRGF5KCksIGRveSxcbiAgICAgICAgICAgICAgIGZhbHNlIHwgMCAvKiBmb3IgVVRDIGRheWxpZ2h0IHNhdmluZ3MgdGltZSBpcyBmYWxzZSAqLylcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2xvY2FsdGltZVxuLy9BbGlhczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIGNhbWxfdW5peF9sb2NhbHRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHZhciBqYW4gPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICB2YXIganVsID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0U2Vjb25kcygpLCBkLmdldE1pbnV0ZXMoKSwgZC5nZXRIb3VycygpLFxuICAgICAgICAgICAgICAgZC5nZXREYXRlKCksIGQuZ2V0TW9udGgoKSwgZC5nZXRGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICAgICAgIGQuZ2V0RGF5KCksIGRveSxcbiAgICAgICAgICAgICAgIChkLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBzdGRUaW1lem9uZU9mZnNldCkgfCAwIC8qIGRheWxpZ2h0IHNhdmluZ3MgdGltZSAgZmllbGQuICovKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbWt0aW1lXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfbG9jYWx0aW1lXG4vL0FsaWFzOiB1bml4X21rdGltZVxuZnVuY3Rpb24gY2FtbF91bml4X21rdGltZSh0bSl7XG4gIHZhciBkID0gKG5ldyBEYXRlKHRtWzZdKzE5MDAsdG1bNV0sdG1bNF0sdG1bM10sdG1bMl0sdG1bMV0pKS5nZXRUaW1lKCk7XG4gIHZhciB0ID0gTWF0aC5mbG9vcihkIC8gMTAwMCk7XG4gIHZhciB0bTIgPSBjYW1sX3VuaXhfbG9jYWx0aW1lKHQpO1xuICByZXR1cm4gQkxPQ0soMCx0LHRtMik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfc3RhcnR1cCBjb25zdFxuLy9BbGlhczogd2luX3N0YXJ0dXBcbmZ1bmN0aW9uIGNhbWxfdW5peF9zdGFydHVwKCkge31cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2NsZWFudXAgY29uc3Rcbi8vQWxpYXM6IHdpbl9jbGVhbnVwXG5mdW5jdGlvbiBjYW1sX3VuaXhfY2xlYW51cCgpIHt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9maWxlZGVzY3Jfb2ZfZmQgY29uc3Rcbi8vQWxpYXM6IHdpbl9oYW5kbGVfZmRcbmZ1bmN0aW9uIGNhbWxfdW5peF9maWxlZGVzY3Jfb2ZfZmQoeCkge3JldHVybiB4O31cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2lzYXR0eVxuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWRcbi8vQWxpYXM6IHVuaXhfaXNhdHR5XG5mdW5jdGlvbiBjYW1sX3VuaXhfaXNhdHR5KGZpbGVEZXNjcmlwdG9yKSB7XG4gIGlmKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAgICB2YXIgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG4gICAgcmV0dXJuIHR0eS5pc2F0dHkoZmlsZURlc2NyaXB0b3IpPzE6MDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9pc2F0dHlcbi8vQWxpYXM6IHVuaXhfaXNhdHR5XG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBjYW1sX3VuaXhfaXNhdHR5KGZpbGVEZXNjcmlwdG9yKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtYWtlX3VuaXhfZXJyX2FyZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgdW5peF9lcnJvciA9IFtcbiAgLyogPT09VW5peC5lcnJvcj09PVxuICAgKlxuICAgKiBUaGlzIGFycmF5IGlzIGluIG9yZGVyIG9mIHRoZSB2YXJpYW50IGluIE9DYW1sXG4gICAqL1xuICBcIkUyQklHXCIsIFwiRUFDQ0VTXCIsIFwiRUFHQUlOXCIsIFwiRUJBREZcIiwgXCJFQlVTWVwiLCBcIkVDSElMRFwiLCBcIkVERUFETEtcIiwgXCJFRE9NXCIsXG4gIFwiRUVYSVNUXCIsIFwiRUZBVUxUXCIsIFwiRUZCSUdcIiwgXCJFSU5UUlwiLCBcIkVJTlZBTFwiLCBcIkVJT1wiLCBcIkVJU0RJUlwiLCBcIkVNRklMRVwiLFxuICBcIkVNTElOS1wiLCBcIkVOQU1FVE9PTE9OR1wiLCBcIkVORklMRVwiLCBcIkVOT0RFVlwiLCBcIkVOT0VOVFwiLCBcIkVOT0VYRUNcIiwgXCJFTk9MQ0tcIixcbiAgXCJFTk9NRU1cIiwgXCJFTk9TUENcIiwgXCJFTk9TWVNcIiwgXCJFTk9URElSXCIsIFwiRU5PVEVNUFRZXCIsIFwiRU5PVFRZXCIsIFwiRU5YSU9cIixcbiAgXCJFUEVSTVwiLCBcIkVQSVBFXCIsIFwiRVJBTkdFXCIsIFwiRVJPRlNcIiwgXCJFU1BJUEVcIiwgXCJFU1JDSFwiLCBcIkVYREVWXCIsIFwiRVdPVUxEQkxPQ0tcIixcbiAgXCJFSU5QUk9HUkVTU1wiLCBcIkVBTFJFQURZXCIsIFwiRU5PVFNPQ0tcIiwgXCJFREVTVEFERFJSRVFcIiwgXCJFTVNHU0laRVwiLFxuICBcIkVQUk9UT1RZUEVcIiwgXCJFTk9QUk9UT09QVFwiLCBcIkVQUk9UT05PU1VQUE9SVFwiLCBcIkVTT0NLVE5PU1VQUE9SVFwiLFxuICBcIkVPUE5PVFNVUFBcIiwgXCJFUEZOT1NVUFBPUlRcIiwgXCJFQUZOT1NVUFBPUlRcIiwgXCJFQUREUklOVVNFXCIsIFwiRUFERFJOT1RBVkFJTFwiLFxuICBcIkVORVRET1dOXCIsIFwiRU5FVFVOUkVBQ0hcIiwgXCJFTkVUUkVTRVRcIiwgXCJFQ09OTkFCT1JURURcIiwgXCJFQ09OTlJFU0VUXCIsIFwiRU5PQlVGU1wiLFxuICBcIkVJU0NPTk5cIiwgXCJFTk9UQ09OTlwiLCBcIkVTSFVURE9XTlwiLCBcIkVUT09NQU5ZUkVGU1wiLCBcIkVUSU1FRE9VVFwiLCBcIkVDT05OUkVGVVNFRFwiLFxuICBcIkVIT1NURE9XTlwiLCBcIkVIT1NUVU5SRUFDSFwiLCBcIkVMT09QXCIsIFwiRU9WRVJGTE9XXCJcbl07XG5mdW5jdGlvbiBtYWtlX3VuaXhfZXJyX2FyZ3MoY29kZSwgc3lzY2FsbCwgcGF0aCwgZXJybm8pIHtcbiAgdmFyIHZhcmlhbnQgPSB1bml4X2Vycm9yLmluZGV4T2YoY29kZSk7XG4gIGlmICh2YXJpYW50IDwgMCkge1xuICAgIC8vIERlZmF1bHQgaWYgdW5kZWZpbmVkXG4gICAgaWYgKGVycm5vID09IG51bGwpIHtcbiAgICAgIGVycm5vID0gLTk5OTlcbiAgICB9XG4gICAgLy8gSWYgbm9uZSBvZiB0aGUgYWJvdmUgdmFyaWFudHMsIGZhbGxiYWNrIHRvIEVVTktOT1dORVJSKGludClcbiAgICB2YXJpYW50ID0gQkxPQ0soMCwgZXJybm8pO1xuICB9XG4gIHZhciBhcmdzID0gW1xuICAgIHZhcmlhbnQsXG4gICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoc3lzY2FsbCB8fCBcIlwiKSxcbiAgICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhwYXRoIHx8IFwiXCIpXG4gIF07XG4gIHJldHVybiBhcmdzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfc3RhdFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfc3RhdFxuZnVuY3Rpb24gY2FtbF91bml4X3N0YXQobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnN0YXQpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3N0YXQ6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2Uuc3RhdChyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9zdGF0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfc3RhdCwgY2FtbF9pbnQ2NF9vZl9pbnQzMlxuLy9BbGlhczogdW5peF9zdGF0XzY0XG5mdW5jdGlvbiBjYW1sX3VuaXhfc3RhdF82NChuYW1lKSB7XG4gIHZhciByID0gY2FtbF91bml4X3N0YXQobmFtZSk7XG4gIHJbOV0gPSBjYW1sX2ludDY0X29mX2ludDMyKHJbOV0pO1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2xzdGF0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9sc3RhdFxuZnVuY3Rpb24gY2FtbF91bml4X2xzdGF0KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5sc3RhdCkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfbHN0YXQ6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UubHN0YXQocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbHN0YXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sc3RhdCwgY2FtbF9pbnQ2NF9vZl9pbnQzMlxuLy9BbGlhczogdW5peF9sc3RhdF82NFxuZnVuY3Rpb24gY2FtbF91bml4X2xzdGF0XzY0KG5hbWUpIHtcbiAgdmFyIHIgPSBjYW1sX3VuaXhfbHN0YXQobmFtZSk7XG4gIHJbOV0gPSBjYW1sX2ludDY0X29mX2ludDMyKHJbOV0pO1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X21rZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9ta2RpclxuZnVuY3Rpb24gY2FtbF91bml4X21rZGlyKG5hbWUsIHBlcm0pIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5ta2Rpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfbWtkaXI6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UubWtkaXIocm9vdC5yZXN0LCBwZXJtLCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcm1kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3JtZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfcm1kaXIobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnJtZGlyKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9ybWRpcjogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5ybWRpcihyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9zeW1saW5rXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9zeW1saW5rXG5mdW5jdGlvbiBjYW1sX3VuaXhfc3ltbGluayh0b19kaXIsIHNyYywgZHN0KSB7XG4gIHZhciBzcmNfcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKHNyYyk7XG4gIHZhciBkc3Rfcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRzdCk7XG4gIGlmKHNyY19yb290LmRldmljZSAhPSBkc3Rfcm9vdC5kZXZpY2UpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9zeW1saW5rOiBjYW5ub3Qgc3ltbGluayBiZXR3ZWVuIHR3byBmaWxlc3lzdGVtc1wiKTtcbiAgaWYgKCFzcmNfcm9vdC5kZXZpY2Uuc3ltbGluaykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfc3ltbGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiBzcmNfcm9vdC5kZXZpY2Uuc3ltbGluayh0b19kaXIsIHNyY19yb290LnJlc3QsIGRzdF9yb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9yZWFkbGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfcmVhZGxpbmtcbmZ1bmN0aW9uIGNhbWxfdW5peF9yZWFkbGluayhuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UucmVhZGxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3JlYWRsaW5rOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnJlYWRsaW5rKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3VubGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfdW5saW5rXG5mdW5jdGlvbiBjYW1sX3VuaXhfdW5saW5rKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS51bmxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3VubGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZ2V0dWlkXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9BbGlhczogdW5peF9nZXR1aWRcbmZ1bmN0aW9uIGNhbWxfdW5peF9nZXR1aWQodW5pdCkge1xuICBpZihnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLmdldHVpZCl7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMucHJvY2Vzcy5nZXR1aWQoKTtcbiAgfVxuICBjYW1sX3JhaXNlX25vdF9mb3VuZCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZ2V0cHd1aWRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL0FsaWFzOiB1bml4X2dldHB3dWlkXG5mdW5jdGlvbiBjYW1sX3VuaXhfZ2V0cHd1aWQodW5pdCkge1xuICBjYW1sX3JhaXNlX25vdF9mb3VuZCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfaGFzX3N5bWxpbmtcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL0FsaWFzOiB1bml4X2hhc19zeW1saW5rXG5mdW5jdGlvbiBjYW1sX3VuaXhfaGFzX3N5bWxpbmsodW5pdCkge1xuICByZXR1cm4gZnNfbm9kZV9zdXBwb3J0ZWQoKT8xOjBcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X29wZW5kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X29wZW5kaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9vcGVuZGlyKHBhdGgpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShwYXRoKTtcbiAgaWYgKCFyb290LmRldmljZS5vcGVuZGlyKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9vcGVuZGlyOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgdmFyIGRpcl9oYW5kbGUgPSByb290LmRldmljZS5vcGVuZGlyKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbiAgcmV0dXJuIHsgcG9pbnRlciA6IGRpcl9oYW5kbGUsIHBhdGg6IHBhdGggfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcmVhZGRpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJncywgY2FtbF9yYWlzZV93aXRoX2FyZ3MsIGNhbWxfbmFtZWRfdmFsdWVcbi8vQWxpYXM6IHVuaXhfcmVhZGRpclxuZnVuY3Rpb24gY2FtbF91bml4X3JlYWRkaXIoZGlyX2hhbmRsZSkge1xuICB2YXIgZW50cnk7XG4gIHRyeSB7XG4gICAgICBlbnRyeSA9IGRpcl9oYW5kbGUucG9pbnRlci5yZWFkU3luYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgICB2YXIgdW5peF9lcnJvciA9IGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUJBREZcIiwgXCJyZWFkZGlyXCIsIGRpcl9oYW5kbGUucGF0aCkpO1xuICB9XG4gIGlmIChlbnRyeSA9PT0gbnVsbCkge1xuICAgICAgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGVudHJ5Lm5hbWUpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9jbG9zZWRpclxuLy9SZXF1aXJlczogbWFrZV91bml4X2Vycl9hcmdzLCBjYW1sX3JhaXNlX3dpdGhfYXJncywgY2FtbF9uYW1lZF92YWx1ZVxuLy9BbGlhczogdW5peF9jbG9zZWRpclxuZnVuY3Rpb24gY2FtbF91bml4X2Nsb3NlZGlyKGRpcl9oYW5kbGUpIHtcbiAgdHJ5IHtcbiAgICAgIGRpcl9oYW5kbGUucG9pbnRlci5jbG9zZVN5bmMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgICAgdmFyIHVuaXhfZXJyb3IgPSBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVCQURGXCIsIFwiY2xvc2VkaXJcIiwgZGlyX2hhbmRsZS5wYXRoKSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3Jld2luZGRpclxuLy9SZXF1aXJlczogY2FtbF91bml4X2Nsb3NlZGlyLCBjYW1sX3VuaXhfb3BlbmRpclxuLy9BbGlhczogdW5peF9yZXdpbmRkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9yZXdpbmRkaXIoZGlyX2hhbmRsZSkge1xuICBjYW1sX3VuaXhfY2xvc2VkaXIoZGlyX2hhbmRsZSk7XG4gIHZhciBuZXdfZGlyX2hhbmRsZSA9IGNhbWxfdW5peF9vcGVuZGlyKGRpcl9oYW5kbGUucGF0aCk7XG4gIGRpcl9oYW5kbGUucG9pbnRlciA9IG5ld19kaXJfaGFuZGxlLnBvaW50ZXI7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmluZGZpcnN0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9vcGVuZGlyLCBjYW1sX3VuaXhfcmVhZGRpclxuLy9BbGlhczogd2luX2ZpbmRmaXJzdFxuZnVuY3Rpb24gY2FtbF91bml4X2ZpbmRmaXJzdChwYXRoKSB7XG4gIC8vIFRoZSBXaW5kb3dzIGNvZGUgYWRkcyB0aGlzIGdsb2IgdG8gdGhlIHBhdGgsIHNvIHdlIG5lZWQgdG8gcmVtb3ZlIGl0XG4gIHZhciBwYXRoX2pzID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCk7XG4gIHBhdGhfanMgPSBwYXRoX2pzLnJlcGxhY2UoLyhefFtcXFxcXFwvXSlcXCpcXC5cXCokLywgXCJcIik7XG4gIHBhdGggPSBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhwYXRoX2pzKTtcbiAgLy8gKi4qIGlzIG5vdyBzdHJpcHBlZFxuICB2YXIgZGlyX2hhbmRsZSA9IGNhbWxfdW5peF9vcGVuZGlyKHBhdGgpO1xuICB2YXIgZmlyc3RfZW50cnkgPSBjYW1sX3VuaXhfcmVhZGRpcihkaXJfaGFuZGxlKTtcbiAgLy8gVGhlIFdpbmRvd3MgYmluZGluZ3MgdHlwZSBkaXJfaGFuZGxlIGFzIGFuIGBpbnRgIGJ1dCBpdCdzIG5vdCBpbiBKU1xuICByZXR1cm4gWzAsIGZpcnN0X2VudHJ5LCBkaXJfaGFuZGxlXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZpbmRuZXh0XG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfcmVhZGRpclxuLy9BbGlhczogd2luX2ZpbmRuZXh0XG5mdW5jdGlvbiBjYW1sX3VuaXhfZmluZG5leHQoZGlyX2hhbmRsZSkge1xuICByZXR1cm4gY2FtbF91bml4X3JlYWRkaXIoZGlyX2hhbmRsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9maW5kY2xvc2Vcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9jbG9zZWRpclxuLy9BbGlhczogd2luX2ZpbmRjbG9zZVxuZnVuY3Rpb24gY2FtbF91bml4X2ZpbmRjbG9zZShkaXJfaGFuZGxlKSB7XG4gIHJldHVybiBjYW1sX3VuaXhfY2xvc2VkaXIoZGlyX2hhbmRsZSk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2luZXRfYWRkcl9vZl9zdHJpbmcgY29uc3Rcbi8vQWxpYXM6IHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF91bml4X2luZXRfYWRkcl9vZl9zdHJpbmcgKCkge3JldHVybiAwO31cblxuXG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsX2dlbiAoY29uc3QsIHNoYWxsb3cpXG4vL0lmOiAhZWZmZWN0c1xuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpIHtcbiAgdmFyIG4gPSAoZi5sID49IDApP2YubDooZi5sID0gZi5sZW5ndGgpO1xuICB2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgZCA9IG4gLSBhcmdzTGVuO1xuICBpZiAoZCA9PSAwKVxuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICBlbHNlIGlmIChkIDwgMCkge1xuICAgIHZhciBnID0gZi5hcHBseShudWxsLGFyZ3Muc2xpY2UoMCxuKSk7XG4gICAgaWYodHlwZW9mIGcgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGc7XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZyxhcmdzLnNsaWNlKG4pKTtcbiAgfVxuICBlbHNlIHtcbiAgICBzd2l0Y2ggKGQpIHtcbiAgICBjYXNlIDE6IHtcbiAgICAgIHZhciBnID0gZnVuY3Rpb24gKHgpe1xuICAgICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJnc0xlbiArIDEpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJnc0xlbjsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgICBuYXJnc1thcmdzTGVuXSA9IHg7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIG5hcmdzKVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDI6IHtcbiAgICAgIHZhciBnID0gZnVuY3Rpb24gKHgsIHkpe1xuICAgICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJnc0xlbiArIDIpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJnc0xlbjsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgICBuYXJnc1thcmdzTGVuXSA9IHg7XG4gICAgICAgIG5hcmdzW2FyZ3NMZW4gKyAxXSA9IHk7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIG5hcmdzKVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB2YXIgZyA9IGZ1bmN0aW9uICgpe1xuICAgICAgICB2YXIgZXh0cmFfYXJncyA9IChhcmd1bWVudHMubGVuZ3RoID09IDApPzE6YXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoK2V4dHJhX2FyZ3MpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIG5hcmdzW2FyZ3MubGVuZ3RoK2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBuYXJncylcbiAgICAgIH07XG4gICAgfX1cbiAgICBnLmwgPSBkO1xuICAgIHJldHVybiBnO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9JZjogZWZmZWN0c1xuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpIHtcbiAgdmFyIG4gPSAoZi5sID49IDApP2YubDooZi5sID0gZi5sZW5ndGgpO1xuICB2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgZCA9IG4gLSBhcmdzTGVuO1xuICBpZiAoZCA9PSAwKSB7XG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIH0gZWxzZSBpZiAoZCA8IDApIHtcbiAgICB2YXIgcmVzdCA9IGFyZ3Muc2xpY2UobiAtIDEpO1xuICAgIHZhciBrID0gYXJncyBbYXJnc0xlbiAtIDFdO1xuICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDAsIG4pO1xuICAgIGFyZ3NbbiAtIDFdID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgIGlmICh0eXBlb2YgZyAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gayhnKTtcbiAgICAgIHZhciBhcmdzID0gcmVzdC5zbGljZSgpO1xuICAgICAgYXJnc1thcmdzLmxlbmd0aCAtIDFdID0gaztcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGcsIGFyZ3MpOyB9O1xuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3NMZW4tLTtcbiAgICB2YXIgayA9IGFyZ3MgW2FyZ3NMZW5dO1xuICAgIHN3aXRjaCAoZCkge1xuICAgIGNhc2UgMToge1xuICAgICAgdmFyIGcgPSBmdW5jdGlvbiAoeCwgeSl7XG4gICAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzTGVuICsgMik7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzTGVuOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgIG5hcmdzW2FyZ3NMZW5dID0geDtcbiAgICAgICAgbmFyZ3NbYXJnc0xlbiArIDFdID0geTtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgbmFyZ3MpXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMjoge1xuICAgICAgdmFyIGcgPSBmdW5jdGlvbiAoeCwgeSwgeil7XG4gICAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzTGVuICsgMyk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzTGVuOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgIG5hcmdzW2FyZ3NMZW5dID0geDtcbiAgICAgICAgbmFyZ3NbYXJnc0xlbiArIDFdID0geTtcbiAgICAgICAgbmFyZ3NbYXJnc0xlbiArIDJdID0gejtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgbmFyZ3MpXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHZhciBnID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHZhciBleHRyYV9hcmdzID0gKGFyZ3VtZW50cy5sZW5ndGggPT0gMCk/MTphcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJnc0xlbiArIGV4dHJhX2FyZ3MpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJnc0xlbjsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrIClcbiAgICAgICAgICBuYXJnc1thcmdzTGVuICsgaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIG5hcmdzKVxuICAgICAgfTtcbiAgICB9fVxuICAgIGcubCA9IGQgKyAxO1xuICAgIHJldHVybiBrKGcpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG52YXIgY2FtbF9uYW1lZF92YWx1ZXMgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSAoY29uc3QsbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlKG5tLHYpIHtcbiAgY2FtbF9uYW1lZF92YWx1ZXNbY2FtbF9qc2J5dGVzX29mX3N0cmluZyhubSldID0gdjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG5mdW5jdGlvbiBjYW1sX25hbWVkX3ZhbHVlKG5tKSB7XG4gIHJldHVybiBjYW1sX25hbWVkX3ZhbHVlc1tubV1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nbG9iYWxfZGF0YVxudmFyIGNhbWxfZ2xvYmFsX2RhdGEgPSBbMF07XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnVpbGRfc3ltYm9sc1xuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYnVpbGRfc3ltYm9scyhzeW1iKSB7XG4gIHZhciByID0ge307XG4gIGlmKHN5bWIpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgc3ltYi5sZW5ndGg7IGkrKyl7XG4gICAgICByW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHN5bWJbaV1bMV0pXSA9IHN5bWJbaV1bMl1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChjb25zdCwgc2hhbGxvdywgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX2NhbGxiYWNrLCBjYW1sX2J1aWxkX3N5bWJvbHNcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChuLCB2LCBuYW1lX29wdCkge1xuICBpZiAobmFtZV9vcHQpIHtcbiAgICB2YXIgbmFtZSA9IG5hbWVfb3B0O1xuICAgIGlmKGdsb2JhbFRoaXMudG9wbGV2ZWxSZWxvYykge1xuICAgICAgbiA9IGNhbWxfY2FsbGJhY2soZ2xvYmFsVGhpcy50b3BsZXZlbFJlbG9jLCBbbmFtZV0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYW1sX2dsb2JhbF9kYXRhLnN5bWJvbHMpIHtcbiAgICAgIGlmKCFjYW1sX2dsb2JhbF9kYXRhLnN5bWlkeCkge1xuICAgICAgICBjYW1sX2dsb2JhbF9kYXRhLnN5bWlkeCA9IGNhbWxfYnVpbGRfc3ltYm9scyhjYW1sX2dsb2JhbF9kYXRhLnN5bWJvbHMpXG4gICAgICB9XG4gICAgICB2YXIgbmlkID0gY2FtbF9nbG9iYWxfZGF0YS5zeW1pZHhbbmFtZV1cbiAgICAgIGlmKG5pZCA+PSAwKVxuICAgICAgICBuID0gbmlkXG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImNhbWxfcmVnaXN0ZXJfZ2xvYmFsOiBjYW5ub3QgbG9jYXRlIFwiICsgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbWxfZ2xvYmFsX2RhdGFbbiArIDFdID0gdjtcbiAgaWYobmFtZV9vcHQpIGNhbWxfZ2xvYmFsX2RhdGFbbmFtZV9vcHRdID0gdjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfZ2xvYmFsX2RhdGEgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9nZXRfZ2xvYmFsX2RhdGEgKCkgeyByZXR1cm4gY2FtbF9nbG9iYWxfZGF0YTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX3ByaW50YWJsZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2lzX3ByaW50YWJsZShjKSB7IHJldHVybiArKGMgPiAzMSAmJiBjIDwgMTI3KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21heWJlX3ByaW50X3N0YXRzXG5mdW5jdGlvbiBjYW1sX21heWJlX3ByaW50X3N0YXRzKHVuaXQpIHsgcmV0dXJuIDAgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBTeXNcblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuU3lzX2Vycm9yLCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4aXQgKGNvZGUpIHtcbiAgaWYoZ2xvYmFsVGhpcy5xdWl0KSBnbG9iYWxUaGlzLnF1aXQoY29kZSk7XG4gIC8vbm9kZWpzXG4gIGlmKGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MuZXhpdClcbiAgICBnbG9iYWxUaGlzLnByb2Nlc3MuZXhpdChjb2RlKTtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiRnVuY3Rpb24gJ2V4aXQnIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvbihleG4pe1xuICBzd2l0Y2goZXhuWzJdKSB7XG4gIGNhc2UgLTg6IC8vIE1hdGNoX2ZhaWx1cmVcbiAgY2FzZSAtMTE6IC8vIEFzc2VydF9mYWlsdXJlXG4gIGNhc2UgLTEyOiAvLyBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZVxuICAgIHJldHVybiAxO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2V4Y2VwdGlvblxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9mb3JtYXRfZXhjZXB0aW9uKGV4bil7XG4gIHZhciByID0gXCJcIjtcbiAgaWYoZXhuWzBdID09IDApIHtcbiAgICByICs9IGV4blsxXVsxXTtcbiAgICBpZihleG4ubGVuZ3RoID09IDMgJiYgZXhuWzJdWzBdID09IDAgJiYgY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvbihleG5bMV0pKSB7XG5cbiAgICAgIHZhciBidWNrZXQgPSBleG5bMl07XG4gICAgICB2YXIgc3RhcnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSAyXG4gICAgICB2YXIgYnVja2V0ID0gZXhuO1xuICAgIH1cbiAgICByICs9IFwiKFwiO1xuICAgIGZvcih2YXIgaSA9IHN0YXJ0OyBpIDwgYnVja2V0Lmxlbmd0aDsgaSArKyl7XG4gICAgICBpZihpID4gc3RhcnQpIHIrPVwiLCBcIjtcbiAgICAgIHZhciB2ID0gYnVja2V0W2ldXG4gICAgICBpZih0eXBlb2YgdiA9PSBcIm51bWJlclwiKVxuICAgICAgICByKz0gdi50b1N0cmluZygpO1xuICAgICAgZWxzZSBpZih2IGluc3RhbmNlb2YgTWxCeXRlcyl7XG4gICAgICAgIHIrPSAnXCInICsgdi50b1N0cmluZygpICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodHlwZW9mIHYgPT0gXCJzdHJpbmdcIil7XG4gICAgICAgIHIrPSAnXCInICsgdi50b1N0cmluZygpICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGVsc2UgciArPSBcIl9cIjtcbiAgICB9XG4gICAgciArPSBcIilcIlxuICB9IGVsc2UgaWYgKGV4blswXSA9PSAyNDgpe1xuICAgIHIgKz0gZXhuWzFdXG4gIH1cbiAgcmV0dXJuIHJcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25cbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfZm9ybWF0X2V4Y2VwdGlvbiwgY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24oZXJyKXtcbiAgaWYoZXJyIGluc3RhbmNlb2YgQXJyYXkgJiYgKGVyclswXSA9PSAwIHx8IGVyclswXSA9PSAyNDgpKSB7XG4gICAgdmFyIGhhbmRsZXIgPSBjYW1sX25hbWVkX3ZhbHVlKFwiUHJpbnRleGMuaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblwiKTtcbiAgICBpZihoYW5kbGVyKSBjYW1sX2NhbGxiYWNrKGhhbmRsZXIsIFtlcnIsZmFsc2VdKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBtc2cgPSBjYW1sX2Zvcm1hdF9leGNlcHRpb24oZXJyKTtcbiAgICAgIHZhciBhdF9leGl0ID0gY2FtbF9uYW1lZF92YWx1ZShcIlBlcnZhc2l2ZXMuZG9fYXRfZXhpdFwiKTtcbiAgICAgIGlmKGF0X2V4aXQpIGNhbWxfY2FsbGJhY2soYXRfZXhpdCwgWzBdKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uIFwiICsgbXNnKTtcbiAgICAgIGlmKGVyci5qc19lcnJvcikgdGhyb3cgZXJyLmpzX2Vycm9yO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9zdGF0aWNfZW52XG5mdW5jdGlvbiBjYW1sX3NldF9zdGF0aWNfZW52KGssdil7XG4gIGlmKCFnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudilcbiAgICBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudiA9IHt9XG4gIGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W2tdID0gdjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fc3lzX2dldGVudiAoY29uc3QpXG5mdW5jdGlvbiBqc29vX3N5c19nZXRlbnYobikge1xuICB2YXIgcHJvY2VzcyA9IGdsb2JhbFRoaXMucHJvY2VzcztcbiAgLy9ub2RlanMgZW52XG4gIGlmKHByb2Nlc3NcbiAgICAgJiYgcHJvY2Vzcy5lbnZcbiAgICAgJiYgcHJvY2Vzcy5lbnZbbl0gIT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBwcm9jZXNzLmVudltuXTtcbiAgaWYoZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZcbiAgICAgJiYgZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZbbl0pXG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W25dXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGVudiAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX3N5c19nZXRlbnZcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGVudiAobmFtZSkge1xuICB2YXIgciA9IGpzb29fc3lzX2dldGVudihjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKSk7XG4gIGlmKHIgPT09IHVuZGVmaW5lZClcbiAgICBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3Vuc2FmZV9nZXRlbnZcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2dldGVudlxuZnVuY3Rpb24gY2FtbF9zeXNfdW5zYWZlX2dldGVudihuYW1lKXtcbiAgcmV0dXJuIGNhbWxfc3lzX2dldGVudiAobmFtZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJndlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbnZhciBjYW1sX2FyZ3YgPSAoKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb2Nlc3MgPSBnbG9iYWxUaGlzLnByb2Nlc3M7XG4gIHZhciBtYWluID0gXCJhLm91dFwiO1xuICB2YXIgYXJncyA9IFtdXG5cbiAgaWYocHJvY2Vzc1xuICAgICAmJiBwcm9jZXNzLmFyZ3ZcbiAgICAgJiYgcHJvY2Vzcy5hcmd2Lmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYXJndiA9IHByb2Nlc3MuYXJndlxuICAgIC8vbm9kZWpzXG4gICAgbWFpbiA9IGFyZ3ZbMV07XG4gICAgYXJncyA9IGFyZ3Yuc2xpY2UoMik7XG4gIH1cblxuICB2YXIgcCA9IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKG1haW4pO1xuICB2YXIgYXJnczIgPSBbMCwgcF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKVxuICAgIGFyZ3MyLnB1c2goY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoYXJnc1tpXSkpO1xuICByZXR1cm4gYXJnczI7XG59KSgpKVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG52YXIgY2FtbF9leGVjdXRhYmxlX25hbWUgPSBjYW1sX2FyZ3ZbMV1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2FyZ3YgKGEpIHtcbiAgcmV0dXJuIFswLCBjYW1sX2FyZ3ZbMV0sIGNhbWxfYXJndl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfYXJndiAoYSkge1xuICByZXR1cm4gY2FtbF9hcmd2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19tb2RpZnlfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19tb2RpZnlfYXJndihhcmcpe1xuICBjYW1sX2FyZ3YgPSBhcmc7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG5mdW5jdGlvbiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUoYSl7XG4gIHJldHVybiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kKGNtZCl7XG4gIHZhciBjbWQgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhjbWQpO1xuICBpZiAodHlwZW9mIHJlcXVpcmUgIT0gXCJ1bmRlZmluZWRcIil7XG4gICAgdmFyIGNoaWxkX3Byb2Nlc3MgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG4gICAgaWYoY2hpbGRfcHJvY2VzcyAmJiBjaGlsZF9wcm9jZXNzLmV4ZWNTeW5jKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY2hpbGRfcHJvY2Vzcy5leGVjU3luYyhjbWQse3N0ZGlvOiAnaW5oZXJpdCd9KTtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgfVxuICBlbHNlIHJldHVybiAxMjc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKXtcbiAgcmV0dXJuIDEyNztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZSBtdXRhYmxlXG52YXIgY2FtbF9pbml0aWFsX3RpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICogMC4wMDE7XG5mdW5jdGlvbiBjYW1sX3N5c190aW1lICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHJldHVybiBub3cgKiAwLjAwMSAtIGNhbWxfaW5pdGlhbF90aW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW5cbi8vUmVxdWlyZXM6IGNhbWxfc3lzX3RpbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlbihiKSB7XG4gIHJldHVybiBjYW1sX3N5c190aW1lKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JhbmRvbV9zZWVkIG11dGFibGVcbi8vVGhlIGZ1bmN0aW9uIG5lZWRzIHRvIHJldHVybiBhbiBhcnJheSBzaW5jZSBPQ2FtbCA0LjAuLi5cbmZ1bmN0aW9uIGNhbWxfc3lzX3JhbmRvbV9zZWVkICgpIHtcbiAgaWYgKGdsb2JhbFRoaXMuY3J5cHRvKSB7XG4gICAgIGlmIChnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICB2YXIgYSA9IGdsb2JhbFRoaXMuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgSW50MzJBcnJheSg0KSk7XG4gICAgICAgcmV0dXJuIFswLCBhWzBdLCBhWzFdLCBhWzJdLCBhWzNdXTtcbiAgICAgfSBlbHNlIGlmIChnbG9iYWxUaGlzLmNyeXB0by5yYW5kb21CeXRlcykge1xuICAgICAgIHZhciBhID0gbmV3IEludDMyQXJyYXkoZ2xvYmFsVGhpcy5jcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLmJ1ZmZlcik7XG4gICAgICAgcmV0dXJuIFswLCBhWzBdLCBhWzFdLCBhWzJdLCBhWzNdXTtcbiAgICAgfVxuICB9XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICB2YXIgeCA9IG5vd14weGZmZmZmZmZmKk1hdGgucmFuZG9tKCk7XG4gIHJldHVybiBbMCx4XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2ludF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIGNvbnN0XG4vLyBtYXhfaW50IC8gNCBzbyB0aGF0IHRoZSBmb2xsb3dpbmcgZG9lcyBub3Qgb3ZlcmZsb3dcbi8vbGV0IG1heF9zdHJpbmdfbGVuZ3RoID0gd29yZF9zaXplIC8gOCAqIG1heF9hcnJheV9sZW5ndGggLSAxOztcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgKCkgeyByZXR1cm4gKDB4N0ZGRkZGRkYvNCkgfCAwO31cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4ICgpIHsgcmV0dXJuIG9zX3R5cGUgPT0gXCJVbml4XCIgPyAxIDogMDsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgKCkgeyByZXR1cm4gb3NfdHlwZSA9PSBcIldpbjMyXCIgPyAxIDogMDsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiAoKSB7IHJldHVybiBvc190eXBlID09IFwiQ3lnd2luXCIgPyAxIDogMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcImpzX29mX29jYW1sXCIpXTtcbn1cblxuLy9Qcm92aWRlczogb3NfdHlwZVxudmFyIG9zX3R5cGUgPSAoZ2xvYmFsVGhpcy5wcm9jZXNzICYmXG4gICAgICAgICAgICAgICBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gJiZcbiAgICAgICAgICAgICAgIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSA9PSBcIndpbjMyXCIpID8gXCJDeWd3aW5cIiA6IFwiVW5peFwiO1xuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldF9jb25maWcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldF9jb25maWcgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMob3NfdHlwZSksIDMyLCAwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNhdHR5XG5mdW5jdGlvbiBjYW1sX3N5c19pc2F0dHkoX2NoYW4pIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV92YXJpYW50XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfdmFyaWFudChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyhfdW5pdCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIoKXtyZXR1cm4gMH1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG52YXIgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5nc1xuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzIChib29sKSB7XG4gIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IGJvb2w7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZFxuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCAoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfcnVudGltZV93YXJuaW5ncztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9lbmFibGVkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUoX2NoYW5uZWwpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcIlNwYWNldGltZSBwcm9maWxpbmcgb25seSB3b3JrcyBmb3IgbmF0aXZlIGNvZGVcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfeGRnX2RlZmF1bHRzXG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF94ZGdfZGVmYXVsdHMoX3VuaXQpIHtcbiAgcmV0dXJuIDA7IC8vIGVtcHR5IGxpc3Rcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNfcmVndWxhcl9maWxlXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNfcmVndWxhcl9maWxlKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmlzRmlsZShyb290LnJlc3QpO1xufVxuLy9BbHdheXNcbi8vUmVxdWlyZXM6IGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyKCkge1xuICB2YXIgcHJvY2VzcyA9IGdsb2JhbFRoaXMucHJvY2VzcztcbiAgaWYocHJvY2VzcyAmJiBwcm9jZXNzLm9uKSB7XG4gICAgcHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCBmdW5jdGlvbiAoZXJyLCBvcmlnaW4pIHtcbiAgICAgIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGVycik7XG4gICAgICBwcm9jZXNzLmV4aXQgKDIpO1xuICAgIH0pXG4gIH1cbiAgZWxzZSBpZihnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIpe1xuICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbihldmVudCl7XG4gICAgICBpZihldmVudC5lcnJvcil7XG4gICAgICAgIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGV2ZW50LmVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlcigpO1xuXG5cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cblxuLy9Qcm92aWRlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWdcbi8vUmVxdWlyZXM6IGpzb29fc3lzX2dldGVudlxudmFyIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnID0gRkxBRyhcIndpdGgtanMtZXJyb3JcIik7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciByID0ganNvb19zeXNfZ2V0ZW52KFwiT0NBTUxSVU5QQVJBTVwiKVxuICBpZihyICE9PSB1bmRlZmluZWQpe1xuICAgIHZhciBsID0gci5zcGxpdChcIixcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGwubGVuZ3RoOyBpKyspe1xuICAgICAgaWYobFtpXSA9PSBcImJcIikgeyBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZyA9IDE7IGJyZWFrIH1cbiAgICAgIGVsc2UgaWYgKGxbaV0uc3RhcnRzV2l0aChcImI9XCIpKSB7XG4gICAgICAgIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnID0gKyhsW2ldLnNsaWNlKDIpKX1cbiAgICAgIGVsc2UgY29udGludWU7XG4gICAgfVxuICB9XG59KSAoKVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9iYWNrdHJhY2Vfc3RhdHVzXG4vL1JlcXVpcmVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZ1xuZnVuY3Rpb24gY2FtbF9iYWNrdHJhY2Vfc3RhdHVzIChfdW5pdCkgeyByZXR1cm4gY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWcgPyAxIDogMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnXG5mdW5jdGlvbiBjYW1sX3JlY29yZF9iYWNrdHJhY2UgKGIpIHsgY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWcgPSBiOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90ICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdDogaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZShleG4sIGJ0KSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayAoKSB7IHJldHVybiBbMF07IH1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCgpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3B1cmVfZXhwciBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc19wdXJlX2V4cHIgKGYpIHsgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgWzBdKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3NldCAobXV0YWJsZSwgY29uc3QsIG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2pzX3NldChvLGYsdikgeyBvW2ZdPXY7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldCAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2dldChvLGYpIHsgcmV0dXJuIG9bZl07IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZGVsZXRlIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZGVsZXRlKG8sZikgeyBkZWxldGUgb1tmXTsgcmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaW5zdGFuY2VvZiAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19pbnN0YW5jZW9mKG8sYykgeyByZXR1cm4gKG8gaW5zdGFuY2VvZiBjKSA/IDEgOiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdHlwZW9mIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdHlwZW9mKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfc3RhY2tfZGVwdGhcbi8vSWY6IGVmZmVjdHNcbnZhciBjYW1sX3N0YWNrX2RlcHRoID0gMDtcblxuLy9Qcm92aWRlczpjYW1sX3N0YWNrX2NoZWNrX2RlcHRoXG4vL0lmOiBlZmZlY3RzXG4vL1JlcXVpcmVzOmNhbWxfc3RhY2tfZGVwdGhcbmZ1bmN0aW9uIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKSB7XG4gICAgcmV0dXJuIC0tY2FtbF9zdGFja19kZXB0aCA+IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbGJhY2tcbi8vSWY6ICFlZmZlY3RzXG4vL1JlcXVpcmVzOmNhbWxfY2FsbF9nZW5cbnZhciBjYW1sX2NhbGxiYWNrID0gY2FtbF9jYWxsX2dlbjtcblxuLy9Qcm92aWRlczogY2FtbF9jYWxsYmFja1xuLy9JZjogZWZmZWN0c1xuLy9SZXF1aXJlczpjYW1sX3N0YWNrX2RlcHRoLCBjYW1sX2NhbGxfZ2VuLCBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFjaywgY2FtbF93cmFwX2V4Y2VwdGlvbiwgY2FtbF9yZXN1bWVfc3RhY2ssIGNhbWxfZnJlc2hfb29faWQsIGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfY2FsbGJhY2soZixhcmdzKSB7XG4gIGZ1bmN0aW9uIHVuY2F1Z2h0X2VmZmVjdF9oYW5kbGVyKGVmZixrLG1zKSB7XG4gICAgLy8gUmVzdW1lcyB0aGUgY29udGludWF0aW9uIGsgYnkgcmFpc2luZyBleGNlcHRpb24gVW5oYW5kbGVkLlxuICAgIGNhbWxfcmVzdW1lX3N0YWNrKGtbMV0sbXMpO1xuICAgIHZhciBleG4gPSBjYW1sX25hbWVkX3ZhbHVlKFwiRWZmZWN0LlVuaGFuZGxlZFwiKTtcbiAgICBpZihleG4pIGNhbWxfcmFpc2Vfd2l0aF9hcmcoZXhuLCBlZmYpO1xuICAgIGVsc2Uge1xuICAgICAgZXhuID0gWzI0OCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiRWZmZWN0LlVuaGFuZGxlZFwiKSwgY2FtbF9mcmVzaF9vb19pZCgwKV07XG4gICAgICBjYW1sX3JhaXNlX2NvbnN0YW50KGV4bik7XG4gICAgfVxuICB9XG4gIHZhciBzYXZlZF9zdGFja19kZXB0aCA9IGNhbWxfc3RhY2tfZGVwdGg7XG4gIHZhciBzYXZlZF9leG5fc3RhY2sgPSBjYW1sX2V4bl9zdGFjaztcbiAgdmFyIHNhdmVkX2ZpYmVyX3N0YWNrID0gY2FtbF9maWJlcl9zdGFjaztcbiAgdHJ5IHtcbiAgICBjYW1sX2V4bl9zdGFjayA9IDA7XG4gICAgY2FtbF9maWJlcl9zdGFjayA9XG4gICAgICB7aDpbMCwgMCwgMCwgdW5jYXVnaHRfZWZmZWN0X2hhbmRsZXJdLCByOntrOjAsIHg6MCwgZTowfX07XG4gICAgdmFyIHJlcyA9IHtqb29fdHJhbXA6IGYsXG4gICAgICAgICAgICAgICBqb29fYXJnczogYXJncy5jb25jYXQoZnVuY3Rpb24gKHgpe3JldHVybiB4O30pfTtcbiAgICBkbyB7XG4gICAgICBjYW1sX3N0YWNrX2RlcHRoID0gNDA7XG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSBjYW1sX2NhbGxfZ2VuKHJlcy5qb29fdHJhbXAsIHJlcy5qb29fYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIEhhbmRsZSBleGNlcHRpb24gY29taW5nIGZyb20gSmF2YVNjcmlwdCBvciBmcm9tIHRoZSBydW50aW1lLiAqL1xuICAgICAgICBpZiAoIWNhbWxfZXhuX3N0YWNrKSB0aHJvdyBlO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGNhbWxfZXhuX3N0YWNrWzFdO1xuICAgICAgICBjYW1sX2V4bl9zdGFjayA9IGNhbWxfZXhuX3N0YWNrWzJdO1xuICAgICAgICByZXMgPSB7am9vX3RyYW1wOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgam9vX2FyZ3M6IFtjYW1sX3dyYXBfZXhjZXB0aW9uKGUpXX07XG4gICAgICB9XG4gICAgfSB3aGlsZShyZXMgJiYgcmVzLmpvb19hcmdzKVxuICB9IGZpbmFsbHkge1xuICAgIGNhbWxfc3RhY2tfZGVwdGggPSBzYXZlZF9zdGFja19kZXB0aDtcbiAgICBjYW1sX2V4bl9zdGFjayA9IHNhdmVkX2V4bl9zdGFjaztcbiAgICBjYW1sX2ZpYmVyX3N0YWNrID0gc2F2ZWRfZmliZXJfc3RhY2s7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19qc1xuZnVuY3Rpb24gY2FtbF9pc19qcygpIHtcbiAgcmV0dXJuIDE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNvb19mbGFnc191c2VfanNfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzb29fZmxhZ3NfdXNlX2pzX3N0cmluZyh1bml0KXtcbiAgcmV0dXJuIEZMQUcoXCJ1c2UtanMtc3RyaW5nXCIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNvb19mbGFnc19lZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2pzb29fZmxhZ3NfZWZmZWN0cyh1bml0KXtcbiAgcmV0dXJuIEZMQUcoXCJlZmZlY3RzXCIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd3JhcF9leGNlcHRpb24gY29uc3QgKG11dGFibGUpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLGNhbWxfbmFtZWRfdmFsdWVcbmZ1bmN0aW9uIGNhbWxfd3JhcF9leGNlcHRpb24oZSkge1xuICBpZiAoRkxBRyhcImV4Y3dyYXBcIikpIHtcbiAgICBpZihlIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBlO1xuICAgIHZhciBleG47XG4gICAgLy9TdGFja19vdmVyZmxvdzogY2hyb21lLCBzYWZhcmlcbiAgICBpZihnbG9iYWxUaGlzLlJhbmdlRXJyb3JcbiAgICAgICAmJiBlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5SYW5nZUVycm9yXG4gICAgICAgJiYgZS5tZXNzYWdlXG4gICAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC9tYXhpbXVtIGNhbGwgc3RhY2svaSkpXG4gICAgICBleG4gPSBjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93O1xuICAgIC8vU3RhY2tfb3ZlcmZsb3c6IGZpcmVmb3hcbiAgICBlbHNlIGlmKGdsb2JhbFRoaXMuSW50ZXJuYWxFcnJvclxuICAgICAgICYmIGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkludGVybmFsRXJyb3JcbiAgICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL3RvbyBtdWNoIHJlY3Vyc2lvbi9pKSlcbiAgICAgIGV4biA9IGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3c7XG4gICAgLy9XcmFwIEVycm9yIGluIEpzLkVycm9yIGV4Y2VwdGlvblxuICAgIGVsc2UgaWYoZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRXJyb3IgJiYgY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIikpXG4gICAgICBleG4gPSBbMCxjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSxlXTtcbiAgICBlbHNlXG4gICAgICAvL2ZhbGxiYWNrOiB3cmFwcGVkIGluIEZhaWx1cmVcbiAgICAgIGV4biA9IFswLGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoU3RyaW5nKGUpKV07XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yIGF0IGhhbmQsIGxldCdzIHVzZSBpdC5cbiAgICBpZiAoZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRXJyb3IpXG4gICAgICBleG4uanNfZXJyb3IgPSBlO1xuICAgIHJldHVybiBleG47XG4gIH0gZWxzZVxuICAgIHJldHVybiBlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZ1xuZnVuY3Rpb24gY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlKGV4biwgZm9yY2UpIHtcbiAgaWYoY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWcpXG4gICAgcmV0dXJuIGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlKGV4biwgZm9yY2UpO1xuICBlbHNlIHJldHVybiBleG5cbn1cblxuLy8gRXhwZXJpbWVudGFsXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UoZXhuLCBmb3JjZSkge1xuICAvL25ldmVyIHJlcmFpc2UgZm9yIGNvbnN0YW50IGV4blxuICBpZighZXhuLmpzX2Vycm9yIHx8IGZvcmNlIHx8IGV4blswXSA9PSAyNDgpIGV4bi5qc19lcnJvciA9IG5ldyBnbG9iYWxUaGlzLkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZihleG4uanNfZXJyb3IpIHsgcmV0dXJuIFswLCBleG4uanNfZXJyb3JdOyB9XG4gIHJldHVybiAwO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Jvb2woeCkgeyByZXR1cm4gISF4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19ib29sKHgpIHsgcmV0dXJuICt4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fZmxvYXQgY29uc3QgKGNvbnN0KVxuLy9BbGlhczogY2FtbF9qc19mcm9tX2ludDMyXG4vL0FsaWFzOiBjYW1sX2pzX2Zyb21fbmF0aXZlaW50XG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9faW50MzIgY29uc3QgKGNvbnN0KVxuLy9BbGlhczogY2FtbF9qc190b19uYXRpdmVpbnRcbmZ1bmN0aW9uIGNhbWxfanNfdG9faW50MzIoeCkgeyByZXR1cm4geHwwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2FycmF5KGEpIHtcbiAgcmV0dXJuIGEuc2xpY2UoMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2FycmF5KGEpIHtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGJbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGxlbjtpKyspIGJbaSsxXSA9IGFbaV07XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkoYSl7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBpPWEubGVuZ3RoIC0gMTsgaT49MDsgaS0tKXtcbiAgICB2YXIgZSA9IGFbaV07XG4gICAgbCA9IFswLGUsbF07XG4gIH1cbiAgcmV0dXJuIGxcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X3RvX2pzX2FycmF5IGNvbnN0IChtdXRhYmxlKVxuZnVuY3Rpb24gY2FtbF9saXN0X3RvX2pzX2FycmF5KGwpe1xuICB2YXIgYSA9IFtdO1xuICBmb3IoOyBsICE9PSAwOyBsID0gbFsyXSkge1xuICAgIGEucHVzaChsWzFdKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc192YXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdmFyKHgpIHtcbiAgdmFyIHggPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh4KTtcbiAgLy9DaGVja3MgdGhhdCB4IGhhcyB0aGUgZm9ybSBpZGVudFsuaWRlbnRdKlxuICBpZigheC5tYXRjaCgvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKihcXC5bYS16QS1aXyRdW2EtekEtWl8kMC05XSopKiQvKSl7XG4gICAgY29uc29sZS5lcnJvcihcImNhbWxfanNfdmFyOiBcXFwiXCIgKyB4ICsgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIEphdmFTY3JpcHQgdmFyaWFibGUuIGNvbnRpbnVpbmcgLi5cIik7XG4gICAgLy9jb25zb2xlLmVycm9yKFwiSnMuVW5zYWZlLmV2YWxfc3RyaW5nXCIpXG4gIH1cbiAgcmV0dXJuIGV2YWwoeCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2NhbGwgKGNvbnN0LCBtdXRhYmxlLCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2NhbGwoZiwgbywgYXJncykgeyByZXR1cm4gZi5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bl9jYWxsIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19mdW5fY2FsbChmLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gZigpO1xuICBjYXNlIDI6IHJldHVybiBmIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gZiAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICByZXR1cm4gZi5hcHBseShudWxsLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19tZXRoX2NhbGwgKG11dGFibGUsIGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19tZXRoX2NhbGwobywgZiwgYXJncykge1xuICByZXR1cm4gb1tjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhmKV0uYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbmV3IChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19uZXcoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgY2FtbF9qc19mcm9tX2FycmF5KGEpKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX29qc19uZXdfYXJyIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9vanNfbmV3X2FycihjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAwOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjIChhWzBdKTtcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBhKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihsZW4gPiAwKXtcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzID0gW3VuZGVmaW5lZF07XG4gICAgfVxuICAgIHZhciByZXMgPSBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpO1xuICAgIHJldHVybiAocmVzIGluc3RhbmNlb2YgRnVuY3Rpb24pP2NhbWxfanNfd3JhcF9jYWxsYmFjayhyZXMpOnJlcztcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBbYXJnc10pO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyaXR5KTtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCwgYXJpdHkpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFjaywgY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX3Vuc2FmZShmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGNhbWxfanNfZnVuY3Rpb25fYXJpdHkoZik7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpOyB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrLCBjYW1sX2pzX3dyYXBfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgdmFyIHJlcyA9IGNhbWxfY2FsbGJhY2soZixhcmdzKTtcbiAgICByZXR1cm4gKHJlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uKT9jYW1sX2pzX3dyYXBfY2FsbGJhY2socmVzKTpyZXM7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLFt0aGlzLGFyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSArIDEpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFjaywgY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKSAtIDE7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpOyB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuY3Rpb25fYXJpdHlcbi8vSWY6ICFlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5KGYpIHtcbiAgcmV0dXJuIChmLmwgPj0gMCk/Zi5sOihmLmwgPSBmLmxlbmd0aClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKSB7XG4gIC8vIEZ1bmN0aW9ucyBoYXZlIGFuIGFkZGl0aW9uYWwgY29udGludWF0aW9uIHBhcmFtZXRlci4gVGhpcyBzaG91bGRcbiAgLy8gbm90IGJlIHZpc2libGUgd2hlbiBjYWxsaW5nIHRoZW0gZnJvbSBKYXZhU2NyaXB0XG4gIHJldHVybiAoKGYubCA+PSAwKT9mLmw6KGYubCA9IGYubGVuZ3RoKSkgLSAxXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZXF1YWxzICh4LCB5KSB7IHJldHVybiArKHggPT0geSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zdHJpY3RfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc3RyaWN0X2VxdWFscyAoeCwgeSkgeyByZXR1cm4gKyh4ID09PSB5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V2YWxfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V2YWxfc3RyaW5nIChzKSB7cmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19leHByIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V4cHIocykge1xuICBjb25zb2xlLmVycm9yKFwiY2FtbF9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cXG5cIik7XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcHVyZV9qc19leHByIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3B1cmVfanNfZXhwciAocyl7XG4gIGNvbnNvbGUuZXJyb3IoXCJjYW1sX3B1cmVfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29iamVjdCAob2JqZWN0X2xpdGVyYWwpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19vYmplY3QgKGEpIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBhW2ldO1xuICAgIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocFsxXSldID0gcFsyXTtcbiAgfVxuICByZXR1cm4gbztcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUmFpc2UgZXhjZXB0aW9uXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9jb25zdGFudCAodGFnKSB7IHRocm93IHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnIChjb25zdCwgbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBhcmcpIHsgdGhyb3cgY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlKFswLCB0YWcsIGFyZ10pOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmdzIChjb25zdCwgbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX2FyZ3MgKHRhZywgYXJncykgeyB0aHJvdyBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UoWzAsIHRhZ10uY29uY2F0KGFyZ3MpKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nICh0YWcsIG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobXNnKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmFpbHdpdGggKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9mYWlsd2l0aCAobXNnKSB7XG4gIGlmKCFjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUpXG4gICAgY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlPVsyNDgsY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIkZhaWx1cmVcIiksLTNdO1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSwgbXNnKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkludmFsaWRfYXJndW1lbnQsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRW5kX29mX2ZpbGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkRpdmlzaW9uX2J5X3plcm8pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfZm91bmQgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuTm90X2ZvdW5kKTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIER1bW15IGZpbGVzeXN0ZW1cblxuLy9Qcm92aWRlczogY2FtbF90cmFpbGluZ19zbGFzaFxuZnVuY3Rpb24gY2FtbF90cmFpbGluZ19zbGFzaChuYW1lKXtcbiAgcmV0dXJuIChuYW1lLnNsaWNlKC0xKSAhPT0gXCIvXCIpID8gKG5hbWUgKyBcIi9cIikgOiBuYW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3RyYWlsaW5nX3NsYXNoLCBmc19ub2RlX3N1cHBvcnRlZFxuaWYoZnNfbm9kZV9zdXBwb3J0ZWQgKCkgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5jd2QpXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gZ2xvYmFsVGhpcy5wcm9jZXNzLmN3ZCgpLnJlcGxhY2UoL1xcXFwvZywnLycpO1xuZWxzZVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9ICBcIi9zdGF0aWNcIjtcbmNhbWxfY3VycmVudF9kaXIgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKGNhbWxfY3VycmVudF9kaXIpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9yb290XG4vL1JlcXVpcmVzOiBwYXRoX2lzX2Fic29sdXRlXG5mdW5jdGlvbiBjYW1sX2dldF9yb290KHBhdGgpe1xuICB2YXIgeCA9IHBhdGhfaXNfYWJzb2x1dGUocGF0aCk7XG4gIGlmICgheCkgcmV0dXJuO1xuICByZXR1cm4geFswXSArIFwiL1wifVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Jvb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ2V0X3Jvb3QsIGNhbWxfY3VycmVudF9kaXIsIGNhbWxfZmFpbHdpdGhcbnZhciBjYW1sX3Jvb3QgPSBjYW1sX2dldF9yb290KGNhbWxfY3VycmVudF9kaXIpIHx8IGNhbWxfZmFpbHdpdGgoXCJ1bmFibGUgdG8gY29tcHV0ZSBjYW1sX3Jvb3RcIik7XG5cblxuLy9Qcm92aWRlczogTWxGaWxlXG5mdW5jdGlvbiBNbEZpbGUoKXsgIH1cblxuLy9Qcm92aWRlczogcGF0aF9pc19hYnNvbHV0ZVxuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIG1ha2VfcGF0aF9pc19hYnNvbHV0ZSgpIHtcbiAgZnVuY3Rpb24gcG9zaXgocGF0aCkge1xuICAgIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSByZXR1cm4gW1wiXCIsIHBhdGguc3Vic3RyaW5nKDEpXTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmdW5jdGlvbiB3aW4zMihwYXRoKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvYjNmY2MyNDVmYjI1NTM5OTA5ZWYxZDVlYWEwMWRiZjkyZTE2ODYzMy9saWIvcGF0aC5qcyNMNTZcbiAgICB2YXIgc3BsaXREZXZpY2VSZSA9IC9eKFthLXpBLVpdOnxbXFxcXC9dezJ9W15cXFxcL10rW1xcXFwvXStbXlxcXFwvXSspPyhbXFxcXC9dKT8oW1xcc1xcU10qPykkLztcbiAgICB2YXIgcmVzdWx0ID0gc3BsaXREZXZpY2VSZS5leGVjKHBhdGgpO1xuICAgIHZhciBkZXZpY2UgPSByZXN1bHRbMV0gfHwgJyc7XG4gICAgdmFyIGlzVW5jID0gQm9vbGVhbihkZXZpY2UgJiYgZGV2aWNlLmNoYXJBdCgxKSAhPT0gJzonKTtcblxuICAgIC8vIFVOQyBwYXRocyBhcmUgYWx3YXlzIGFic29sdXRlXG4gICAgaWYgKEJvb2xlYW4ocmVzdWx0WzJdIHx8IGlzVW5jKSkge1xuICAgICAgdmFyIHJvb3QgPSAocmVzdWx0WzFdIHx8ICcnKTtcbiAgICAgIHZhciBzZXAgPSAocmVzdWx0WzJdIHx8ICcnKTtcbiAgICAgIHJldHVybiBbcm9vdCwgcGF0aC5zdWJzdHJpbmcocm9vdC5sZW5ndGggKyBzZXAubGVuZ3RoKV1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmKGZzX25vZGVfc3VwcG9ydGVkICgpICYmIGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0pIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIgOiBwb3NpeDtcbiAgfVxuICBlbHNlIHJldHVybiBwb3NpeFxufVxudmFyIHBhdGhfaXNfYWJzb2x1dGUgPSBtYWtlX3BhdGhfaXNfYWJzb2x1dGUoKTtcblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3BhdGhcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nLCBwYXRoX2lzX2Fic29sdXRlXG5mdW5jdGlvbiBjYW1sX21ha2VfcGF0aCAobmFtZSkge1xuICBuYW1lPWNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICBpZiggIXBhdGhfaXNfYWJzb2x1dGUobmFtZSkgKVxuICAgIG5hbWUgPSBjYW1sX2N1cnJlbnRfZGlyICsgbmFtZTtcbiAgdmFyIGNvbXAwID0gcGF0aF9pc19hYnNvbHV0ZShuYW1lKTtcbiAgdmFyIGNvbXAgPSBjb21wMFsxXS5zcGxpdChcIi9cIik7XG4gIHZhciBuY29tcCA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGk8Y29tcC5sZW5ndGg7IGkrKyl7XG4gICAgc3dpdGNoKGNvbXBbaV0pe1xuICAgIGNhc2UgXCIuLlwiOiBpZihuY29tcC5sZW5ndGg+MSkgbmNvbXAucG9wKCk7IGJyZWFrO1xuICAgIGNhc2UgXCIuXCI6IGJyZWFrO1xuICAgIGNhc2UgXCJcIjogYnJlYWs7XG4gICAgZGVmYXVsdDogbmNvbXAucHVzaChjb21wW2ldKTticmVha1xuICAgIH1cbiAgfVxuICBuY29tcC51bnNoaWZ0KGNvbXAwWzBdKTtcbiAgbmNvbXAub3JpZyA9IG5hbWU7XG4gIHJldHVybiBuY29tcDtcbn1cblxuLy9Qcm92aWRlczpqc29vX21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIE1sTm9kZURldmljZSwgY2FtbF9yb290LCBmc19ub2RlX3N1cHBvcnRlZFxudmFyIGpzb29fbW91bnRfcG9pbnQgPSBbXVxuaWYgKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShjYW1sX3Jvb3QpfSk7XG59IGVsc2Uge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn1cbmpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpcIi9zdGF0aWMvXCIsIGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKFwiL3N0YXRpYy9cIil9KTtcblxuLy9Qcm92aWRlczpjYW1sX2xpc3RfbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGlzdF9tb3VudF9wb2ludCgpe1xuICB2YXIgcHJldiA9IDBcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspe1xuICAgIHZhciBvbGQgPSBwcmV2O1xuICAgIHByZXYgPSBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhqc29vX21vdW50X3BvaW50W2ldLnBhdGgpLCBvbGRdXG4gIH1cbiAgcmV0dXJuIHByZXY7XG59XG5cbi8vUHJvdmlkZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludCwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2V0X3Jvb3QsIE1sTm9kZURldmljZSwgY2FtbF90cmFpbGluZ19zbGFzaCwgZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIik7XG4gIHZhciBuYW1lX3NsYXNoID0gY2FtbF90cmFpbGluZ19zbGFzaChuYW1lKTtcbiAgdmFyIHJlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbSA9IGpzb29fbW91bnRfcG9pbnRbaV07XG4gICAgaWYobmFtZV9zbGFzaC5zZWFyY2gobS5wYXRoKSA9PSAwXG4gICAgICAgJiYgKCFyZXMgfHwgcmVzLnBhdGgubGVuZ3RoIDwgbS5wYXRoLmxlbmd0aCkpXG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICB9XG4gIGlmKCAhcmVzICYmIGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAgICB2YXIgcm9vdCA9IGNhbWxfZ2V0X3Jvb3QobmFtZSk7XG4gICAgaWYgKHJvb3QgJiYgcm9vdC5tYXRjaCgvXlthLXpBLVpdOlxcLyQvKSl7XG4gICAgICB2YXIgbSA9IHtwYXRoOnJvb3QsZGV2aWNlOm5ldyBNbE5vZGVEZXZpY2Uocm9vdCl9O1xuICAgICAganNvb19tb3VudF9wb2ludC5wdXNoKG0pO1xuICAgICAgcmVzID0ge3BhdGg6bS5wYXRoLGRldmljZTptLmRldmljZSxyZXN0Om5hbWUuc3Vic3RyaW5nKG0ucGF0aC5sZW5ndGgsbmFtZS5sZW5ndGgpfTtcbiAgICB9XG4gIH1cbiAgaWYoIHJlcyApIHJldHVybiByZXM7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwibm8gZGV2aWNlIGZvdW5kIGZvciBcIiArIG5hbWVfc2xhc2gpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vdW50X2F1dG9sb2FkXG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50LCBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX21vdW50X2F1dG9sb2FkKG5hbWUsZil7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gY2FtbF90cmFpbGluZ19zbGFzaChwYXRoLmpvaW4oXCIvXCIpKTtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOm5hbWUsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UobmFtZSxmKX0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VubW91bnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfbWFrZV9wYXRoLCBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX3VubW91bnQobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gY2FtbF90cmFpbGluZ19zbGFzaChwYXRoLmpvaW4oXCIvXCIpKTtcbiAgdmFyIGlkeCA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKylcbiAgICBpZihqc29vX21vdW50X3BvaW50W2ldLnBhdGggPT0gbmFtZSkgaWR4ID0gaTtcbiAgaWYoaWR4ID4gLTEpIGpzb29fbW91bnRfcG9pbnQuc3BsaWNlKGlkeCwxKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0Y3dkXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRjd2QoKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfY3VycmVudF9kaXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jaGRpclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19jaGRpcihkaXIpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkaXIpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIGlmKHJvb3QucmVzdCkgY2FtbF9jdXJyZW50X2RpciA9IGNhbWxfdHJhaWxpbmdfc2xhc2gocm9vdC5wYXRoICsgcm9vdC5yZXN0KTtcbiAgICBlbHNlIGNhbWxfY3VycmVudF9kaXIgPSByb290LnBhdGg7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhkaXIpKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpe1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9hX2RpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2FfZGlyKG5hbWUpe1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2ZpbGVfZXhpc3RzXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfZmlsZV9leGlzdHMgKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfYV9kaXIsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5yZWFkZGlyKHJvb3QucmVzdCk7XG4gIHZhciBsID0gbmV3IEFycmF5KGEubGVuZ3RoICsgMSk7XG4gIGxbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGEubGVuZ3RoO2krKylcbiAgICBsW2krMV0gPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGFbaV0pO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVtb3ZlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbW92ZShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIG9rID0gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCk7XG4gIGlmKG9rID09IDApIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLmlzX2Rpcihyb290LnJlc3QpO1xuICByZXR1cm4gYT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbmFtZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbmFtZShvLG4pe1xuICB2YXIgb19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobyk7XG4gIHZhciBuX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuKTtcbiAgaWYob19yb290LmRldmljZSAhPSBuX3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IGNhbm5vdCBtb3ZlIGZpbGUgYmV0d2VlbiB0d28gZmlsZXN5c3RlbVwiKTtcbiAgaWYoIW9fcm9vdC5kZXZpY2UucmVuYW1lKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IG5vIGltcGxlbWVudGVkXCIpO1xuICBvX3Jvb3QuZGV2aWNlLnJlbmFtZShvX3Jvb3QucmVzdCwgbl9yb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19ta2RpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3N5c19ta2RpcihuYW1lLCBwZXJtKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcm9vdC5kZXZpY2UubWtkaXIocm9vdC5yZXN0LHBlcm0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcm1kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV9ub3RfYV9kaXJcbmZ1bmN0aW9uIGNhbWxfc3lzX3JtZGlyKG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByb290LmRldmljZS5ybWRpcihyb290LnJlc3QpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZSh2ZmQsIGtpbmQsIGxheW91dCwgc2hhcmVkLCBkaW1zLCBwb3MpIHtcbiAgLy8gdmFyIGRhdGEgPSBjYW1sX3N5c19mZHNbdmZkXTtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfYmFfbWFwX2ZpbGUgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX21hcF9maWxlXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlKGFyZ3YsYXJnbil7XG4gIHJldHVybiBjYW1sX2JhX21hcF9maWxlKGFyZ3ZbMF0sYXJndlsxXSxhcmd2WzJdLGFyZ3ZbM10sYXJndls0XSxhcmd2WzVdKTtcbn1cblxuLy9Qcm92aWRlczoganNvb19jcmVhdGVfZmlsZV9leHRlcm5cbmZ1bmN0aW9uIGpzb29fY3JlYXRlX2ZpbGVfZXh0ZXJuKG5hbWUsY29udGVudCl7XG4gIGlmKGdsb2JhbFRoaXMuanNvb19jcmVhdGVfZmlsZSlcbiAgICBnbG9iYWxUaGlzLmpzb29fY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KTtcbiAgZWxzZSB7XG4gICAgaWYoIWdsb2JhbFRoaXMuY2FtbF9mc190bXApIGdsb2JhbFRoaXMuY2FtbF9mc190bXAgPSBbXTtcbiAgICBnbG9iYWxUaGlzLmNhbWxfZnNfdG1wLnB1c2goe25hbWU6bmFtZSxjb250ZW50OmNvbnRlbnR9KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mc19pbml0XG4vL1JlcXVpcmVzOiBqc29vX2NyZWF0ZV9maWxlXG5mdW5jdGlvbiBjYW1sX2ZzX2luaXQgKCl7XG4gIHZhciB0bXA9Z2xvYmFsVGhpcy5jYW1sX2ZzX3RtcFxuICBpZih0bXApe1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpKyspe1xuICAgICAganNvb19jcmVhdGVfZmlsZSh0bXBbaV0ubmFtZSx0bXBbaV0uY29udGVudCk7XG4gICAgfVxuICB9XG4gIGdsb2JhbFRoaXMuanNvb19jcmVhdGVfZmlsZSA9IGpzb29fY3JlYXRlX2ZpbGU7XG4gIGdsb2JhbFRoaXMuY2FtbF9mc190bXAgPSBbXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZighIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKSBjYW1sX2ZhaWx3aXRoKFwiY2Fubm90IHJlZ2lzdGVyIGZpbGVcIik7XG4gIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKHJvb3QucmVzdCxjb250ZW50KTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczoganNvb19jcmVhdGVfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfZmlsZSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24ganNvb19jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpIHtcbiAgdmFyIG5hbWUgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpO1xuICB2YXIgY29udGVudCA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY29udGVudCk7XG4gIHJldHVybiBjYW1sX2NyZWF0ZV9maWxlKG5hbWUsIGNvbnRlbnQpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVhZF9maWxlX2NvbnRlbnRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmVhZF9maWxlX2NvbnRlbnQgKG5hbWUpIHtcbiAgdmFyIG5hbWUgPSAodHlwZW9mIG5hbWUgPT0gXCJzdHJpbmdcIik/Y2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKTpuYW1lO1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3Qse3Jkb25seToxfSk7XG4gICAgdmFyIGxlbiAgPSBmaWxlLmxlbmd0aCgpO1xuICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGZpbGUucmVhZCgwLGJ1ZiwwLGxlbik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGJ1ZilcbiAgfVxuICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IE1sRmFrZURldmljZVxuLy9SZXF1aXJlczogTWxGYWtlRmlsZSwgTWxGYWtlRmQsIGNhbWxfY3JlYXRlX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2FycmF5LCBjYW1sX2J5dGVzX29mX3N0cmluZywgY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9yYWlzZV93aXRoX2FyZ3MsIGNhbWxfbmFtZWRfdmFsdWVzXG4vL1JlcXVpcmVzOiBtYWtlX3VuaXhfZXJyX2FyZ3NcbmZ1bmN0aW9uIE1sRmFrZURldmljZSAocm9vdCwgZikge1xuICB0aGlzLmNvbnRlbnQ9e307XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHRoaXMubG9va3VwRnVuID0gZjtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubm0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAodGhpcy5yb290ICsgbmFtZSk7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmNyZWF0ZV9kaXJfaWZfbmVlZGVkID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY29tcCA9IG5hbWUuc3BsaXQoXCIvXCIpO1xuICB2YXIgcmVzID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGNvbXAubGVuZ3RoIC0gMTsgaSsrKXtcbiAgICByZXMgKz0gY29tcFtpXSArIFwiL1wiO1xuICAgIGlmKHRoaXMuY29udGVudFtyZXNdKSBjb250aW51ZTtcbiAgICB0aGlzLmNvbnRlbnRbcmVzXSA9IFN5bWJvbChcImRpcmVjdG9yeVwiKTtcbiAgfVxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5zbGFzaCA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gL1xcLyQvLnRlc3QobmFtZSk/bmFtZToobmFtZSArIFwiL1wiKTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24obmFtZSkge1xuICBpZighdGhpcy5jb250ZW50W25hbWVdICYmIHRoaXMubG9va3VwRnVuKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMubG9va3VwRnVuKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXModGhpcy5yb290KSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKSk7XG4gICAgaWYocmVzICE9PSAwKSB7XG4gICAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgICAgdGhpcy5jb250ZW50W25hbWVdPW5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHJlc1sxXSkpO1xuICAgIH1cbiAgfVxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIC8vIFRoZSByb290IG9mIHRoZSBkZXZpY2UgZXhpc3RzXG4gIGlmKG5hbWUgPT0gXCJcIikgcmV0dXJuIDE7XG4gIC8vIENoZWNrIGlmIGEgZGlyZWN0b3J5IGV4aXN0c1xuICB2YXIgbmFtZV9zbGFzaCA9IHRoaXMuc2xhc2gobmFtZSk7XG4gIGlmKHRoaXMuY29udGVudFtuYW1lX3NsYXNoXSkgcmV0dXJuIDE7XG4gIC8vIENoZWNrIGlmIGEgZmlsZSBleGlzdHNcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV0/MTowO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5pc0ZpbGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKHRoaXMuZXhpc3RzKG5hbWUpICYmICF0aGlzLmlzX2RpcihuYW1lKSkge1xuICAgIHJldHVybiAxXG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIDBcbiAgfVxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ta2RpciA9IGZ1bmN0aW9uKG5hbWUsbW9kZSwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IHJhaXNlX3VuaXggJiYgY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG4gIGlmKHRoaXMuZXhpc3RzKG5hbWUpKSB7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVFWElTVFwiLCBcIm1rZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IEZpbGUgZXhpc3RzXCIpO1xuICAgIH1cbiAgfVxuICB2YXIgcGFyZW50ID0gL14oLiopXFwvW14vXSsvLmV4ZWMobmFtZSk7XG4gIHBhcmVudCA9IChwYXJlbnQgJiYgcGFyZW50WzFdKSB8fCAnJztcbiAgaWYoIXRoaXMuZXhpc3RzKHBhcmVudCkpe1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9FTlRcIiwgXCJta2RpclwiLCB0aGlzLm5tKHBhcmVudCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihwYXJlbnQgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgaWYoIXRoaXMuaXNfZGlyKHBhcmVudCkpe1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9URElSXCIsIFwibWtkaXJcIiwgdGhpcy5ubShwYXJlbnQpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IocGFyZW50ICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZCh0aGlzLnNsYXNoKG5hbWUpKTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUucm1kaXIgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHZhciB1bml4X2Vycm9yID0gcmFpc2VfdW5peCAmJiBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOih0aGlzLnNsYXNoKG5hbWUpKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCArIFwiKFteL10rKVwiKTtcbiAgaWYoIXRoaXMuZXhpc3RzKG5hbWUpKSB7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT0VOVFwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9URElSXCIsIFwicm1kaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgaWYobi5tYXRjaChyKSkge1xuICAgICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVEVNUFRZXCIsIFwicm1kaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiOiBEaXJlY3Rvcnkgbm90IGVtcHR5XCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZWxldGUgdGhpcy5jb250ZW50W25hbWVfc2xhc2hdO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KHRoaXMuc2xhc2gobmFtZSkpO1xuICBpZighdGhpcy5leGlzdHMobmFtZSkpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG4gIH1cbiAgaWYoIXRoaXMuaXNfZGlyKG5hbWUpKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG4gIH1cbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCArIFwiKFteL10rKVwiKTtcbiAgdmFyIHNlZW4gPSB7fVxuICB2YXIgYSA9IFtdO1xuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgdmFyIG0gPSBuLm1hdGNoKHIpO1xuICAgIGlmKG0gJiYgIXNlZW5bbVsxXV0pIHtzZWVuW21bMV1dID0gdHJ1ZTsgYS5wdXNoKG1bMV0pfVxuICB9XG4gIHJldHVybiBhO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IHJhaXNlX3VuaXggJiYgY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG5cbiAgdmFyIGEgPSB0aGlzLnJlYWRkaXIobmFtZSk7XG4gIHZhciBjID0gZmFsc2U7XG4gIHZhciBpID0gMDtcbiAgcmV0dXJuIHsgcmVhZFN5bmMgOiAoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjKSB7XG4gICAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFQkFERlwiLCBcImNsb3NlZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IGNsb3NlZGlyIGZhaWxlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoaSA9PSBhLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIGVudHJ5ID0gYVtpXTtcbiAgICBpKys7XG4gICAgcmV0dXJuIHsgbmFtZTogZW50cnkgfVxuICB9KVxuICAgICwgY2xvc2VTeW5jOiAoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGMpIHtcbiAgICAgICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFQkFERlwiLCBcImNsb3NlZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IGNsb3NlZGlyIGZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYyA9IHRydWU7XG4gICAgICBhID0gW107XG4gICAgfSlcbiAgfVxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5pc19kaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKG5hbWUgPT0gXCJcIikgIHJldHVybiB0cnVlO1xuICB2YXIgbmFtZV9zbGFzaCA9IHRoaXMuc2xhc2gobmFtZSk7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF0/MTowO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBvayA9IHRoaXMuY29udGVudFtuYW1lXT90cnVlOmZhbHNlO1xuICBkZWxldGUgdGhpcy5jb250ZW50W25hbWVdO1xuICByZXR1cm4gb2s7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIHZhciBmaWxlO1xuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICBpZiAodGhpcy5jb250ZW50W25hbWVdKSB7XG4gICAgaWYgKHRoaXMuaXNfZGlyKG5hbWUpKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBpcyBhIGRpcmVjdG9yeVwiKTtcbiAgICBpZiAoZi5jcmVhdGUgJiYgZi5leGNsKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gICAgaWYoZi50cnVuY2F0ZSkgZmlsZS50cnVuY2F0ZSgpO1xuICB9IGVsc2UgaWYgKGYuY3JlYXRlKSB7XG4gICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gICAgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSAodGhpcy5ubShuYW1lKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBNbEZha2VGZCh0aGlzLm5tKG5hbWUpLCBmaWxlLCBmKTtcbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICB2YXIgZmlsZTtcbiAgaWYoZi5yZG9ubHkgJiYgZi53cm9ubHkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgaWYgKHRoaXMuY29udGVudFtuYW1lXSkge1xuICAgIGlmICh0aGlzLmlzX2RpcihuYW1lKSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogaXMgYSBkaXJlY3RvcnlcIik7XG4gICAgaWYgKGYuY3JlYXRlICYmIGYuZXhjbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgIGlmKGYudHJ1bmNhdGUpIGZpbGUudHJ1bmNhdGUoKTtcbiAgfSBlbHNlIGlmIChmLmNyZWF0ZSkge1xuICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICAgIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUgKHRoaXMubm0obmFtZSkpO1xuICB9XG4gIHJldHVybiBuZXcgTWxGYWtlRmQodGhpcy5ubShuYW1lKSwgZmlsZSwgZik7XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVnaXN0ZXI9IGZ1bmN0aW9uIChuYW1lLGNvbnRlbnQpe1xuICB2YXIgZmlsZTtcbiAgaWYodGhpcy5jb250ZW50W25hbWVdKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICBpZihjYW1sX2lzX21sX2J5dGVzKGNvbnRlbnQpKVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjb250ZW50KTtcbiAgaWYoY2FtbF9pc19tbF9zdHJpbmcoY29udGVudCkpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoY29udGVudCkpO1xuICBlbHNlIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQudG9TdHJpbmcpIHtcbiAgICB2YXIgYnl0ZXMgPSBjYW1sX2J5dGVzX29mX3N0cmluZyhjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhjb250ZW50LnRvU3RyaW5nKCkpKTtcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoYnl0ZXMpO1xuICB9XG4gIGlmKGZpbGUpe1xuICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gZmlsZTtcbiAgfVxuICBlbHNlIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IHJlZ2lzdGVyaW5nIGZpbGUgd2l0aCBpbnZhbGlkIGNvbnRlbnQgdHlwZVwiKTtcbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ibGl0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzLCBjYW1sX2J5dGVzX29mX2FycmF5XG5mdW5jdGlvbiBNbEZha2VGaWxlKGNvbnRlbnQpe1xuICB0aGlzLmRhdGEgPSBjb250ZW50O1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuTWxGYWtlRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VGaWxlXG5NbEZha2VGaWxlLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHZhciBvbGQgPSB0aGlzLmRhdGE7XG4gIHRoaXMuZGF0YSA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbnwwKTtcbiAgY2FtbF9ibGl0X2J5dGVzKG9sZCwgMCwgdGhpcy5kYXRhLCAwLCBsZW4pO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgodGhpcy5kYXRhKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBpZihvZmZzZXQgKyBsZW4gPj0gY2xlbikge1xuICAgIHZhciBuZXdfc3RyID0gY2FtbF9jcmVhdGVfYnl0ZXMob2Zmc2V0ICsgbGVuKTtcbiAgICB2YXIgb2xkX2RhdGEgPSB0aGlzLmRhdGE7XG4gICAgdGhpcy5kYXRhID0gbmV3X3N0cjtcbiAgICBjYW1sX2JsaXRfYnl0ZXMob2xkX2RhdGEsIDAsIHRoaXMuZGF0YSwgMCwgY2xlbik7XG4gIH1cbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoYnVmKSwgcG9zLCB0aGlzLmRhdGEsIG9mZnNldCwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGlmKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgbGVuID0gY2xlbiAtIG9mZnNldDtcbiAgfVxuICBpZihsZW4pIHtcbiAgICB2YXIgZGF0YSA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbnwwKTtcbiAgICBjYW1sX2JsaXRfYnl0ZXModGhpcy5kYXRhLCBvZmZzZXQsIGRhdGEsIDAsIGxlbik7XG4gICAgYnVmLnNldChjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGRhdGEpLCBwb3MpO1xuICB9XG4gIHJldHVybiBsZW5cbn1cblxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGZF9vdXRcbi8vUmVxdWlyZXM6IE1sRmFrZUZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBNbEZha2VGZF9vdXQoZmQsZmxhZ3MpIHtcbiAgTWxGYWtlRmlsZS5jYWxsKHRoaXMsIGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgdGhpcy5sb2cgPSAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIDAgfSk7XG4gIGlmKGZkID09IDEgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09IFwiZnVuY3Rpb25cIilcbiAgICB0aGlzLmxvZyA9IGNvbnNvbGUubG9nO1xuICBlbHNlIGlmKGZkID09IDIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT0gXCJmdW5jdGlvblwiKVxuICAgIHRoaXMubG9nID0gY29uc29sZS5lcnJvcjtcbiAgZWxzZSBpZih0eXBlb2YgY29uc29sZS5sb2cgPT0gXCJmdW5jdGlvblwiKVxuICAgIHRoaXMubG9nID0gY29uc29sZS5sb2dcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xufVxuTWxGYWtlRmRfb3V0LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDAgfVxuTWxGYWtlRmRfb3V0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChvZmZzZXQsYnVmLHBvcyxsZW4pIHtcbiAgaWYodGhpcy5sb2cpIHtcbiAgICBpZihsZW4gPiAwXG4gICAgICAgJiYgcG9zID49IDBcbiAgICAgICAmJiBwb3MrbGVuIDw9IGJ1Zi5sZW5ndGhcbiAgICAgICAmJiBidWZbcG9zK2xlbi0xXSA9PSAxMClcbiAgICAgIGxlbiAtLTtcbiAgICAvLyBEbyBub3Qgb3V0cHV0IHRoZSBsYXN0IFxcbiBpZiBwcmVzZW50XG4gICAgLy8gYXMgY29uc29sZSBsb2dnaW5nIGRpc3BsYXkgYSBuZXdsaW5lIGF0IHRoZSBlbmRcbiAgICB2YXIgc3JjID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShidWYpLCBwb3MsIHNyYywgMCwgbGVuKTtcbiAgICB0aGlzLmxvZyhzcmMudG9VdGYxNigpKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLmZkICArIFwiOiBmaWxlIGRlc2NyaXB0b3IgYWxyZWFkeSBjbG9zZWRcIik7XG59XG5NbEZha2VGZF9vdXQucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCBidWYsIHBvcywgbGVuKSB7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMuZmQgICsgXCI6IGZpbGUgZGVzY3JpcHRvciBpcyB3cml0ZSBvbmx5XCIpO1xufVxuTWxGYWtlRmRfb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sb2cgPSB1bmRlZmluZWQ7XG59XG5cblxuLy9Qcm92aWRlczogTWxGYWtlRmRcbi8vUmVxdWlyZXM6IE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBNbEZha2VGZChuYW1lLCBmaWxlLGZsYWdzKSB7XG4gIHRoaXMuZmlsZSA9IGZpbGU7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbn1cblxuTWxGYWtlRmQucHJvdG90eXBlLmVycl9jbG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubmFtZSAgKyBcIjogZmlsZSBkZXNjcmlwdG9yIGFscmVhZHkgY2xvc2VkXCIpO1xufVxuTWxGYWtlRmQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLmZpbGUpIHJldHVybiB0aGlzLmZpbGUubGVuZ3RoICgpXG4gIHRoaXMuZXJyX2Nsb3NlZCgpO1xufVxuTWxGYWtlRmQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG9mZnNldCxidWYscG9zLGxlbikge1xuICBpZih0aGlzLmZpbGUpIHJldHVybiB0aGlzLmZpbGUud3JpdGUob2Zmc2V0LGJ1Zixwb3MsbGVuKVxuICB0aGlzLmVycl9jbG9zZWQoKTtcbn1cbk1sRmFrZUZkLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG9mZnNldCwgYnVmLCBwb3MsIGxlbikge1xuICBpZih0aGlzLmZpbGUpIHJldHVybiB0aGlzLmZpbGUucmVhZChvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pXG4gIHRoaXMuZXJyX2Nsb3NlZCgpO1xufVxuTWxGYWtlRmQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZpbGUgPSB1bmRlZmluZWQ7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZmZzZXRcbnZhciBjYW1sX2ludDY0X29mZnNldCA9IE1hdGgucG93KDIsIC0yNCk7XG5cbi8vUHJvdmlkZXM6IE1sSW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBNbEludDY0IChsbyxtaSxoaSkge1xuICB0aGlzLmxvID0gbG8gJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9IG1pICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSBoaSAmIDB4ZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfalwiXG5NbEludDY0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyx0aGlzLm1pLHRoaXMuaGkpO1xufVxuXG5NbEludDY0LnByb3RvdHlwZS51Y29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIGlmICh0aGlzLmhpID4geC5oaSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmhpIDwgeC5oaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBoaSA9IHRoaXMuaGkgPDwgMTY7XG4gIHZhciB4aGkgPSB4LmhpIDw8IDE2O1xuICBpZiAoaGkgPiB4aGkpIHJldHVybiAxO1xuICBpZiAoaGkgPCB4aGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvID0gLSB0aGlzLmxvO1xuICB2YXIgbWkgPSAtIHRoaXMubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSAtIHRoaXMuaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICsgeC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSArIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpICsgeC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gLSB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pIC0geC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgLSB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAqIHgubG87XG4gIHZhciBtaSA9ICgobG8gKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMubWkgKiB4LmxvICsgdGhpcy5sbyAqIHgubWk7XG4gIHZhciBoaSA9ICgobWkgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMuaGkgKiB4LmxvICsgdGhpcy5taSAqIHgubWkgKyB0aGlzLmxvICogeC5oaTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMubG98dGhpcy5taXx0aGlzLmhpKSA9PSAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5oaSA8PCAxNikgPCAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8gJiB4LmxvLCB0aGlzLm1pICYgeC5taSwgdGhpcy5oaSAmIHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb3x4LmxvLCB0aGlzLm1pfHgubWksIHRoaXMuaGl8eC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb154LmxvLCB0aGlzLm1pXngubWksIHRoaXMuaGleeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9sZWZ0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpIHtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMubG8gPDwgcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IHMpIHwgKHRoaXMubG8gPj4gKDI0IC0gcykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuaGkgPDwgcykgfCAodGhpcy5taSA+PiAoMjQgLSBzKSkpO1xuICB9XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sbyA8PCAocyAtIDI0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IChzIC0gMjQpKSB8ICh0aGlzLmxvID4+ICg0OCAtIHMpKSk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCgwLCAwLCB0aGlzLmxvIDw8IChzIC0gNDgpKVxufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHRfdW5zaWduZWQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8ICh0aGlzLmhpIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IHMpKTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gKHMgLSAyNCkpLFxuICAgICAgMCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5oaSA+PiAocyAtIDQ4KSwgMCwgMCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICB2YXIgaCA9ICh0aGlzLmhpIDw8IDE2KSA+PiAxNjtcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8IChoIDw8ICgyNCAtIHMpKSxcbiAgICAgICgodGhpcy5oaSA8PCAxNikgPj4gcykgPj4+IDE2KTtcbiAgdmFyIHNpZ24gPSAodGhpcy5oaSA8PCAxNikgPj4gMzE7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDI0KSA+PiAxNixcbiAgICAgIHNpZ24gJiAweGZmZmYpO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKCh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDMyKSwgc2lnbiwgc2lnbik7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc2wxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhpID0gKHRoaXMuaGkgPDwgMSkgfCAodGhpcy5taSA+PiAyMyk7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPDwgMSkgfCAodGhpcy5sbyA+PiAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubG8gPSAodGhpcy5sbyA8PCAxKSAmIDB4ZmZmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNyMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sbyA9ICgodGhpcy5sbyA+Pj4gMSkgfCAodGhpcy5taSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPj4+IDEpIHwgKHRoaXMuaGkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gdGhpcy5oaSA+Pj4gMTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnVkaXZtb2QgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIG1vZHVsdXMgPSB0aGlzLmNvcHkoKTtcbiAgdmFyIGRpdmlzb3IgPSB4LmNvcHkoKTtcbiAgdmFyIHF1b3RpZW50ID0gbmV3IE1sSW50NjQoMCwwLDApO1xuICB3aGlsZSAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+IDApIHtcbiAgICBvZmZzZXQrKztcbiAgICBkaXZpc29yLmxzbDEoKTtcbiAgfVxuICB3aGlsZSAob2Zmc2V0ID49IDApIHtcbiAgICBvZmZzZXQgLS07XG4gICAgcXVvdGllbnQubHNsMSgpO1xuICAgIGlmIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID49IDApIHtcbiAgICAgIHF1b3RpZW50LmxvICsrO1xuICAgICAgbW9kdWx1cyA9IG1vZHVsdXMuc3ViKGRpdmlzb3IpO1xuICAgIH1cbiAgICBkaXZpc29yLmxzcjEoKTtcbiAgfVxuICByZXR1cm4geyBxdW90aWVudCA6IHF1b3RpZW50LCBtb2R1bHVzIDogbW9kdWx1cyB9O1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaSBeIHkuaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgcSA9IHgudWRpdm1vZCh5KS5xdW90aWVudDtcbiAgaWYgKHNpZ24gJiAweDgwMDApIHEgPSBxLm5lZygpO1xuICByZXR1cm4gcTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgciA9IHgudWRpdm1vZCh5KS5tb2R1bHVzO1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgciA9IHIubmVnKCk7XG4gIHJldHVybiByO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKHRoaXMubWkgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9GbG9hdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5oaSA8PCAxNikgKiBNYXRoLnBvdygyLCAzMikgKyB0aGlzLm1pICogTWF0aC5wb3coMiwgMjQpKSArIHRoaXMubG87XG59XG5NbEludDY0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW3RoaXMuaGkgPj4gOCxcbiAgICAgICAgICB0aGlzLmhpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pID4+IDE2LFxuICAgICAgICAgICh0aGlzLm1pID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvID4+IDE2LFxuICAgICAgICAgICh0aGlzLmxvID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvICYgMHhmZl07XG59XG5NbEludDY0LnByb3RvdHlwZS5sbzMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICgodGhpcy5taSAmIDB4ZmYpIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmhpMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMubWkgPj4+IDgpICYgMHhmZmZmKSB8ICh0aGlzLmhpIDw8IDE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdWx0KHgseSkgeyByZXR1cm4geC51Y29tcGFyZSh5KSA8IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NvbXBhcmUoeCx5LCB0b3RhbCkgeyByZXR1cm4geC5jb21wYXJlKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9uZWcgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbmVnICh4KSB7IHJldHVybiB4Lm5lZygpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hZGQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYWRkICh4LCB5KSB7IHJldHVybiB4LmFkZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc3ViIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3N1YiAoeCwgeSkgeyByZXR1cm4geC5zdWIoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X211bCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbXVsKHgseSkgeyByZXR1cm4geC5tdWwoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX3plcm8gY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfemVybyh4KSB7IHJldHVybiAreC5pc1plcm8oKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpIHsgcmV0dXJuICt4LmlzTmVnKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hbmQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYW5kICh4LCB5KSB7IHJldHVybiB4LmFuZCh5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29yICh4LCB5KSB7IHJldHVybiB4Lm9yKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfeG9yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3hvciAoeCwgeSkgeyByZXR1cm4geC54b3IoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfbGVmdCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9sZWZ0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodF91bnNpZ25lZChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2RpdiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9kaXYgKHgsIHkpIHsgcmV0dXJuIHguZGl2KHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tb2QgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbW9kICh4LCB5KSB7IHJldHVybiB4Lm1vZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfaW50MzIgKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHggJiAweGZmZmZmZiwgKHggPj4gMjQpICYgMHhmZmZmZmYsICh4ID4+IDMxKSAmIDB4ZmZmZilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19pbnQzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19pbnQzMiAoeCkgeyByZXR1cm4geC50b0ludCgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19mbG9hdCAoeCkgeyByZXR1cm4geC50b0Zsb2F0ICgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKHggPCAwKSB4ID0gTWF0aC5jZWlsKHgpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgeCAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mb3JtYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF90b19pbnQzMlxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZm9ybWF0IChmbXQsIHgpIHtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoZi5zaWduZWRjb252ICYmIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkpIHtcbiAgICBmLnNpZ24gPSAtMTsgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICB9XG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICB2YXIgd2Jhc2UgPSBjYW1sX2ludDY0X29mX2ludDMyKGYuYmFzZSk7XG4gIHZhciBjdnRibCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICBkbyB7XG4gICAgdmFyIHAgPSB4LnVkaXZtb2Qod2Jhc2UpO1xuICAgIHggPSBwLnF1b3RpZW50O1xuICAgIGJ1ZmZlciA9IGN2dGJsLmNoYXJBdChjYW1sX2ludDY0X3RvX2ludDMyKHAubW9kdWx1cykpICsgYnVmZmVyO1xuICB9IHdoaWxlICghIGNhbWxfaW50NjRfaXNfemVybyh4KSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gYnVmZmVyLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIGJ1ZmZlciA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIGJ1ZmZlcjtcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBidWZmZXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3BhcnNlX2RpZ2l0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3VsdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGJhc2U2NCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoYmFzZSk7XG4gIHZhciB0aHJlc2hvbGQgPVxuICAgICAgbmV3IE1sSW50NjQoMHhmZmZmZmYsIDB4ZmZmZmZmZiwgMHhmZmZmKS51ZGl2bW9kKGJhc2U2NCkucXVvdGllbnQ7XG4gIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBtdWx0aXBsaWNhdGlvbiBiYXNlICogcmVzICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHRocmVzaG9sZCwgcmVzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgZCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gICAgcmVzID0gY2FtbF9pbnQ2NF9hZGQoY2FtbF9pbnQ2NF9tdWwoYmFzZTY0LCByZXMpLCBkKTtcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gYWRkaXRpb24gKGJhc2UgKiByZXMpICsgZCAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdChyZXMsIGQpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoYmFzZSA9PSAxMCAmJiBjYW1sX2ludDY0X3VsdChuZXcgTWxJbnQ2NCgwLCAwLCAweDgwMDApLCByZXMpKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoc2lnbiA8IDApIHJlcyA9IGNhbWxfaW50NjRfbmVnKHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShsbywgbWksIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobG8sIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICBsbyAmIDB4ZmZmZmZmLFxuICAgICgobG8gPj4+IDI0KSAmIDB4ZmYpIHwgKChoaSAmIDB4ZmZmZikgPDwgOCksXG4gICAgKGhpID4+PiAxNikgJiAweGZmZmYpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9sbzMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2xvMzIodil7IHJldHVybiB2LmxvMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGkzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oaTMyKHYpeyByZXR1cm4gdi5oaTMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2J5dGVzKGEpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGFbN10gPDwgMCB8IChhWzZdIDw8IDgpIHwgKGFbNV0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVs0XSA8PCAwIHwgKGFbM10gPDwgOCkgfCAoYVsyXSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzFdIDw8IDAgfCAoYVswXSA8PCA4KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2J5dGVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2J5dGVzKHgpIHsgcmV0dXJuIHgudG9BcnJheSgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oYXNoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hhc2godil7XG4gIHJldHVybiAodi5sbzMyKCkpIF4gKHYuaGkzMigpKVxufVxuIiwiXG4vL1Byb3ZpZGVzOiBNbE11dGV4XG5mdW5jdGlvbiBNbE11dGV4KCkge1xuICB0aGlzLmxvY2tlZCA9IGZhbHNlXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfbmV3XG4vL1JlcXVpcmVzOiBNbE11dGV4XG5mdW5jdGlvbiBjYW1sX21sX211dGV4X25ldyh1bml0KSB7XG4gIHJldHVybiBuZXcgTWxNdXRleCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX211dGV4X2xvY2tcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfbG9jayh0KSB7XG4gIGlmKHQubG9ja2VkKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJNdXRleC5sb2NrOiBtdXRleCBhbHJlYWR5IGxvY2tlZC4gQ2Fubm90IHdhaXQuXCIpO1xuICBlbHNlIHQubG9ja2VkID0gdHJ1ZTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfdHJ5X2xvY2tcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfdHJ5X2xvY2sodCkge1xuICBpZighdC5sb2NrZWQpIHtcbiAgICB0LmxvY2tlZCA9IHRydWU7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfdW5sb2NrXG5mdW5jdGlvbiBjYW1sX21sX211dGV4X3VubG9jayh0KSB7XG4gIHQubG9ja2VkID0gZmFsc2U7XG4gIHJldHVybiAwO1xufVxuIiwiLy9Qcm92aWRlczogaW5pdGlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogc2VyaWFsaXplX25hdCwgZGVzZXJpYWxpemVfbmF0LCBjYW1sX2hhc2hfbmF0XG5mdW5jdGlvbiBpbml0aWFsaXplX25hdCgpIHtcbiAgY2FtbF9jdXN0b21fb3BzW1wiX25hdFwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZSA6IGRlc2VyaWFsaXplX25hdCxcbiAgICAgIHNlcmlhbGl6ZSA6IHNlcmlhbGl6ZV9uYXQsXG4gICAgICBoYXNoIDogY2FtbF9oYXNoX25hdFxuICAgIH1cbn1cblxuLy9Qcm92aWRlczogTWxOYXRcbmZ1bmN0aW9uIE1sTmF0KHgpe1xuICB0aGlzLmRhdGEgPSBuZXcgSW50MzJBcnJheSh4KTtcbiAgLy8gRm9yIG51bSA8IDEuNVxuICAvLyBsZW5ndGhfbmF0IGlzbid0IGV4dGVybmFsLCBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhlIE9iai5zaXplXG4gIC8vIHdvcmsgb3V0IHJpZ2h0LlxuICAvLyBXZSBhZGQgKzIgdG8gdGhlIGFycmF5IGxlbmd0aDpcbiAgLy8gLSArMSBmb3IgdGhlIHRhZ1xuICAvLyAtICsxIGZvciB0aGUgY3VzdG9tX29wcyBzbG90XG4gIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCArIDJcbn1cblxuTWxOYXQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfbmF0XCI7XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY2FtbF9oYXNoX25hdCh4KSB7XG4gIHZhciBsZW4gPSBudW1fZGlnaXRzX25hdCh4LCAwLCB4LmRhdGEubGVuZ3RoKTtcbiAgdmFyIGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHguZGF0YVtpXSk7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGxlbmd0aF9uYXRcbmZ1bmN0aW9uIGxlbmd0aF9uYXQoeCkge1xuICByZXR1cm4geC5kYXRhLmxlbmd0aDtcbn1cblxuLy9Qcm92aWRlczogbmF0X29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gbmF0X29mX2FycmF5KGwpe1xuICByZXR1cm4gbmV3IE1sTmF0KGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjcmVhdGVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gY3JlYXRlX25hdChzaXplKSB7XG4gIHZhciBhcnIgPSBuZXcgTWxOYXQoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBhcnIuZGF0YVtpXSA9IC0xO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8vUHJvdmlkZXM6IHNldF90b196ZXJvX25hdFxuZnVuY3Rpb24gc2V0X3RvX3plcm9fbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmxpdF9uYXRcbmZ1bmN0aW9uIGJsaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IG5hdDIuZGF0YVtvZnMyK2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0XG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0KG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0XG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0KG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIG51bV9kaWdpdHNfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZihuYXQuZGF0YVtvZnMraV0gIT0gMCkgcmV0dXJuIGkrMTtcbiAgfVxuICByZXR1cm4gMTsgLy8gMCBjb3VudHMgYXMgMSBkaWdpdFxufVxuXG4vL1Byb3ZpZGVzOiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXRcbmZ1bmN0aW9uIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQsIG9mcykge1xuICB2YXIgYSA9IG5hdC5kYXRhW29mc107XG4gIHZhciBiID0gMDtcbiAgaWYoYSAmIDB4RkZGRjAwMDApIHsgYiArPTE2OyBhID4+Pj0xNjsgfVxuICBpZihhICYgMHhGRjAwKSAgICAgeyBiICs9IDg7IGEgPj4+PSA4OyB9XG4gIGlmKGEgJiAweEYwKSAgICAgICB7IGIgKz0gNDsgYSA+Pj49IDQ7IH1cbiAgaWYoYSAmIDEyKSAgICAgICAgIHsgYiArPSAyOyBhID4+Pj0gMjsgfVxuICBpZihhICYgMikgICAgICAgICAgeyBiICs9IDE7IGEgPj4+PSAxOyB9XG4gIGlmKGEgJiAxKSAgICAgICAgICB7IGIgKz0gMTsgfVxuICByZXR1cm4gMzIgLSBiO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9pbnRcbmZ1bmN0aW9uIGlzX2RpZ2l0X2ludChuYXQsIG9mcykge1xuICBpZiAobmF0LmRhdGFbb2ZzXSA+PSAwKSByZXR1cm4gMVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfemVyb1xuZnVuY3Rpb24gaXNfZGlnaXRfemVybyhuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdID09IDApIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfb2RkXG5mdW5jdGlvbiBpc19kaWdpdF9vZGQobmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSAmIDEpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGluY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKHggfCAwKTtcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IGFkZF9uYXRcbi8vUmVxdWlyZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geFxuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBjYXJyeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBsZW1lbnRfbmF0XG5mdW5jdGlvbiBjb21wbGVtZW50X25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICgtMSA+Pj4gMCkgLSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKTtcbiAgfVxufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy9Qcm92aWRlczogZGVjcl9uYXRcbmZ1bmN0aW9uIGRlY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PjApIC0gYm9ycm93O1xuICAgIG5hdC5kYXRhW29mcytpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGJvcnJvdyA9PSAxKSA/IDAgOiAxO1xufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBzdWJfbmF0XG4vL1JlcXVpcmVzOiBkZWNyX25hdFxuZnVuY3Rpb24gc3ViX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgLSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApIC0gYm9ycm93O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIChib3Jyb3c9PTEpPzA6MSk7XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNbb2ZzM11cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogbXVsdF9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGFkZF9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMykge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgYSA9IChuYXQzLmRhdGFbb2ZzM10gPj4+IDApO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHgxID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSAmIDB4MDAwMEZGRkYpICsgY2Fycnk7XG4gICAgdmFyIHgyID0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhID4+PiAxNik7XG4gICAgY2FycnkgPSBNYXRoLmZsb29yKHgyLzY1NTM2KTtcbiAgICB2YXIgeDMgPSB4MSArICh4MiAlIDY1NTM2KSAqIDY1NTM2O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDM7XG4gICAgY2FycnkgKz0gTWF0aC5mbG9vcih4My80Mjk0OTY3Mjk2KTtcbiAgfVxuXG4gIGlmKGxlbjIgPCBsZW4xICYmIGNhcnJ5KSB7XG4gICAgcmV0dXJuIGFkZF9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIG5hdF9vZl9hcnJheShbY2FycnldKSwgMCwgMSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhcnJ5O1xuICB9XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNcbi8vIGxlbjEgPj0gbGVuMiArIGxlbjMuXG4vL1Byb3ZpZGVzOiBtdWx0X25hdFxuLy9SZXF1aXJlczogbXVsdF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMsIGxlbjMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjM7IGkrKykge1xuICAgIGNhcnJ5ICs9IG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEraSwgbGVuMS1pLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzK2kpO1xuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbmF0MSA9IDIgKiBuYXQxICsgbmF0MiAqIG5hdDJcbi8vIGxlbjEgPj0gMiAqIGxlbjJcbi8vUHJvdmlkZXM6IHNxdWFyZV9uYXRcbi8vUmVxdWlyZXM6IG11bHRfbmF0LCBhZGRfbmF0XG5mdW5jdGlvbiBzcXVhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgY2FycnkgKz0gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQxLCBvZnMxLCBsZW4xLCAwKTtcbiAgY2FycnkgKz0gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMik7XG4gIHJldHVybiBjYXJyeTtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X2xlZnRfbmF0XG5mdW5jdGlvbiBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICB2YXIgYSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA8PCBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhID4+PiAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIEFzc3VtaW5nIGMgPiBhLCByZXR1cm5zIFtxdW90aWVudCwgcmVtYWluZGVyXSBvZiAoYTw8MzIgKyBiKS9jXG4vL1Byb3ZpZGVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfaGVscGVyKGEsIGIsIGMpIHtcbiAgdmFyIHggPSBhICogNjU1MzYgKyAoYj4+PjE2KTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHgvYykgKiA2NTUzNjtcbiAgdmFyIHogPSAoeCAlIGMpICogNjU1MzY7XG4gIHZhciB3ID0geiArIChiICYgMHgwMDAwRkZGRik7XG4gIHJldHVybiBbeSArIE1hdGguZmxvb3Iody9jKSwgdyAlIGNdO1xufVxuXG4vLyBuYXQxW29mczErbGVuXSA8IG5hdDJbb2ZzMl1cbi8vUHJvdmlkZXM6IGRpdl9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9kaWdpdF9uYXQobmF0cSwgb2ZzcSwgbmF0ciwgb2ZzciwgbmF0MSwgb2ZzMSwgbGVuLCBuYXQyLCBvZnMyKSB7XG4gIHZhciByZW0gPSAobmF0MS5kYXRhW29mczErbGVuLTFdID4+PjApO1xuICAvLyBuYXRxW29mc3ErbGVuLTFdIGlzIGd1YXJhbnRlZWQgdG8gYmUgemVybyAoZHVlIHRvIHRoZSBNU0QgcmVxdWlyZW1lbnQpLFxuICAvLyBhbmQgc2hvdWxkIG5vdCBiZSB3cml0dGVuIHRvLlxuICBmb3IodmFyIGkgPSBsZW4tMjsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgeCA9IGRpdl9oZWxwZXIocmVtLCAobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0Mi5kYXRhW29mczJdID4+PiAwKSk7XG4gICAgbmF0cS5kYXRhW29mc3EraV0gPSB4WzBdO1xuICAgIHJlbSA9IHhbMV07XG4gIH1cbiAgbmF0ci5kYXRhW29mc3JdID0gcmVtO1xuICByZXR1cm4gMDtcbn1cblxuLy8gbmF0MVtuYXQyOl0gOj0gbmF0MSAvIG5hdDJcbi8vIG5hdDFbOm5hdDJdIDo9IG5hdDEgJSBuYXQyXG4vLyBsZW4xID4gbGVuMiwgbmF0MltvZnMyK2xlbjItMV0gPiBuYXQxW29mczErbGVuMS0xXVxuLy9Qcm92aWRlczogZGl2X25hdFxuLy9SZXF1aXJlczogZGl2X2RpZ2l0X25hdCwgZGl2X2hlbHBlciwgbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0LCBzaGlmdF9sZWZ0X25hdCwgc2hpZnRfcmlnaHRfbmF0LCBjcmVhdGVfbmF0LCBzZXRfdG9femVyb19uYXQsIG11bHRfZGlnaXRfbmF0LCBzdWJfbmF0LCBjb21wYXJlX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBkaXZfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgaWYobGVuMiA9PSAxKSB7XG4gICAgZGl2X2RpZ2l0X25hdChuYXQxLCBvZnMxKzEsIG5hdDEsIG9mczEsIG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHMgPSBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0Miwgb2ZzMitsZW4yLTEpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcblxuICB2YXIgZCA9IChuYXQyLmRhdGFbb2ZzMitsZW4yLTFdID4+PiAwKSArIDE7XG4gIHZhciBhID0gY3JlYXRlX25hdChsZW4yKzEpO1xuICBmb3IgKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gbGVuMjsgaS0tKSB7XG4gICAgLy8gRGVjZW50IGxvd2VyIGJvdW5kIG9uIHF1b1xuICAgIHZhciBxdW8gPSBkID09IDQyOTQ5NjcyOTYgPyAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDogZGl2X2hlbHBlcigobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0MS5kYXRhW29mczEraS0xXSA+Pj4wKSwgZClbMF07XG4gICAgc2V0X3RvX3plcm9fbmF0KGEsIDAsIGxlbjIrMSk7XG4gICAgbXVsdF9kaWdpdF9uYXQoYSwgMCwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoW3F1b10pLCAwKTtcbiAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIGEsIDAsIGxlbjIrMSwgMSk7XG5cbiAgICB3aGlsZSAobmF0MS5kYXRhW29mczEraV0gIT0gMCB8fCBjb21wYXJlX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMikgPj0gMCkge1xuICAgICAgcXVvID0gcXVvICsgMTtcbiAgICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgMSk7XG4gICAgfVxuXG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBxdW87XG4gIH1cblxuICBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyBzaGlmdCByZW1haW5kZXJcbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gcmVzdG9yZVxuICByZXR1cm4gMDtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X3JpZ2h0X25hdFxuZnVuY3Rpb24gc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gbGVuMS0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBhID0gbmF0MS5kYXRhW29mczEraV0gPj4+IDA7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA+Pj4gbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA8PCAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgaWYobmF0MS5kYXRhW29mczFdID4gbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gMTtcbiAgaWYobmF0MS5kYXRhW29mczFdIDwgbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdFxuLy9SZXF1aXJlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGEgPSBudW1fZGlnaXRzX25hdChuYXQxLCBvZnMxLCBsZW4xKTtcbiAgdmFyIGIgPSBudW1fZGlnaXRzX25hdChuYXQyLCBvZnMyLCBsZW4yKTtcbiAgaWYoYSA+IGIpIHJldHVybiAxO1xuICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICBmb3IodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA+IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAxO1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDwgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdF9yZWFsXG4vL1JlcXVpcmVzOiBjb21wYXJlX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXRfcmVhbChuYXQxLG5hdDIpe1xuICByZXR1cm4gY29tcGFyZV9uYXQobmF0MSwwLG5hdDEuZGF0YS5sZW5ndGgsbmF0MiwwLG5hdDIuZGF0YS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBsYW5kX2RpZ2l0X25hdFxuZnVuY3Rpb24gbGFuZF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gJj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSB8PSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBseG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbHhvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gXj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBzZXJpYWxpemVfbmF0XG5mdW5jdGlvbiBzZXJpYWxpemVfbmF0KHdyaXRlciwgbmF0LCBzeil7XG4gIHZhciBsZW4gPSBuYXQuZGF0YS5sZW5ndGg7XG4gIHdyaXRlci53cml0ZSgzMiwgbGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICB3cml0ZXIud3JpdGUoMzIsIG5hdC5kYXRhW2ldKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHN6WzFdID0gbGVuICogODtcbn1cblxuLy9Qcm92aWRlczogZGVzZXJpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gZGVzZXJpYWxpemVfbmF0KHJlYWRlciwgc3ope1xuICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIG5hdCA9IG5ldyBNbE5hdChsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIG5hdC5kYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHJldHVybiBuYXQ7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBnbG9iYWxUaGlzLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzLnZlcnNpb25zICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGdsb2JhbFRoaXMucHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJylcbn1cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCAoKSB7XG4gIHJldHVybiBmYWxzZVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9SZXF1aXJlczogTWxOb2RlRmQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX3dpdGhfYXJnc1xuLy9SZXF1aXJlczogbWFrZV91bml4X2Vycl9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKHJvb3QpIHtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmlzRmlsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5zdGF0U3luYyh0aGlzLm5tKG5hbWUpKS5pc0ZpbGUoKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ta2RpciA9IGZ1bmN0aW9uKG5hbWUsIG1vZGUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLm1rZGlyU3luYyh0aGlzLm5tKG5hbWUpLHttb2RlOm1vZGV9KTtcbiAgICByZXR1cm4gMFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMucm1kaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiAwXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5yZWFkZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5pc19kaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNEaXJlY3RvcnkoKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICAgIHRoaXMuZnMudW5saW5rU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gYjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZiwgcmFpc2VfdW5peCkge1xuICB2YXIgY29uc3RzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG4gIHZhciByZXMgPSAwO1xuICBmb3IodmFyIGtleSBpbiBmKXtcbiAgICBzd2l0Y2goa2V5KXtcbiAgICBjYXNlIFwicmRvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1JET05MWTsgYnJlYWs7XG4gICAgY2FzZSBcIndyb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19XUk9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJhcHBlbmRcIiAgOlxuICAgICAgcmVzIHw9IGNvbnN0cy5PX1dST05MWSB8IGNvbnN0cy5PX0FQUEVORDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjcmVhdGVcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0NSRUFUOyAgICBicmVhaztcbiAgICBjYXNlIFwidHJ1bmNhdGVcIiA6IHJlcyB8PSBjb25zdHMuT19UUlVOQzsgICAgYnJlYWs7XG4gICAgY2FzZSBcImV4Y2xcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fRVhDTDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiaW5hcnlcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0JJTkFSWTsgICBicmVhaztcbiAgICBjYXNlIFwidGV4dFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19URVhUOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vbmJsb2NrXCIgOiByZXMgfD0gY29uc3RzLk9fTk9OQkxPQ0s7IGJyZWFrO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHZhciBmZCA9IHRoaXMuZnMub3BlblN5bmModGhpcy5ubShuYW1lKSwgcmVzKTtcbiAgICB2YXIgaXNDaGFyYWN0ZXJEZXZpY2UgPSB0aGlzLmZzLmxzdGF0U3luYyh0aGlzLm5tKG5hbWUpKS5pc0NoYXJhY3RlckRldmljZSgpO1xuICAgIGYuaXNDaGFyYWN0ZXJEZXZpY2UgPSBpc0NoYXJhY3RlckRldmljZTtcbiAgICByZXR1cm4gbmV3IE1sTm9kZUZkKGZkLCBmKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKG8sIG4sIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlbmFtZVN5bmModGhpcy5ubShvKSwgdGhpcy5ubShuKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3RhdCA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIganNfc3RhdHMgPSB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiB0aGlzLnN0YXRzX2Zyb21fanMoanNfc3RhdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmxzdGF0ID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMubHN0YXRTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiB0aGlzLnN0YXRzX2Zyb21fanMoanNfc3RhdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnN5bWxpbmsgPSBmdW5jdGlvbih0b19kaXIsIHRhcmdldCwgcGF0aCwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMuc3ltbGlua1N5bmModGhpcy5ubSh0YXJnZXQpLCB0aGlzLm5tKHBhdGgpLCB0b19kaXIgPyAnZGlyJyA6ICdmaWxlJyk7XG4gICAgcmV0dXJuIDA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGxpbmsgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGxpbmsgPSB0aGlzLmZzLnJlYWRsaW5rU3luYyh0aGlzLm5tKG5hbWUpLCAndXRmOCcpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhsaW5rKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLm9wZW5kaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJhaXNlX25vZGVqc19lcnJvciA9IGZ1bmN0aW9uKGVyciwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IGNhbWxfbmFtZWRfdmFsdWUoXCJVbml4LlVuaXhfZXJyb3JcIik7XG4gIGlmIChyYWlzZV91bml4ICYmIHVuaXhfZXJyb3IpIHtcbiAgICB2YXIgYXJncyA9IG1ha2VfdW5peF9lcnJfYXJncyhlcnIuY29kZSwgZXJyLnN5c2NhbGwsIGVyci5wYXRoLCBlcnIuZXJybm8pO1xuICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5zdGF0c19mcm9tX2pzID0gZnVuY3Rpb24oanNfc3RhdHMpIHtcbiAgLyogPT09VW5peC5maWxlX2tpbmQ9PT1cbiAgICogdHlwZSBmaWxlX2tpbmQgPVxuICAgKiAgICAgU19SRUcgICAgICAgICAgICAgICAgICAgICAgICgqKiBSZWd1bGFyIGZpbGUgKilcbiAgICogICB8IFNfRElSICAgICAgICAgICAgICAgICAgICAgICAoKiogRGlyZWN0b3J5ICopXG4gICAqICAgfCBTX0NIUiAgICAgICAgICAgICAgICAgICAgICAgKCoqIENoYXJhY3RlciBkZXZpY2UgKilcbiAgICogICB8IFNfQkxLICAgICAgICAgICAgICAgICAgICAgICAoKiogQmxvY2sgZGV2aWNlICopXG4gICAqICAgfCBTX0xOSyAgICAgICAgICAgICAgICAgICAgICAgKCoqIFN5bWJvbGljIGxpbmsgKilcbiAgICogICB8IFNfRklGTyAgICAgICAgICAgICAgICAgICAgICAoKiogTmFtZWQgcGlwZSAqKVxuICAgKiAgIHwgU19TT0NLICAgICAgICAgICAgICAgICAgICAgICgqKiBTb2NrZXQgKilcbiAgICovXG4gIHZhciBmaWxlX2tpbmQ7XG4gIGlmIChqc19zdGF0cy5pc0ZpbGUoKSkge1xuICAgIGZpbGVfa2luZCA9IDA7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIGZpbGVfa2luZCA9IDE7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNDaGFyYWN0ZXJEZXZpY2UoKSkge1xuICAgIGZpbGVfa2luZCA9IDI7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNCbG9ja0RldmljZSgpKSB7XG4gICAgZmlsZV9raW5kID0gMztcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgZmlsZV9raW5kID0gNDtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc0ZJRk8oKSkge1xuICAgIGZpbGVfa2luZCA9IDU7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNTb2NrZXQoKSkge1xuICAgIGZpbGVfa2luZCA9IDY7XG4gIH1cbiAgLyogPT09VW5peC5zdGF0cz09PVxuICAgKiB0eXBlIHN0YXRzID1cbiAgICogIHsgc3RfZGV2IDogaW50OyAgICAgICAgICAgICAgICgqKiBEZXZpY2UgbnVtYmVyICopXG4gICAqICAgIHN0X2lubyA6IGludDsgICAgICAgICAgICAgICAoKiogSW5vZGUgbnVtYmVyICopXG4gICAqICAgIHN0X2tpbmQgOiBmaWxlX2tpbmQ7ICAgICAgICAoKiogS2luZCBvZiB0aGUgZmlsZSAqKVxuICAgKiAgICBzdF9wZXJtIDogZmlsZV9wZXJtOyAgICAgICAgKCoqIEFjY2VzcyByaWdodHMgKilcbiAgICogICAgc3RfbmxpbmsgOiBpbnQ7ICAgICAgICAgICAgICgqKiBOdW1iZXIgb2YgbGlua3MgKilcbiAgICogICAgc3RfdWlkIDogaW50OyAgICAgICAgICAgICAgICgqKiBVc2VyIGlkIG9mIHRoZSBvd25lciAqKVxuICAgKiAgICBzdF9naWQgOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIEdyb3VwIElEIG9mIHRoZSBmaWxlJ3MgZ3JvdXAgKilcbiAgICogICAgc3RfcmRldiA6IGludDsgICAgICAgICAgICAgICgqKiBEZXZpY2UgSUQgKGlmIHNwZWNpYWwgZmlsZSkgKilcbiAgICogICAgc3Rfc2l6ZSA6IGludDsgICAgICAgICAgICAgICgqKiBTaXplIGluIGJ5dGVzICopXG4gICAqICAgIHN0X2F0aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBhY2Nlc3MgdGltZSAqKVxuICAgKiAgICBzdF9tdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3QgbW9kaWZpY2F0aW9uIHRpbWUgKilcbiAgICogICAgc3RfY3RpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IHN0YXR1cyBjaGFuZ2UgdGltZSAqKVxuICAgKiAgfVxuICAgKi9cbiAgcmV0dXJuIEJMT0NLKFxuICAgIDAsXG4gICAganNfc3RhdHMuZGV2LFxuICAgIGpzX3N0YXRzLmlubyxcbiAgICBmaWxlX2tpbmQsXG4gICAganNfc3RhdHMubW9kZSxcbiAgICBqc19zdGF0cy5ubGluayxcbiAgICBqc19zdGF0cy51aWQsXG4gICAganNfc3RhdHMuZ2lkLFxuICAgIGpzX3N0YXRzLnJkZXYsXG4gICAganNfc3RhdHMuc2l6ZSxcbiAgICBqc19zdGF0cy5hdGltZU1zLFxuICAgIGpzX3N0YXRzLm10aW1lTXMsXG4gICAganNfc3RhdHMuY3RpbWVNc1xuICApO1xufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKCkge1xufVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVGZFxuLy9SZXF1aXJlczogTWxGaWxlLCBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZywgY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcywgY2FtbF9ieXRlc19zZXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBNbE5vZGVGZChmZCwgZmxhZ3Mpe1xuICB0aGlzLmZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdGhpcy5mZCA9IGZkO1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG59XG5NbE5vZGVGZC5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuTWxOb2RlRmQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRmQ7XG5cbk1sTm9kZUZkLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5mdHJ1bmNhdGVTeW5jKHRoaXMuZmQsbGVufDApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZkLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZnN0YXRTeW5jKHRoaXMuZmQpLnNpemU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1ZixidWZfb2Zmc2V0LGxlbil7XG4gIHRyeSB7XG4gICAgaWYodGhpcy5mbGFncy5pc0NoYXJhY3RlckRldmljZSlcbiAgICAgIHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZiwgYnVmX29mZnNldCwgbGVuKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLmZzLndyaXRlU3luYyh0aGlzLmZkLCBidWYsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuTWxOb2RlRmQucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYSxidWZfb2Zmc2V0LGxlbil7XG4gIHRyeSB7XG4gICAgaWYodGhpcy5mbGFncy5pc0NoYXJhY3RlckRldmljZSlcbiAgICAgIHZhciByZWFkID0gdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBhLCBidWZfb2Zmc2V0LCBsZW4pO1xuICAgIGVsc2VcbiAgICAgIHZhciByZWFkID0gdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBhLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gICAgcmV0dXJuIHJlYWQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmNsb3NlU3luYyh0aGlzLmZkKTtcbiAgICByZXR1cm4gMFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVGZFxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gTWxOb2RlRmQoKXtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlXG4vL1JlcXVpcmVzOiBNbE5vZGVGZFxuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZShmZCwgZmxhZ3Mpe1xuICBpZihmbGFncy5uYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICAgIHZhciBmZDIgPSBmcy5vcGVuU3luYyhmbGFncy5uYW1lLCBcInJzXCIpO1xuICAgICAgcmV0dXJuIG5ldyBNbE5vZGVGZChmZDIsIGZsYWdzKTtcbiAgICB9IGNhdGNoKGUpIHsgIH1cbiAgfVxuICByZXR1cm4gbmV3IE1sTm9kZUZkKGZkLCBmbGFncyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5fZm9yX25vZGVcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW5fZm9yX25vZGUoZmQsIGZsYWdzKXtcbiAgcmV0dXJuIG51bGw7XG59XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9iaWdzdHJpbmcoaCwgYnMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsYnMuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlcihicykge1xuICByZXR1cm4gYnMuZGF0YS5idWZmZXJcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b190eXBlZF9hcnJheShicykge1xuICByZXR1cm4gYnMuZGF0YVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlcihhYikge1xuICB2YXIgdGEgPSBuZXcgVWludDhBcnJheShhYik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheShiYSkge1xuICB2YXIgdGEgPSBuZXcgVWludDhBcnJheShiYS5idWZmZXIsIGJhLmJ5dGVPZmZzZXQsIGJhLmxlbmd0aCAqIGJhLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfbWVtY21wXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19tZW1jbXAoczEsIHBvczEsIHMyLCBwb3MyLCBsZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHMxLHBvczEgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEoczIscG9zMiArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShiYTEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zdWJhcnJheShvZnMxLG9mczErbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLHBvczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhiYTEsIHBvczEsIGJ5dGVzMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYocG9zMiArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ5dGVzMikpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zbGljZShvZnMxLCBvZnMxK2xlbik7XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KHNsaWNlKSwgMCwgYnl0ZXMyLCBwb3MyLCBsZW4pO1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2NoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX01ENUluaXQsIGNhbWxfTUQ1VXBkYXRlLCBjYW1sX01ENUZpbmFsXG5mdW5jdGlvbiBjYW1sX21kNV9jaGFuKGNoYW5pZCx0b3JlYWQpe1xuICB2YXIgY3R4ID0gY2FtbF9NRDVJbml0KCk7XG4gIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheSg0MDk2KTtcbiAgaWYodG9yZWFkIDwgMCl7XG4gICAgd2hpbGUodHJ1ZSl7XG4gICAgICB2YXIgcmVhZCA9IGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLGJ1ZmZlciwwLGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgaWYocmVhZCA9PSAwKSBicmVhaztcbiAgICAgIGNhbWxfTUQ1VXBkYXRlKGN0eCxidWZmZXIuc3ViYXJyYXkoMCwgcmVhZCksIHJlYWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSh0b3JlYWQgPiAwKSB7XG4gICAgICB2YXIgcmVhZCA9IGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLGJ1ZmZlciwwLCAodG9yZWFkID4gYnVmZmVyLmxlbmd0aCA/IGJ1ZmZlci5sZW5ndGggOiB0b3JlYWQpKTtcbiAgICAgIGlmKHJlYWQgPT0gMCkgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICAgICAgY2FtbF9NRDVVcGRhdGUoY3R4LGJ1ZmZlci5zdWJhcnJheSgwLCByZWFkKSwgcmVhZCk7XG4gICAgICB0b3JlYWQgLT0gcmVhZFxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoY2FtbF9NRDVGaW5hbChjdHgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3N0cmluZywgY2FtbF9tZDVfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X3N0cmluZyhzLCBvZnMsIGxlbikge1xuICByZXR1cm4gY2FtbF9tZDVfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcocyksb2ZzLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG52YXIgY2FtbF9NRDVUcmFuc2Zvcm0gPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBhZGQgKHgsIHkpIHsgcmV0dXJuICh4ICsgeSkgfCAwOyB9XG4gIGZ1bmN0aW9uIHh4KHEsYSxiLHgscyx0KSB7XG4gICAgYSA9IGFkZChhZGQoYSwgcSksIGFkZCh4LCB0KSk7XG4gICAgcmV0dXJuIGFkZCgoYSA8PCBzKSB8IChhID4+PiAoMzIgLSBzKSksIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGZmKGEsYixjLGQseCxzLHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGdnKGEsYixjLGQseCxzLHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGhoKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7IH1cbiAgZnVuY3Rpb24gaWkoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpOyB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh3LCBidWZmZXIpIHtcbiAgICB2YXIgYSA9IHdbMF0sIGIgPSB3WzFdLCBjID0gd1syXSwgZCA9IHdbM107XG5cbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlclsgMV0sIDEyLCAweEU4QzdCNzU2KTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyWyAyXSwgMTcsIDB4MjQyMDcwREIpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlclsgNF0sIDcsIDB4RjU3QzBGQUYpO1xuICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbIDVdLCAxMiwgMHg0Nzg3QzYyQSk7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlclsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyWyA3XSwgMjIsIDB4RkQ0Njk1MDEpO1xuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbIDhdLCA3LCAweDY5ODA5OEQ4KTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyWyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbMTBdLCAxNywgMHhGRkZGNUJCMSk7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlclsxMV0sIDIyLCAweDg5NUNEN0JFKTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlclsxM10sIDEyLCAweEZEOTg3MTkzKTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyWzE0XSwgMTcsIDB4QTY3OTQzOEUpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWyAxXSwgNSwgMHhGNjFFMjU2Mik7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsgNl0sIDksIDB4QzA0MEIzNDApO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsgMF0sIDIwLCAweEU5QjZDN0FBKTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWyA1XSwgNSwgMHhENjJGMTA1RCk7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbMTVdLCAxNCwgMHhEOEExRTY4MSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsgNF0sIDIwLCAweEU3RDNGQkM4KTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsxNF0sIDksIDB4QzMzNzA3RDYpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbIDNdLCAxNCwgMHhGNEQ1MEQ4Nyk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWzEzXSwgNSwgMHhBOUUzRTkwNSk7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsgMl0sIDksIDB4RkNFRkEzRjgpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsxMl0sIDIwLCAweDhEMkE0QzhBKTtcblxuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbIDVdLCA0LCAweEZGRkEzOTQyKTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyWyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbMTFdLCAxNiwgMHg2RDlENjEyMik7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlclsxNF0sIDIzLCAweEZERTUzODBDKTtcbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyWyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlclsgNF0sIDExLCAweDRCREVDRkE5KTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyWyA3XSwgMTYsIDB4RjZCQjRCNjApO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlclsxM10sIDQsIDB4Mjg5QjdFQzYpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbIDBdLCAxMSwgMHhFQUExMjdGQSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlclsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyWyA2XSwgMjMsIDB4MDQ4ODFEMDUpO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbIDldLCA0LCAweEQ5RDREMDM5KTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyWzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbMTVdLCAxNiwgMHgxRkEyN0NGOCk7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlclsgMl0sIDIzLCAweEM0QUM1NjY1KTtcblxuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyWyA3XSwgMTAsIDB4NDMyQUZGOTcpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbMTRdLCAxNSwgMHhBQjk0MjNBNyk7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlclsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyWzEyXSwgNiwgMHg2NTVCNTlDMyk7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlclsgM10sIDEwLCAweDhGMENDQzkyKTtcbiAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyWzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbIDFdLCAyMSwgMHg4NTg0NUREMSk7XG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlclsgOF0sIDYsIDB4NkZBODdFNEYpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlclsgNl0sIDE1LCAweEEzMDE0MzE0KTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyWzEzXSwgMjEsIDB4NEUwODExQTEpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyWzExXSwgMTAsIDB4QkQzQUYyMzUpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbIDJdLCAxNSwgMHgyQUQ3RDJCQik7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlclsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgIHdbMF0gPSBhZGQoYSwgd1swXSk7XG4gICAgd1sxXSA9IGFkZChiLCB3WzFdKTtcbiAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgIHdbM10gPSBhZGQoZCwgd1szXSk7XG4gIH19KSgpXG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1SW5pdFxuZnVuY3Rpb24gY2FtbF9NRDVJbml0KCkge1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDY0KTtcbiAgdmFyIGIzMiA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICB2YXIgYjggPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICByZXR1cm4ge2xlbjowLFxuICAgICAgICAgIHc6bmV3IFVpbnQzMkFycmF5KFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XSksXG4gICAgICAgICAgYjMyOmIzMixcbiAgICAgICAgICBiODpiOH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9NRDVVcGRhdGVcbi8vUmVxdWlyZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG5mdW5jdGlvbiBjYW1sX01ENVVwZGF0ZShjdHgsIGlucHV0LCBpbnB1dF9sZW4pe1xuICB2YXIgaW5fYnVmID0gY3R4LmxlbiAmIDB4M2Y7XG4gIHZhciBpbnB1dF9wb3MgPSAwO1xuICBjdHgubGVuICs9IGlucHV0X2xlbjtcbiAgaWYoaW5fYnVmKXtcbiAgICB2YXIgbWlzc2luZyA9IDY0IC0gaW5fYnVmO1xuICAgIGlmKGlucHV0X2xlbiA8IG1pc3NpbmcpIHtcbiAgICAgIGN0eC5iOC5zZXQoaW5wdXQuc3ViYXJyYXkoMCxpbnB1dF9sZW4pLGluX2J1Zik7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheSgwLG1pc3NpbmcpLGluX2J1Zik7XG4gICAgY2FtbF9NRDVUcmFuc2Zvcm0oY3R4LncsIGN0eC5iMzIpO1xuICAgIGlucHV0X2xlbiAtPSBtaXNzaW5nO1xuICAgIGlucHV0X3BvcyArPSBtaXNzaW5nO1xuICB9XG4gIHdoaWxlKGlucHV0X2xlbiA+PSA2NCl7XG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheShpbnB1dF9wb3MsaW5wdXRfcG9zICsgNjQpLCAwKTtcbiAgICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gICAgaW5wdXRfbGVuIC09IDY0O1xuICAgIGlucHV0X3BvcyArPSA2NDtcbiAgfVxuICBpZihpbnB1dF9sZW4pXG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheShpbnB1dF9wb3MsaW5wdXRfcG9zICsgaW5wdXRfbGVuKSwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1RmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG5mdW5jdGlvbiBjYW1sX01ENUZpbmFsKGN0eCl7XG4gIHZhciBpbl9idWYgPSBjdHgubGVuICYgMHgzZjtcbiAgY3R4LmI4W2luX2J1Zl0gPSAweDgwO1xuICBpbl9idWYgKys7XG4gIGlmKGluX2J1ZiA+IDU2KSB7XG4gICAgZm9yKHZhciBqID0gaW5fYnVmOyBqIDwgNjQ7IGorKyl7XG4gICAgICBjdHguYjhbal0gPSAwO1xuICAgIH1cbiAgICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDU2OyBqKyspe1xuICAgICAgY3R4LmI4W2pdID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yKHZhciBqID0gaW5fYnVmOyBqIDwgNTY7IGorKyl7XG4gICAgICBjdHguYjhbal0gPSAwO1xuICAgIH1cbiAgfVxuICBjdHguYjMyWzE0XSA9IGN0eC5sZW4gPDwgMztcbiAgY3R4LmIzMlsxNV0gPSAoY3R4LmxlbiA+PiAyOSkgJiAweDFGRkZGRkZGO1xuICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gIHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgIHRbaSAqIDQgKyBqXSA9IChjdHgud1tpXSA+PiAoOCAqIGopKSAmIDB4RkY7XG4gIHJldHVybiB0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9NRDVJbml0LCBjYW1sX01ENVVwZGF0ZSwgY2FtbF9NRDVGaW5hbFxuZnVuY3Rpb24gY2FtbF9tZDVfYnl0ZXMocywgb2ZzLCBsZW4pIHtcbiAgdmFyIGN0eCA9IGNhbWxfTUQ1SW5pdCgpO1xuICB2YXIgYSA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMocyk7XG4gIGNhbWxfTUQ1VXBkYXRlKGN0eCxhLnN1YmFycmF5KG9mcywgb2ZzICsgbGVuKSwgbGVuKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGNhbWxfTUQ1RmluYWwoY3R4KSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19mbG9vcl9sb2cyXG52YXIgbG9nMl9vayA9IE1hdGgubG9nMiAmJiBNYXRoLmxvZzIoMS4xMjM1NTgyMDkyODg5NDc0RSszMDcpID09IDEwMjBcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gIGlmKGxvZzJfb2spIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nMih4KSlcbiAgdmFyIGkgPSAwO1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLUluZmluaXR5O1xuICBpZih4Pj0xKSB7d2hpbGUgKHg+PTIpIHt4Lz0yOyBpKyt9IH1cbiAgZWxzZSB7d2hpbGUgKHggPCAxKSB7eCo9MjsgaS0tfSB9O1xuICByZXR1cm4gaTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSlcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgxLCAwLCAweDdmZjApO1xuICAgIGlmICh4ID4gMClcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweDdmZjApXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4ZmZmMClcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzB4ODAwMDooeD49MCk/MDoweDgwMDA7XG4gIGlmIChzaWduKSB4ID0gLXg7XG4gIC8vIEludDY0LmJpdHNfb2ZfZmxvYXQgMS4xMjM1NTgyMDkyODg5NDc0RSszMDcgPSAweDdmYjAwMDAwMDAwMDAwMDBMXG4gIC8vIHVzaW5nIE1hdGguTE9HMkUqTWF0aC5sb2coeCkgaW4gcGxhY2Ugb2YgTWF0aC5sb2cyIHJlc3VsdCBpbiBwcmVjaXNpb24gbG9zdFxuICB2YXIgZXhwID0ganNvb19mbG9vcl9sb2cyKHgpICsgMTAyMztcbiAgaWYgKGV4cCA8PSAwKSB7XG4gICAgZXhwID0gMDtcbiAgICB4IC89IE1hdGgucG93KDIsLTEwMjYpO1xuICB9IGVsc2Uge1xuICAgIHggLz0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gICAgaWYgKHggPCAxNikge1xuICAgICAgeCAqPSAyOyBleHAgLT0xOyB9XG4gICAgaWYgKGV4cCA9PSAwKSB7XG4gICAgICB4IC89IDI7IH1cbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsMjQpO1xuICB2YXIgcjMgPSB4fDA7XG4gIHggPSAoeCAtIHIzKSAqIGs7XG4gIHZhciByMiA9IHh8MDtcbiAgeCA9ICh4IC0gcjIpICogaztcbiAgdmFyIHIxID0geHwwO1xuICByMyA9IChyMyAmMHhmKSB8IHNpZ24gfCBleHAgPDwgNDtcbiAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHIxLCByMiwgcjMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG4gIGZsb2F0MzJhWzBdID0geDtcbiAgdmFyIGludDMyYSA9IG5ldyBJbnQzMkFycmF5KGZsb2F0MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBpbnQzMmFbMF0gfCAwO1xufVxuXG4vL0ZQIGxpdGVyYWxzIGNhbiBiZSB3cml0dGVuIHVzaW5nIHRoZSBoZXhhZGVjaW1hbFxuLy9ub3RhdGlvbiAweDxtYW50aXNzYSBpbiBoZXg+cDxleHBvbmVudD4gZnJvbSBJU08gQzk5LlxuLy9odHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtaGV4ZmxvYXQvYmxvYi9tYXN0ZXIvaGV4ZmxvYXQuanNcbi8vUHJvdmlkZXM6IGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCAoeCwgcHJlYywgc3R5bGUpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSkgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFwibmFuXCIpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoKHggPiAwKT9cImluZmluaXR5XCI6XCItaW5maW5pdHlcIik7XG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8xOih4Pj0wKT8wOjE7XG4gIGlmKHNpZ24pIHggPSAteDtcbiAgdmFyIGV4cCA9IDA7XG4gIGlmICh4ID09IDApIHsgfVxuICBlbHNlIGlmICh4IDwgMSkge1xuICAgIHdoaWxlICh4IDwgMSAmJiBleHAgPiAtMTAyMikgIHsgeCAqPSAyOyBleHAtLSB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHggPj0gMikgeyB4IC89IDI7IGV4cCsrIH1cbiAgfVxuICB2YXIgZXhwX3NpZ24gPSBleHAgPCAwID8gJycgOiAnKyc7XG4gIHZhciBzaWduX3N0ciA9ICcnO1xuICBpZiAoc2lnbikgc2lnbl9zdHIgPSAnLSdcbiAgZWxzZSB7XG4gICAgc3dpdGNoKHN0eWxlKXtcbiAgICBjYXNlIDQzIC8qICcrJyAqLzogc2lnbl9zdHIgPSAnKyc7IGJyZWFrO1xuICAgIGNhc2UgMzIgLyogJyAnICovOiBzaWduX3N0ciA9ICcgJzsgYnJlYWs7XG4gICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChwcmVjID49IDAgJiYgcHJlYyA8IDEzKSB7XG4gICAgLyogSWYgYSBwcmVjaXNpb24gaXMgZ2l2ZW4sIGFuZCBpcyBzbWFsbCwgcm91bmQgbWFudGlzc2EgYWNjb3JkaW5nbHkgKi9cbiAgICB2YXIgY3N0ID0gTWF0aC5wb3coMixwcmVjICogNCk7XG4gICAgeCA9IE1hdGgucm91bmQoeCAqIGNzdCkgLyBjc3Q7XG4gIH1cbiAgdmFyIHhfc3RyID0geC50b1N0cmluZygxNik7XG4gIGlmKHByZWMgPj0gMCl7XG4gICAgdmFyIGlkeCA9IHhfc3RyLmluZGV4T2YoJy4nKTtcbiAgICBpZihpZHg8MCkge1xuICAgICAgeF9zdHIgKz0gJy4nICsgY2FtbF9zdHJfcmVwZWF0KHByZWMsICcwJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpemUgPSBpZHgrMStwcmVjO1xuICAgICAgaWYoeF9zdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgeF9zdHIgKz0gY2FtbF9zdHJfcmVwZWF0KHNpemUgLSB4X3N0ci5sZW5ndGgsICcwJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHhfc3RyID0geF9zdHIuc3Vic3RyKDAsc2l6ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoc2lnbl9zdHIgKyAnMHgnICsgeF9zdHIgKyAncCcgKyBleHBfc2lnbiArIGV4cC50b1N0cmluZygxMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgbG8gPSB4LmxvO1xuICB2YXIgbWkgPSB4Lm1pO1xuICB2YXIgaGkgPSB4LmhpO1xuICB2YXIgZXhwID0gKGhpICYgMHg3ZmZmKSA+PiA0O1xuICBpZiAoZXhwID09IDIwNDcpIHtcbiAgICBpZiAoKGxvfG1pfChoaSYweGYpKSA9PSAwKVxuICAgICAgcmV0dXJuIChoaSAmIDB4ODAwMCk/KC1JbmZpbml0eSk6SW5maW5pdHk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE5hTjtcbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsLTI0KTtcbiAgdmFyIHJlcyA9IChsbyprK21pKSprKyhoaSYweGYpO1xuICBpZiAoZXhwID4gMCkge1xuICAgIHJlcyArPSAxNjtcbiAgICByZXMgKj0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gIH0gZWxzZVxuICAgIHJlcyAqPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgaWYgKGhpICYgMHg4MDAwKSByZXMgPSAtIHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9zdWIsY2FtbF9pbnQ2NF9vZl9pbnQzMlxuZnVuY3Rpb24gY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgKHgseSkge1xuICBpZihpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIE5hTjtcbiAgaWYoeD09eSkgcmV0dXJuIHk7XG4gIGlmKHg9PTApe1xuICAgIGlmKHkgPCAwKVxuICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAtMTA3NClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwNzQpXG4gIH1cbiAgdmFyIGJpdHMgPSBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoeCk7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X29mX2ludDMyKDEpO1xuICBpZiAoKHg8eSkgPT0gKHg+MCkpXG4gICAgYml0cyA9IGNhbWxfaW50NjRfYWRkKGJpdHMsIG9uZSlcbiAgZWxzZVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X3N1YihiaXRzLCBvbmUpXG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoYml0cyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJ1bmNfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdHJ1bmNfZmxvYXQoeCl7XG4gIHJldHVybiBNYXRoLnRydW5jKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgaW50MzJhID0gbmV3IEludDMyQXJyYXkoMSk7XG4gIGludDMyYVswXSA9IHg7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBGbG9hdDMyQXJyYXkoaW50MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBmbG9hdDMyYVswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jbGFzc2lmeV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jbGFzc2lmeV9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpID49IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSByZXR1cm4gMDtcbiAgICBpZiAoeCAhPSAwKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gaXNOYU4oeCk/NDozO1xufVxuLy9Qcm92aWRlczogY2FtbF9tb2RmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX21vZGZfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIHZhciBuZWcgPSAoMS94KSA8IDA7XG4gICAgeCA9IE1hdGguYWJzKHgpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vciAoeCk7XG4gICAgdmFyIGYgPSB4IC0gaTtcbiAgICBpZiAobmVnKSB7IGkgPSAtaTsgZiA9IC1mOyB9XG4gICAgcmV0dXJuIFswLCBmLCBpXTtcbiAgfVxuICBpZiAoaXNOYU4gKHgpKSByZXR1cm4gWzAsIE5hTiwgTmFOXTtcbiAgcmV0dXJuIFswLCAxL3gsIHhdO1xufVxuLy9Qcm92aWRlczogY2FtbF9sZGV4cF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sZGV4cF9mbG9hdCAoeCxleHApIHtcbiAgZXhwIHw9IDA7XG4gIGlmIChleHAgPiAxMDIzKSB7XG4gICAgZXhwIC09IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICBpZiAoZXhwID4gMTAyMykgeyAgLy8gaW4gY2FzZSB4IGlzIHN1Ym5vcm1hbFxuICAgICAgZXhwIC09IDEwMjM7XG4gICAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIH1cbiAgfVxuICBpZiAoZXhwIDwgLTEwMjMpIHtcbiAgICBleHAgKz0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIC0xMDIzKTtcbiAgfVxuICB4ICo9IE1hdGgucG93KDIsIGV4cCk7XG4gIHJldHVybiB4O1xufVxuLy9Qcm92aWRlczogY2FtbF9mcmV4cF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ZyZXhwX2Zsb2F0ICh4KSB7XG4gIGlmICgoeCA9PSAwKSB8fCAhaXNGaW5pdGUoeCkpIHJldHVybiBbMCwgeCwgMF07XG4gIHZhciBuZWcgPSB4IDwgMDtcbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgdmFyIGV4cCA9IE1hdGgubWF4KC0xMDIzLCBqc29vX2Zsb29yX2xvZzIoeCkgKyAxKTtcbiAgeCAqPSBNYXRoLnBvdygyLC1leHApO1xuICB3aGlsZSAoeCA8IDAuNSkge1xuICAgIHggKj0gMjtcbiAgICBleHAtLTtcbiAgfVxuICB3aGlsZSAoeCA+PSAxKSB7XG4gICAgeCAqPSAwLjU7XG4gICAgZXhwKys7XG4gIH1cbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSAoeCwgeSkge1xuICBpZiAoeCA9PT0geSkgcmV0dXJuIDA7XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICBpZiAoeCA+IHkpIHJldHVybiAxO1xuICBpZiAoeCA9PT0geCkgcmV0dXJuIDE7XG4gIGlmICh5ID09PSB5KSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvcHlzaWduX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvcHlzaWduX2Zsb2F0ICh4LCB5KSB7XG4gIGlmICh5ID09IDApIHkgPSAxIC8geTtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICByZXR1cm4gKHkgPCAwKT8oLXgpOng7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2lnbmJpdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaWduYml0X2Zsb2F0KHgpIHtcbiAgaWYgKHggPT0gMCkgeCA9IDEgLyB4O1xuICByZXR1cm4gKHggPCAwKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhwbTFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwbTFfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguZXhwbTEoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZXhwMl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9leHAyX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgucG93KDIsIHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzFwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzFwX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgubG9nMXAoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cyX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgubG9nMih4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9oeXBvdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9oeXBvdF9mbG9hdCAoeCwgeSkgeyByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTsgfVxuLy9Qcm92aWRlczogY2FtbF9sb2cxMF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxMF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5sb2cxMCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9jb3NoX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Nvc2hfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguY29zaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hY29zaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hY29zaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9zaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguc2luaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hc2luaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hc2luaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hc2luaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF90YW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3RhbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgudGFuaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hdGFuaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hdGFuaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9yb3VuZF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9yb3VuZF9mbG9hdCAoeCkge1xuICBpZiAoeCA+PSAwKSB7XG4gICAgdmFyIHkgPSBNYXRoLmZsb29yKHgpO1xuICAgIHJldHVybiAoeCAtIHkgPj0gMC41KT8oeSArIDEpOnlcbiAgfSBlbHNlIHtcbiAgICB2YXIgeSA9IE1hdGguY2VpbCh4KTtcbiAgICByZXR1cm4gKHkgLSB4ID49IDAuNSk/KHkgLSAxKTp5XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY2JydF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jYnJ0X2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmNicnQoeCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9lcmZfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXJmX2Zsb2F0KHgpIHtcbiAgdmFyIGExID0gMC4yNTQ4Mjk1OTI7XG4gIHZhciBhMiA9IC0wLjI4NDQ5NjczNjtcbiAgdmFyIGEzID0gMS40MjE0MTM3NDE7XG4gIHZhciBhNCA9IC0xLjQ1MzE1MjAyNztcbiAgdmFyIGE1ID0gMS4wNjE0MDU0Mjk7XG4gIHZhciBwID0gMC4zMjc1OTExO1xuXG4gIHZhciBzaWduID0gMTtcbiAgaWYgKHggPCAwKSB7XG4gICAgc2lnbiA9IC0xO1xuICB9XG4gIHggPSBNYXRoLmFicyh4KTtcbiAgdmFyIHQgPSAxLjAgLyAoMS4wICsgcCAqIHgpO1xuICB2YXIgeSA9IDEuMCAtICgoKChhNSAqIHQgKyBhNCkgKiB0ICsgYTMpICogdCArIGEyKSAqIHQgKyBhMSkgKiB0ICogTWF0aC5leHAoLXggKiB4KTtcblxuICByZXR1cm4gc2lnbiAqIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXJmY19mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9lcmZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfZXJmY19mbG9hdCh4KSB7XG4gIHJldHVybiAxIC0gY2FtbF9lcmZfZmxvYXQoeCk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9mbWFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZm1hX2Zsb2F0KHgsIHksIHopIHtcbiAgdmFyIFNQTElUID0gTWF0aC5wb3coMiwgMjcpICsgMTtcbiAgdmFyIE1JTl9WQUxVRSA9IE1hdGgucG93KDIsIC0xMDIyKTtcbiAgdmFyIEVQU0lMT04gPSBNYXRoLnBvdygyLCAtNTIpO1xuICB2YXIgQyA9IDQxNjtcbiAgdmFyIEEgPSBNYXRoLnBvdygyLCArQyk7XG4gIHZhciBCID0gTWF0aC5wb3coMiwgLUMpO1xuXG4gIGZ1bmN0aW9uIG11bHRpcGx5IChhLCBiKSB7XG4gICAgdmFyIGF0ID0gU1BMSVQgKiBhO1xuICAgIHZhciBhaGkgPSBhdCAtIChhdCAtIGEpO1xuICAgIHZhciBhbG8gPSBhIC0gYWhpO1xuICAgIHZhciBidCA9IFNQTElUICogYjtcbiAgICB2YXIgYmhpID0gYnQgLSAoYnQgLSBiKTtcbiAgICB2YXIgYmxvID0gYiAtIGJoaTtcbiAgICB2YXIgcCA9IGEgKiBiO1xuICAgIHZhciBlID0gKChhaGkgKiBiaGkgLSBwKSArIGFoaSAqIGJsbyArIGFsbyAqIGJoaSkgKyBhbG8gKiBibG87XG4gICAgcmV0dXJuIHtcbiAgICAgIHA6IHAsXG4gICAgICBlOiBlXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB2YXIgcyA9IGEgKyBiO1xuICAgIHZhciB2ID0gcyAtIGE7XG4gICAgdmFyIGUgPSAoYSAtIChzIC0gdikpICsgKGIgLSB2KTtcbiAgICByZXR1cm4ge1xuICAgICAgczogcyxcbiAgICAgIGU6IGVcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkanVzdCAoeCwgeSkge1xuICAgIHJldHVybiB4ICE9PSAwICYmIHkgIT09IDAgJiYgU1BMSVQgKiB4IC0gKFNQTElUICogeCAtIHgpID09PSB4ID8geCAqICgxICsgKHggPCAwID8gLTEgOiArMSkgKiAoeSA8IDAgPyAtMSA6ICsxKSAqIEVQU0lMT04pIDogeDtcbiAgfTtcblxuICBpZiAoeCA9PT0gMCB8fCB4ICE9PSB4IHx8IHggPT09ICsxIC8gMCB8fCB4ID09PSAtMSAvIDAgfHxcbiAgICAgIHkgPT09IDAgfHwgeSAhPT0geSB8fCB5ID09PSArMSAvIDAgfHwgeSA9PT0gLTEgLyAwKSB7XG4gICAgcmV0dXJuIHggKiB5ICsgejtcbiAgfVxuICBpZiAoeiA9PT0gMCkge1xuICAgIHJldHVybiB4ICogeTtcbiAgfVxuICBpZiAoeiAhPT0geiB8fCB6ID09PSArMSAvIDAgfHwgeiA9PT0gLTEgLyAwKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cblxuICB2YXIgc2NhbGUgPSAxO1xuICB3aGlsZSAoTWF0aC5hYnMoeCkgPiBBKSB7XG4gICAgc2NhbGUgKj0gQTtcbiAgICB4ICo9IEI7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHkpID4gQSkge1xuICAgIHNjYWxlICo9IEE7XG4gICAgeSAqPSBCO1xuICB9XG4gIGlmIChzY2FsZSA9PT0gMSAvIDApIHtcbiAgICByZXR1cm4geCAqIHkgKiBzY2FsZTtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeCkgPCBCKSB7XG4gICAgc2NhbGUgKj0gQjtcbiAgICB4ICo9IEE7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHkpIDwgQikge1xuICAgIHNjYWxlICo9IEI7XG4gICAgeSAqPSBBO1xuICB9XG4gIGlmIChzY2FsZSA9PT0gMCkge1xuICAgIHJldHVybiB6O1xuICB9XG5cbiAgdmFyIHhzID0geDtcbiAgdmFyIHlzID0geTtcbiAgdmFyIHpzID0geiAvIHNjYWxlO1xuXG4gIGlmIChNYXRoLmFicyh6cykgPiBNYXRoLmFicyh4cyAqIHlzKSAqIDQgLyBFUFNJTE9OKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cbiAgaWYgKE1hdGguYWJzKHpzKSA8IE1hdGguYWJzKHhzICogeXMpICogRVBTSUxPTiAvIDQgKiBFUFNJTE9OIC8gNCkge1xuICAgIHpzID0gKHogPCAwID8gLTEgOiArMSkgKiBNSU5fVkFMVUU7XG4gIH1cblxuICB2YXIgeHkgPSBtdWx0aXBseSh4cywgeXMpO1xuICB2YXIgcyA9IGFkZCh4eS5wLCB6cyk7XG4gIHZhciB1ID0gYWRkKHh5LmUsIHMuZSk7XG4gIHZhciBpID0gYWRkKHMucywgdS5zKTtcblxuICB2YXIgZiA9IGkucyArIGFkanVzdChpLmUsIHUuZSk7XG4gIGlmIChmID09PSAwKSB7XG4gICAgcmV0dXJuIGY7XG4gIH1cblxuICB2YXIgZnMgPSBmICogc2NhbGU7XG4gIGlmIChNYXRoLmFicyhmcykgPiBNSU5fVkFMVUUpIHtcbiAgICByZXR1cm4gZnM7XG4gIH1cblxuICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZXJlIHdhcyBleHRyYSByb3VuZGluZyBmb3IgYSBkZW5vcm1hbGl6ZWQgdmFsdWUuXG4gIHJldHVybiBmcyArIGFkanVzdChmIC0gZnMgLyBzY2FsZSwgaS5lKSAqIHNjYWxlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2Zsb2F0IChmbXQsIHgpIHtcbiAgZnVuY3Rpb24gdG9GaXhlZCh4LGRwKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpIDwgMS4wKSB7XG4gICAgICByZXR1cm4geC50b0ZpeGVkKGRwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGUgPSBwYXJzZUludCh4LnRvU3RyaW5nKCkuc3BsaXQoJysnKVsxXSk7XG4gICAgICBpZiAoZSA+IDIwKSB7XG4gICAgICAgIGUgLT0gMjA7XG4gICAgICAgIHggLz0gTWF0aC5wb3coMTAsZSk7XG4gICAgICAgIHggKz0gKG5ldyBBcnJheShlKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIGlmKGRwID4gMCkge1xuICAgICAgICAgIHggPSB4ICsgJy4nICsgKG5ldyBBcnJheShkcCsxKSkuam9pbignMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgICAgZWxzZSByZXR1cm4geC50b0ZpeGVkKGRwKVxuICAgIH1cbiAgfVxuICB2YXIgcywgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIHZhciBwcmVjID0gKGYucHJlYyA8IDApPzY6Zi5wcmVjO1xuICBpZiAoeCA8IDAgfHwgKHggPT0gMCAmJiAxL3ggPT0gLUluZmluaXR5KSkgeyBmLnNpZ24gPSAtMTsgeCA9IC14OyB9XG4gIGlmIChpc05hTih4KSkgeyBzID0gXCJuYW5cIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZSBpZiAoIWlzRmluaXRlKHgpKSB7IHMgPSBcImluZlwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlXG4gICAgc3dpdGNoIChmLmNvbnYpIHtcbiAgICBjYXNlICdlJzpcbiAgICAgIHZhciBzID0geC50b0V4cG9uZW50aWFsKHByZWMpO1xuICAgICAgLy8gZXhwb25lbnQgc2hvdWxkIGJlIGF0IGxlYXN0IHR3byBkaWdpdHNcbiAgICAgIHZhciBpID0gcy5sZW5ndGg7XG4gICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2YnOlxuICAgICAgcyA9IHRvRml4ZWQoeCwgcHJlYyk7IGJyZWFrO1xuICAgIGNhc2UgJ2cnOlxuICAgICAgcHJlYyA9IHByZWM/cHJlYzoxO1xuICAgICAgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjIC0gMSk7XG4gICAgICB2YXIgaiA9IHMuaW5kZXhPZignZScpO1xuICAgICAgdmFyIGV4cCA9ICtzLnNsaWNlKGogKyAxKTtcbiAgICAgIGlmIChleHAgPCAtNCB8fCB4ID49IDFlMjEgfHwgeC50b0ZpeGVkKDApLmxlbmd0aCA+IHByZWMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICB2YXIgaSA9IGogLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpICsgcy5zbGljZShqKTtcbiAgICAgICAgaSA9IHMubGVuZ3RoO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwID0gcHJlYztcbiAgICAgICAgaWYgKGV4cCA8IDApIHsgcCAtPSBleHAgKyAxOyBzID0geC50b0ZpeGVkKHApOyB9XG4gICAgICAgIGVsc2Ugd2hpbGUgKHMgPSB4LnRvRml4ZWQocCksIHMubGVuZ3RoID4gcHJlYyArIDEpIHAtLTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgICAgdmFyIGkgPSBzLmxlbmd0aCAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX3N0cmluZyhzKSB7XG4gIHZhciByZXM7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpXG4gIHJlcyA9ICtzO1xuICBpZiAoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgcmV0dXJuIHJlcztcbiAgcyA9IHMucmVwbGFjZSgvXy9nLFwiXCIpO1xuICByZXMgPSArcztcbiAgaWYgKCgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSB8fCAvXlsrLV0/bmFuJC9pLnRlc3QocykpIHJldHVybiByZXM7XG4gIHZhciBtID0gL14gKihbKy1dPykweChbMC05YS1mXSspXFwuPyhbMC05YS1mXSopKHAoWystXT9bMC05XSspKT8vaS5leGVjKHMpO1xuICAvLyAgICAgICAgICAxICAgICAgICAyICAgICAgICAgICAgIDMgICAgICAgICAgIDVcbiAgaWYobSl7XG4gICAgdmFyIG0zID0gbVszXS5yZXBsYWNlKC8wKyQvLCcnKTtcbiAgICB2YXIgbWFudGlzc2EgPSBwYXJzZUludChtWzFdICsgbVsyXSArIG0zLCAxNik7XG4gICAgdmFyIGV4cG9uZW50ID0gKG1bNV18MCkgLSA0Km0zLmxlbmd0aDtcbiAgICByZXMgPSBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmKC9eXFwrP2luZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiBJbmZpbml0eTtcbiAgaWYoL14taW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgY2FtbF9mYWlsd2l0aChcImZsb2F0X29mX3N0cmluZ1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX3VwZGF0ZV9kdW1teSAoeCwgeSkge1xuICBpZiggeS5mdW4gKSB7IHguZnVuID0geS5mdW47IHJldHVybiAwOyB9XG4gIGlmKCB0eXBlb2YgeT09PVwiZnVuY3Rpb25cIiApIHsgeC5mdW4gPSB5OyByZXR1cm4gMDsgfVxuICB2YXIgaSA9IHkubGVuZ3RoOyB3aGlsZSAoaS0tKSB4W2ldID0geVtpXTsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYWxsb2NfZHVtbXlfaW5maXhcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfYWxsb2NfZHVtbXlfaW5maXggKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZiAoeCkgeyByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmZ1biwgW3hdKSB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2lzX2Jsb2NrIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2lzX2Jsb2NrICh4KSB7IHJldHVybiArKHggaW5zdGFuY2VvZiBBcnJheSk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90YWdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX29ial90YWcgKHgpIHtcbiAgaWYgKCh4IGluc3RhbmNlb2YgQXJyYXkpICYmIHhbMF0gPT0gKHhbMF0gPj4+IDApKVxuICAgIHJldHVybiB4WzBdXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKCh4IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8IHR5cGVvZiB4ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gMjQ3XG4gIGVsc2UgaWYgKHggJiYgeC5jYW1sX2N1c3RvbSlcbiAgICByZXR1cm4gMjU1XG4gIGVsc2VcbiAgICByZXR1cm4gMTAwMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfdGFnIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF90YWcgKHgsIHRhZykgeyB4WzBdID0gdGFnOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9vYmpfYmxvY2sgY29uc3QgKGNvbnN0LGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfYmxvY2sgKHRhZywgc2l6ZSkge1xuICB2YXIgbyA9IG5ldyBBcnJheShzaXplKzEpO1xuICBvWzBdPXRhZztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc2l6ZTsgaSsrKSBvW2ldID0gMDtcbiAgcmV0dXJuIG87XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3dpdGhfdGFnXG5mdW5jdGlvbiBjYW1sX29ial93aXRoX3RhZyh0YWcseCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IHRhZztcbiAgZm9yKHZhciBpID0gMTsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfZHVwIG11dGFibGUgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX29ial9kdXAgKHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RydW5jYXRlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9vYmpfdHJ1bmNhdGUgKHgsIHMpIHtcbiAgaWYgKHM8PTAgfHwgcyArIDEgPiB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiT2JqLnRydW5jYXRlXCIpO1xuICBpZiAoeC5sZW5ndGggIT0gcyArIDEpIHgubGVuZ3RoID0gcyArIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9tYWtlX2ZvcndhcmRcbmZ1bmN0aW9uIGNhbWxfb2JqX21ha2VfZm9yd2FyZCAoYix2KSB7XG4gIGJbMF09MjUwO1xuICBiWzFdPXY7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXBcbmZ1bmN0aW9uIGNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXAoeCxpLG9sZCxuKXtcbiAgaWYoeFtpKzFdID09IG9sZCkge1xuICAgIHhbaSsxXSA9IG47XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfc2hhcmVkXG5mdW5jdGlvbiBjYW1sX29ial9pc19zaGFyZWQoeCl7XG4gIHJldHVybiAxXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgY29uc3QgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkICh2KSB7IHJldHVybiBbMjUwLCB2XTsgfVxuXG4vLy8vLy8vLy8vLy8vIENhbWxpbnRlcm5hbE9PXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIGNvbnN0XG52YXIgY2FtbF9tZXRob2RfY2FjaGUgPSBbXTtcbmZ1bmN0aW9uIGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgKG9iaiwgdGFnLCBjYWNoZWlkKSB7XG4gIHZhciBtZXRocyA9IG9ialsxXTtcbiAgdmFyIG9mcyA9IGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdO1xuICBpZiAob2ZzID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycmF5IGlzIG5vdCBzcGFyc2VcbiAgICBmb3IgKHZhciBpID0gY2FtbF9tZXRob2RfY2FjaGUubGVuZ3RoOyBpIDwgY2FjaGVpZDsgaSsrKVxuICAgICAgY2FtbF9tZXRob2RfY2FjaGVbaV0gPSAwO1xuICB9IGVsc2UgaWYgKG1ldGhzW29mc10gPT09IHRhZykge1xuICAgIHJldHVybiBtZXRoc1tvZnMgLSAxXTtcbiAgfVxuICB2YXIgbGkgPSAzLCBoaSA9IG1ldGhzWzFdICogMiArIDEsIG1pO1xuICB3aGlsZSAobGkgPCBoaSkge1xuICAgIG1pID0gKChsaStoaSkgPj4gMSkgfCAxO1xuICAgIGlmICh0YWcgPCBtZXRoc1ttaSsxXSkgaGkgPSBtaS0yO1xuICAgIGVsc2UgbGkgPSBtaTtcbiAgfVxuICBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXSA9IGxpICsgMTtcbiAgLyogcmV0dXJuIDAgaWYgdGFnIGlzIG5vdCB0aGVyZSAqL1xuICByZXR1cm4gKHRhZyA9PSBtZXRoc1tsaSsxXSA/IG1ldGhzW2xpXSA6IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29vX2xhc3RfaWRcbnZhciBjYW1sX29vX2xhc3RfaWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX3NldF9vb19pZCAoYikge1xuICBiWzJdPWNhbWxfb29fbGFzdF9pZCsrO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mcmVzaF9vb19pZCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX2ZyZXNoX29vX2lkKCkge1xuICByZXR1cm4gY2FtbF9vb19sYXN0X2lkKys7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfcmF3X2ZpZWxkKG8saSkgeyByZXR1cm4gb1tpKzFdIH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3Jhd19maWVsZChvLGksdikgeyByZXR1cm4gb1tpKzFdID0gdiB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1xuZnVuY3Rpb24gY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzKG8pIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfYWRkX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9vYmpfYWRkX29mZnNldCh2LG9mZnNldCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiT2JqLmFkZF9vZmZzZXQgaXMgbm90IHN1cHBvcnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdXBkYXRlX3RhZ1xuZnVuY3Rpb24gY2FtbF9vYmpfdXBkYXRlX3RhZyhiLG8sbikge1xuICAgIGlmKGJbMF09PW8pIHsgYlswXSA9IG47IHJldHVybiAxIH1cbiAgICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcmNpbmdcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3VwZGF0ZV90YWdcbmZ1bmN0aW9uIGNhbWxfbGF6eV91cGRhdGVfdG9fZm9yY2luZyhvKSB7XG4gIGlmICgobyBpbnN0YW5jZW9mIEFycmF5KSAmJiBvWzBdID09IChvWzBdID4+PiAwKSAmJlxuICAgICAgY2FtbF9vYmpfdXBkYXRlX3RhZyhvLCAyNDYsIDI0NCkpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcndhcmRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3VwZGF0ZV90YWdcbiAgZnVuY3Rpb24gY2FtbF9sYXp5X3VwZGF0ZV90b19mb3J3YXJkKG8pIHtcbiAgY2FtbF9vYmpfdXBkYXRlX3RhZyhvLDI0NCwyNTApO1xuICByZXR1cm4gMDsgLy8gdW5pdFxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9yZXNldF90b19sYXp5XG4vL1JlcXVpcmVzOiBjYW1sX29ial91cGRhdGVfdGFnXG5mdW5jdGlvbiBjYW1sX2xhenlfcmVzZXRfdG9fbGF6eShvKSB7XG4gIGNhbWxfb2JqX3VwZGF0ZV90YWcobywyNDQsMjQ2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9yZWFkX3Jlc3VsdFxuLy9SZXF1aXJlczogY2FtbF9vYmpfdGFnXG5mdW5jdGlvbiBjYW1sX2xhenlfcmVhZF9yZXN1bHQobykge1xuICByZXR1cm4gKGNhbWxfb2JqX3RhZyhvKSA9PSAyNTApP29bMV06bztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbi8vVmVyc2lvbjogPCA1XG5mdW5jdGlvbiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19jb250aW51YXRpb25fdGFnXG4vL1ZlcnNpb246ID49IDVcbmZ1bmN0aW9uIGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh0KSB7XG4gIHJldHVybiAodCA9PSAyNDUpID8gMSA6IDA7XG59XG4iLCIvKlxuVG8gZGVhbCB3aXRoIGVmZmVjdHMsIHRoZSBleGVjdXRpb24gY29udGV4dCBpcyBpbnR1aXRpdmVseSBjb21wb3NlZCBvZlxuYSBzdGFjayBvZiBmaWJlcnMuIEVhY2ggZmliZXIgaGFzIGEgY3VycmVudCBsb3ctbGV2ZWwgY29udGludWF0aW9uXG4ob25lLWFyZ3VtZW50IEphdmFTY3JpcHQgZnVuY3Rpb24pLCBhIHN0YWNrIG9mIGV4Y2VwdGlvbiBoYW5kbGVycyBhbmRcbmEgdHJpcGxlIG9mIGhhbmRsZXJzLCB3aGljaCBhcmUgaW52b2tlZCB3aGVuIHRoZSBmaWJlciB0ZXJtaW5hdGVzXG4oZWl0aGVyIHdpdGggYSB2YWx1ZSBvciBhbiBleGNlcHRpb24pIG9yIHdoZW4gYW4gZWZmZWN0IGlzIHBlcmZvcm1lZC5cblRoZSBsb3ctbGV2ZWwgY29udGludWF0aW9uIG9mIHRoZSB0b3Btb3N0IGZpYmVyICh3aGljaCBpcyBjdXJyZW50bHlcbmV4ZWN1dGluZykgaXMgcGFzc2VkIGZyb20gZnVuY3Rpb24gdG8gZnVuY3Rpb24gYXMgYW4gYWRkaXRpb25hbFxuYXJndW1lbnQuIEl0cyBzdGFjayBvZiBleGNlcHRpb24gaGFuZGxlcnMgaXMgc3RvcmVkIGluXG5bY2FtbF9leG5fc3RhY2tdLiBFeGNlcHRpb24gaGFuZGxlcnMgYXJlIHB1c2hlZCBpbnRvIHRoaXMgc3RhY2sgd2hlblxuZW50ZXJpbmcgYSBbdHJ5IC4uLiB3aXRoIC4uLl0gYW5kIHBvcHBlZCBvbiBleGl0LiBUaGVuLCBoYW5kbGVycyBhbmRcbnRoZSByZW1haW5pbmcgZmliZXJzIGFyZSBzdG9yZWQgaW4gW2NhbWxfZmliZXJfc3RhY2tdLiBUbyBpbnN0YWxsIGFuXG5lZmZlY3QgaGFuZGxlciwgd2UgcHVzaCBhIG5ldyBmaWJlciBpbnRvIHRoZSBleGVjdXRpb24gY29udGV4dC5cblxuV2UgaGF2ZSBiYXNpY2FsbHkgdGhlIGZvbGxvd2luZyB0eXBlIGZvciByZWlmaWVkIGNvbnRpbnVhdGlvbnMgKHR5cGVcbltjb250aW51YXRpb25dIGluIG1vZHVsZSBbRWZmZWN0XSBvZiB0aGUgc3RhbmRhcmQgbGlicmFyeSk6XG5cbiAgdHlwZSAoJ2EsICdiKSBjb250aW51YXRpb24gPSAoJ2EsICdiKSBzdGFjayByZWZcblxuICBhbmQgKF8sIF8pIHN0YWNrID1cbiAgICAgIENvbnMgOiAoJ2IgLT4gdW5pdCkgKiAgICAgICAgICAgICAoKiBsb3ctbGV2ZWwgY29udGludWF0aW9uICopXG4gICAgICAgICAgICAgKGV4biAtPiB1bml0KSBsaXN0ICogICAgICAgKCogZXhjZXB0aW9uIGhhbmRsZXJzICopXG4gICAgICAgICAgICAgKCdiLCAnYykgaGFuZGxlciAqXG4gICAgICAgICAgICAgKCdhLCAnYikgc3RhY2tcbiAgICAgICAgICAgICAtPiAoJ2EsICdjKSBzdGFja1xuICAgIHwgRW1wdHkgOiAoJ2EsICdhKSBzdGFja1xuXG4gIGFuZCAoJ2EsJ2IpIGhhbmRsZXIgPSAgICgqIEFzIGluIG1vZHVsZSBFZmZlY3QgZnJvbSB0aGUgc3RhbmRhcmQgbGlicmFyeSAqKVxuICAgIHsgcmV0YzogJ2EgLT4gJ2I7XG4gICAgICBleG5jOiBleG4gLT4gJ2I7XG4gICAgICBlZmZjOiAnYy4nYyBFZmZlY3QudCAtPiAoKCdjLCdiKSBjb250aW51YXRpb24gLT4gJ2IpIG9wdGlvbiB9XG5cbkNvbnRpbnVhdGlvbnMgYXJlIG9uZS1zaG90LiBBIGNvbnRpbnVhdGlvbiBbcmVmIEVtcHR5XSBoYXMgYWxyZWFkeVxuYmVlbiByZXN1bWVkLlxuXG5BIGNvbnRpbnVhdGlvbiBpcyBiYXNpY2FsbHkgY29tcG9zZWQgb2YgYSBsaXN0IG9mIGZpYmVycywgd2hpY2ggZWFjaFxuaGFzIGl0cyBsb3ctbGV2ZWwgY29udGludWF0aW9uLCBpdHMgc3RhY2sgb2YgZXhjZXB0aW9uIGhhbmRsZXJzIGFuZCBhXG50cmlwbGUgb2YgaGFuZGxlcnMgdG8gZGVhbCB3aXRoIHdoZW4gdGhlIGZpYmVyIHRlcm1pbmF0ZXMgb3IgYW5cbmVmZmVjdCBpcyBwZXJmb3JtZWQuIFdoZW4gcmVzdW1pbmcgYSBjb250aW51YXRpb24sIHRoZSBpbm5lcm1vc3QgZmliZXJcbmlzIHJlc3VtZWQgZmlyc3QuXG5cblRoZSBoYW5kbGVycyBhcmUgQ1BTLXRyYW5zZm9ybWVkIGZ1bmN0aW9uczogdGhleSBhY3R1YWxseSB0YWtlIGFuXG5hZGRpdGlvbmFsIHBhcmFtZXRlciB3aGljaCBpcyB0aGUgY3VycmVudCBsb3ctbGV2ZWwgY29udGludWF0aW9uLlxuKi9cblxuLy9Qcm92aWRlczogY2FtbF9leG5fc3RhY2tcbi8vSWY6IGVmZmVjdHNcbi8vIFRoaXMgaXMgYW4gT0NhbWwgbGlzdCBvZiBleGNlcHRpb24gaGFuZGxlcnNcbnZhciBjYW1sX2V4bl9zdGFjayA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfcHVzaF90cmFwXG4vL1JlcXVpcmVzOiBjYW1sX2V4bl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9wdXNoX3RyYXAoaGFuZGxlcikge1xuICBjYW1sX2V4bl9zdGFjaz1bMCxoYW5kbGVyLGNhbWxfZXhuX3N0YWNrXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3BfdHJhcFxuLy9SZXF1aXJlczogY2FtbF9leG5fc3RhY2tcbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfcG9wX3RyYXAoKSB7XG4gIGlmICghY2FtbF9leG5fc3RhY2spIHJldHVybiBmdW5jdGlvbih4KXt0aHJvdyB4O31cbiAgdmFyIGggPSBjYW1sX2V4bl9zdGFja1sxXTtcbiAgY2FtbF9leG5fc3RhY2s9Y2FtbF9leG5fc3RhY2tbMl07XG4gIHJldHVybiBoXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmliZXJfc3RhY2tcbi8vSWY6IGVmZmVjdHNcbi8vIFRoaXMgaGFzIHRoZSBzaGFwZSB7aCwgcjp7aywgeCwgZX19IHdoZXJlIGggaXMgYSB0cmlwbGUgb2YgaGFuZGxlcnNcbi8vIChzZWUgZWZmZWN0LmpzKSBhbmQgaywgeCBhbmQgZSBhcmUgdGhlIHNhdmVkIGNvbnRpbnVhdGlvbixcbi8vIGV4Y2VwdGlvbiBzdGFjayBhbmQgZmliZXIgc3RhY2sgb2YgdGhlIHBhcmVudCBmaWJlci5cbnZhciBjYW1sX2ZpYmVyX3N0YWNrO1xuXG4vL1Byb3ZpZGVzOmNhbWxfcmVzdW1lX3N0YWNrXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9yZXN1bWVfc3RhY2soc3RhY2ssIGspIHtcbiAgaWYgKCFzdGFjaykgY2FtbF9yYWlzZV9jb25zdGFudFxuICAgICAgICAgICAgICAgICAoY2FtbF9uYW1lZF92YWx1ZShcIkVmZmVjdC5Db250aW51YXRpb25fYWxyZWFkeV9yZXN1bWVkXCIpKTtcbiAgLy8gVXBkYXRlIHRoZSBleGVjdXRpb24gY29udGV4dCB3aXRoIHRoZSBzdGFjayBvZiBmaWJlcnMgaW4gW3N0YWNrXSBpblxuICAvLyBvcmRlciB0byByZXN1bWUgdGhlIGNvbnRpbnVhdGlvblxuICBkbyB7XG4gICAgY2FtbF9maWJlcl9zdGFjayA9XG4gICAgICB7aDpzdGFja1szXSwgcjp7azprLCB4OmNhbWxfZXhuX3N0YWNrLCBlOmNhbWxfZmliZXJfc3RhY2t9fTtcbiAgICBrID0gc3RhY2tbMV07XG4gICAgY2FtbF9leG5fc3RhY2sgPSBzdGFja1syXTtcbiAgICBzdGFjayA9IHN0YWNrWzRdO1xuICB9IHdoaWxlIChzdGFjaylcbiAgcmV0dXJuIGs7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcG9wX2ZpYmVyXG4vL1JlcXVpcmVzOiBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9wb3BfZmliZXIoKSB7XG4gIC8vIE1vdmUgdG8gdGhlIHBhcmVudCBmaWJlciwgcmV0dXJuaW5nIHRoZSBwYXJlbnQncyBsb3ctbGV2ZWwgY29udGludWF0aW9uXG4gIHZhciByZW0gPSBjYW1sX2ZpYmVyX3N0YWNrLnI7XG4gIGNhbWxfZXhuX3N0YWNrID0gcmVtLng7XG4gIGNhbWxfZmliZXJfc3RhY2sgPSByZW0uZTtcbiAgcmV0dXJuIHJlbS5rO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BlcmZvcm1fZWZmZWN0XG4vL1JlcXVpcmVzOiBjYW1sX3BvcF9maWJlciwgY2FtbF9zdGFja19jaGVja19kZXB0aCwgY2FtbF90cmFtcG9saW5lX3JldHVybiwgY2FtbF9leG5fc3RhY2ssIGNhbWxfZmliZXJfc3RhY2tcbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfcGVyZm9ybV9lZmZlY3QoZWZmLCBjb250LCBrMCkge1xuICAvLyBBbGxvY2F0ZSBhIGNvbnRpbnVhdGlvbiBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICghY29udCkgY29udCA9IFsyNDUgLypjb250aW51YXRpb24qLywgMF07XG4gIC8vIEdldCBjdXJyZW50IGVmZmVjdCBoYW5kbGVyXG4gIHZhciBoYW5kbGVyID0gY2FtbF9maWJlcl9zdGFjay5oWzNdO1xuICAvLyBDb25zIHRoZSBjdXJyZW50IGZpYmVyIG9udG8gdGhlIGNvbnRpbnVhdGlvbjpcbiAgLy8gICBjb250IDo9IENvbnMgKGssIGV4bl9zdGFjaywgaGFuZGxlcnMsICFjb250KVxuICBjb250WzFdID0gWzAsazAsY2FtbF9leG5fc3RhY2ssY2FtbF9maWJlcl9zdGFjay5oLGNvbnRbMV1dO1xuICAvLyBNb3ZlIHRvIHBhcmVudCBmaWJlciBhbmQgZXhlY3V0ZSB0aGUgZWZmZWN0IGhhbmRsZXIgdGhlcmVcbiAgLy8gVGhlIGhhbmRsZXIgaXMgZGVmaW5lZCBpbiBTdGRsaWIuRWZmZWN0LCBzbyB3ZSBrbm93IHRoYXQgdGhlIGFyaXR5IG1hdGNoZXNcbiAgdmFyIGsxID0gY2FtbF9wb3BfZmliZXIoKTtcbiAgcmV0dXJuIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKT9oYW5kbGVyKGVmZixjb250LGsxLGsxKVxuICAgICAgICAgOmNhbWxfdHJhbXBvbGluZV9yZXR1cm4oaGFuZGxlcixbZWZmLGNvbnQsazEsazFdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hbGxvY19zdGFja1xuLy9SZXF1aXJlczogY2FtbF9wb3BfZmliZXIsIGNhbWxfZmliZXJfc3RhY2ssIGNhbWxfY2FsbF9nZW4sIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgsIGNhbWxfdHJhbXBvbGluZV9yZXR1cm5cbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfYWxsb2Nfc3RhY2soaHYsIGh4LCBoZikge1xuICBmdW5jdGlvbiBjYWxsKGksIHgpIHtcbiAgICB2YXIgZj1jYW1sX2ZpYmVyX3N0YWNrLmhbaV07XG4gICAgdmFyIGFyZ3MgPSBbeCwgY2FtbF9wb3BfZmliZXIoKV07XG4gICAgcmV0dXJuIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKT9jYW1sX2NhbGxfZ2VuKGYsYXJncylcbiAgICAgICAgICAgOmNhbWxfdHJhbXBvbGluZV9yZXR1cm4oZixhcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBodmFsKHgpIHtcbiAgICAvLyBDYWxsIFtodl0gaW4gdGhlIHBhcmVudCBmaWJlclxuICAgIHJldHVybiBjYWxsKDEsIHgpO1xuICB9XG4gIGZ1bmN0aW9uIGhleG4oZSkge1xuICAgIC8vIENhbGwgW2h4XSBpbiB0aGUgcGFyZW50IGZpYmVyXG4gICAgcmV0dXJuIGNhbGwoMiwgZSk7XG4gIH1cbiAgcmV0dXJuIFswLCBodmFsLCBbMCwgaGV4biwgMF0sIFswLCBodiwgaHgsIGhmXSwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYWxsb2Nfc3RhY2tcbi8vSWY6ICFlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2FsbG9jX3N0YWNrKGh2LCBoeCwgaGYpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Y1xuZnVuY3Rpb24gY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjKGNvbnQpIHtcbiAgdmFyIHN0YWNrPWNvbnRbMV07XG4gIGNvbnRbMV09MDtcbiAgcmV0dXJuIHN0YWNrO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnRpbnVhdGlvbl91c2VfYW5kX3VwZGF0ZV9oYW5kbGVyX25vZXhjXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGNcbmZ1bmN0aW9uIGNhbWxfY29udGludWF0aW9uX3VzZV9hbmRfdXBkYXRlX2hhbmRsZXJfbm9leGMoY29udCwgaHZhbCwgaGV4biwgaGVmZikge1xuICB2YXIgc3RhY2sgPSBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGMoY29udCk7XG4gIHN0YWNrWzNdID0gWzAsIGh2YWwsIGhleG4sIGhlZmZdO1xuICByZXR1cm4gc3RhY2s7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2NvbnRpbnVhdGlvbl9jYWxsc3RhY2tcbmZ1bmN0aW9uIGNhbWxfZ2V0X2NvbnRpbnVhdGlvbl9jYWxsc3RhY2sgKCkgeyByZXR1cm4gWzBdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY29uZGl0aW9uX25ld1xuZnVuY3Rpb24gY2FtbF9tbF9jb25kaXRpb25fbmV3KHVuaXQpe1xuICAgIHJldHVybiB7Y29uZGl0aW9uOjF9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NvbmRpdGlvbl93YWl0XG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl93YWl0KHQsbXV0ZXh0KXtcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fYnJvYWRjYXN0XG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl9icm9hZGNhc3QodCl7XG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY29uZGl0aW9uX3NpZ25hbFxuZnVuY3Rpb24gY2FtbF9tbF9jb25kaXRpb25fc2lnbmFsKHQpe1xuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2VmZmVjdF9ub3Rfc3VwcG9ydGVkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyFJZjogZWZmZWN0c1xuZnVuY3Rpb24ganNvb19lZmZlY3Rfbm90X3N1cHBvcnRlZCgpe1xuICBjYW1sX2ZhaWx3aXRoKFwiRWZmZWN0IGhhbmRsZXJzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBBcnJheVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3N1YiBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X3N1YiAoYSwgaSwgbGVuKSB7XG4gIHZhciBhMiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGEyWzBdPTA7XG4gIGZvcih2YXIgaTIgPSAxLCBpMT0gaSsxOyBpMiA8PSBsZW47IGkyKyssaTErKyApe1xuICAgIGEyW2kyXT1hW2kxXTtcbiAgfVxuICByZXR1cm4gYTI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYXBwZW5kIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMikge1xuICB2YXIgbDEgPSBhMS5sZW5ndGgsIGwyID0gYTIubGVuZ3RoO1xuICB2YXIgbCA9IGwxK2wyLTFcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSAwO1xuICB2YXIgaSA9IDEsaiA9IDE7XG4gIGZvcig7aTxsMTtpKyspIGFbaV09YTFbaV07XG4gIGZvcig7aTxsO2krKyxqKyspIGFbaV09YTJbal07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2NvbmNhdCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2NvbmNhdChsKSB7XG4gIHZhciBhID0gWzBdO1xuICB3aGlsZSAobCAhPT0gMCkge1xuICAgIHZhciBiID0gbFsxXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGIubGVuZ3RoOyBpKyspIGEucHVzaChiW2ldKTtcbiAgICBsID0gbFsyXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vLy8vLy8vLy8vLy8gUGVydmFzaXZlXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3NldCAobXV0YWJsZSwgY29uc3QsIG11dGFibGUpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X3NldCAoYXJyYXksIGluZGV4LCBuZXd2YWwpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBhcnJheVtpbmRleCsxXT1uZXd2YWw7IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2dldCBtdXRhYmxlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZ2V0IChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXlbaW5kZXgrMV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZmlsbFxuZnVuY3Rpb24gY2FtbF9hcnJheV9maWxsKGFycmF5LCBvZnMsIGxlbiwgdil7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgYXJyYXlbb2ZzK2krMV0gPSB2O1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoZWNrX2JvdW5kIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoaW5kZXggPj4+IDAgPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV92ZWN0IGNvbnN0IChjb25zdCwgbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV92ZWN0IChsZW4sIGluaXQpIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSBpbml0O1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX2Zsb2F0X3ZlY3QgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX2Zsb2F0X3ZlY3QobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9jcmVhdGUobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4iLCIvL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9kbHNcbnZhciBjYW1sX2RvbWFpbl9kbHMgPSBbMF07XG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2Rsc19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2Rsc1xuZnVuY3Rpb24gY2FtbF9kb21haW5fZGxzX3NldChhKSB7XG4gIGNhbWxfZG9tYWluX2RscyA9IGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2Rsc19jb21wYXJlX2FuZF9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2Rsc1xuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX2Rsc19jb21wYXJlX2FuZF9zZXQob2xkLG4pIHtcbiAgaWYoY2FtbF9kb21haW5fZGxzICE9PSBvbGQpIHJldHVybiAwXG4gIGNhbWxfZG9tYWluX2RscyA9IG47XG4gIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9kbHNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9kbHNcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX2Rsc19nZXQodW5pdCkge1xuICByZXR1cm4gY2FtbF9kb21haW5fZGxzO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2xvYWRcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2xvYWQocmVmKXtcbiAgcmV0dXJuIHJlZlsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfY2FzXG5mdW5jdGlvbiBjYW1sX2F0b21pY19jYXMocmVmLG8sbikge1xuICBpZihyZWZbMV0gPT09IG8pe1xuICAgIHJlZlsxXSA9IG47XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2ZldGNoX2FkZFxuZnVuY3Rpb24gY2FtbF9hdG9taWNfZmV0Y2hfYWRkKHJlZiwgaSkge1xuICB2YXIgb2xkID0gcmVmWzFdO1xuICByZWZbMV0gKz0gaTtcbiAgcmV0dXJuIG9sZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfZXhjaGFuZ2VcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2V4Y2hhbmdlKHJlZiwgdikge1xuICB2YXIgciA9IHJlZlsxXTtcbiAgcmVmWzFdID0gdjtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX21ha2VfY29udGVuZGVkXG5mdW5jdGlvbiBjYW1sX2F0b21pY19tYWtlX2NvbnRlbmRlZChhKSB7XG4gIHJldHVybiBbMCwgYV1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuXG4vL1ZlcnNpb246IDwgNS4yXG52YXIgY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuXyA9IFswXVxuZnVuY3Rpb24gY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuKHVuaXQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlbl9cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RvbWFpbl9zZXRfbmFtZVxuZnVuY3Rpb24gY2FtbF9tbF9kb21haW5fc2V0X25hbWUoX25hbWUpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb21tZW5kZWRfZG9tYWluX2NvdW50XG5mdW5jdGlvbiBjYW1sX3JlY29tbWVuZGVkX2RvbWFpbl9jb3VudCh1bml0KSB7IHJldHVybiAxIH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9pZFxudmFyIGNhbWxfZG9tYWluX2lkID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9kb21haW5fc3Bhd25cbi8vUmVxdWlyZXM6IGNhbWxfbWxfbXV0ZXhfdW5sb2NrXG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9pZFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuLy9WZXJzaW9uOiA+PSA1LjJcbnZhciBjYW1sX2RvbWFpbl9sYXRlc3RfaWR4ID0gMVxuZnVuY3Rpb24gY2FtbF9kb21haW5fc3Bhd24oZix0ZXJtX3N5bmMpe1xuICAgIHZhciBpZCA9IGNhbWxfZG9tYWluX2xhdGVzdF9pZHgrKztcbiAgICB2YXIgb2xkID0gY2FtbF9kb21haW5faWQ7XG4gICAgY2FtbF9kb21haW5faWQgPSBpZDtcbiAgICB2YXIgcmVzID0gY2FtbF9jYWxsYmFjayhmLFswXSk7XG4gICAgY2FtbF9kb21haW5faWQgPSBvbGQ7XG4gICAgY2FtbF9tbF9tdXRleF91bmxvY2sodGVybV9zeW5jWzJdKTtcbiAgICAvL1RPRE86IGZpeCBleG4gY2FzZVxuICAgIHRlcm1fc3luY1sxXSA9IFswLCBbMCwgcmVzXV07XG4gICAgcmV0dXJuIGlkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9zcGF3blxuLy9SZXF1aXJlczogY2FtbF9tbF9tdXRleF91bmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2lkXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG4vL1ZlcnNpb246IDwgNS4yXG52YXIgY2FtbF9kb21haW5fbGF0ZXN0X2lkeCA9IDFcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX3NwYXduKGYsbXV0ZXgpe1xuICAgIHZhciBpZCA9IGNhbWxfZG9tYWluX2xhdGVzdF9pZHgrKztcbiAgICB2YXIgb2xkID0gY2FtbF9kb21haW5faWQ7XG4gICAgY2FtbF9kb21haW5faWQgPSBpZDtcbiAgICB2YXIgcmVzID0gY2FtbF9jYWxsYmFjayhmLFswXSk7XG4gICAgY2FtbF9kb21haW5faWQgPSBvbGQ7XG4gICAgY2FtbF9tbF9tdXRleF91bmxvY2sobXV0ZXgpO1xuICAgIHJldHVybiBpZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RvbWFpbl9pZFxuLy9SZXF1aXJlczogY2FtbF9kb21haW5faWRcbmZ1bmN0aW9uIGNhbWxfbWxfZG9tYWluX2lkKHVuaXQpe1xuICAgIHJldHVybiBjYW1sX2RvbWFpbl9pZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RvbWFpbl9jcHVfcmVsYXhcbmZ1bmN0aW9uIGNhbWxfbWxfZG9tYWluX2NwdV9yZWxheCh1bml0KXtcbiAgICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2ludCBjb25zdCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcsIGNhbWxfc3RyX3JlcGVhdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfaW50KGZtdCwgaSkge1xuICBpZiAoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpID09IFwiJWRcIikgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIitpKTtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoaSA8IDApIHsgaWYgKGYuc2lnbmVkY29udikgeyBmLnNpZ24gPSAtMTsgaSA9IC1pOyB9IGVsc2UgaSA+Pj49IDA7IH1cbiAgdmFyIHMgPSBpLnRvU3RyaW5nKGYuYmFzZSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gcy5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBzID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgcztcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocykge1xuICB2YXIgaSA9IDAsIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSwgYmFzZSA9IDEwLCBzaWduID0gMTtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKSkge1xuICAgIGNhc2UgNDU6IGkrKzsgc2lnbiA9IC0xOyBicmVhaztcbiAgICBjYXNlIDQzOiBpKys7IHNpZ24gPSAxOyBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGkgKyAxIDwgbGVuICYmIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSkgPT0gNDgpXG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyAxKSkge1xuICAgIGNhc2UgMTIwOiBjYXNlIDg4OiBiYXNlID0gMTY7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTE6IGNhc2UgNzk6IGJhc2UgPSAgODsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlICA5ODogY2FzZSA2NjogYmFzZSA9ICAyOyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTE3OiBjYXNlIDg1OiBpICs9IDI7IGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIFtpLCBzaWduLCBiYXNlXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9kaWdpdFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9kaWdpdChjKSB7XG4gIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpICByZXR1cm4gYyAtIDQ4O1xuICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSAgcmV0dXJuIGMgLSA1NTtcbiAgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMjIpIHJldHVybiBjIC0gODc7XG4gIHJldHVybiAtMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX3BhcnNlX2RpZ2l0LCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2ludF9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIHRocmVzaG9sZCA9IC0xID4+PiAwO1xuICB2YXIgYyA9IChpIDwgbGVuKT9jYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpOjA7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBkO1xuICBmb3IgKGkrKztpPGxlbjtpKyspIHtcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgcmVzID0gYmFzZSAqIHJlcyArIGQ7XG4gICAgaWYgKHJlcyA+IHRocmVzaG9sZCkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgLy8gRm9yIGJhc2UgZGlmZmVyZW50IGZyb20gMTAsIHdlIGV4cGVjdCBhbiB1bnNpZ25lZCByZXByZXNlbnRhdGlvbixcbiAgLy8gaGVuY2UgYW55IHZhbHVlIG9mICdyZXMnIChsZXNzIHRoYW4gJ3RocmVzaG9sZCcpIGlzIGFjY2VwdGFibGUuXG4gIC8vIEJ1dCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIHRvIGEgc2lnbmVkIGludGVnZXIuXG4gIHJlcyA9IHNpZ24gKiByZXM7XG4gIGlmICgoYmFzZSA9PSAxMCkgJiYgKChyZXMgfCAwKSAhPSByZXMpKVxuICAgIC8qIFNpZ25lZCByZXByZXNlbnRhdGlvbiBleHBlY3RlZCwgYWxsb3cgLTJeKG5iaXRzLTEpIHRvIDJeKG5iaXRzLTEpIC0gMSAqL1xuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tdWwgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbXVsKGEsYil7XG4gIHJldHVybiBNYXRoLmltdWwoYSxiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kaXZcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfZGl2KHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4gKHgveSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfbW9kKHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4geCV5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Jzd2FwMTZcbmZ1bmN0aW9uIGNhbWxfYnN3YXAxNih4KSB7XG4gIHJldHVybiAoKCgoeCAmIDB4MDBGRikgPDwgOCkgfFxuICAgICAgICAgICAoKHggJiAweEZGMDApID4+IDgpKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Jzd2FwXG5mdW5jdGlvbiBjYW1sX2ludDMyX2Jzd2FwKHgpIHtcbiAgcmV0dXJuICgoKHggJiAweDAwMDAwMEZGKSA8PCAyNCkgfFxuICAgICAgICAgICgoeCAmIDB4MDAwMEZGMDApIDw8IDgpIHxcbiAgICAgICAgICAoKHggJiAweDAwRkYwMDAwKSA+Pj4gOCkgfFxuICAgICAgICAgICgoeCAmIDB4RkYwMDAwMDApID4+PiAyNCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9ic3dhcFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9ic3dhcCh4KSB7XG4gIHZhciB5ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh4KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW3lbN10sIHlbNl0sIHlbNV0sIHlbNF0sIHlbM10sIHlbMl0sIHlbMV0sIHlbMF1dKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSGFzaHRibFxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF91bml2X3BhcmFtIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2NvbnRlbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9WZXJzaW9uOiA8IDQuMTJcbmZ1bmN0aW9uIGNhbWxfaGFzaF91bml2X3BhcmFtIChjb3VudCwgbGltaXQsIG9iaikge1xuICB2YXIgaGFzaF9hY2N1ID0gMDtcbiAgZnVuY3Rpb24gaGFzaF9hdXggKG9iaikge1xuICAgIGxpbWl0IC0tO1xuICAgIGlmIChjb3VudCA8IDAgfHwgbGltaXQgPCAwKSByZXR1cm47XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5ICYmIG9ialswXSA9PT0gKG9ialswXXwwKSkge1xuICAgICAgc3dpdGNoIChvYmpbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9ialsyXSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIGxpbWl0Kys7IGhhc2hfYXV4KG9iaik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIG9ialswXSkgfCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gb2JqLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIGhhc2hfYXV4IChvYmpbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyhvYmopKSB7XG4gICAgICBjb3VudCAtLTtcbiAgICAgIHZhciBjb250ZW50ID0gY2FtbF9tbF9ieXRlc19jb250ZW50KG9iaik7XG4gICAgICBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBmb3IgKHZhciBiID0gY29udGVudCwgbCA9IGIubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgIH0gZWxzZSB7IC8qIEFSUkFZICovXG4gICAgICAgIGZvciAodmFyIGEgPSBjb250ZW50LCBsID0gYS5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGFbaV0pIHwgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKG9iaikpIHtcbiAgICAgIHZhciBqc2J5dGVzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhvYmopO1xuICAgICAgZm9yICh2YXIgYiA9IGpzYnl0ZXMsIGwgPSBqc2J5dGVzLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZm9yICh2YXIgYiA9IG9iaiwgbCA9IG9iai5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gKG9ianwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgY291bnQgLS07XG4gICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmopIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gK29iaikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGNvdW50LS07XG4gICAgICB2YXIgcCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAob2JqKSk7XG4gICAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyBpLS0pIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIHBbaV0pIHwgMDtcbiAgICB9IGVsc2UgaWYob2JqICYmIG9iai5jYW1sX2N1c3RvbSkge1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaCA9IGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gob2JqKSB8IDA7XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIGgpIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzaF9hdXggKG9iaik7XG4gIHJldHVybiBoYXNoX2FjY3UgJiAweDNGRkZGRkZGO1xufVxuXG4vL2Z1bmN0aW9uIFJPVEwzMih4LG4pIHsgcmV0dXJuICgoeCA8PCBuKSB8ICh4ID4+PiAoMzItbikpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludChoLGQpIHtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4Y2M5ZTJkNTF8MCk7XG4gIGQgPSAoKGQgPDwgMTUpIHwgKGQgPj4+ICgzMi0xNSkpKTsgLy8gUk9UTDMyKGQsIDE1KTtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4MWI4NzM1OTMpO1xuICBoIF49IGQ7XG4gIGggPSAoKGggPDwgMTMpIHwgKGggPj4+ICgzMi0xMykpKTsgICAvL1JPVEwzMihoLCAxMyk7XG4gIHJldHVybiAoKChoICsgKGggPDwgMikpfDApICsgKDB4ZTY1NDZiNjR8MCkpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpIHtcbiAgaCBePSBoID4+PiAxNjtcbiAgaCA9IGNhbWxfbXVsIChoLCAweDg1ZWJjYTZifDApO1xuICBoIF49IGggPj4+IDEzO1xuICBoID0gY2FtbF9tdWwgKGgsIDB4YzJiMmFlMzV8MCk7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaGFzaF9taXhfaW50NjRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmxvYXQgKGgsIHYwKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2ludDY0KGgsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAodjApKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2xvMzIsIGNhbWxfaW50NjRfaGkzMlxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQ2NCAoaCwgdikge1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9sbzMyKHYpKTtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfaGkzMih2KSk7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHMuY2hhckNvZGVBdChpKVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgOClcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzIpIDw8IDE2KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMykgPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHMuY2hhckNvZGVBdChpKzEpIDw8IDg7XG4gIGNhc2UgMTpcbiAgICB3IHw9IHMuY2hhckNvZGVBdChpKTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzW2ldXG4gICAgICB8IChzW2krMV0gPDwgOClcbiAgICAgIHwgKHNbaSsyXSA8PCAxNilcbiAgICAgIHwgKHNbaSszXSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHNbaSsyXSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHNbaSsxXSA8PCA4O1xuICBjYXNlIDE6IHcgfD0gc1tpXTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2NvbnRlbnRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXMoaCwgdikge1xuICB2YXIgY29udGVudCA9IGNhbWxfbWxfYnl0ZXNfY29udGVudCh2KTtcbiAgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBjb250ZW50KVxuICBlbHNlIC8qIEFSUkFZICovXG4gICAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIGNvbnRlbnQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLCB2KSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZyh2KSk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9mbG9hdCwgY2FtbF9oYXNoX21peF9zdHJpbmcsIGNhbWxfaGFzaF9taXhfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbmZ1bmN0aW9uIGNhbWxfaGFzaCAoY291bnQsIGxpbWl0LCBzZWVkLCBvYmopIHtcbiAgdmFyIHF1ZXVlLCByZCwgd3IsIHN6LCBudW0sIGgsIHYsIGksIGxlbjtcbiAgc3ogPSBsaW1pdDtcbiAgaWYgKHN6IDwgMCB8fCBzeiA+IDI1Nikgc3ogPSAyNTY7XG4gIG51bSA9IGNvdW50O1xuICBoID0gc2VlZDtcbiAgcXVldWUgPSBbb2JqXTsgcmQgPSAwOyB3ciA9IDE7XG4gIHdoaWxlIChyZCA8IHdyICYmIG51bSA+IDApIHtcbiAgICB2ID0gcXVldWVbcmQrK107XG4gICAgaWYgKHYgJiYgdi5jYW1sX2N1c3RvbSl7XG4gICAgICBpZihjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dLmhhc2gpIHtcbiAgICAgICAgdmFyIGhoID0gY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dLmhhc2godik7XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludCAoaCwgaGgpO1xuICAgICAgICBudW0gLS07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgc3dpdGNoICh2WzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2WzJdKTtcbiAgICAgICAgbnVtLS07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgcXVldWVbLS1yZF0gPSB2WzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmKGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh2WzBdKSkge1xuICAgICAgICAgIC8qIEFsbCBjb250aW51YXRpb25zIGhhc2ggdG8gdGhlIHNhbWUgdmFsdWUsXG4gICAgICAgICAgICAgc2luY2Ugd2UgaGF2ZSBubyBpZGVhIGhvdyB0byBkaXN0aW5ndWlzaCB0aGVtLiAqL1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWcgPSAoKHYubGVuZ3RoIC0gMSkgPDwgMTApIHwgdlswXTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHRhZyk7XG4gICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAod3IgPj0gc3opIGJyZWFrO1xuICAgICAgICAgIHF1ZXVlW3dyKytdID0gdltpXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2J5dGVzKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gKHZ8MCkpIHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2K3YrMSk7XG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCx2KTtcbiAgICAgIG51bS0tO1xuICAgIH1cbiAgfVxuICBoID0gY2FtbF9oYXNoX21peF9maW5hbChoKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ZpbmFsLCBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfaGFzaChoLCB2KXtcbiAgdmFyIGggPSBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLHYpO1xuICB2YXIgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoaCk7XG4gIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSW9cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZmRzXG52YXIgY2FtbF9zeXNfZmRzID0gbmV3IEFycmF5KDMpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jbG9zZVxuLy9SZXF1aXJlczogY2FtbF9zeXNfZmRzXG5mdW5jdGlvbiBjYW1sX3N5c19jbG9zZShmZCkge1xuICB2YXIgZmlsZSA9IGNhbWxfc3lzX2Zkc1tmZF07XG4gIGlmKGZpbGUpIGZpbGUuY2xvc2UoKTtcbiAgZGVsZXRlIGNhbWxfc3lzX2Zkc1tmZF07XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBNbEZha2VGZF9vdXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9SZXF1aXJlczogY2FtbF9zeXNfZmRzXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2ludGVybmFsKGZpbGUsaWR4KSB7XG4gIGlmKGlkeCA9PSB1bmRlZmluZWQpe1xuICAgIGlkeCA9IGNhbWxfc3lzX2Zkcy5sZW5ndGg7XG4gIH1cbiAgY2FtbF9zeXNfZmRzW2lkeF0gPSBmaWxlO1xuICByZXR1cm4gaWR4IHwgMDtcbn1cbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW4gKG5hbWUsIGZsYWdzLCBfcGVybXMpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUoZmxhZ3Mpe1xuICAgIHN3aXRjaChmbGFnc1sxXSl7XG4gICAgY2FzZSAwOiBmLnJkb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAxOiBmLndyb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAyOiBmLmFwcGVuZCA9IDE7YnJlYWs7XG4gICAgY2FzZSAzOiBmLmNyZWF0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA0OiBmLnRydW5jYXRlID0gMTticmVhaztcbiAgICBjYXNlIDU6IGYuZXhjbCA9IDE7IGJyZWFrO1xuICAgIGNhc2UgNjogZi5iaW5hcnkgPSAxO2JyZWFrO1xuICAgIGNhc2UgNzogZi50ZXh0ID0gMTticmVhaztcbiAgICBjYXNlIDg6IGYubm9uYmxvY2sgPSAxO2JyZWFrO1xuICAgIH1cbiAgICBmbGFncz1mbGFnc1syXTtcbiAgfVxuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsZik7XG4gIHJldHVybiBjYW1sX3N5c19vcGVuX2ludGVybmFsIChmaWxlLCB1bmRlZmluZWQpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZmlsZShmZCwgZmxhZ3MpIHtcbiAgICBpZihmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgICByZXR1cm4gY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZShmZCwgZmxhZ3MpO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICByZXR1cm4gbmV3IE1sRmFrZUZkX291dChmZCwgZmxhZ3MpXG4gIH1cbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlKDAse3Jkb25seToxLGFsdG5hbWU6XCIvZGV2L3N0ZGluXCIsaXNDaGFyYWN0ZXJEZXZpY2U6dHJ1ZX0pLCAwKTtcbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlKDEse2J1ZmZlcmVkOjIsd3Jvbmx5OjEsaXNDaGFyYWN0ZXJEZXZpY2U6dHJ1ZX0pLCAxKTtcbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlKDIse2J1ZmZlcmVkOjIsd3Jvbmx5OjEsaXNDaGFyYWN0ZXJEZXZpY2U6dHJ1ZX0pLCAyKTtcbn0pKClcblxuXG4vLyBvY2FtbCBDaGFubmVsc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZShjaGFuaWQsIG5hbWUpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGNoYW4ubmFtZSA9IG5hbWU7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxzXG52YXIgY2FtbF9tbF9jaGFubmVscyA9IG5ldyBBcnJheSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfcmVkaXJlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9yZWRpcmVjdCAoY2FwdHVyZWQsIGludG8pe1xuICB2YXIgdG9fcmVzdG9yZSA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2FwdHVyZWQpO1xuICB2YXIgbmV3XyA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoaW50byk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2FwdHVyZWRdID0gbmV3XzsgLy8gWFhYXG4gIHJldHVybiB0b19yZXN0b3JlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfcmVzdG9yZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3Jlc3RvcmUgKGNhcHR1cmVkLCB0b19yZXN0b3JlKXtcbiAgY2FtbF9tbF9jaGFubmVsc1tjYXB0dXJlZF0gPSB0b19yZXN0b3JlOyAvLyBYWFhcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9nZXQoaWQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbaWRdOyAvLyBYWFhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCAoKSB7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBjID0gMDsgYyA8IGNhbWxfbWxfY2hhbm5lbHMubGVuZ3RoOyBjKyspe1xuICAgIGlmKGNhbWxfbWxfY2hhbm5lbHNbY10gJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vcGVuZWQgJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vdXQpXG4gICAgICBsPVswLGNhbWxfbWxfY2hhbm5lbHNbY10uZmQsbF07XG4gIH1cbiAgcmV0dXJuIGw7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3N5c19mZHNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19vcGVuXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQgKGZkKSB7XG4gIHZhciBmaWxlID0gY2FtbF9zeXNfZmRzW2ZkXTtcbiAgaWYoZmlsZS5mbGFncy5yZG9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgcmVhZG9ubHlcIik7XG4gIHZhciBidWZmZXJlZCA9IChmaWxlLmZsYWdzLmJ1ZmZlcmVkICE9PSB1bmRlZmluZWQpID8gZmlsZS5mbGFncy5idWZmZXJlZCA6IDE7XG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZmlsZSxcbiAgICBvZmZzZXQ6ZmlsZS5mbGFncy5hcHBlbmQ/ZmlsZS5sZW5ndGgoKTowLFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDp0cnVlLFxuICAgIGJ1ZmZlcl9jdXJyOjAsXG4gICAgYnVmZmVyOm5ldyBVaW50OEFycmF5KDY1NTM2KSxcbiAgICBidWZmZXJlZDpidWZmZXJlZFxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9zeXNfZmRzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogY2FtbF9zeXNfb3BlblxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4gKGZkKSAge1xuICB2YXIgZmlsZSA9IGNhbWxfc3lzX2Zkc1tmZF07XG4gIGlmKGZpbGUuZmxhZ3Mud3Jvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHdyaXRlb25seVwiKTtcbiAgdmFyIHJlZmlsbCA9IG51bGw7XG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZmlsZSxcbiAgICBvZmZzZXQ6ZmlsZS5mbGFncy5hcHBlbmQ/ZmlsZS5sZW5ndGgoKTowLFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDogZmFsc2UsXG4gICAgYnVmZmVyX2N1cnI6MCxcbiAgICBidWZmZXJfbWF4OjAsXG4gICAgYnVmZmVyOm5ldyBVaW50OEFycmF5KDY1NTM2KSxcbiAgICByZWZpbGw6cmVmaWxsXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5fd2l0aF9mbGFnc1xuLy9SZXF1aXJlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vVmVyc2lvbjogPj0gNS4xXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbl93aXRoX2ZsYWdzKGZkLCBmbGFncyl7XG4gIHJldHVybiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbihmZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dF93aXRoX2ZsYWdzXG4vL1JlcXVpcmVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcbi8vVmVyc2lvbjogPj0gNS4xXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRfd2l0aF9mbGFncyhmZCwgZmxhZ3Mpe1xuICByZXR1cm4gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0KGZkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbi8vQWxpYXM6IHdpbl9maWxlZGVzY3Jfb2ZfY2hhbm5lbFxuZnVuY3Rpb24gY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3IoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHJldHVybiBjaGFuLmZkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUoY2hhbmlkLG1vZGUpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgY2hhbi5maWxlLmZsYWdzLnRleHQgPSAhbW9kZVxuICBjaGFuLmZpbGUuZmxhZ3MuYmluYXJ5ID0gbW9kZVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pc19iaW5hcnlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfbWxfaXNfYmluYXJ5X21vZGUoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICByZXR1cm4gY2hhbi5maWxlLmZsYWdzLmJpbmFyeVxufVxuXG4vL0lucHV0IGZyb20gaW5fY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsIGNhbWxfbWxfY2hhbm5lbF9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Nsb3NlXG5mdW5jdGlvbiBjYW1sX21sX2Nsb3NlX2NoYW5uZWwgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgaWYoY2hhbi5vcGVuZWQpIHtcbiAgICBjaGFuLm9wZW5lZCA9IGZhbHNlO1xuICAgIGNhbWxfc3lzX2Nsb3NlKGNoYW4uZmQpO1xuICAgIGNoYW4uZmQgPSAtMTtcbiAgICBjaGFuLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHJldHVybiBjaGFuLmZpbGUubGVuZ3RoKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0KGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2hhbi5maWxlLmxlbmd0aCAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dChjaGFuaWQsZikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgY2hhbi5vdXRwdXQgPSAoZnVuY3Rpb24gKHMpIHtmKHMpfSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwoY2hhbmlkLGYpIHtcbiAgY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpLnJlZmlsbCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWZpbGwgKGNoYW4pIHtcbiAgaWYoY2hhbi5yZWZpbGwgIT0gbnVsbCl7XG4gICAgdmFyIHN0ciA9IGNoYW4ucmVmaWxsKCk7XG4gICAgdmFyIHN0cl9hID0gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoc3RyKTtcbiAgICBpZiAoc3RyX2EubGVuZ3RoID09IDApIHtcbiAgICAgIGNoYW4ucmVmaWxsID0gbnVsbFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKGNoYW4uYnVmZmVyLmxlbmd0aCA8IGNoYW4uYnVmZmVyX21heCArIHN0cl9hLmxlbmd0aCl7XG4gICAgICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkoY2hhbi5idWZmZXJfbWF4ICsgc3RyX2EubGVuZ3RoKTtcbiAgICAgICAgYi5zZXQoY2hhbi5idWZmZXIpO1xuICAgICAgICBjaGFuLmJ1ZmZlciA9IGI7XG4gICAgICB9XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoc3RyX2EsY2hhbi5idWZmZXJfbWF4KTtcbiAgICAgIGNoYW4ub2Zmc2V0ICs9IHN0cl9hLmxlbmd0aDtcbiAgICAgIGNoYW4uYnVmZmVyX21heCArPSBzdHJfYS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBucmVhZCA9IGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LCBjaGFuLmJ1ZmZlciwgY2hhbi5idWZmZXJfbWF4LCBjaGFuLmJ1ZmZlci5sZW5ndGggLSBjaGFuLmJ1ZmZlcl9tYXgpO1xuICAgIGNoYW4ub2Zmc2V0ICs9IG5yZWFkO1xuICAgIGNoYW4uYnVmZmVyX21heCArPSBucmVhZDtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0IChjaGFuaWQsIGIsIGksIGwpIHtcbiAgdmFyIGJhID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhiKTtcbiAgcmV0dXJuIGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLCBiYSwgaSwgbClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9iaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9pbnB1dF9ibG9ja1xuLy9SZXF1aXJlczogY2FtbF9iYV90b190eXBlZF9hcnJheVxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9iaWdhcnJheSAoY2hhbmlkLCBiLCBpLCBsKSB7XG4gIHZhciBiYSA9IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoYik7XG4gIHJldHVybiBjYW1sX21sX2lucHV0X2Jsb2NrKGNoYW5pZCwgYmEsIGksIGwpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfYmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfcmVmaWxsLCBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2Jsb2NrIChjaGFuaWQsIGJhLCBpLCBsKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICB2YXIgbiA9IGw7XG4gIHZhciBhdmFpbCA9IGNoYW4uYnVmZmVyX21heCAtIGNoYW4uYnVmZmVyX2N1cnI7XG4gIGlmKGwgPD0gYXZhaWwpIHtcbiAgICBiYS5zZXQoY2hhbi5idWZmZXIuc3ViYXJyYXkoY2hhbi5idWZmZXJfY3VycixjaGFuLmJ1ZmZlcl9jdXJyICsgbCksIGkpO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gbDtcbiAgfVxuICBlbHNlIGlmKGF2YWlsID4gMCkge1xuICAgIGJhLnNldChjaGFuLmJ1ZmZlci5zdWJhcnJheShjaGFuLmJ1ZmZlcl9jdXJyLGNoYW4uYnVmZmVyX2N1cnIgKyBhdmFpbCksIGkpO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gYXZhaWw7XG4gICAgbiA9IGF2YWlsO1xuICB9IGVsc2Uge1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gICAgY2FtbF9yZWZpbGwoY2hhbik7XG4gICAgdmFyIGF2YWlsID0gY2hhbi5idWZmZXJfbWF4IC0gY2hhbi5idWZmZXJfY3VycjtcbiAgICBpZihuID4gYXZhaWwpIG4gPSBhdmFpbDtcbiAgICBiYS5zZXQoY2hhbi5idWZmZXIuc3ViYXJyYXkoY2hhbi5idWZmZXJfY3VycixjaGFuLmJ1ZmZlcl9jdXJyICsgbiksIGkpO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gbjtcbiAgfVxuICByZXR1cm4gbiB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcywgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfcmVmaWxsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemVcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWUgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgdmFyIGhlYWRlciA9IG5ldyBVaW50OEFycmF5KGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSk7XG4gIGZ1bmN0aW9uIGJsb2NrKGJ1ZmZlciwgb2Zmc2V0LCBuKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHdoaWxlKHIgPCBuKXtcbiAgICAgIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KXtcbiAgICAgICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gICAgICAgIGNhbWxfcmVmaWxsKGNoYW4pO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KVxuICAgICAgICBicmVhaztcbiAgICAgIGJ1ZmZlcltvZmZzZXQrcl0gPSBjaGFuLmJ1ZmZlcltjaGFuLmJ1ZmZlcl9jdXJyXTtcbiAgICAgIGNoYW4uYnVmZmVyX2N1cnIrKztcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdmFyIHIgPSBibG9jayhoZWFkZXIsIDAsIGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSk7XG4gIGlmKHIgPT0gMClcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIGVsc2UgaWYgKHIgPCBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB0cnVuY2F0ZWQgb2JqZWN0XCIpO1xuICB2YXIgbGVuID0gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAoY2FtbF9ieXRlc19vZl9hcnJheShoZWFkZXIpLCAwKTtcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbiArIGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSk7XG4gIGJ1Zi5zZXQoaGVhZGVyLDApO1xuICB2YXIgciA9IGJsb2NrKGJ1ZiwgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplLCBsZW4pXG4gIGlmKHIgPCBsZW4pXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB0cnVuY2F0ZWQgb2JqZWN0IFwiICsgciArIFwiICBcIiArIGxlbik7XG4gIHZhciBvZmZzZXQgPSBbMF07XG4gIHZhciByZXMgPSBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShidWYpLCBvZmZzZXQpO1xuICBjaGFuLm9mZnNldCA9IGNoYW4ub2Zmc2V0ICsgb2Zmc2V0WzBdO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX3RvX291dHNpZGVfaGVhcFxuLy9SZXF1aXJlczogY2FtbF9pbnB1dF92YWx1ZVxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV90b19vdXRzaWRlX2hlYXAoYykge1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZShjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0LCBjYW1sX3JlZmlsbFxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9jaGFyIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KXtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgICBjaGFuLmJ1ZmZlcl9tYXggPSAwO1xuICAgIGNhbWxfcmVmaWxsKGNoYW4pO1xuICB9XG4gIGlmIChjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyX21heClcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciByZXMgPSBjaGFuLmJ1ZmZlcltjaGFuLmJ1ZmZlcl9jdXJyXTtcbiAgY2hhbi5idWZmZXJfY3VycisrO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9tbF9pbnB1dF9jaGFyLCBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2ludCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgcmVzID0gKHJlcyA8PCA4KSArIGNhbWxfbWxfaW5wdXRfY2hhcihjaGFuaWQpIHwgMDtcbiAgfVxuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9zZWVrX2luKGNoYW5pZCwgcG9zKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGlmKHBvcyA+PSBjaGFuLm9mZnNldCAtIGNoYW4uYnVmZmVyX21heFxuICAgICAmJiBwb3MgPD0gY2hhbi5vZmZzZXRcbiAgICAgJiYgY2hhbi5maWxlLmZsYWdzLmJpbmFyeSkge1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSBjaGFuLmJ1ZmZlcl9tYXggLSAoY2hhbi5vZmZzZXQgLSBwb3MpO1xuICB9IGVsc2Uge1xuICAgIGNoYW4ub2Zmc2V0ID0gcG9zO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pblxuLy9SZXF1aXJlczogY2FtbF9zZWVrX2luXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW4oY2hhbmlkLHBvcyl7XG4gIHJldHVybiBjYW1sX3NlZWtfaW4oY2hhbmlkLHBvcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9zZWVrX2luXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW5fNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBwb3MgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiBjYW1sX3NlZWtfaW4oY2hhbmlkLCBwb3MpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9wb3NfaW4oY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICByZXR1cm4gY2hhbi5vZmZzZXQgLSAoY2hhbi5idWZmZXJfbWF4IC0gY2hhbi5idWZmZXJfY3VycikgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9wb3NfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luKGNoYW5pZCkge1xuICByZXR1cm4gY2FtbF9wb3NfaW4oY2hhbmlkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfcG9zX2luXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbl82NChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2FtbF9wb3NfaW4oY2hhbmlkKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0LCBjYW1sX3JlZmlsbFxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHZhciBwID0gY2hhbi5idWZmZXJfY3VycjtcbiAgZG8ge1xuICAgIGlmKHAgPj0gY2hhbi5idWZmZXJfbWF4KSB7XG4gICAgICBpZihjaGFuLmJ1ZmZlcl9jdXJyID4gMCkge1xuICAgICAgICBjaGFuLmJ1ZmZlci5zZXQoY2hhbi5idWZmZXIuc3ViYXJyYXkoY2hhbi5idWZmZXJfY3VyciksMCk7XG4gICAgICAgIHAgLT0gY2hhbi5idWZmZXJfY3VycjtcbiAgICAgICAgY2hhbi5idWZmZXJfbWF4IC09IGNoYW4uYnVmZmVyX2N1cnI7XG4gICAgICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgICAgfVxuICAgICAgaWYoY2hhbi5idWZmZXJfbWF4ID49IGNoYW4uYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLShjaGFuLmJ1ZmZlcl9tYXgpIHwgMDtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2X21heCA9IGNoYW4uYnVmZmVyX21heDtcbiAgICAgIGNhbWxfcmVmaWxsIChjaGFuKTtcbiAgICAgIGlmKHByZXZfbWF4ID09IGNoYW4uYnVmZmVyX21heCkge1xuICAgICAgICByZXR1cm4gLShjaGFuLmJ1ZmZlcl9tYXgpIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKGNoYW4uYnVmZmVyW3ArK10gIT0gMTApO1xuICByZXR1cm4gKHAgLSBjaGFuLmJ1ZmZlcl9jdXJyKSB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZmx1c2hcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3QgZmx1c2ggYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgaWYoIWNoYW4uYnVmZmVyIHx8IGNoYW4uYnVmZmVyX2N1cnIgPT0gMCkgcmV0dXJuIDA7XG4gIGlmKGNoYW4ub3V0cHV0KSB7XG4gICAgY2hhbi5vdXRwdXQoY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKGNoYW4uYnVmZmVyLCAwLCBjaGFuLmJ1ZmZlcl9jdXJyKSk7XG4gIH0gZWxzZSB7XG4gICAgY2hhbi5maWxlLndyaXRlKGNoYW4ub2Zmc2V0LCBjaGFuLmJ1ZmZlciwgMCwgY2hhbi5idWZmZXJfY3Vycik7XG4gIH1cbiAgY2hhbi5vZmZzZXQgKz0gY2hhbi5idWZmZXJfY3VycjtcbiAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL291dHB1dCB0byBvdXRfY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF90YVxuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCxjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X3RhKGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3Qgb3V0cHV0IHRvIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIGlmKGNoYW4uYnVmZmVyX2N1cnIgKyBidWZmZXIubGVuZ3RoID4gY2hhbi5idWZmZXIubGVuZ3RoKSB7XG4gICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShjaGFuLmJ1ZmZlcl9jdXJyICsgYnVmZmVyLmxlbmd0aCk7XG4gICAgYi5zZXQoY2hhbi5idWZmZXIpO1xuICAgIGNoYW4uYnVmZmVyID0gYlxuICB9XG4gIHN3aXRjaChjaGFuLmJ1ZmZlcmVkKXtcbiAgY2FzZSAwOiAvLyBVbmJ1ZmZlcmVkXG4gICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlciwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoO1xuICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgYnJlYWtcbiAgY2FzZSAxOiAvLyBCdWZmZXJlZCAodGhlIGRlZmF1bHQpXG4gICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlciwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoO1xuICAgIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXIubGVuZ3RoKVxuICAgICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICBicmVhaztcbiAgY2FzZSAyOiAvLyBCdWZmZXJlZCAob25seSBmb3Igc3Rkb3V0IGFuZCBzdGRlcnIpXG4gICAgdmFyIGlkID0gYnVmZmVyLmxhc3RJbmRleE9mKDEwKVxuICAgIGlmKGlkIDwgMCkge1xuICAgICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlciwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICBpZihjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyLmxlbmd0aClcbiAgICAgICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLnN1YmFycmF5KDAsIGlkICsgMSksIGNoYW4uYnVmZmVyX2N1cnIpO1xuICAgICAgY2hhbi5idWZmZXJfY3VyciArPSBpZCArIDE7XG4gICAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheShpZCArIDEpLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gYnVmZmVyLmxlbmd0aCAtIGlkIC0gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzLCBjYW1sX21sX291dHB1dF90YVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBidWZmZXIgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGJ1ZmZlcik7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF90YShjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5LCBjYW1sX21sX291dHB1dF90YVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYmlnYXJyYXkoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBidWZmZXIgPSBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJ1ZmZlcik7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF90YShjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXQoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKXtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxjYW1sX2J5dGVzX29mX3N0cmluZyhidWZmZXIpLG9mZnNldCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfY2hhciAoY2hhbmlkLGMpIHtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZywgY2FtbF9tbF9vdXRwdXQsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZSAoY2hhbmlkLHYsZmxhZ3MpIHtcbiAgdmFyIHMgPSBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcodiwgZmxhZ3MpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfc2Vla19vdXQoY2hhbmlkLCBwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICBjaGFuLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfc2Vla19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXQoY2hhbmlkLHBvcyl7XG4gIHJldHVybiBjYW1sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfc2Vla19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXRfNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBwb3MgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiBjYW1sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3Nfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0LCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICByZXR1cm4gY2hhbi5vZmZzZXQgKyBjaGFuLmJ1ZmZlcl9jdXJyXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dFxuLy9SZXF1aXJlczogY2FtbF9wb3Nfb3V0XG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX3Bvc19vdXQoY2hhbmlkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX3Bvc19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dF82NChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQgKGNhbWxfcG9zX291dChjaGFuaWQpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2ludCAoY2hhbmlkLGkpIHtcbiAgdmFyIGFyciA9IFsoaT4+MjQpICYgMHhGRiwoaT4+MTYpICYgMHhGRiwoaT4+OCkgJiAweEZGLGkgJiAweEZGIF07XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCw0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pc19idWZmZXJlZFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9pc19idWZmZXJlZChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKS5idWZmZXJlZCA/IDEgOiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2J1ZmZlcmVkXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0LCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NldF9idWZmZXJlZChjaGFuaWQsdikge1xuICBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCkuYnVmZmVyZWQgPSB2O1xuICBpZighdikgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbF90YWdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKXtcbiAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyhhKSkgcmV0dXJuIDI1MjsgLy8gc3RyaW5nX3RhZ1xuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyhhKSkgcmV0dXJuIDEyNTI7IC8vIG9jYW1sIHN0cmluZyAoaWYgZGlmZmVyZW50IGZyb20gYnl0ZXMpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSAmJiBhWzBdID09PSAoYVswXT4+PjApICYmIGFbMF0gPD0gMjU1KSB7XG4gICAgLy8gTG9vayBsaWtlIGFuIG9jYW1sIGJsb2NrXG4gICAgdmFyIHRhZyA9IGFbMF0gfCAwO1xuICAgIC8vIGlnbm9yZSBkb3VibGVfYXJyYXlfdGFnIGJlY2F1c2Ugd2UgY2Fubm90IGFjY3VyYXRlbHkgc2V0XG4gICAgLy8gdGhpcyB0YWcgd2hlbiB3ZSBjcmVhdGUgYW4gYXJyYXkgb2YgZmxvYXQuXG4gICAgcmV0dXJuICh0YWcgPT0gMjU0KT8wOnRhZ1xuICB9XG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBTdHJpbmcpIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiKSByZXR1cm4gMTI1MjA7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIE51bWJlcikgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGEgJiYgYS5jYW1sX2N1c3RvbSkgcmV0dXJuIDEyNTU7IC8vIGxpa2UgY3VzdG9tX3RhZyAoMjU1KVxuICBlbHNlIGlmIChhICYmIGEuY29tcGFyZSkgcmV0dXJuIDEyNTY7IC8vIGxpa2UgY3VzdG9tX3RhZyAoMjU1KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiAxMjQ3OyAvLyBsaWtlIGNsb3N1cmVfdGFnICgyNDcpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3ltYm9sXCIpIHJldHVybiAxMjUxO1xuICByZXR1cm4gMTAwMTsgLy9vdXRfb2ZfaGVhcF90YWdcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKXtcbiAgcmV0dXJuIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0uY29tcGFyZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShudW0sIGN1c3RvbSwgc3dhcCwgdG90YWwpIHtcbiAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oY3VzdG9tKTtcbiAgaWYoY29tcCkge1xuICAgIHZhciB4ID0gKHN3YXAgPiAwKT9jb21wKGN1c3RvbSxudW0sdG90YWwpOmNvbXAobnVtLGN1c3RvbSx0b3RhbCk7XG4gICAgaWYodG90YWwgJiYgeCAhPSB4KSByZXR1cm4gc3dhcDsgLy8gdG90YWwgJiYgbmFuXG4gICAgaWYoK3ggIT0gK3gpIHJldHVybiAreDsgLy8gbmFuXG4gICAgaWYoKHggfCAwKSAhPSAwKSByZXR1cm4gKHggfCAwKTsgLy8gIW5hblxuICB9XG4gIHJldHVybiBzd2FwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWwgKGNvbnN0LCBjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ludF9jb21wYXJlLCBjYW1sX3N0cmluZ19jb21wYXJlLCBjYW1sX2J5dGVzX2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tLCBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRvdGFsKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICBmb3IoOzspIHtcbiAgICBpZiAoISh0b3RhbCAmJiBhID09PSBiKSkge1xuICAgICAgdmFyIHRhZ19hID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSk7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYSA9PSAyNTApIHsgYSA9IGFbMV07IGNvbnRpbnVlIH1cblxuICAgICAgdmFyIHRhZ19iID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYik7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYiA9PSAyNTApIHsgYiA9IGJbMV07IGNvbnRpbnVlIH1cblxuICAgICAgLy8gdGFncyBhcmUgZGlmZmVyZW50XG4gICAgICBpZih0YWdfYSAhPT0gdGFnX2IpIHtcbiAgICAgICAgaWYodGFnX2EgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19iID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYSwgYiwgLTEsIHRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYodGFnX2IgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19hID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYiwgYSwgMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGFnX2EgPCB0YWdfYik/LTE6MTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCh0YWdfYSl7XG4gICAgICAgIC8vIDI0NjogTGF6eV90YWcgaGFuZGxlZCBiZWxsb3dcbiAgICAgIGNhc2UgMjQ3OiAvLyBDbG9zdXJlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI0ODogLy8gT2JqZWN0XG4gICAgICAgIHZhciB4ID0gY2FtbF9pbnRfY29tcGFyZShhWzJdLCBiWzJdKTtcbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDk6IC8vIEluZml4XG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjUwOiAvLyBGb3J3YXJkIHRhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRm9yd2FyZF90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUxOiAvL0Fic3RyYWN0XG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MjogLy8gT0NhbWwgYnl0ZXNcbiAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICB2YXIgeCA9IGNhbWxfYnl0ZXNfY29tcGFyZShhLCBiKTtcbiAgICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MzogLy8gRG91YmxlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBhYm92ZVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IERvdWJsZV9hcnJheV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTU6IC8vIEN1c3RvbV90YWdcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBDdXN0b21fdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNDc6IC8vIEZ1bmN0aW9uXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU1OiAvLyBDdXN0b21cbiAgICAgICAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSk7XG4gICAgICAgIGlmKGNvbXAgIT0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGIpKXtcbiAgICAgICAgICByZXR1cm4gKGEuY2FtbF9jdXN0b208Yi5jYW1sX2N1c3RvbSk/LTE6MTtcbiAgICAgICAgfVxuICAgICAgICBpZighY29tcClcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgdmFyIHggPSBjb21wKGEsYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIFVOT1JERVJFRFxuICAgICAgICAgIHJldHVybiB0b3RhbD8tMTp4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHggIT09ICh4fDApKXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU2OiAvLyBjb21wYXJlIGZ1bmN0aW9uXG4gICAgICAgIHZhciB4ID0gYS5jb21wYXJlKGIsdG90YWwpO1xuICAgICAgICBpZih4ICE9IHgpIHsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwMDA6IC8vIE51bWJlclxuICAgICAgICBhID0gK2E7XG4gICAgICAgIGIgPSArYjtcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMTogLy8gVGhlIHJlc3RcbiAgICAgICAgLy8gSGVyZSB3ZSBjYW4gYmUgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgLy8gMS4gSmF2YVNjcmlwdCBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMi4gSmF2YVNjcmlwdCBvYmplY3QgdGhhdCBjYW4gYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMy4gSmF2YVNjcmlwdCBvYmplY3QgdGhhbiBjYW5ub3QgYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gKDMpIHdpbGwgcmFpc2UgYSBbVHlwZUVycm9yXVxuICAgICAgICAvLyAoMikgd2lsbCBjb2VyY2UgdG8gcHJpbWl0aXZlIHR5cGVzIHVzaW5nIFt2YWx1ZU9mXSBvciBbdG9TdHJpbmddXG4gICAgICAgIC8vICgyKSBhbmQgKDMpLCBhZnRlciBldmVudHVhbCBjb2VyY2lvblxuICAgICAgICAvLyAtIGlmIGEgYW5kIGIgYXJlIHN0cmluZ3MsIGFwcGx5IGxleGljb2dyYXBoaWMgY29tcGFyaXNvblxuICAgICAgICAvLyAtIGlmIGEgb3IgYiBhcmUgbm90IHN0cmluZ3MsIGNvbnZlcnQgYSBhbmQgYiB0byBudW1iZXJcbiAgICAgICAgLy8gICBhbmQgYXBwbHkgc3RhbmRhcmQgY29tcGFyaXNvblxuICAgICAgICAvL1xuICAgICAgICAvLyBFeGNlcHRpb246IGAhPWAgd2lsbCBub3QgY29lcmNlL2NvbnZlcnQgaWYgYm90aCBhIGFuZCBiIGFyZSBvYmplY3RzXG4gICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICBpZiAoYSAhPSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICBpZiAoYSA9PSBhKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYiA9PSBiKSByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTE6IC8vIEphdmFTY3JpcHQgU3ltYm9sLCBubyBvcmRlcmluZy5cbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTI6IC8vIG9jYW1sIHN0cmluZ3NcbiAgICAgICAgdmFyIGEgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGEpO1xuICAgICAgICB2YXIgYiA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYik7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjA6IC8vIGphdmFzY3JpcHQgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGEudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGIgPSBiLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ2OiAvLyBMYXp5X3RhZ1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheVxuICAgICAgZGVmYXVsdDogLy8gQmxvY2sgd2l0aCBvdGhlciB0YWdcbiAgICAgICAgaWYoY2FtbF9pc19jb250aW51YXRpb25fdGFnKHRhZ19hKSkge1xuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGNvbnRpbnVhdGlvbiB2YWx1ZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiAoYS5sZW5ndGggPCBiLmxlbmd0aCk/LTE6MTtcbiAgICAgICAgaWYgKGEubGVuZ3RoID4gMSkgc3RhY2sucHVzaChhLCBiLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFjay5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG4gICAgdmFyIGkgPSBzdGFjay5wb3AoKTtcbiAgICBiID0gc3RhY2sucG9wKCk7XG4gICAgYSA9IHN0YWNrLnBvcCgpO1xuICAgIGlmIChpICsgMSA8IGEubGVuZ3RoKSBzdGFjay5wdXNoKGEsIGIsIGkgKyAxKTtcbiAgICBhID0gYVtpXTtcbiAgICBiID0gYltpXTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmUgKGEsIGIpIHsgcmV0dXJuIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRydWUpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9jb21wYXJlIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfaW50X2NvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSByZXR1cm4gKC0xKTsgaWYgKGEgPT0gYikgcmV0dXJuIDA7IHJldHVybiAxO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA9PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX25vdGVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSAhPSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVyZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVyZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID49IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJ0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcnRoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID4gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzdGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3N0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8IDApOyB9XG4iLCJcbi8vUHJvdmlkZXM6IGNhbWxfY3VzdG9tX2V2ZW50X2luZGV4XG52YXIgY2FtbF9jdXN0b21fZXZlbnRfaW5kZXggPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVnaXN0ZXJcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX2V2ZW50X2luZGV4XG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVnaXN0ZXIoZXZlbnRfbmFtZSwgZXZlbnRfdGFnLCBldmVudF90eXBlKSB7XG4gIGNhbWxfY3VzdG9tX2V2ZW50X2luZGV4ICs9IDE7XG4gIHJldHVybiBbMCwgY2FtbF9jdXN0b21fZXZlbnRfaW5kZXgsIGV2ZW50X25hbWUsIGV2ZW50X3R5cGUsIGV2ZW50X3RhZ107XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl93cml0ZVxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3dyaXRlKGV2ZW50LCBldmVudF9jb250ZW50KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVzb2x2ZVxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3Jlc29sdmUoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3J1bnRpbWVfZXZlbnRzX3N0YXJ0XG4vL0FsaWFzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3N0YXJ0XG5mdW5jdGlvbiBjYW1sX21sX3J1bnRpbWVfZXZlbnRzX3N0YXJ0KCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX2V2ZW50c19wYXVzZVxuLy9BbGlhczogY2FtbF9ydW50aW1lX2V2ZW50c19wYXVzZVxuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX2V2ZW50c19wYXVzZSgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV9ldmVudHNfYXJlX2FjdGl2ZVxuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV9ldmVudHNfYXJlX2FjdGl2ZSgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV9ldmVudHNfcmVzdW1lXG4vL0FsaWFzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3Jlc3VtZVxuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX2V2ZW50c19yZXN1bWUoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX2NyZWF0ZV9jdXJzb3JcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfY3JlYXRlX2N1cnNvcih0YXJnZXQpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX2ZyZWVfY3Vyc29yXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfZXZlbnRzX2ZyZWVfY3Vyc29yKGN1cnNvcikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c19yZWFkX3BvbGxcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfcmVhZF9wb2xsKGN1cnNvciwgY2FsbGJhY2tzLCBudW0pIHtcbiAgcmV0dXJuIDA7XG59XG4iLCJcbi8vUHJvdmlkZXM6IHpzdGRfZGVjb21wcmVzc1xuLy9WZXJzaW9uOiA+PSA1LjFcbnZhciB6c3RkX2RlY29tcHJlc3MgPSAoZnVuY3Rpb24gKCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxudmFyIGFiID0gQXJyYXlCdWZmZXIsIHU4ID0gVWludDhBcnJheSwgdTE2ID0gVWludDE2QXJyYXksIGkxNiA9IEludDE2QXJyYXksIHUzMiA9IFVpbnQzMkFycmF5LCBpMzIgPSBJbnQzMkFycmF5O1xudmFyIHNsYyA9IGZ1bmN0aW9uICh2LCBzLCBlKSB7XG4gICAgaWYgKHU4LnByb3RvdHlwZS5zbGljZSlcbiAgICAgICAgcmV0dXJuIHU4LnByb3RvdHlwZS5zbGljZS5jYWxsKHYsIHMsIGUpO1xuICAgIGlmIChzID09IG51bGwgfHwgcyA8IDApXG4gICAgICAgIHMgPSAwO1xuICAgIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKVxuICAgICAgICBlID0gdi5sZW5ndGg7XG4gICAgdmFyIG4gPSBuZXcgdTgoZSAtIHMpO1xuICAgIG4uc2V0KHYuc3ViYXJyYXkocywgZSkpO1xuICAgIHJldHVybiBuO1xufTtcbnZhciBmaWxsID0gZnVuY3Rpb24gKHYsIG4sIHMsIGUpIHtcbiAgICBpZiAodTgucHJvdG90eXBlLmZpbGwpXG4gICAgICAgIHJldHVybiB1OC5wcm90b3R5cGUuZmlsbC5jYWxsKHYsIG4sIHMsIGUpO1xuICAgIGlmIChzID09IG51bGwgfHwgcyA8IDApXG4gICAgICAgIHMgPSAwO1xuICAgIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKVxuICAgICAgICBlID0gdi5sZW5ndGg7XG4gICAgZm9yICg7IHMgPCBlOyArK3MpXG4gICAgICAgIHZbc10gPSBuO1xuICAgIHJldHVybiB2O1xufTtcbnZhciBjcHcgPSBmdW5jdGlvbiAodiwgdCwgcywgZSkge1xuICAgIGlmICh1OC5wcm90b3R5cGUuY29weVdpdGhpbilcbiAgICAgICAgcmV0dXJuIHU4LnByb3RvdHlwZS5jb3B5V2l0aGluLmNhbGwodiwgdCwgcywgZSk7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMClcbiAgICAgICAgcyA9IDA7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpXG4gICAgICAgIGUgPSB2Lmxlbmd0aDtcbiAgICB3aGlsZSAocyA8IGUpIHtcbiAgICAgICAgdlt0KytdID0gdltzKytdO1xuICAgIH1cbn07XG4vKipcbiAqIENvZGVzIGZvciBlcnJvcnMgZ2VuZXJhdGVkIHdpdGhpbiB0aGlzIGxpYnJhcnlcbiAqL1xuLy8gZXJyb3IgY29kZXNcbnZhciBlYyA9IFtcbiAgICAnaW52YWxpZCB6c3RkIGRhdGEnLFxuICAgICd3aW5kb3cgc2l6ZSB0b28gbGFyZ2UgKD4yMDQ2TUIpJyxcbiAgICAnaW52YWxpZCBibG9jayB0eXBlJyxcbiAgICAnRlNFIGFjY3VyYWN5IHRvbyBoaWdoJyxcbiAgICAnbWF0Y2ggZGlzdGFuY2UgdG9vIGZhciBiYWNrJyxcbiAgICAndW5leHBlY3RlZCBFT0YnXG5dO1xuO1xudmFyIGVyciA9IGZ1bmN0aW9uIChpbmQsIG1zZywgbnQpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtc2cgfHwgZWNbaW5kXSk7XG4gICAgZS5jb2RlID0gaW5kO1xuICAgIGlmICghbnQpXG4gICAgICAgIHRocm93IGU7XG4gICAgcmV0dXJuIGU7XG59O1xudmFyIHJiID0gZnVuY3Rpb24gKGQsIGIsIG4pIHtcbiAgICB2YXIgaSA9IDAsIG8gPSAwO1xuICAgIGZvciAoOyBpIDwgbjsgKytpKVxuICAgICAgICBvIHw9IGRbYisrXSA8PCAoaSA8PCAzKTtcbiAgICByZXR1cm4gbztcbn07XG52YXIgYjQgPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gKGRbYl0gfCAoZFtiICsgMV0gPDwgOCkgfCAoZFtiICsgMl0gPDwgMTYpIHwgKGRbYiArIDNdIDw8IDI0KSkgPj4+IDA7IH07XG4vLyByZWFkIFpzdGFuZGFyZCBmcmFtZSBoZWFkZXJcbnZhciByemZoID0gZnVuY3Rpb24gKGRhdCwgdykge1xuICAgIHZhciBuMyA9IGRhdFswXSB8IChkYXRbMV0gPDwgOCkgfCAoZGF0WzJdIDw8IDE2KTtcbiAgICBpZiAobjMgPT0gMHgyRkI1MjggJiYgZGF0WzNdID09IDI1Mykge1xuICAgICAgICAvLyBac3RhbmRhcmRcbiAgICAgICAgdmFyIGZsZyA9IGRhdFs0XTtcbiAgICAgICAgLy8gICAgc2luZ2xlIHNlZ21lbnQgICAgICAgY2hlY2tzdW0gICAgICAgICAgICAgZGljdCBmbGFnICAgICBmcmFtZSBjb250ZW50IGZsYWdcbiAgICAgICAgdmFyIHNzID0gKGZsZyA+PiA1KSAmIDEsIGNjID0gKGZsZyA+PiAyKSAmIDEsIGRmID0gZmxnICYgMywgZmNmID0gZmxnID4+IDY7XG4gICAgICAgIGlmIChmbGcgJiA4KVxuICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAvLyBieXRlXG4gICAgICAgIHZhciBidCA9IDYgLSBzcztcbiAgICAgICAgLy8gZGljdCBieXRlc1xuICAgICAgICB2YXIgZGIgPSBkZiA9PSAzID8gNCA6IGRmO1xuICAgICAgICAvLyBkaWN0aW9uYXJ5IGlkXG4gICAgICAgIHZhciBkaSA9IHJiKGRhdCwgYnQsIGRiKTtcbiAgICAgICAgYnQgKz0gZGI7XG4gICAgICAgIC8vIGZyYW1lIHNpemUgYnl0ZXNcbiAgICAgICAgdmFyIGZzYiA9IGZjZiA/ICgxIDw8IGZjZikgOiBzcztcbiAgICAgICAgLy8gZnJhbWUgc291cmNlIHNpemVcbiAgICAgICAgdmFyIGZzcyA9IHJiKGRhdCwgYnQsIGZzYikgKyAoKGZjZiA9PSAxKSAmJiAyNTYpO1xuICAgICAgICAvLyB3aW5kb3cgc2l6ZVxuICAgICAgICB2YXIgd3MgPSBmc3M7XG4gICAgICAgIGlmICghc3MpIHtcbiAgICAgICAgICAgIC8vIHdpbmRvdyBkZXNjcmlwdG9yXG4gICAgICAgICAgICB2YXIgd2IgPSAxIDw8ICgxMCArIChkYXRbNV0gPj4gMykpO1xuICAgICAgICAgICAgd3MgPSB3YiArICh3YiA+PiAzKSAqIChkYXRbNV0gJiA3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3MgPiAyMTQ1Mzg2NDk2KVxuICAgICAgICAgICAgZXJyKDEpO1xuICAgICAgICB2YXIgYnVmID0gbmV3IHU4KCh3ID09IDEgPyAoZnNzIHx8IHdzKSA6IHcgPyAwIDogd3MpICsgMTIpO1xuICAgICAgICBidWZbMF0gPSAxLCBidWZbNF0gPSA0LCBidWZbOF0gPSA4O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYjogYnQgKyBmc2IsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgbDogMCxcbiAgICAgICAgICAgIGQ6IGRpLFxuICAgICAgICAgICAgdzogKHcgJiYgdyAhPSAxKSA/IHcgOiBidWYuc3ViYXJyYXkoMTIpLFxuICAgICAgICAgICAgZTogd3MsXG4gICAgICAgICAgICBvOiBuZXcgaTMyKGJ1Zi5idWZmZXIsIDAsIDMpLFxuICAgICAgICAgICAgdTogZnNzLFxuICAgICAgICAgICAgYzogY2MsXG4gICAgICAgICAgICBtOiBNYXRoLm1pbigxMzEwNzIsIHdzKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgoKG4zID4+IDQpIHwgKGRhdFszXSA8PCAyMCkpID09IDB4MTg0RDJBNSkge1xuICAgICAgICAvLyBza2lwcGFibGVcbiAgICAgICAgcmV0dXJuIGI0KGRhdCwgNCkgKyA4O1xuICAgIH1cbiAgICBlcnIoMCk7XG59O1xuLy8gbW9zdCBzaWduaWZpY2FudCBiaXQgZm9yIG5vbnplcm9cbnZhciBtc2IgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIGJpdHMgPSAwO1xuICAgIGZvciAoOyAoMSA8PCBiaXRzKSA8PSB2YWw7ICsrYml0cylcbiAgICAgICAgO1xuICAgIHJldHVybiBiaXRzIC0gMTtcbn07XG4vLyByZWFkIGZpbml0ZSBzdGF0ZSBlbnRyb3B5XG52YXIgcmZzZSA9IGZ1bmN0aW9uIChkYXQsIGJ0LCBtYWwpIHtcbiAgICAvLyB0YWJsZSBwb3NcbiAgICB2YXIgdHBvcyA9IChidCA8PCAzKSArIDQ7XG4gICAgLy8gYWNjdXJhY3kgbG9nXG4gICAgdmFyIGFsID0gKGRhdFtidF0gJiAxNSkgKyA1O1xuICAgIGlmIChhbCA+IG1hbClcbiAgICAgICAgZXJyKDMpO1xuICAgIC8vIHNpemVcbiAgICB2YXIgc3ogPSAxIDw8IGFsO1xuICAgIC8vIHByb2JhYmlsaXRpZXMgc3ltYm9scyAgcmVwZWF0ICAgaW5kZXggICBoaWdoIHRocmVzaG9sZFxuICAgIHZhciBwcm9icyA9IHN6LCBzeW0gPSAtMSwgcmUgPSAtMSwgaSA9IC0xLCBodCA9IHN6O1xuICAgIC8vIG9wdGltaXphdGlvbjogc2luZ2xlIGFsbG9jYXRpb24gaXMgbXVjaCBmYXN0ZXJcbiAgICB2YXIgYnVmID0gbmV3IGFiKDUxMiArIChzeiA8PCAyKSk7XG4gICAgdmFyIGZyZXEgPSBuZXcgaTE2KGJ1ZiwgMCwgMjU2KTtcbiAgICAvLyBzYW1lIHZpZXcgYXMgZnJlcVxuICAgIHZhciBkc3RhdGUgPSBuZXcgdTE2KGJ1ZiwgMCwgMjU2KTtcbiAgICB2YXIgbnN0YXRlID0gbmV3IHUxNihidWYsIDUxMiwgc3opO1xuICAgIHZhciBiYjEgPSA1MTIgKyAoc3ogPDwgMSk7XG4gICAgdmFyIHN5bXMgPSBuZXcgdTgoYnVmLCBiYjEsIHN6KTtcbiAgICB2YXIgbmJpdHMgPSBuZXcgdTgoYnVmLCBiYjEgKyBzeik7XG4gICAgd2hpbGUgKHN5bSA8IDI1NSAmJiBwcm9icyA+IDApIHtcbiAgICAgICAgdmFyIGJpdHMgPSBtc2IocHJvYnMgKyAxKTtcbiAgICAgICAgdmFyIGNidCA9IHRwb3MgPj4gMztcbiAgICAgICAgLy8gbWFza1xuICAgICAgICB2YXIgbXNrID0gKDEgPDwgKGJpdHMgKyAxKSkgLSAxO1xuICAgICAgICB2YXIgdmFsID0gKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkgfCAoZGF0W2NidCArIDJdIDw8IDE2KSkgPj4gKHRwb3MgJiA3KSkgJiBtc2s7XG4gICAgICAgIC8vIG1hc2sgKDEgZmV3ZXIgYml0KVxuICAgICAgICB2YXIgbXNrMWZiID0gKDEgPDwgYml0cykgLSAxO1xuICAgICAgICAvLyBtYXggc21hbGwgdmFsdWVcbiAgICAgICAgdmFyIG1zdiA9IG1zayAtIHByb2JzIC0gMTtcbiAgICAgICAgLy8gc21hbGwgdmFsdWVcbiAgICAgICAgdmFyIHN2YWwgPSB2YWwgJiBtc2sxZmI7XG4gICAgICAgIGlmIChzdmFsIDwgbXN2KVxuICAgICAgICAgICAgdHBvcyArPSBiaXRzLCB2YWwgPSBzdmFsO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRwb3MgKz0gYml0cyArIDE7XG4gICAgICAgICAgICBpZiAodmFsID4gbXNrMWZiKVxuICAgICAgICAgICAgICAgIHZhbCAtPSBtc3Y7XG4gICAgICAgIH1cbiAgICAgICAgZnJlcVsrK3N5bV0gPSAtLXZhbDtcbiAgICAgICAgaWYgKHZhbCA9PSAtMSkge1xuICAgICAgICAgICAgcHJvYnMgKz0gdmFsO1xuICAgICAgICAgICAgc3ltc1stLWh0XSA9IHN5bTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwcm9icyAtPSB2YWw7XG4gICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gcmVwZWF0IGJ5dGVcbiAgICAgICAgICAgICAgICB2YXIgcmJ0ID0gdHBvcyA+PiAzO1xuICAgICAgICAgICAgICAgIHJlID0gKChkYXRbcmJ0XSB8IChkYXRbcmJ0ICsgMV0gPDwgOCkpID4+ICh0cG9zICYgNykpICYgMztcbiAgICAgICAgICAgICAgICB0cG9zICs9IDI7XG4gICAgICAgICAgICAgICAgc3ltICs9IHJlO1xuICAgICAgICAgICAgfSB3aGlsZSAocmUgPT0gMyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN5bSA+IDI1NSB8fCBwcm9icylcbiAgICAgICAgZXJyKDApO1xuICAgIHZhciBzeW1wb3MgPSAwO1xuICAgIC8vIHN5bSBzdGVwIChjb3ByaW1lIHdpdGggc3ogLSBmb3JtdWxhIGZyb20genN0ZCBzb3VyY2UpXG4gICAgdmFyIHNzdGVwID0gKHN6ID4+IDEpICsgKHN6ID4+IDMpICsgMztcbiAgICAvLyBzeW0gbWFza1xuICAgIHZhciBzbWFzayA9IHN6IC0gMTtcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8PSBzeW07ICsrcykge1xuICAgICAgICB2YXIgc2YgPSBmcmVxW3NdO1xuICAgICAgICBpZiAoc2YgPCAxKSB7XG4gICAgICAgICAgICBkc3RhdGVbc10gPSAtc2Y7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIHNwbGl0IGludG8gdHdvIGxvb3BzIGluIHpzdGQgdG8gYXZvaWQgYnJhbmNoaW5nLCBidXQgYXMgSlMgaXMgaGlnaGVyLWxldmVsIHRoYXQgaXMgdW5uZWNlc3NhcnlcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNmOyArK2kpIHtcbiAgICAgICAgICAgIHN5bXNbc3ltcG9zXSA9IHM7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgc3ltcG9zID0gKHN5bXBvcyArIHNzdGVwKSAmIHNtYXNrO1xuICAgICAgICAgICAgfSB3aGlsZSAoc3ltcG9zID49IGh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZnRlciBzcHJlYWRpbmcgc3ltYm9scywgc2hvdWxkIGJlIHplcm8gYWdhaW5cbiAgICBpZiAoc3ltcG9zKVxuICAgICAgICBlcnIoMCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN6OyArK2kpIHtcbiAgICAgICAgLy8gbmV4dCBzdGF0ZVxuICAgICAgICB2YXIgbnMgPSBkc3RhdGVbc3ltc1tpXV0rKztcbiAgICAgICAgLy8gbnVtIGJpdHNcbiAgICAgICAgdmFyIG5iID0gbmJpdHNbaV0gPSBhbCAtIG1zYihucyk7XG4gICAgICAgIG5zdGF0ZVtpXSA9IChucyA8PCBuYikgLSBzejtcbiAgICB9XG4gICAgcmV0dXJuIFsodHBvcyArIDcpID4+IDMsIHtcbiAgICAgICAgICAgIGI6IGFsLFxuICAgICAgICAgICAgczogc3ltcyxcbiAgICAgICAgICAgIG46IG5iaXRzLFxuICAgICAgICAgICAgdDogbnN0YXRlXG4gICAgICAgIH1dO1xufTtcbi8vIHJlYWQgaHVmZm1hblxudmFyIHJodSA9IGZ1bmN0aW9uIChkYXQsIGJ0KSB7XG4gICAgLy8gIGluZGV4ICB3ZWlnaHQgY291bnRcbiAgICB2YXIgaSA9IDAsIHdjID0gLTE7XG4gICAgLy8gICAgYnVmZmVyICAgICAgICAgICAgIGhlYWRlciBieXRlXG4gICAgdmFyIGJ1ZiA9IG5ldyB1OCgyOTIpLCBoYiA9IGRhdFtidF07XG4gICAgLy8gaHVmZm1hbiB3ZWlnaHRzXG4gICAgdmFyIGh3ID0gYnVmLnN1YmFycmF5KDAsIDI1Nik7XG4gICAgLy8gcmFuayBjb3VudFxuICAgIHZhciByYyA9IGJ1Zi5zdWJhcnJheSgyNTYsIDI2OCk7XG4gICAgLy8gcmFuayBpbmRleFxuICAgIHZhciByaSA9IG5ldyB1MTYoYnVmLmJ1ZmZlciwgMjY4KTtcbiAgICAvLyBOT1RFOiBhdCB0aGlzIHBvaW50IGJ0IGlzIDEgbGVzcyB0aGFuIGV4cGVjdGVkXG4gICAgaWYgKGhiIDwgMTI4KSB7XG4gICAgICAgIC8vIGVuZCBieXRlLCBmc2UgZGVjb2RlIHRhYmxlXG4gICAgICAgIHZhciBfYSA9IHJmc2UoZGF0LCBidCArIDEsIDYpLCBlYnQgPSBfYVswXSwgZmR0ID0gX2FbMV07XG4gICAgICAgIGJ0ICs9IGhiO1xuICAgICAgICB2YXIgZXBvcyA9IGVidCA8PCAzO1xuICAgICAgICAvLyBsYXN0IGJ5dGVcbiAgICAgICAgdmFyIGxiID0gZGF0W2J0XTtcbiAgICAgICAgaWYgKCFsYilcbiAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgLy8gIHN0YXRlMSAgIHN0YXRlMiAgIHN0YXRlMSBiaXRzICAgc3RhdGUyIGJpdHNcbiAgICAgICAgdmFyIHN0MSA9IDAsIHN0MiA9IDAsIGJ0cjEgPSBmZHQuYiwgYnRyMiA9IGJ0cjE7XG4gICAgICAgIC8vIGZzZSBwb3NcbiAgICAgICAgLy8gcHJlLWluY3JlbWVudCB0byBhY2NvdW50IGZvciBvcmlnaW5hbCBkZWZpY2l0IG9mIDFcbiAgICAgICAgdmFyIGZwb3MgPSAoKytidCA8PCAzKSAtIDggKyBtc2IobGIpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBmcG9zIC09IGJ0cjE7XG4gICAgICAgICAgICBpZiAoZnBvcyA8IGVwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgY2J0ID0gZnBvcyA+PiAzO1xuICAgICAgICAgICAgc3QxICs9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoZnBvcyAmIDcpKSAmICgoMSA8PCBidHIxKSAtIDEpO1xuICAgICAgICAgICAgaHdbKyt3Y10gPSBmZHQuc1tzdDFdO1xuICAgICAgICAgICAgZnBvcyAtPSBidHIyO1xuICAgICAgICAgICAgaWYgKGZwb3MgPCBlcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2J0ID0gZnBvcyA+PiAzO1xuICAgICAgICAgICAgc3QyICs9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoZnBvcyAmIDcpKSAmICgoMSA8PCBidHIyKSAtIDEpO1xuICAgICAgICAgICAgaHdbKyt3Y10gPSBmZHQuc1tzdDJdO1xuICAgICAgICAgICAgYnRyMSA9IGZkdC5uW3N0MV07XG4gICAgICAgICAgICBzdDEgPSBmZHQudFtzdDFdO1xuICAgICAgICAgICAgYnRyMiA9IGZkdC5uW3N0Ml07XG4gICAgICAgICAgICBzdDIgPSBmZHQudFtzdDJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICgrK3djID4gMjU1KVxuICAgICAgICAgICAgZXJyKDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2MgPSBoYiAtIDEyNztcbiAgICAgICAgZm9yICg7IGkgPCB3YzsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZSA9IGRhdFsrK2J0XTtcbiAgICAgICAgICAgIGh3W2ldID0gYnl0ZSA+PiA0O1xuICAgICAgICAgICAgaHdbaSArIDFdID0gYnl0ZSAmIDE1O1xuICAgICAgICB9XG4gICAgICAgICsrYnQ7XG4gICAgfVxuICAgIC8vIHdlaWdodCBleHBvbmVudGlhbCBzdW1cbiAgICB2YXIgd2VzID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgICAgICB2YXIgd3QgPSBod1tpXTtcbiAgICAgICAgLy8gYml0cyBtdXN0IGJlIGF0IG1vc3QgMTEsIHNhbWUgYXMgd2VpZ2h0XG4gICAgICAgIGlmICh3dCA+IDExKVxuICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICB3ZXMgKz0gd3QgJiYgKDEgPDwgKHd0IC0gMSkpO1xuICAgIH1cbiAgICAvLyBtYXggYml0c1xuICAgIHZhciBtYiA9IG1zYih3ZXMpICsgMTtcbiAgICAvLyB0YWJsZSBzaXplXG4gICAgdmFyIHRzID0gMSA8PCBtYjtcbiAgICAvLyByZW1haW5pbmcgc3VtXG4gICAgdmFyIHJlbSA9IHRzIC0gd2VzO1xuICAgIC8vIG11c3QgYmUgcG93ZXIgb2YgMlxuICAgIGlmIChyZW0gJiAocmVtIC0gMSkpXG4gICAgICAgIGVycigwKTtcbiAgICBod1t3YysrXSA9IG1zYihyZW0pICsgMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgICAgICB2YXIgd3QgPSBod1tpXTtcbiAgICAgICAgKytyY1tod1tpXSA9IHd0ICYmIChtYiArIDEgLSB3dCldO1xuICAgIH1cbiAgICAvLyBodWYgYnVmXG4gICAgdmFyIGhidWYgPSBuZXcgdTgodHMgPDwgMSk7XG4gICAgLy8gICAgc3ltYm9scyAgICAgICAgICAgICAgICAgICAgICBudW0gYml0c1xuICAgIHZhciBzeW1zID0gaGJ1Zi5zdWJhcnJheSgwLCB0cyksIG5iID0gaGJ1Zi5zdWJhcnJheSh0cyk7XG4gICAgcmlbbWJdID0gMDtcbiAgICBmb3IgKGkgPSBtYjsgaSA+IDA7IC0taSkge1xuICAgICAgICB2YXIgcHYgPSByaVtpXTtcbiAgICAgICAgZmlsbChuYiwgaSwgcHYsIHJpW2kgLSAxXSA9IHB2ICsgcmNbaV0gKiAoMSA8PCAobWIgLSBpKSkpO1xuICAgIH1cbiAgICBpZiAocmlbMF0gIT0gdHMpXG4gICAgICAgIGVycigwKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgICAgICB2YXIgYml0cyA9IGh3W2ldO1xuICAgICAgICBpZiAoYml0cykge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByaVtiaXRzXTtcbiAgICAgICAgICAgIGZpbGwoc3ltcywgaSwgY29kZSwgcmlbYml0c10gPSBjb2RlICsgKDEgPDwgKG1iIC0gYml0cykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2J0LCB7XG4gICAgICAgICAgICBuOiBuYixcbiAgICAgICAgICAgIGI6IG1iLFxuICAgICAgICAgICAgczogc3ltc1xuICAgICAgICB9XTtcbn07XG4vLyBUYWJsZXMgZ2VuZXJhdGVkIHVzaW5nIHRoaXM6XG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDFhcnJvd3ovYTk3OTQ1MmQ0MzU1OTkyY2JmOGYyNTdjYmZmYzllZGRcbi8vIGRlZmF1bHQgbGl0ZXJhbCBsZW5ndGggdGFibGVcbnZhciBkbGx0ID0gLyojX19QVVJFX18qLyByZnNlKC8qI19fUFVSRV9fKi8gbmV3IHU4KFtcbiAgICA4MSwgMTYsIDk5LCAxNDAsIDQ5LCAxOTgsIDI0LCA5OSwgMTIsIDMzLCAxOTYsIDI0LCA5OSwgMTAyLCAxMDIsIDEzNCwgNzAsIDE0NiwgNFxuXSksIDAsIDYpWzFdO1xuLy8gZGVmYXVsdCBtYXRjaCBsZW5ndGggdGFibGVcbnZhciBkbWx0ID0gLyojX19QVVJFX18qLyByZnNlKC8qI19fUFVSRV9fKi8gbmV3IHU4KFtcbiAgICAzMywgMjAsIDE5NiwgMjQsIDk5LCAxNDAsIDMzLCAxMzIsIDE2LCA2NiwgOCwgMzMsIDEzMiwgMTYsIDY2LCA4LCAzMywgNjgsIDY4LCA2OCwgNjgsIDY4LCA2OCwgNjgsIDY4LCAzNiwgOVxuXSksIDAsIDYpWzFdO1xuLy8gZGVmYXVsdCBvZmZzZXQgY29kZSB0YWJsZVxudmFyIGRvY3QgPSAvKiNfX1BVUkVfXyAqLyByZnNlKC8qI19fUFVSRV9fKi8gbmV3IHU4KFtcbiAgICAzMiwgMTMyLCAxNiwgNjYsIDEwMiwgNzAsIDY4LCA2OCwgNjgsIDY4LCAzNiwgNzMsIDJcbl0pLCAwLCA1KVsxXTtcbi8vIGJpdHMgdG8gYmFzZWxpbmVcbnZhciBiMmJsID0gZnVuY3Rpb24gKGIsIHMpIHtcbiAgICB2YXIgbGVuID0gYi5sZW5ndGgsIGJsID0gbmV3IGkzMihsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgYmxbaV0gPSBzO1xuICAgICAgICBzICs9IDEgPDwgYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJsO1xufTtcbi8vIGxpdGVyYWwgbGVuZ3RoIGJpdHNcbnZhciBsbGIgPSAvKiNfX1BVUkVfXyAqLyBuZXcgdTgoKCAvKiNfX1BVUkVfXyAqL25ldyBpMzIoW1xuICAgIDAsIDAsIDAsIDAsIDE2ODQzMDA5LCA1MDUyODc3MCwgMTM0Njc4MDIwLCAyMDIwNTAwNTcsIDI2OTQyMjA5M1xuXSkpLmJ1ZmZlciwgMCwgMzYpO1xuLy8gbGl0ZXJhbCBsZW5ndGggYmFzZWxpbmVcbnZhciBsbGJsID0gLyojX19QVVJFX18gKi8gYjJibChsbGIsIDApO1xuLy8gbWF0Y2ggbGVuZ3RoIGJpdHNcbnZhciBtbGIgPSAvKiNfX1BVUkVfXyAqLyBuZXcgdTgoKCAvKiNfX1BVUkVfXyAqL25ldyBpMzIoW1xuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDE2ODQzMDA5LCA1MDUyODc3MCwgMTE3NzY5MjIwLCAxODUyMDcwNDgsIDI1MjU3OTA4NCwgMTZcbl0pKS5idWZmZXIsIDAsIDUzKTtcbi8vIG1hdGNoIGxlbmd0aCBiYXNlbGluZVxudmFyIG1sYmwgPSAvKiNfX1BVUkVfXyAqLyBiMmJsKG1sYiwgMyk7XG4vLyBkZWNvZGUgaHVmZm1hbiBzdHJlYW1cbnZhciBkaHUgPSBmdW5jdGlvbiAoZGF0LCBvdXQsIGh1KSB7XG4gICAgdmFyIGxlbiA9IGRhdC5sZW5ndGgsIHNzID0gb3V0Lmxlbmd0aCwgbGIgPSBkYXRbbGVuIC0gMV0sIG1zayA9ICgxIDw8IGh1LmIpIC0gMSwgZWIgPSAtaHUuYjtcbiAgICBpZiAoIWxiKVxuICAgICAgICBlcnIoMCk7XG4gICAgdmFyIHN0ID0gMCwgYnRyID0gaHUuYiwgcG9zID0gKGxlbiA8PCAzKSAtIDggKyBtc2IobGIpIC0gYnRyLCBpID0gLTE7XG4gICAgZm9yICg7IHBvcyA+IGViICYmIGkgPCBzczspIHtcbiAgICAgICAgdmFyIGNidCA9IHBvcyA+PiAzO1xuICAgICAgICB2YXIgdmFsID0gKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSB8IChkYXRbY2J0ICsgMl0gPDwgMTYpKSA+PiAocG9zICYgNyk7XG4gICAgICAgIHN0ID0gKChzdCA8PCBidHIpIHwgdmFsKSAmIG1zaztcbiAgICAgICAgb3V0WysraV0gPSBodS5zW3N0XTtcbiAgICAgICAgcG9zIC09IChidHIgPSBodS5uW3N0XSk7XG4gICAgfVxuICAgIGlmIChwb3MgIT0gZWIgfHwgaSArIDEgIT0gc3MpXG4gICAgICAgIGVycigwKTtcbn07XG4vLyBkZWNvZGUgaHVmZm1hbiBzdHJlYW0gNHhcbi8vIFRPRE86IHVzZSB3b3JrZXJzIHRvIHBhcmFsbGVsaXplXG52YXIgZGh1NCA9IGZ1bmN0aW9uIChkYXQsIG91dCwgaHUpIHtcbiAgICB2YXIgYnQgPSA2O1xuICAgIHZhciBzcyA9IG91dC5sZW5ndGgsIHN6MSA9IChzcyArIDMpID4+IDIsIHN6MiA9IHN6MSA8PCAxLCBzejMgPSBzejEgKyBzejI7XG4gICAgZGh1KGRhdC5zdWJhcnJheShidCwgYnQgKz0gZGF0WzBdIHwgKGRhdFsxXSA8PCA4KSksIG91dC5zdWJhcnJheSgwLCBzejEpLCBodSk7XG4gICAgZGh1KGRhdC5zdWJhcnJheShidCwgYnQgKz0gZGF0WzJdIHwgKGRhdFszXSA8PCA4KSksIG91dC5zdWJhcnJheShzejEsIHN6MiksIGh1KTtcbiAgICBkaHUoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBkYXRbNF0gfCAoZGF0WzVdIDw8IDgpKSwgb3V0LnN1YmFycmF5KHN6Miwgc3ozKSwgaHUpO1xuICAgIGRodShkYXQuc3ViYXJyYXkoYnQpLCBvdXQuc3ViYXJyYXkoc3ozKSwgaHUpO1xufTtcbi8vIHJlYWQgWnN0YW5kYXJkIGJsb2NrXG52YXIgcnpiID0gZnVuY3Rpb24gKGRhdCwgc3QsIG91dCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgYnQgPSBzdC5iO1xuICAgIC8vICAgIGJ5dGUgMCAgICAgICAgYmxvY2sgdHlwZVxuICAgIHZhciBiMCA9IGRhdFtidF0sIGJ0eXBlID0gKGIwID4+IDEpICYgMztcbiAgICBzdC5sID0gYjAgJiAxO1xuICAgIHZhciBzeiA9IChiMCA+PiAzKSB8IChkYXRbYnQgKyAxXSA8PCA1KSB8IChkYXRbYnQgKyAyXSA8PCAxMyk7XG4gICAgLy8gZW5kIGJ5dGUgZm9yIGJsb2NrXG4gICAgdmFyIGVidCA9IChidCArPSAzKSArIHN6O1xuICAgIGlmIChidHlwZSA9PSAxKSB7XG4gICAgICAgIGlmIChidCA+PSBkYXQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdC5iID0gYnQgKyAxO1xuICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICBmaWxsKG91dCwgZGF0W2J0XSwgc3QueSwgc3QueSArPSBzeik7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxsKG5ldyB1OChzeiksIGRhdFtidF0pO1xuICAgIH1cbiAgICBpZiAoZWJ0ID4gZGF0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChidHlwZSA9PSAwKSB7XG4gICAgICAgIHN0LmIgPSBlYnQ7XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIG91dC5zZXQoZGF0LnN1YmFycmF5KGJ0LCBlYnQpLCBzdC55KTtcbiAgICAgICAgICAgIHN0LnkgKz0gc3o7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzbGMoZGF0LCBidCwgZWJ0KTtcbiAgICB9XG4gICAgaWYgKGJ0eXBlID09IDIpIHtcbiAgICAgICAgLy8gICAgYnl0ZSAzICAgICAgICBsaXQgYnR5cGUgICAgIHNpemUgZm9ybWF0XG4gICAgICAgIHZhciBiMyA9IGRhdFtidF0sIGxidCA9IGIzICYgMywgc2YgPSAoYjMgPj4gMikgJiAzO1xuICAgICAgICAvLyBsaXQgc3JjIHNpemUgIGxpdCBjbXAgc3ogNCBzdHJlYW1zXG4gICAgICAgIHZhciBsc3MgPSBiMyA+PiA0LCBsY3MgPSAwLCBzNCA9IDA7XG4gICAgICAgIGlmIChsYnQgPCAyKSB7XG4gICAgICAgICAgICBpZiAoc2YgJiAxKVxuICAgICAgICAgICAgICAgIGxzcyB8PSAoZGF0WysrYnRdIDw8IDQpIHwgKChzZiAmIDIpICYmIChkYXRbKytidF0gPDwgMTIpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsc3MgPSBiMyA+PiAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgczQgPSBzZjtcbiAgICAgICAgICAgIGlmIChzZiA8IDIpXG4gICAgICAgICAgICAgICAgbHNzIHw9ICgoZGF0WysrYnRdICYgNjMpIDw8IDQpLCBsY3MgPSAoZGF0W2J0XSA+PiA2KSB8IChkYXRbKytidF0gPDwgMik7XG4gICAgICAgICAgICBlbHNlIGlmIChzZiA9PSAyKVxuICAgICAgICAgICAgICAgIGxzcyB8PSAoZGF0WysrYnRdIDw8IDQpIHwgKChkYXRbKytidF0gJiAzKSA8PCAxMiksIGxjcyA9IChkYXRbYnRdID4+IDIpIHwgKGRhdFsrK2J0XSA8PCA2KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsc3MgfD0gKGRhdFsrK2J0XSA8PCA0KSB8ICgoZGF0WysrYnRdICYgNjMpIDw8IDEyKSwgbGNzID0gKGRhdFtidF0gPj4gNikgfCAoZGF0WysrYnRdIDw8IDIpIHwgKGRhdFsrK2J0XSA8PCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgKytidDtcbiAgICAgICAgLy8gYWRkIGxpdGVyYWxzIHRvIGVuZCAtIGNhbiBuZXZlciBvdmVybGFwIHdpdGggYmFja3JlZmVyZW5jZXMgYmVjYXVzZSB1bnVzZWQgbGl0ZXJhbHMgYWx3YXlzIGFwcGVuZGVkXG4gICAgICAgIHZhciBidWYgPSBvdXQgPyBvdXQuc3ViYXJyYXkoc3QueSwgc3QueSArIHN0Lm0pIDogbmV3IHU4KHN0Lm0pO1xuICAgICAgICAvLyBzdGFydGluZyBwb2ludCBmb3IgbGl0ZXJhbHNcbiAgICAgICAgdmFyIHNwbCA9IGJ1Zi5sZW5ndGggLSBsc3M7XG4gICAgICAgIGlmIChsYnQgPT0gMClcbiAgICAgICAgICAgIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBsc3MpLCBzcGwpO1xuICAgICAgICBlbHNlIGlmIChsYnQgPT0gMSlcbiAgICAgICAgICAgIGZpbGwoYnVmLCBkYXRbYnQrK10sIHNwbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaHVmZm1hbiB0YWJsZVxuICAgICAgICAgICAgdmFyIGh1ID0gc3QuaDtcbiAgICAgICAgICAgIGlmIChsYnQgPT0gMikge1xuICAgICAgICAgICAgICAgIHZhciBodWQgPSByaHUoZGF0LCBidCk7XG4gICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgZGVzY3JpcHRpb24gbGVuZ3RoXG4gICAgICAgICAgICAgICAgbGNzICs9IGJ0IC0gKGJ0ID0gaHVkWzBdKTtcbiAgICAgICAgICAgICAgICBzdC5oID0gaHUgPSBodWRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaHUpXG4gICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgKHM0ID8gZGh1NCA6IGRodSkoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBsY3MpLCBidWYuc3ViYXJyYXkoc3BsKSwgaHUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG51bSBzZXF1ZW5jZXNcbiAgICAgICAgdmFyIG5zID0gZGF0W2J0KytdO1xuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIGlmIChucyA9PSAyNTUpXG4gICAgICAgICAgICAgICAgbnMgPSAoZGF0W2J0KytdIHwgKGRhdFtidCsrXSA8PCA4KSkgKyAweDdGMDA7XG4gICAgICAgICAgICBlbHNlIGlmIChucyA+IDEyNylcbiAgICAgICAgICAgICAgICBucyA9ICgobnMgLSAxMjgpIDw8IDgpIHwgZGF0W2J0KytdO1xuICAgICAgICAgICAgLy8gc3ltYm9sIGNvbXByZXNzaW9uIG1vZGVzXG4gICAgICAgICAgICB2YXIgc2NtID0gZGF0W2J0KytdO1xuICAgICAgICAgICAgaWYgKHNjbSAmIDMpXG4gICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgdmFyIGR0cyA9IFtkbWx0LCBkb2N0LCBkbGx0XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyOyBpID4gLTE7IC0taSkge1xuICAgICAgICAgICAgICAgIHZhciBtZCA9IChzY20gPj4gKChpIDw8IDEpICsgMikpICYgMztcbiAgICAgICAgICAgICAgICBpZiAobWQgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBybGUgYnVmXG4gICAgICAgICAgICAgICAgICAgIHZhciByYnVmID0gbmV3IHU4KFswLCAwLCBkYXRbYnQrK11dKTtcbiAgICAgICAgICAgICAgICAgICAgZHRzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgczogcmJ1Zi5zdWJhcnJheSgyLCAzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG46IHJidWYuc3ViYXJyYXkoMCwgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0OiBuZXcgdTE2KHJidWYuYnVmZmVyLCAwLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGI6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWQgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhY2N1cmFjeSBsb2cgOCBmb3Igb2Zmc2V0cywgOSBmb3Igb3RoZXJzXG4gICAgICAgICAgICAgICAgICAgIF9hID0gcmZzZShkYXQsIGJ0LCA5IC0gKGkgJiAxKSksIGJ0ID0gX2FbMF0sIGR0c1tpXSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3QudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgICAgICAgICAgICAgZHRzW2ldID0gc3QudFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBzdC50ID0gZHRzLCBtbHQgPSBfYlswXSwgb2N0ID0gX2JbMV0sIGxsdCA9IF9iWzJdO1xuICAgICAgICAgICAgdmFyIGxiID0gZGF0W2VidCAtIDFdO1xuICAgICAgICAgICAgaWYgKCFsYilcbiAgICAgICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgICAgICB2YXIgc3BvcyA9IChlYnQgPDwgMykgLSA4ICsgbXNiKGxiKSAtIGxsdC5iLCBjYnQgPSBzcG9zID4+IDMsIG91YnQgPSAwO1xuICAgICAgICAgICAgdmFyIGxzdCA9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBsbHQuYikgLSAxKTtcbiAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG9jdC5iKSA+PiAzO1xuICAgICAgICAgICAgdmFyIG9zdCA9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBvY3QuYikgLSAxKTtcbiAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG1sdC5iKSA+PiAzO1xuICAgICAgICAgICAgdmFyIG1zdCA9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBtbHQuYikgLSAxKTtcbiAgICAgICAgICAgIGZvciAoKytuczsgLS1uczspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGxjID0gbGx0LnNbbHN0XTtcbiAgICAgICAgICAgICAgICB2YXIgbGJ0ciA9IGxsdC5uW2xzdF07XG4gICAgICAgICAgICAgICAgdmFyIG1sYyA9IG1sdC5zW21zdF07XG4gICAgICAgICAgICAgICAgdmFyIG1idHIgPSBtbHQublttc3RdO1xuICAgICAgICAgICAgICAgIHZhciBvZmMgPSBvY3Quc1tvc3RdO1xuICAgICAgICAgICAgICAgIHZhciBvYnRyID0gb2N0Lm5bb3N0XTtcbiAgICAgICAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBvZmMpID4+IDM7XG4gICAgICAgICAgICAgICAgdmFyIG9mcCA9IDEgPDwgb2ZjO1xuICAgICAgICAgICAgICAgIHZhciBvZmYgPSBvZnAgKyAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkgfCAoZGF0W2NidCArIDJdIDw8IDE2KSB8IChkYXRbY2J0ICsgM10gPDwgMjQpKSA+Pj4gKHNwb3MgJiA3KSkgJiAob2ZwIC0gMSkpO1xuICAgICAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG1sYlttbGNdKSA+PiAzO1xuICAgICAgICAgICAgICAgIHZhciBtbCA9IG1sYmxbbWxjXSArICgoKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSB8IChkYXRbY2J0ICsgMl0gPDwgMTYpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBtbGJbbWxjXSkgLSAxKSk7XG4gICAgICAgICAgICAgICAgY2J0ID0gKHNwb3MgLT0gbGxiW2xsY10pID4+IDM7XG4gICAgICAgICAgICAgICAgdmFyIGxsID0gbGxibFtsbGNdICsgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpIHwgKGRhdFtjYnQgKyAyXSA8PCAxNikpID4+IChzcG9zICYgNykpICYgKCgxIDw8IGxsYltsbGNdKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBsYnRyKSA+PiAzO1xuICAgICAgICAgICAgICAgIGxzdCA9IGxsdC50W2xzdF0gKyAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChzcG9zICYgNykpICYgKCgxIDw8IGxidHIpIC0gMSkpO1xuICAgICAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG1idHIpID4+IDM7XG4gICAgICAgICAgICAgICAgbXN0ID0gbWx0LnRbbXN0XSArICgoKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSkgPj4gKHNwb3MgJiA3KSkgJiAoKDEgPDwgbWJ0cikgLSAxKSk7XG4gICAgICAgICAgICAgICAgY2J0ID0gKHNwb3MgLT0gb2J0cikgPj4gMztcbiAgICAgICAgICAgICAgICBvc3QgPSBvY3QudFtvc3RdICsgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBvYnRyKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBpZiAob2ZmID4gMykge1xuICAgICAgICAgICAgICAgICAgICBzdC5vWzJdID0gc3Qub1sxXTtcbiAgICAgICAgICAgICAgICAgICAgc3Qub1sxXSA9IHN0Lm9bMF07XG4gICAgICAgICAgICAgICAgICAgIHN0Lm9bMF0gPSBvZmYgLT0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBvZmYgLSAobGwgIT0gMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZiA9IGlkeCA9PSAzID8gc3Qub1swXSAtIDEgOiBzdC5vW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID4gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdC5vWzJdID0gc3Qub1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0Lm9bMV0gPSBzdC5vWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Qub1swXSA9IG9mZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmYgPSBzdC5vWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW291YnQgKyBpXSA9IGJ1ZltzcGwgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3VidCArPSBsbCwgc3BsICs9IGxsO1xuICAgICAgICAgICAgICAgIHZhciBzdGluID0gb3VidCAtIG9mZjtcbiAgICAgICAgICAgICAgICBpZiAoc3RpbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IC1zdGluO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnMgPSBzdC5lICsgc3RpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IG1sKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gbWw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltvdWJ0ICsgaV0gPSBzdC53W2JzICsgaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3VidCArPSBsZW4sIG1sIC09IGxlbiwgc3RpbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBidWZbb3VidCArIGldID0gYnVmW3N0aW4gKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3VidCArPSBtbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdWJ0ICE9IHNwbCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChzcGwgPCBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltvdWJ0KytdID0gYnVmW3NwbCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3VidCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob3V0KVxuICAgICAgICAgICAgICAgIHN0LnkgKz0gb3VidDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBidWYgPSBzbGMoYnVmLCAwLCBvdWJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgICAgICBzdC55ICs9IGxzcztcbiAgICAgICAgICAgICAgICBpZiAoc3BsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbHNzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltpXSA9IGJ1ZltzcGwgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNwbClcbiAgICAgICAgICAgICAgICBidWYgPSBzbGMoYnVmLCBzcGwpO1xuICAgICAgICB9XG4gICAgICAgIHN0LmIgPSBlYnQ7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIGVycigyKTtcbn07XG4vLyBjb25jYXRcbnZhciBjY3QgPSBmdW5jdGlvbiAoYnVmcywgb2wpIHtcbiAgICBpZiAoYnVmcy5sZW5ndGggPT0gMSlcbiAgICAgICAgcmV0dXJuIGJ1ZnNbMF07XG4gICAgdmFyIGJ1ZiA9IG5ldyB1OChvbCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGIgPSAwOyBpIDwgYnVmcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2hrID0gYnVmc1tpXTtcbiAgICAgICAgYnVmLnNldChjaGssIGIpO1xuICAgICAgICBiICs9IGNoay5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59O1xuLyoqXG4gKiBEZWNvbXByZXNzZXMgWnN0YW5kYXJkIGRhdGFcbiAqIEBwYXJhbSBkYXQgVGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSBidWYgVGhlIG91dHB1dCBidWZmZXIuIElmIHVuc3BlY2lmaWVkLCB0aGUgZnVuY3Rpb24gd2lsbCBhbGxvY2F0ZVxuICogICAgICAgICAgICBleGFjdGx5IGVub3VnaCBtZW1vcnkgdG8gZml0IHRoZSBkZWNvbXByZXNzZWQgZGF0YS4gSWYgeW91clxuICogICAgICAgICAgICBkYXRhIGhhcyBtdWx0aXBsZSBmcmFtZXMgYW5kIHlvdSBrbm93IHRoZSBvdXRwdXQgc2l6ZSwgc3BlY2lmeWluZ1xuICogICAgICAgICAgICBpdCB3aWxsIHlpZWxkIGJldHRlciBwZXJmb3JtYW5jZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgZGF0YVxuICovXG5yZXR1cm4gZnVuY3Rpb24gZGVjb21wcmVzcyhkYXQsIGJ1Zikge1xuICAgIHZhciBidCA9IDAsIGJ1ZnMgPSBbXSwgbmIgPSArIWJ1Ziwgb2wgPSAwO1xuICAgIGZvciAoOyBkYXQubGVuZ3RoOykge1xuICAgICAgICB2YXIgc3QgPSByemZoKGRhdCwgbmIgfHwgYnVmKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKG5iKSB7XG4gICAgICAgICAgICAgICAgYnVmID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3Qudy5sZW5ndGggPT0gc3QudSkge1xuICAgICAgICAgICAgICAgICAgICBidWZzLnB1c2goYnVmID0gc3Qudyk7XG4gICAgICAgICAgICAgICAgICAgIG9sICs9IHN0LnU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmcy5wdXNoKGJ1Zik7XG4gICAgICAgICAgICAgICAgc3QuZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgIXN0Lmw7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsayA9IHJ6YihkYXQsIHN0LCBidWYpO1xuICAgICAgICAgICAgICAgIGlmICghYmxrKVxuICAgICAgICAgICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZilcbiAgICAgICAgICAgICAgICAgICAgc3QuZSA9IHN0Lnk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZnMucHVzaChibGspO1xuICAgICAgICAgICAgICAgICAgICBvbCArPSBibGsubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjcHcoc3QudywgMCwgYmxrLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHN0Lncuc2V0KGJsaywgc3Qudy5sZW5ndGggLSBibGsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidCA9IHN0LmIgKyAoc3QuYyAqIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJ0ID0gc3Q7XG4gICAgICAgIGRhdCA9IGRhdC5zdWJhcnJheShidCk7XG4gICAgfVxuICAgIHJldHVybiBjY3QoYnVmcywgb2wpO1xufVxufSkgKClcblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RlY29tcHJlc3NfaW5wdXRcbi8vVmVyc2lvbjogPCA1LjEuMFxudmFyIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IG51bGxcblxuLy9Qcm92aWRlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG4vL1ZlcnNpb246ID49IDUuMS4wXG4vL1ZlcnNpb246IDwgNS4xLjFcbi8vUmVxdWlyZXM6IHpzdGRfZGVjb21wcmVzc1xudmFyIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IHpzdGRfZGVjb21wcmVzcztcblxuLy9Qcm92aWRlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG4vL1ZlcnNpb246ID49IDUuMS4xXG4vL1ZlcnNpb246IDwgNS4yLjBcbnZhciBjYW1sX2RlY29tcHJlc3NfaW5wdXQgPSBudWxsXG5cbi8vUHJvdmlkZXM6IGNhbWxfZGVjb21wcmVzc19pbnB1dFxuLy9WZXJzaW9uOiA+PSA1LjJcbi8vUmVxdWlyZXM6IHpzdGRfZGVjb21wcmVzc1xudmFyIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IHpzdGRfZGVjb21wcmVzcztcblxuLy9Qcm92aWRlczogY2FtbF96c3RkX2luaXRpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfZGVjb21wcmVzc19pbnB1dFxuLy9SZXF1aXJlczogenN0ZF9kZWNvbXByZXNzXG4vL1ZlcnNpb246ID49IDUuMS4xXG5mdW5jdGlvbiBjYW1sX3pzdGRfaW5pdGlhbGl6ZSh1bml0KSB7XG4gIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IHpzdGRfZGVjb21wcmVzcztcbiAgcmV0dXJuIDFcbn1cblxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIFdlYWsgQVBJXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxudmFyIGNhbWxfZXBoZV9kYXRhX29mZnNldCA9IDJcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHYpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgaWYgKHYgaW5zdGFuY2VvZiBPYmplY3QgJiYgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgaWYoeFsxXS5yZWdpc3RlcikgeFsxXS5yZWdpc3Rlcih2LCB1bmRlZmluZWQsIHYpO1xuICAgIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IG5ldyBnbG9iYWxUaGlzLldlYWtSZWYodik7XG4gIH1cbiAgZWxzZSB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB2O1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgaWYoZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZiAmJiB4WzFdLnVucmVnaXN0ZXIpIHtcbiAgICB2YXIgb2xkID0geFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldLmRlcmVmKCk7XG4gICAgaWYob2xkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb3VudCA9IDBcbiAgICAgIGZvcih2YXIgaiA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0OyBqIDwgeC5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBrZXkgPSB4W2pdO1xuICAgICAgICBpZihrZXkgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYWtSZWYpe1xuICAgICAgICAgIGtleSA9IGtleS5kZXJlZigpXG4gICAgICAgICAgaWYoa2V5ID09PSBvbGQpIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKGNvdW50ID09IDEpIHhbMV0udW5yZWdpc3RlcihvbGQpO1xuICAgIH1cbiAgfVxuICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB1bmRlZmluZWQ7XG4gIHJldHVybiAwXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NyZWF0ZSwgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfY3JlYXRlIChuKSB7XG4gIHZhciB4ID0gY2FtbF93ZWFrX2NyZWF0ZShuKTtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfY3JlYXRlIChuKSB7XG4gIGlmIChuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuY3JlYXRlXCIpO1xuICB2YXIgeCA9IFsyNTEsXCJjYW1sX2VwaGVfbGlzdF9oZWFkXCJdO1xuICB4Lmxlbmd0aCA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgbjtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX3NldF9rZXksIGNhbWxfZXBoZV91bnNldF9rZXlcbmZ1bmN0aW9uIGNhbWxfd2Vha19zZXQoeCwgaSwgdikge1xuICBpZih2ID09IDApIGNhbWxfZXBoZV91bnNldF9rZXkoeCxpKVxuICBlbHNlIGNhbWxfZXBoZV9zZXRfa2V5KHgsaSx2WzFdKVxuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0FsaWFzOiBjYW1sX3dlYWtfZ2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2tleSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfa2V5XCIpO1xuICB2YXIgd2VhayA9IHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpIF07XG4gIGlmKGdsb2JhbFRoaXMuV2Vha1JlZiAmJiB3ZWFrIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmKSB3ZWFrID0gd2Vhay5kZXJlZigpO1xuICByZXR1cm4gKHdlYWs9PT11bmRlZmluZWQpPzA6WzAsIHdlYWtdO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2dldF9rZXksY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0FsaWFzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfa2V5X2NvcHkoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2NvcHlcIik7XG4gIHZhciB5ID0gY2FtbF9lcGhlX2dldF9rZXkoeCwgaSk7XG4gIGlmICh5ID09PSAwKSByZXR1cm4geTtcbiAgdmFyIHogPSB5WzFdO1xuICBpZiAoeiBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh6KV07XG4gIHJldHVybiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfa2V5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL0FsaWFzOiBjYW1sX3dlYWtfY2hlY2tcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19rZXkoeCwgaSkge1xuICB2YXIgd2VhayA9IHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXTtcbiAgaWYoZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHdlYWsgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYWtSZWYpIHdlYWsgPSB3ZWFrLmRlcmVmKCk7XG4gIGlmKHdlYWs9PT11bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL0FsaWFzOiBjYW1sX3dlYWtfYmxpdFxuZnVuY3Rpb24gY2FtbF9lcGhlX2JsaXRfa2V5KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgLy8gbWludXMgb25lIGJlY2F1c2UgY2FtbF9hcnJheV9ibGl0IHdvcmtzIG9uIG9jYW1sIGFycmF5XG4gIGNhbWxfYXJyYXlfYmxpdChhMSwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMSAtIDEsXG4gICAgICAgICAgICAgICAgICBhMiwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMiAtIDEsXG4gICAgICAgICAgICAgICAgICBsZW4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0LCBjYW1sX2VwaGVfc2V0X2RhdGEsIGNhbWxfZXBoZV91bnNldF9kYXRhXG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9kYXRhKHNyYywgZHN0KXtcbiAgdmFyIG4gPSBzcmNbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XTtcbiAgaWYobiA9PT0gdW5kZWZpbmVkKSBjYW1sX2VwaGVfdW5zZXRfZGF0YShkc3QpO1xuICBlbHNlIGNhbWxfZXBoZV9zZXRfZGF0YShkc3QsIG4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cFxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0LCBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfZGF0YSh4LCBkYXRhKXtcbiAgaWYoZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeSAmJiBnbG9iYWxUaGlzLldlYWtSZWYpIHtcbiAgICBpZighICh4WzFdIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeSkpIHtcbiAgICAgIHhbMV0gPSBuZXcgZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeShmdW5jdGlvbiAoKSB7IGNhbWxfZXBoZV91bnNldF9kYXRhKHgpIH0pO1xuICAgICAgLy9yZWdpc3RlciBhbGwga2V5c1xuICAgICAgZm9yKHZhciBqID0gY2FtbF9lcGhlX2tleV9vZmZzZXQ7IGogPCB4Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGtleSA9IHhbal07XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgICAgICAgIGtleSA9IGtleS5kZXJlZigpO1xuICAgICAgICAgIGlmKGtleSkgeFsxXS5yZWdpc3RlcihrZXksIHVuZGVmaW5lZCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBkYXRhO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldCwgY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9kYXRhKHgpe1xuICBpZihnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgIGlmKHhbMV0gaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KXtcbiAgICAgIC8vdW5yZWdpc3RlciBhbGwga2V5c1xuICAgICAgZm9yKHZhciBqID0gY2FtbF9lcGhlX2tleV9vZmZzZXQ7IGogPCB4Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGtleSA9IHhbal07XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgICAgICAgIGtleSA9IGtleS5kZXJlZigpO1xuICAgICAgICAgIGlmKGtleSkgeFsxXS51bnJlZ2lzdGVyKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gdW5kZWZpbmVkO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIDE7XG59XG4iLCJcblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vclxuZnVuY3Rpb24gY2FtbF9nY19taW5vcih1bml0KXtcbiAgLy9hdmFpbGFibGUgd2l0aCBbbm9kZSAtLWV4cG9zZS1nY11cbiAgaWYodHlwZW9mIGdsb2JhbFRoaXMuZ2MgPT0gJ2Z1bmN0aW9uJykgZ2xvYmFsVGhpcy5nYyh0cnVlKTtcbiAgcmV0dXJuIDBcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3IodW5pdCl7XG4gIC8vYXZhaWxhYmxlIHdpdGggW25vZGUgLS1leHBvc2UtZ2NdXG4gIGlmKHR5cGVvZiBnbG9iYWxUaGlzLmdjID09ICdmdW5jdGlvbicpIGdsb2JhbFRoaXMuZ2MoKTtcbiAgcmV0dXJuIDBcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZnVsbF9tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19mdWxsX21ham9yKHVuaXQpe1xuICAvL2F2YWlsYWJsZSB3aXRoIFtub2RlIC0tZXhwb3NlLWdjXVxuICBpZih0eXBlb2YgZ2xvYmFsVGhpcy5nYyA9PSAnZnVuY3Rpb24nKSBnbG9iYWxUaGlzLmdjKCk7XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvbXBhY3Rpb25cbmZ1bmN0aW9uIGNhbWxfZ2NfY29tcGFjdGlvbigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY291bnRlcnNcbmZ1bmN0aW9uIGNhbWxfZ2NfY291bnRlcnMoKSB7IHJldHVybiBbMjU0LDAsMCwwXSB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3F1aWNrX3N0YXRcbi8vVmVyc2lvbjogPj0gNC4xMlxuZnVuY3Rpb24gY2FtbF9nY19xdWlja19zdGF0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfcXVpY2tfc3RhdFxuLy9WZXJzaW9uOiA8IDQuMTJcbmZ1bmN0aW9uIGNhbWxfZ2NfcXVpY2tfc3RhdCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc3RhdFxuLy9SZXF1aXJlczogY2FtbF9nY19xdWlja19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3N0YXQoKSB7XG4gIHJldHVybiBjYW1sX2djX3F1aWNrX3N0YXQoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19zZXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2dldFxuZnVuY3Rpb24gY2FtbF9nY19nZXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3NldFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3RlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3RlciAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWVcbnZhciBhbGxfZmluYWxpemVycyA9IG5ldyBnbG9iYWxUaGlzLlNldCgpXG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIChjYiwgYSkge1xuICBpZihnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICB2YXIgeCA9IG5ldyBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KGZ1bmN0aW9uICh4KXthbGxfZmluYWxpemVycy5kZWxldGUoeCk7IGNiKDApOyByZXR1cm47fSk7XG4gICAgeC5yZWdpc3RlcihhLHgpO1xuICAgIGFsbF9maW5hbGl6ZXJzLmFkZCh4KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWxlYXNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlbGVhc2UgKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RhcnRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdGFydChyYXRlLHN0YWNrX3NpemUsdHJhY2tlcil7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RvcFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0b3AodW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX2Rpc2NhcmRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9kaXNjYXJkKHQpIHsgcmV0dXJuIDAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V2ZW50bG9nX3Jlc3VtZVxuZnVuY3Rpb24gY2FtbF9ldmVudGxvZ19yZXN1bWUodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V2ZW50bG9nX3BhdXNlXG5mdW5jdGlvbiBjYW1sX2V2ZW50bG9nX3BhdXNlKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50XG5mdW5jdGlvbiBjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnQodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21ham9yX3NsaWNlXG5mdW5jdGlvbiBjYW1sX2djX21ham9yX3NsaWNlKHdvcmspIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vcl93b3Jkc1xuZnVuY3Rpb24gY2FtbF9nY19taW5vcl93b3Jkcyh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21pbm9yX2ZyZWVcbmZ1bmN0aW9uIGNhbWxfZ2V0X21pbm9yX2ZyZWUodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9tYWpvcl9idWNrZXRcbmZ1bmN0aW9uIGNhbWxfZ2V0X21ham9yX2J1Y2tldChuKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21ham9yX2NyZWRpdFxuZnVuY3Rpb24gY2FtbF9nZXRfbWFqb3JfY3JlZGl0KG4pIHsgcmV0dXJuIDA7IH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRm9ybWF0XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZm9ybWF0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZm9ybWF0IChmbXQpIHtcbiAgZm10ID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpO1xuICB2YXIgbGVuID0gZm10Lmxlbmd0aDtcbiAgaWYgKGxlbiA+IDMxKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJmb3JtYXRfaW50OiBmb3JtYXQgdG9vIGxvbmdcIik7XG4gIHZhciBmID1cbiAgICAgIHsganVzdGlmeTonKycsIHNpZ25zdHlsZTonLScsIGZpbGxlcjonICcsIGFsdGVybmF0ZTpmYWxzZSxcbiAgICAgICAgYmFzZTowLCBzaWduZWRjb252OmZhbHNlLCB3aWR0aDowLCB1cHBlcmNhc2U6ZmFsc2UsXG4gICAgICAgIHNpZ246MSwgcHJlYzotMSwgY29udjonZicgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gZm10LmNoYXJBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlICctJzpcbiAgICAgIGYuanVzdGlmeSA9ICctJzsgYnJlYWs7XG4gICAgY2FzZSAnKyc6IGNhc2UgJyAnOlxuICAgICAgZi5zaWduc3R5bGUgPSBjOyBicmVhaztcbiAgICBjYXNlICcwJzpcbiAgICAgIGYuZmlsbGVyID0gJzAnOyBicmVhaztcbiAgICBjYXNlICcjJzpcbiAgICAgIGYuYWx0ZXJuYXRlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnMSc6IGNhc2UgJzInOiBjYXNlICczJzogY2FzZSAnNCc6IGNhc2UgJzUnOlxuICAgIGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgZi53aWR0aCA9IDA7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYud2lkdGggPSBmLndpZHRoICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJy4nOlxuICAgICAgZi5wcmVjID0gMDtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi5wcmVjID0gZi5wcmVjICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICBjYXNlICdkJzogY2FzZSAnaSc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3UnOlxuICAgICAgZi5iYXNlID0gMTA7IGJyZWFrO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgZi5iYXNlID0gMTY7IGJyZWFrO1xuICAgIGNhc2UgJ1gnOlxuICAgICAgZi5iYXNlID0gMTY7IGYudXBwZXJjYXNlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnbyc6XG4gICAgICBmLmJhc2UgPSA4OyBicmVhaztcbiAgICBjYXNlICdlJzogY2FzZSAnZic6IGNhc2UgJ2cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi5jb252ID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnRSc6IGNhc2UgJ0YnOiBjYXNlICdHJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYudXBwZXJjYXNlID0gdHJ1ZTtcbiAgICAgIGYuY29udiA9IGMudG9Mb3dlckNhc2UgKCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCByYXdidWZmZXIpIHtcbiAgaWYgKGYudXBwZXJjYXNlKSByYXdidWZmZXIgPSByYXdidWZmZXIudG9VcHBlckNhc2UoKTtcbiAgdmFyIGxlbiA9IHJhd2J1ZmZlci5sZW5ndGg7XG4gIC8qIEFkanVzdCBsZW4gdG8gcmVmbGVjdCBhZGRpdGlvbmFsIGNoYXJzIChzaWduLCBldGMpICovXG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgKGYuc2lnbiA8IDAgfHwgZi5zaWduc3R5bGUgIT0gJy0nKSkgbGVuKys7XG4gIGlmIChmLmFsdGVybmF0ZSkge1xuICAgIGlmIChmLmJhc2UgPT0gOCkgbGVuICs9IDE7XG4gICAgaWYgKGYuYmFzZSA9PSAxNikgbGVuICs9IDI7XG4gIH1cbiAgLyogRG8gdGhlIGZvcm1hdHRpbmcgKi9cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcgJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICBpZiAoZi5zaWduZWRjb252KSB7XG4gICAgaWYgKGYuc2lnbiA8IDApIGJ1ZmZlciArPSAnLSc7XG4gICAgZWxzZSBpZiAoZi5zaWduc3R5bGUgIT0gJy0nKSBidWZmZXIgKz0gZi5zaWduc3R5bGU7XG4gIH1cbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSA4KSBidWZmZXIgKz0gJzAnO1xuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDE2KSBidWZmZXIgKz0gZi51cHBlcmNhc2U/XCIwWFwiOlwiMHhcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJzAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnMCc7XG4gIGJ1ZmZlciArPSByYXdidWZmZXI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJy0nKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGJ1ZmZlcik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSHVnbyBIZXV6YXJkXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlXG52YXIgY2FtbF9ncl9zdGF0ZTtcblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9nZXQoKSB7XG4gIGlmKGNhbWxfZ3Jfc3RhdGUpIHtcbiAgICByZXR1cm4gY2FtbF9ncl9zdGF0ZTtcbiAgfVxuICB0aHJvdyBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UoWzAsY2FtbF9uYW1lZF92YWx1ZShcIkdyYXBoaWNzLkdyYXBoaWNfZmFpbHVyZVwiKSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIk5vdCBpbml0aWFsaXplZFwiKV0pO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGUsY2FtbF9ncl9zdGF0ZV9pbml0XG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX3NldChjdHgpIHtcbiAgY2FtbF9ncl9zdGF0ZT1jdHg7XG4gIGNhbWxfZ3Jfc3RhdGVfaW5pdCgpXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX29wZW5fZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9ncmFwaChpbmZvKXtcbiAgdmFyIGluZm8gPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhpbmZvKTtcbiAgZnVuY3Rpb24gZ2V0KG5hbWUpe1xuICAgIHZhciByZXMgPSBpbmZvLm1hdGNoKFwiKF58LCkgKlwiK25hbWUrXCIgKj0gKihbYS16QS1aMC05X10rKSAqKCx8JClcIik7XG4gICAgaWYocmVzKSByZXR1cm4gcmVzWzJdO1xuICB9XG4gIHZhciBzcGVjcyA9IFtdO1xuICBpZighKGluZm89PVwiXCIpKSBzcGVjcy5wdXNoKGluZm8pO1xuICB2YXIgdGFyZ2V0ID0gZ2V0KFwidGFyZ2V0XCIpO1xuICBpZighdGFyZ2V0KSB0YXJnZXQ9XCJcIjtcbiAgdmFyIHN0YXR1cyA9IGdldChcInN0YXR1c1wiKTtcbiAgaWYoIXN0YXR1cykgc3BlY3MucHVzaChcInN0YXR1cz0xXCIpXG5cbiAgdmFyIHcgPSBnZXQoXCJ3aWR0aFwiKTtcbiAgdyA9IHc/cGFyc2VJbnQodyk6MjAwO1xuICBzcGVjcy5wdXNoKFwid2lkdGg9XCIrdyk7XG5cbiAgdmFyIGggPSBnZXQoXCJoZWlnaHRcIik7XG4gIGggPSBoP3BhcnNlSW50KGgpOjIwMDtcbiAgc3BlY3MucHVzaChcImhlaWdodD1cIitoKTtcblxuICB2YXIgd2luID0gZ2xvYmFsVGhpcy5vcGVuKFwiYWJvdXQ6YmxhbmtcIix0YXJnZXQsc3BlY3Muam9pbihcIixcIikpO1xuICBpZighd2luKSB7Y2FtbF9mYWlsd2l0aChcIkdyYXBoaWNzLm9wZW5fZ3JhcGg6IGNhbm5vdCBvcGVuIHRoZSB3aW5kb3dcIil9XG4gIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gIHZhciBjYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgY2FudmFzLndpZHRoID0gdztcbiAgY2FudmFzLmhlaWdodCA9IGg7XG4gIHZhciBjdHggPSBjYW1sX2dyX3N0YXRlX2NyZWF0ZShjYW52YXMsdyxoKTtcbiAgY3R4LnNldF90aXRsZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xuICAgIGRvYy50aXRsZSA9IHRpdGxlO1xuICB9O1xuICBjYW1sX2dyX3N0YXRlX3NldChjdHgpO1xuICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICBib2R5LnN0eWxlLm1hcmdpbiA9IFwiMHB4XCI7XG4gIGJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfaW5pdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfY29sb3IsY2FtbF9ncl9tb3ZldG8sY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF9saW5lX3dpZHRoLGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZSxjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfaW5pdCgpe1xuICBjYW1sX2dyX21vdmV0byhjYW1sX2dyX3N0YXRlLngsY2FtbF9ncl9zdGF0ZS55KTtcbiAgY2FtbF9ncl9yZXNpemVfd2luZG93KGNhbWxfZ3Jfc3RhdGUud2lkdGgsY2FtbF9ncl9zdGF0ZS5oZWlnaHQpO1xuICBjYW1sX2dyX3NldF9saW5lX3dpZHRoKGNhbWxfZ3Jfc3RhdGUubGluZV93aWR0aCk7XG4gIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShjYW1sX2dyX3N0YXRlLnRleHRfc2l6ZSk7XG4gIGNhbWxfZ3Jfc2V0X2ZvbnQoY2FtbF9ncl9zdGF0ZS5mb250KTtcbiAgY2FtbF9ncl9zZXRfY29sb3IoY2FtbF9ncl9zdGF0ZS5jb2xvcik7XG4gIGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZShjYW1sX2dyX3N0YXRlLnRpdGxlKTtcbiAgLy9jYW1sX2dyX3Jlc2l6ZV93aW5kb3cgbWlnaHQgcmVzZXQgc29tZSBjYW52YXMnIHByb3BlcnRpZXNcbiAgY2FtbF9ncl9zdGF0ZS5jb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLHcsaCl7XG4gIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGNhbnZhcyA6IGNhbnZhcyxcbiAgICB4IDogMCxcbiAgICB5IDogMCxcbiAgICB3aWR0aCA6IHcsXG4gICAgaGVpZ2h0IDogaCxcbiAgICBsaW5lX3dpZHRoIDogMSxcbiAgICBmb250IDogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcImZpeGVkXCIpLFxuICAgIHRleHRfc2l6ZSA6IDI2LFxuICAgIGNvbG9yIDogMHgwMDAwMDAsXG4gICAgdGl0bGUgOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpXG4gIH07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZG9jX29mX3N0YXRlXG5mdW5jdGlvbiBjYW1sX2dyX2RvY19vZl9zdGF0ZShzdGF0ZSkge1xuICBpZihzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudClcbiAgICByZXR1cm4gc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2VfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX2dyYXBoKCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSAwO1xuICBzLmNhbnZhcy5oZWlnaHQgPSAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZShuYW1lKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRpdGxlID0gbmFtZTtcbiAgdmFyIGpzbmFtZSA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICBpZihzLnNldF90aXRsZSkgcy5zZXRfdGl0bGUoanNuYW1lKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcmVzaXplX3dpbmRvdyh3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KClcbiAgcy53aWR0aCA9IHc7XG4gIHMuaGVpZ2h0ID0gaDtcbiAgcy5jYW52YXMud2lkdGggPSB3O1xuICBzLmNhbnZhcy5oZWlnaHQgPSBoO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbGVhcl9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xlYXJfZ3JhcGgoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gIHMuY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAvLyAgcy5jb250ZXh0LnN0cm9rZVJlY3QgKDAuLCAwLiwgcy53aWR0aCwgcy5oZWlnaHQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zaXplX3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NpemVfeCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLndpZHRoO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaXplX3lcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NpemVfeSgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmhlaWdodDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2NvbG9yKGNvbG9yKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBmdW5jdGlvbiBjb252ZXJ0KG51bWJlcikge1xuICAgIHZhciBzdHIgPSAnJyArIG51bWJlci50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCAyKSBzdHIgPSAnMCcgKyBzdHI7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICB2YXJcbiAgciA9IChjb2xvciA+PiAxNikgJiAweGZmLFxuICBnID0gKGNvbG9yID4+IDgpICAmIDB4ZmYsXG4gIGIgPSAoY29sb3IgPj4gMCkgICYgMHhmZjtcbiAgcy5jb2xvcj1jb2xvcjtcbiAgdmFyIGNfc3RyID0gJyMnICsgY29udmVydChyKSArIGNvbnZlcnQoZykgKyBjb252ZXJ0KGIpO1xuICBzLmNvbnRleHQuZmlsbFN0eWxlID0gICBjX3N0cjtcbiAgcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gY19zdHI7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9wbG90XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9wbG90KHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltPXMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoMSwxKTtcbiAgdmFyIGQgPSBpbS5kYXRhO1xuICB2YXIgY29sb3IgPSBzLmNvbG9yO1xuICBkWzBdID0gKGNvbG9yID4+IDE2KSAmIDB4ZmY7IC8vclxuICBkWzFdID0gKGNvbG9yID4+IDgpICAmIDB4ZmYsIC8vZ1xuICBkWzJdID0gKGNvbG9yID4+IDApICAmIDB4ZmY7IC8vYlxuICBkWzNdID0gMHhGRjsgLy9hXG4gIHMueD14O1xuICBzLnk9eTtcbiAgcy5jb250ZXh0LnB1dEltYWdlRGF0YShpbSx4LHMuaGVpZ2h0IC0geSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3BvaW50X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9wb2ludF9jb2xvcih4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbT1zLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKHgscy5oZWlnaHQgLSB5LDEsMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgcmV0dXJuIChkWzBdIDw8IDE2KSArIChkWzFdIDw8IDgpICsgZFsyXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbW92ZXRvXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9tb3ZldG8oeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLng9eDtcbiAgcy55PXk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2N1cnJlbnRfeFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3VycmVudF94KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueFxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3lcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeSgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLnlcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbGluZXRvXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9saW5ldG8oeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8ocy54LHMuaGVpZ2h0IC0gcy55KTtcbiAgcy5jb250ZXh0LmxpbmVUbyh4LHMuaGVpZ2h0IC0geSk7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcy54PXg7XG4gIHMueT15O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19yZWN0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3JlY3QoeCx5LHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LnN0cm9rZVJlY3QoeCxzLmhlaWdodCAtIHksdywtaCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfYXJjX2F1eChjdHgsY3gsY3kscnkscngsYTEsYTIpe1xuICB3aGlsZShhMT5hMikgYTIrPTM2MDtcbiAgYTEgLz0gMTgwO1xuICBhMiAvPSAxODA7XG4gIHZhciByb3QgPSAwLHhQb3MseVBvcyx4UG9zX3ByZXYseVBvc19wcmV2O1xuICB2YXIgc3BhY2UgPSAyO1xuICB2YXIgbnVtID0gKCgoYTIgLSBhMSkgKiBNYXRoLlBJICogKChyeCtyeSkvMikpIC8gc3BhY2UpIHwgMDtcbiAgdmFyIGRlbHRhID0gKGEyIC0gYTEpICogTWF0aC5QSSAvIG51bTtcbiAgdmFyIGkgPSBhMSAqIE1hdGguUEk7XG4gIGZvciAodmFyIGo9MDtqPD1udW07aisrKXtcbiAgICB4UG9zID0gY3ggLSAocnggKiBNYXRoLnNpbihpKSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArIChyeSAqIE1hdGguY29zKGkpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHhQb3MgPSB4UG9zLnRvRml4ZWQoMik7XG4gICAgeVBvcyA9IGN5ICsgKHJ5ICogTWF0aC5jb3MoaSkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgKyAocnggKiBNYXRoLnNpbihpKSkgKiBNYXRoLmNvcyhyb3QgKiBNYXRoLlBJKTtcbiAgICB5UG9zID0geVBvcy50b0ZpeGVkKDIpO1xuICAgIGlmIChqPT0wKSB7XG4gICAgICBjdHgubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgIH0gZWxzZSBpZiAoeFBvc19wcmV2IT14UG9zIHx8IHlQb3NfcHJldiE9eVBvcyl7XG4gICAgICBjdHgubGluZVRvKHhQb3MsIHlQb3MpO1xuICAgIH1cbiAgICB4UG9zX3ByZXY9eFBvcztcbiAgICB5UG9zX3ByZXY9eVBvcztcbiAgICBpLT0gZGVsdGE7Ly9jY3dcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfYXJjXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldCwgY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfYXJjKHgseSxyeCxyeSxhMSxhMil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjYW1sX2dyX2FyY19hdXgocy5jb250ZXh0LHgscy5oZWlnaHQgLSB5LHJ4LHJ5LGExLGEyKTtcbiAgcy5jb250ZXh0LnN0cm9rZSgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgodyl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5saW5lX3dpZHRoID0gdztcbiAgcy5jb250ZXh0LmxpbmVXaWR0aCA9IHdcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9yZWN0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX3JlY3QoeCx5LHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmZpbGxSZWN0KHgscy5oZWlnaHQgLSB5LHcsLWgpO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9wb2x5XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX3BvbHkoYXIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcy5jb250ZXh0Lm1vdmVUbyhhclsxXVsxXSxzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgZm9yKHZhciBpID0gMjsgaSA8IGFyLmxlbmd0aDsgaSsrKVxuICAgIHMuY29udGV4dC5saW5lVG8oYXJbaV1bMV0scy5oZWlnaHQgLSBhcltpXVsyXSk7XG4gIHMuY29udGV4dC5saW5lVG8oYXJbMV1bMV0scy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfYXJjXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldCwgY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfYXJjKHgseSxyeCxyeSxhMSxhMil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjYW1sX2dyX2FyY19hdXgocy5jb250ZXh0LHgscy5oZWlnaHQgLSB5LHJ4LHJ5LGExLGEyKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyKHN0cil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIG0gPSBzLmNvbnRleHQubWVhc3VyZVRleHQoc3RyKTtcbiAgdmFyIGR4ID0gbS53aWR0aDtcbiAgcy5jb250ZXh0LmZpbGxUZXh0KHN0cixzLngscy5oZWlnaHQgLSBzLnkpO1xuICBzLnggKz0gZHggfCAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19jaGFyKGMpe1xuICBjYW1sX2dyX2RyYXdfc3RyKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHJpbmcoc3RyKXtcbiAgY2FtbF9ncl9kcmF3X3N0cihjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzdHIpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2ZvbnRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfZm9udChmKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmZvbnQgPSBmO1xuICBzLmNvbnRleHQuZm9udCA9IHMudGV4dF9zaXplICsgXCJweCBcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMuZm9udCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF90ZXh0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfdGV4dF9zaXplKHNpemUpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMudGV4dF9zaXplID0gc2l6ZTtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl90ZXh0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl90ZXh0X3NpemUodHh0KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgdyA9IHMuY29udGV4dC5tZWFzdXJlVGV4dChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh0eHQpKS53aWR0aDtcbiAgcmV0dXJuIFswLHcscy50ZXh0X3NpemVdO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbWFrZV9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbWFrZV9pbWFnZShhcnIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBoID0gYXJyLmxlbmd0aCAtIDEgO1xuICB2YXIgdyA9IGFyclsxXS5sZW5ndGggLSAxO1xuICB2YXIgaW0gPSBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHcsaCk7XG4gIGZvcih2YXIgaT0wO2k8aDtpKyspe1xuICAgIGZvcih2YXIgaj0wO2o8dztqKyspe1xuICAgICAgdmFyIGMgPSBhcnJbaSsxXVtqKzFdO1xuICAgICAgdmFyIG8gPSBpKih3KjQpICsgKGogKiA0KTtcbiAgICAgIGlmKGMgPT0gLTEpIHtcbiAgICAgICAgaW0uZGF0YVtvICsgMF0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgM10gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW0uZGF0YVtvICsgMF0gPSBjID4+IDE2ICYgMHhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgMV0gPSBjID4+ICA4ICYgMHhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSBjID4+ICAwICYgMFhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgM10gPSAweGZmO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHVtcF9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHVtcF9pbWFnZShpbSl7XG4gIHZhciBkYXRhID0gWzBdXG4gIGZvcih2YXIgaT0wOyBpPGltLmhlaWdodDtpKyspe1xuICAgIGRhdGFbaSsxXSA9IFswXVxuICAgIGZvcih2YXIgaj0wOyBqPGltLndpZHRoO2orKyl7XG4gICAgICB2YXIgbyA9IGkqKGltLndpZHRoKjQpICsgKGogKiA0KSxcbiAgICAgICAgICByID0gaW0uZGF0YVtvKzBdLFxuICAgICAgICAgIGcgPSBpbS5kYXRhW28rMV0sXG4gICAgICAgICAgYiA9IGltLmRhdGFbbysyXTtcbiAgICAgIGRhdGFbaSsxXVtqKzFdID0gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiXG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfaW1hZ2UoaW0seCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBpZighaW0uaW1hZ2UpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSBzLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgICBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnB1dEltYWdlRGF0YShpbSwwLDApO1xuICAgIHZhciBpbWFnZSA9IG5ldyBnbG9iYWxUaGlzLkltYWdlKCk7XG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gICAgICBpbS5pbWFnZSA9IGltYWdlO1xuICAgIH1cbiAgICBpbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICB9IGVsc2Uge1xuICAgIHMuY29udGV4dC5kcmF3SW1hZ2UoaW0uaW1hZ2UseCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jcmVhdGVfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NyZWF0ZV9pbWFnZSh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHgseSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2JsaXRfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2JsaXRfaW1hZ2UoaW0seCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW0yID0gcy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSxpbS53aWR0aCxpbS5oZWlnaHQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGltMi5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgaW0uZGF0YVtpXSA9IGltMi5kYXRhW2ldO1xuICAgIGltLmRhdGFbaSsxXSA9IGltMi5kYXRhW2krMV07XG4gICAgaW0uZGF0YVtpKzJdID0gaW0yLmRhdGFbaSsyXTtcbiAgICBpbS5kYXRhW2krM10gPSBpbTIuZGF0YVtpKzNdO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19oYW5kbGVyXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXIoKXtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2lnaW9fc2lnbmFsXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX3NpZ25hbCgpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl93YWl0X2V2ZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dhaXRfZXZlbnQoX2V2bCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dhaXRfZXZlbnQgbm90IEltcGxlbWVudGVkOiB1c2UgR3JhcGhpY3NfanMgaW5zdGVhZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zeW5jaHJvbml6ZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9zeW5jaHJvbml6ZSAoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3N5bmNocm9uaXplIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVtZW1iZXJfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9yZW1lbWJlcl9tb2RlICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Rpc3BsYXlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9kaXNwbGF5X21vZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2luZG93X2lkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dpbmRvd19pZChhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dpbmRvd19pZCBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3coYSxiLGMsZCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9vcGVuX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyhhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWI6IGNvZGUgc3BlY2lmaWMgdG8gSnNfb2Zfb2NhbWxcblxuLy9Qcm92aWRlczogY2FtbF9qc19vbl9pZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19vbl9pZSAoKSB7XG4gIHZhciB1YSA9XG4gICAgICAoZ2xvYmFsVGhpcy5uYXZpZ2F0b3ImJmdsb2JhbFRoaXMubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgID9nbG9iYWxUaGlzLm5hdmlnYXRvci51c2VyQWdlbnQ6XCJcIjtcbiAgcmV0dXJuIHVhLmluZGV4T2YoXCJNU0lFXCIpICE9IC0xICYmIHVhLmluZGV4T2YoXCJPcGVyYVwiKSAhPSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZXNjYXBlIGNvbnN0IChjb25zdClcbnZhciBjYW1sX2pzX3JlZ2V4cHMgPSB7IGFtcDovJi9nLCBsdDovPC9nLCBxdW90Oi9cXFwiL2csIGFsbDovWyY8XFxcIl0vIH07XG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZXNjYXBlIChzKSB7XG4gIGlmICghY2FtbF9qc19yZWdleHBzLmFsbC50ZXN0KHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIHMucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMuYW1wLCBcIiZhbXA7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmx0LCBcIiZsdDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMucXVvdCwgXCImcXVvdDtcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lbnRpdGllc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VudGl0aWVzKHMpIHtcbiAgdmFyIGVudGl0eSA9IC9eJiM/WzAtOWEtekEtWl0rOyQvXG4gIGlmKHMubWF0Y2goZW50aXR5KSlcbiAge1xuICAgIHZhciBzdHIsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgdGVtcC5pbm5lckhUTUw9IHM7XG4gICAgc3RyPSB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0O1xuICAgIHRlbXA9bnVsbDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJJbnZhbGlkIGVudGl0eSBcIiArIHMpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0X2NvbnNvbGUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0X2NvbnNvbGUgKCkge1xuICB2YXIgYyA9IGNvbnNvbGU7XG4gIHZhciBtID0gW1wibG9nXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwiYXNzZXJ0XCIsIFwiZGlyXCIsIFwiZGlyeG1sXCIsXG4gICAgICAgICAgIFwidHJhY2VcIiwgXCJncm91cFwiLCBcImdyb3VwQ29sbGFwc2VkXCIsIFwiZ3JvdXBFbmRcIiwgXCJ0aW1lXCIsIFwidGltZUVuZFwiXTtcbiAgZnVuY3Rpb24gZiAoKSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIGlmICghY1ttW2ldXSkgY1ttW2ldXT1mO1xuICByZXR1cm4gYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGUodW5pdCl7XG4gIGlmKHR5cGVvZiBnbG9iYWxUaGlzLlhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZ2xvYmFsVGhpcy5YTUxIdHRwUmVxdWVzdCB9IGNhdGNoIChlKSB7IH07XG4gIH1cbiAgaWYodHlwZW9mIGdsb2JhbFRoaXMuYWN0aXZlWE9iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGdsb2JhbFRoaXMuYWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLmFjdGl2ZVhPYmplY3QoXCJNc3htbDMuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICAgIHRyeSB7IHJldHVybiBuZXcgZ2xvYmFsVGhpcy5hY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgfVxuICBjYW1sX2ZhaWx3aXRoKFwiQ2Fubm90IGNyZWF0ZSBhIFhNTEh0dHBSZXF1ZXN0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24oZXhuKSB7XG4gIGlmKGV4bi5qc19lcnJvcikgeyByZXR1cm4gZXhuLmpzX2Vycm9yOyB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IGxleGluZy5jIDYwNDUgMjAwNC0wMS0wMSAxNjo0Mjo0M1ogZG9saWdleiAkICovXG5cbi8qIFRoZSB0YWJsZS1kcml2ZW4gYXV0b21hdG9uIGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXguICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9hcnJheShzKSB7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpO1xuICB2YXIgbCA9IHMubGVuZ3RoIC8gMjtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgIGFbaV0gPSAocy5jaGFyQ29kZUF0KDIgKiBpKSB8IChzLmNoYXJDb2RlQXQoMiAqIGkgKyAxKSA8PCA4KSkgPDwgMTYgPj4gMTY7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5LCBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHJldHVybiAtYmFzZS0xO1xuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogTmV3IGxleGVyIGVuZ2luZSwgd2l0aCBtZW1vcnkgb2YgcG9zaXRpb25zICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX21lbShzLCBpLCBtZW0sIGN1cnJfcG9zKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm47XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBjdXJyX3BvcztcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fdGFnKHMsIGksIG1lbSkge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuIDtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IC0xO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbmV3X2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9tZW0gPSAxMDtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuICB2YXIgbGV4X2Jhc2VfY29kZSA9IDY7XG4gIHZhciBsZXhfYmFja3Rya19jb2RlID0gNztcbiAgdmFyIGxleF9kZWZhdWx0X2NvZGUgPSA4O1xuICB2YXIgbGV4X3RyYW5zX2NvZGUgPSA5O1xuICB2YXIgbGV4X2NoZWNrX2NvZGUgPSAxMDtcbiAgdmFyIGxleF9jb2RlID0gMTE7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHRfY29kZSkge1xuICAgIHRibC5sZXhfYmFzZV9jb2RlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV9jb2RlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrX2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrX2NvZGVdKTtcbiAgICB0YmwubGV4X2NoZWNrX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrX2NvZGVdKTtcbiAgICB0YmwubGV4X3RyYW5zX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zX2NvZGVdKTtcbiAgICB0YmwubGV4X2RlZmF1bHRfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRfY29kZV0pO1xuICB9XG4gIGlmICh0YmwubGV4X2NvZGUgPT0gbnVsbCkgdGJsLmxleF9jb2RlID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0YmxbbGV4X2NvZGVdKTtcblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFzZV9jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICByZXR1cm4gLWJhc2UtMTtcbiAgICB9XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFja3Rya19jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIHZhciBwc3RhdGUgPSBzdGF0ZSA7XG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBJZiBzb21lIHRyYW5zaXRpb24sIGdldCBhbmQgcGVyZm9ybSBtZW1vcnkgbW92ZXMgKi9cbiAgICAgIHZhciBiYXNlX2NvZGUgPSB0YmwubGV4X2Jhc2VfY29kZVtwc3RhdGVdLCBwY19vZmY7XG4gICAgICBpZiAodGJsLmxleF9jaGVja19jb2RlW2Jhc2VfY29kZSArIGNdID09IHBzdGF0ZSlcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF90cmFuc19jb2RlW2Jhc2VfY29kZSArIGNdO1xuICAgICAgZWxzZVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X2RlZmF1bHRfY29kZVtwc3RhdGVdO1xuICAgICAgaWYgKHBjX29mZiA+IDApXG4gICAgICAgIGNhbWxfbGV4X3J1bl9tZW1cbiAgICAgICh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dLCBsZXhidWZbbGV4X2N1cnJfcG9zXSk7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cbiIsIlxuLy9Qcm92aWRlczogY2FtbF9seG1fbmV4dFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3hvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbXVsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NldF8xXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2x4bV9uZXh0KHYpIHtcbiAgZnVuY3Rpb24gc2hpZnRfbCh4LCBrKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0KHgsayk7XG4gIH1cbiAgZnVuY3Rpb24gc2hpZnRfcih4LCBrKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LGspO1xuICB9XG4gIGZ1bmN0aW9uIG9yKGEsIGIpe1xuICAgIHJldHVybiBjYW1sX2ludDY0X29yKGEsYik7XG4gIH1cbiAgZnVuY3Rpb24geG9yKGEsIGIpe1xuICAgIHJldHVybiBjYW1sX2ludDY0X3hvcihhLGIpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZChhLCBiKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9hZGQoYSxiKTtcbiAgfVxuICBmdW5jdGlvbiBtdWwoYSwgYil7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfbXVsKGEsYik7XG4gIH1cbiAgZnVuY3Rpb24gcm90bCh4LCBrKSB7XG4gICAgcmV0dXJuIG9yKHNoaWZ0X2woeCxrKSxzaGlmdF9yICh4LCA2NCAtIGspKTtcbiAgfVxuICBmdW5jdGlvbiBnZXQoYSwgaSkge1xuICAgIHJldHVybiBjYW1sX2JhX2dldF8xKGEsIGkpO1xuICB9XG4gIGZ1bmN0aW9uIHNldChhLCBpLCB4KSB7XG4gICAgcmV0dXJuIGNhbWxfYmFfc2V0XzEoYSwgaSwgeCk7XG4gIH1cbiAgdmFyIE0gPSBjYW1sX2ludDY0X29mX3N0cmluZyhjYW1sX25ld19zdHJpbmcoXCIweGQxMzQyNTQzZGU4MmVmOTVcIikpO1xuICB2YXIgZGFiYSA9IGNhbWxfaW50NjRfb2Zfc3RyaW5nKGNhbWxfbmV3X3N0cmluZyhcIjB4ZGFiYTBiNmViMDkzMjJlM1wiKSk7XG4gIHZhciB6LCBxMCwgcTE7XG4gIHZhciBzdCA9IHY7XG4gIHZhciBhID0gZ2V0KHN0LDApO1xuICB2YXIgcyA9IGdldChzdCwxKTtcbiAgdmFyIHgwID0gZ2V0KHN0LDIpO1xuICB2YXIgeDEgPSBnZXQoc3QsMyk7XG4gIC8qIENvbWJpbmluZyBvcGVyYXRpb24gKi9cbiAgeiA9IGFkZChzLCB4MCk7XG4gIC8qIE1peGluZyBmdW5jdGlvbiAqL1xuICB6ID0gbXVsKHhvcih6LHNoaWZ0X3IoeiwzMikpLCBkYWJhKTtcbiAgeiA9IG11bCh4b3IoeixzaGlmdF9yKHosMzIpKSwgZGFiYSk7XG4gIHogPSB4b3IoeixzaGlmdF9yKHosMzIpKTtcbiAgLyogTENHIHVwZGF0ZSAqL1xuICBzZXQoc3QsIDEsIGFkZCAobXVsKHMsTSksIGEpKTtcbiAgLyogWEJHIHVwZGF0ZSAqL1xuICB2YXIgcTAgPSB4MFxuICB2YXIgcTEgPSB4MVxuICBxMSA9IHhvcihxMSxxMCk7XG4gIHEwID0gcm90bChxMCwgMjQpO1xuICBxMCA9IHhvcih4b3IocTAsIHExKSwgKHNoaWZ0X2wocTEsMTYpKSk7XG4gIHExID0gcm90bChxMSwgMzcpO1xuICBzZXQoc3QsIDIsIHEwKTtcbiAgc2V0KHN0LCAzLCBxMSk7XG4gIC8qIFJldHVybiByZXN1bHQgKi9cbiAgcmV0dXJuIHo7XG59XG4iLCIvL1Byb3ZpZGVzOiBjYW1sX29qc193cmFwX2Z1bl9hcmd1bWVudHNcbi8vUmVxdWlyZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9vanNfd3JhcF9mdW5fYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjYW1sX2pzX3dyYXBfY2FsbGJhY2soZikoYXJndW1lbnRzKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29qc19pdGVyYXRlX3Byb3BlcnRpZXNcbi8vUmVxdWlyZXM6IGNhbWxfanNfdG9fc3RyaW5nXG5mdW5jdGlvbiBjYW1sX29qc19pdGVyYXRlX3Byb3BlcnRpZXMobywgZikge1xuICB2YXIgbmFtZTtcbiAgZm9yKG5hbWUgaW4gbykge1xuICAgIGlmKG8uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGYobmFtZSk7XG4gICAgfVxuICB9XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogcGFyc2luZy5jIDg5ODMgMjAwOC0wOC0wNiAwOTozODoyNVogeGxlcm95ICQgKi9cblxuLyogVGhlIFBEQSBhdXRvbWF0b24gZm9yIHBhcnNlcnMgZ2VuZXJhdGVkIGJ5IGNhbWx5YWNjICovXG5cbi8qIFRoZSBwdXNoZG93biBhdXRvbWF0YSAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlcl90cmFjZVxudmFyIGNhbWxfcGFyc2VyX3RyYWNlID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfbGV4X2FycmF5LCBjYW1sX3BhcnNlcl90cmFjZSxjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9wYXJzZV9lbmdpbmUodGFibGVzLCBlbnYsIGNtZCwgYXJnKVxue1xuICB2YXIgRVJSQ09ERSA9IDI1NjtcblxuICAvL3ZhciBTVEFSVCA9IDA7XG4gIC8vdmFyIFRPS0VOX1JFQUQgPSAxO1xuICAvL3ZhciBTVEFDS1NfR1JPV05fMSA9IDI7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8yID0gMztcbiAgLy92YXIgU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEID0gNDtcbiAgLy92YXIgRVJST1JfREVURUNURUQgPSA1O1xuICB2YXIgbG9vcCA9IDY7XG4gIHZhciB0ZXN0c2hpZnQgPSA3O1xuICB2YXIgc2hpZnQgPSA4O1xuICB2YXIgc2hpZnRfcmVjb3ZlciA9IDk7XG4gIHZhciByZWR1Y2UgPSAxMDtcblxuICB2YXIgUkVBRF9UT0tFTiA9IDA7XG4gIHZhciBSQUlTRV9QQVJTRV9FUlJPUiA9IDE7XG4gIHZhciBHUk9XX1NUQUNLU18xID0gMjtcbiAgdmFyIEdST1dfU1RBQ0tTXzIgPSAzO1xuICB2YXIgQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04gPSA0O1xuICB2YXIgQ0FMTF9FUlJPUl9GVU5DVElPTiA9IDU7XG5cbiAgdmFyIGVudl9zX3N0YWNrID0gMTtcbiAgdmFyIGVudl92X3N0YWNrID0gMjtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0X3N0YWNrID0gMztcbiAgdmFyIGVudl9zeW1iX2VuZF9zdGFjayA9IDQ7XG4gIHZhciBlbnZfc3RhY2tzaXplID0gNTtcbiAgdmFyIGVudl9zdGFja2Jhc2UgPSA2O1xuICB2YXIgZW52X2N1cnJfY2hhciA9IDc7XG4gIHZhciBlbnZfbHZhbCA9IDg7XG4gIHZhciBlbnZfc3ltYl9zdGFydCA9IDk7XG4gIHZhciBlbnZfc3ltYl9lbmQgPSAxMDtcbiAgdmFyIGVudl9hc3AgPSAxMTtcbiAgdmFyIGVudl9ydWxlX2xlbiA9IDEyO1xuICB2YXIgZW52X3J1bGVfbnVtYmVyID0gMTM7XG4gIHZhciBlbnZfc3AgPSAxNDtcbiAgdmFyIGVudl9zdGF0ZSA9IDE1O1xuICB2YXIgZW52X2VycmZsYWcgPSAxNjtcblxuICAvLyB2YXIgX3RibF9hY3Rpb25zID0gMTtcbiAgdmFyIHRibF90cmFuc2xfY29uc3QgPSAyO1xuICB2YXIgdGJsX3RyYW5zbF9ibG9jayA9IDM7XG4gIHZhciB0YmxfbGhzID0gNDtcbiAgdmFyIHRibF9sZW4gPSA1O1xuICB2YXIgdGJsX2RlZnJlZCA9IDY7XG4gIHZhciB0YmxfZGdvdG8gPSA3O1xuICB2YXIgdGJsX3NpbmRleCA9IDg7XG4gIHZhciB0YmxfcmluZGV4ID0gOTtcbiAgdmFyIHRibF9naW5kZXggPSAxMDtcbiAgdmFyIHRibF90YWJsZXNpemUgPSAxMTtcbiAgdmFyIHRibF90YWJsZSA9IDEyO1xuICB2YXIgdGJsX2NoZWNrID0gMTM7XG4gIC8vIHZhciBfdGJsX2Vycm9yX2Z1bmN0aW9uID0gMTQ7XG4gIHZhciB0YmxfbmFtZXNfY29uc3QgPSAxNTtcbiAgdmFyIHRibF9uYW1lc19ibG9jayA9IDE2O1xuXG5cbiAgZnVuY3Rpb24gbG9nKHgpIHtcbiAgICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoeCArIFwiXFxuXCIpO1xuICAgIGNhbWxfbWxfb3V0cHV0KDIsIHMsIDAsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbl9uYW1lKG5hbWVzLCBudW1iZXIpXG4gIHtcbiAgICB2YXIgc3RyID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZXMpO1xuICAgIGlmIChzdHJbMF0gPT0gJ1xceDAwJylcbiAgICAgIHJldHVybiBcIjx1bmtub3duIHRva2VuPlwiO1xuICAgIHJldHVybiBzdHIuc3BsaXQoJ1xceDAwJylbbnVtYmVyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50X3Rva2VuKHN0YXRlLCB0b2spXG4gIHtcbiAgICB2YXIgdG9rZW4sIGtpbmQ7XG4gICAgaWYgKHRvayBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0b2tlbiA9IHRva2VuX25hbWUodGFibGVzW3RibF9uYW1lc19ibG9ja10sIHRva1swXSk7XG4gICAgICBpZiAodHlwZW9mIHRva1sxXSA9PSBcIm51bWJlclwiKVxuICAgICAgICBraW5kID0gXCJcIiArIHRva1sxXTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tbMV0gPT0gXCJzdHJpbmdcIilcbiAgICAgICAga2luZCA9IHRva1sxXVxuICAgICAgZWxzZSBpZiAodG9rWzFdIGluc3RhbmNlb2YgTWxCeXRlcylcbiAgICAgICAga2luZCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcodG9rWzFdKVxuICAgICAgZWxzZVxuICAgICAgICBraW5kID0gXCJfXCJcbiAgICAgIGxvZyhcIlN0YXRlIFwiICsgc3RhdGUgKyBcIjogcmVhZCB0b2tlbiBcIiArIHRva2VuICsgXCIoXCIgKyBraW5kICsgXCIpXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b2tlbiA9IHRva2VuX25hbWUodGFibGVzW3RibF9uYW1lc19jb25zdF0sIHRvayk7XG4gICAgICBsb2coXCJTdGF0ZSBcIiArIHN0YXRlICsgXCI6IHJlYWQgdG9rZW4gXCIgKyB0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0YWJsZXMuZGdvdG8pIHtcbiAgICB0YWJsZXMuZGVmcmVkID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGVmcmVkXSk7XG4gICAgdGFibGVzLnNpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3NpbmRleF0pO1xuICAgIHRhYmxlcy5jaGVjayAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9jaGVja10pO1xuICAgIHRhYmxlcy5yaW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9yaW5kZXhdKTtcbiAgICB0YWJsZXMudGFibGUgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfdGFibGVdKTtcbiAgICB0YWJsZXMubGVuICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGVuXSk7XG4gICAgdGFibGVzLmxocyAgICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2xoc10pO1xuICAgIHRhYmxlcy5naW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9naW5kZXhdKTtcbiAgICB0YWJsZXMuZGdvdG8gID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGdvdG9dKTtcbiAgfVxuXG4gIHZhciByZXMgPSAwLCBuLCBuMSwgbjIsIHN0YXRlMTtcblxuICAvLyBSRVNUT1JFXG4gIHZhciBzcCA9IGVudltlbnZfc3BdO1xuICB2YXIgc3RhdGUgPSBlbnZbZW52X3N0YXRlXTtcbiAgdmFyIGVycmZsYWcgPSBlbnZbZW52X2VycmZsYWddO1xuXG4gIGV4aXQ6Zm9yICg7Oykge1xuICAgIG5leHQ6c3dpdGNoKGNtZCkge1xuICAgIGNhc2UgMDovL1NUQVJUOlxuICAgICAgc3RhdGUgPSAwO1xuICAgICAgZXJyZmxhZyA9IDA7XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNjovL2xvb3A6XG4gICAgICBuID0gdGFibGVzLmRlZnJlZFtzdGF0ZV07XG4gICAgICBpZiAobiAhPSAwKSB7IGNtZCA9IHJlZHVjZTsgYnJlYWs7IH1cbiAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPj0gMCkgeyBjbWQgPSB0ZXN0c2hpZnQ7IGJyZWFrOyB9XG4gICAgICByZXMgPSBSRUFEX1RPS0VOO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBsZXhlciBhbmQgdXBkYXRlcyAqL1xuICAgICAgLyogc3ltYl9zdGFydCBhbmQgc3ltYl9lbmQgKi9cbiAgICBjYXNlIDE6Ly9UT0tFTl9SRUFEOlxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2Jsb2NrXVthcmdbMF0gKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IGFyZ1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2NvbnN0XVthcmcgKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpIHByaW50X3Rva2VuIChzdGF0ZSwgYXJnKTtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA3Oi8vdGVzdHNoaWZ0OlxuICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIGNtZCA9IHNoaWZ0OyBicmVhaztcbiAgICAgIH1cbiAgICAgIG4xID0gdGFibGVzLnJpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBuID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgICAgY21kID0gcmVkdWNlOyBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChlcnJmbGFnIDw9IDApIHtcbiAgICAgICAgcmVzID0gQ0FMTF9FUlJPUl9GVU5DVElPTjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGVycm9yIGZ1bmN0aW9uICovXG4gICAgY2FzZSA1Oi8vRVJST1JfREVURUNURUQ6XG4gICAgICBpZiAoZXJyZmxhZyA8IDMpIHtcbiAgICAgICAgZXJyZmxhZyA9IDM7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBzdGF0ZTEgPSBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV07XG4gICAgICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlMV07XG4gICAgICAgICAgbjIgPSBuMSArIEVSUkNPREU7XG4gICAgICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBFUlJDT0RFKSB7XG4gICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgICAgIGxvZyhcIlJlY292ZXJpbmcgaW4gc3RhdGUgXCIgKyBzdGF0ZTEpO1xuICAgICAgICAgICAgY21kID0gc2hpZnRfcmVjb3ZlcjsgYnJlYWsgbmV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNhbWxfcGFyc2VyX3RyYWNlKVxuICAgICAgICAgICAgICBsb2coXCJEaXNjYXJkaW5nIHN0YXRlIFwiICsgc3RhdGUxKTtcbiAgICAgICAgICAgIGlmIChzcCA8PSBlbnZbZW52X3N0YWNrYmFzZV0pIHtcbiAgICAgICAgICAgICAgaWYgKGNhbWxfcGFyc2VyX3RyYWNlKVxuICAgICAgICAgICAgICAgIGxvZyhcIk5vIG1vcmUgc3RhdGVzIHRvIGRpc2NhcmRcIik7XG4gICAgICAgICAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICAgICAgc3AtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPT0gMClcbiAgICAgICAgICByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7IC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgbG9nKFwiRGlzY2FyZGluZyBsYXN0IHRva2VuIHJlYWRcIik7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgODovL3NoaWZ0OlxuICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICBpZiAoZXJyZmxhZyA+IDApIGVycmZsYWctLTtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgOTovL3NoaWZ0X3JlY292ZXI6XG4gICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgIGxvZyhcIlN0YXRlIFwiICsgc3RhdGUgKyBcIjogc2hpZnQgdG8gc3RhdGUgXCIgKyB0YWJsZXMudGFibGVbbjJdKTtcbiAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIHNwKys7XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzE7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMjovL1NUQUNLU19HUk9XTl8xOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X2x2YWxdO1xuICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX3N0YXJ0XTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kXTtcbiAgICAgIGNtZCA9IGxvb3A7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTA6Ly9yZWR1Y2U6XG4gICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgIGxvZyhcIlN0YXRlIFwiICsgc3RhdGUgKyBcIjogcmVkdWNlIGJ5IHJ1bGUgXCIgKyBuKTtcbiAgICAgIHZhciBtID0gdGFibGVzLmxlbltuXTtcbiAgICAgIGVudltlbnZfYXNwXSA9IHNwO1xuICAgICAgZW52W2Vudl9ydWxlX251bWJlcl0gPSBuO1xuICAgICAgZW52W2Vudl9ydWxlX2xlbl0gPSBtO1xuICAgICAgc3AgPSBzcCAtIG0gKyAxO1xuICAgICAgbSA9IHRhYmxlcy5saHNbbl07XG4gICAgICBzdGF0ZTEgPSBlbnZbZW52X3Nfc3RhY2tdW3NwXTtcbiAgICAgIG4xID0gdGFibGVzLmdpbmRleFttXTtcbiAgICAgIG4yID0gbjEgKyBzdGF0ZTE7XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gc3RhdGUxKVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXRlID0gdGFibGVzLmRnb3RvW21dO1xuICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICByZXMgPSBHUk9XX1NUQUNLU18yO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSByZXNpemVzIHRoZSBzdGFja3MgKi9cbiAgICBjYXNlIDM6Ly9TVEFDS1NfR1JPV05fMjpcbiAgICAgIHJlcyA9IENPTVBVVEVfU0VNQU5USUNfQUNUSU9OO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBzZW1hbnRpYyBhY3Rpb24gKi9cbiAgICBjYXNlIDQ6Ly9TRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQ6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGFyZztcbiAgICAgIHZhciBhc3AgPSBlbnZbZW52X2FzcF07XG4gICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICBpZiAoc3AgPiBhc3ApIHtcbiAgICAgICAgLyogVGhpcyBpcyBhbiBlcHNpbG9uIHByb2R1Y3Rpb24uIFRha2Ugc3ltYl9zdGFydCBlcXVhbCB0byBzeW1iX2VuZC4gKi9cbiAgICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICB9XG4gICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIC8qIFNob3VsZCBub3QgaGFwcGVuICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLy8gU0FWRVxuICBlbnZbZW52X3NwXSA9IHNwO1xuICBlbnZbZW52X3N0YXRlXSA9IHN0YXRlO1xuICBlbnZbZW52X2VycmZsYWddID0gZXJyZmxhZztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfcGFyc2VyX3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlcl90cmFjZVxuZnVuY3Rpb24gY2FtbF9zZXRfcGFyc2VyX3RyYWNlKGJvb2wpIHtcbiAgdmFyIG9sZGZsYWcgPSBjYW1sX3BhcnNlcl90cmFjZTtcbiAgY2FtbF9wYXJzZXJfdHJhY2UgPSBib29sO1xuICByZXR1cm4gb2xkZmxhZztcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIEh1Z28gSGV1emFyZFxuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gU2hhY2hhciBJdHpoYWt5XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvb2NhbWwvYmxvYi80LjA3L290aGVybGlicy9zdHIvc3Ryc3R1YnMuY1xuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pzY29xL2pzY29xL2Jsb2IvdjguMTEvY29xLWpzL2pzX3N0dWIvc3RyLmpzXG5cbi8vUHJvdmlkZXM6IHJlX21hdGNoXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19nZXRcblxudmFyIHJlX21hdGNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHJlX3dvcmRfbGV0dGVycyA9IFtcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDAwLTB4MUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweEZGLCAweDAzLCAgICAgICAvKiAweDIwLTB4M0Y6IGRpZ2l0cyAwLTkgKi9cbiAgICAweEZFLCAweEZGLCAweEZGLCAweDg3LCAgICAgICAvKiAweDQwLTB4NUY6IEEgdG8gWiwgXyAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4MDcsICAgICAgIC8qIDB4NjAtMHg3RjogYSB0byB6ICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHg4MC0weDlGOiBub25lICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHhBMC0weEJGOiBub25lICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiwgICAgICAgLyogMHhDMC0weERGOiBMYXRpbi0xIGFjY2VudGVkIHVwcGVyY2FzZSAqL1xuICAgIDB4RkYsIDB4RkYsIDB4N0YsIDB4RkYgICAgICAgIC8qIDB4RTAtMHhGRjogTGF0aW4tMSBhY2NlbnRlZCBsb3dlcmNhc2UgKi9cbiAgXTtcblxuICB2YXIgb3Bjb2RlcyA9IHtcbiAgICBDSEFSOiAwLCBDSEFSTk9STTogMSwgU1RSSU5HOiAyLCBTVFJJTkdOT1JNOiAzLCBDSEFSQ0xBU1M6IDQsXG4gICAgQk9MOiA1LCBFT0w6IDYsIFdPUkRCT1VOREFSWTogNyxcbiAgICBCRUdHUk9VUDogOCwgRU5ER1JPVVA6IDksIFJFRkdST1VQOiAxMCxcbiAgICBBQ0NFUFQ6IDExLFxuICAgIFNJTVBMRU9QVDogMTIsIFNJTVBMRVNUQVI6IDEzLCBTSU1QTEVQTFVTOiAxNCxcbiAgICBHT1RPOiAxNSwgUFVTSEJBQ0s6IDE2LCBTRVRNQVJLOiAxNyxcbiAgICBDSEVDS1BST0dSRVNTOiAxOFxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzX3dvcmRfbGV0dGVyKGMpIHtcbiAgICByZXR1cm4gKHJlX3dvcmRfbGV0dGVyc1sgIChjID4+IDMpXSA+PiAoYyAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiBpbl9iaXRzZXQocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX3N0cmluZ19nZXQocywoaSA+PiAzKSkgPj4gKGkgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVfbWF0Y2hfaW1wbChyZSwgcywgcG9zLCBwYXJ0aWFsKSB7XG5cbiAgICB2YXIgcHJvZyAgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsxXSksXG4gICAgICAgIGNwb29sICAgICAgICAgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMl0pLFxuICAgICAgICBub3JtdGFibGUgICAgID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZVszXSksXG4gICAgICAgIG51bWdyb3VwcyAgICAgPSByZVs0XSB8IDAsXG4gICAgICAgIG51bXJlZ2lzdGVycyAgPSByZVs1XSB8IDAsXG4gICAgICAgIHN0YXJ0Y2hhcnMgICAgPSByZVs2XSB8IDA7XG5cbiAgICB2YXIgcyA9IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHMpO1xuXG4gICAgdmFyIHBjID0gMCxcbiAgICAgICAgcXVpdCA9IGZhbHNlLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBncm91cHMgPSBuZXcgQXJyYXkobnVtZ3JvdXBzKSxcbiAgICAgICAgcmVfcmVnaXN0ZXIgPSBuZXcgQXJyYXkobnVtcmVnaXN0ZXJzKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgZ3JvdXBzW2ldID0ge3N0YXJ0OiAtMSwgZW5kOi0xfVxuICAgIH1cbiAgICBncm91cHNbMF0uc3RhcnQgPSBwb3M7XG5cbiAgICB2YXIgYmFja3RyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoaXRlbS51bmRvKSB7XG4gICAgICAgICAgaXRlbS51bmRvLm9ialtpdGVtLnVuZG8ucHJvcF0gPSBpdGVtLnVuZG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpdGVtLnBvcykge1xuICAgICAgICAgIHBjID0gaXRlbS5wb3MucGM7XG4gICAgICAgICAgcG9zID0gaXRlbS5wb3MudHh0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcXVpdCA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBwdXNoID0gZnVuY3Rpb24oaXRlbSkgeyBzdGFjay5wdXNoKGl0ZW0pOyB9O1xuXG4gICAgdmFyIGFjY2VwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdyb3Vwc1swXS5lbmQgPSBwb3M7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KDEgKyBncm91cHMubGVuZ3RoKjIpO1xuICAgICAgcmVzdWx0WzBdID0gMDsgLy8gdGFnXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGcgPSBncm91cHNbaV07XG4gICAgICAgIGlmKGcuc3RhcnQgPCAwIHx8IGcuZW5kIDwgMCkge1xuICAgICAgICAgIGcuc3RhcnQgPSBnLmVuZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxIF0gPSBnLnN0YXJ0O1xuICAgICAgICByZXN1bHRbMippICsgMSArIDEgXSA9IGcuZW5kO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgdmFyIHByZWZpeF9tYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmKHBhcnRpYWwpIHJldHVybiBhY2NlcHQgKCk7XG4gICAgICBlbHNlIGJhY2t0cmFjayAoKTtcbiAgICB9XG5cbiAgICAvKiBNYWluIERGQSBpbnRlcnByZXRlciBsb29wICovXG4gICAgd2hpbGUgKCFxdWl0KSB7XG4gICAgICB2YXIgb3AgPSBwcm9nW3BjXSAmIDB4ZmYsXG4gICAgICAgICAgc2FyZyA9IHByb2dbcGNdID4+IDgsXG4gICAgICAgICAgdWFyZyA9IHNhcmcgJiAweGZmLFxuICAgICAgICAgIGMgPSBzW3Bvc10sXG4gICAgICAgICAgZ3JvdXA7XG5cbiAgICAgIHBjKys7XG5cbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChjID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUk5PUk06XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU1RSSU5HOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKGMgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkdOT1JNOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSBhcmcuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBlbHNlIHsgYmFja3RyYWNrKCk7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUkNMQVNTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQk9MOlxuICAgICAgICBpZihwb3MgPiAwICYmIHNbcG9zIC0gMV0gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkVPTDpcbiAgICAgICAgaWYocG9zIDwgcy5sZW5ndGggJiYgc1twb3NdICE9IDEwIC8qIFxcbiAqLykge2JhY2t0cmFjaygpfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5XT1JEQk9VTkRBUlk6XG4gICAgICAgIGlmKHBvcyA9PSAwKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbMF0pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1twb3MgLSAxXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSAhPSBpc193b3JkX2xldHRlcihzW3Bvc10pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2sgKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQkVHR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOmdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdyb3VwLnN0YXJ0fX0pO1xuICAgICAgICBncm91cC5zdGFydCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU5ER1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6J2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuZW5kfX0pO1xuICAgICAgICBncm91cC5lbmQgPSBwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlJFRkdST1VQOlxuICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgaWYoZ3JvdXAuc3RhcnQgPCAwIHx8IGdyb3VwLmVuZCA8IDApIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICBmb3IgKHZhciBpID0gZ3JvdXAuc3RhcnQ7IGkgPCBncm91cC5lbmQ7IGkrKyl7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKHNbaV0gIT0gc1twb3NdKSB7YmFja3RyYWNrICgpOyBicmVha31cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVPUFQ6XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0lNUExFU1RBUjpcbiAgICAgICAgd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpXG4gICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVQTFVTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIH0gd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkFDQ0VQVDpcbiAgICAgICAgcmV0dXJuIGFjY2VwdCgpO1xuICAgICAgY2FzZSBvcGNvZGVzLkdPVE86XG4gICAgICAgIHBjID0gcGMgKyBzYXJnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5QVVNIQkFDSzpcbiAgICAgICAgcHVzaCh7cG9zOiB7cGM6IHBjICsgc2FyZywgdHh0OiBwb3N9fSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNFVE1BUks6XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6cmVfcmVnaXN0ZXIsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOiB1YXJnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlX3JlZ2lzdGVyW3VhcmddfX0pO1xuICAgICAgICByZV9yZWdpc3Rlclt1YXJnXSA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hFQ0tQUk9HUkVTUzpcbiAgICAgICAgaWYgKHJlX3JlZ2lzdGVyW3VhcmddID09PSBwb3MpIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZWNvZGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHJlX21hdGNoX2ltcGw7XG59KCk7XG5cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2ZvcndhcmRcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc2VhcmNoX2ZvcndhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2ZvcndhcmRcIilcbiAgd2hpbGUgKHBvcyA8PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIHtcbiAgICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICBwb3MrKztcbiAgfVxuXG4gIHJldHVybiBbMF07ICAvKiBbfHxdIDogaW50IGFycmF5ICovXG59XG5cbi8vUHJvdmlkZXM6IHJlX3NlYXJjaF9iYWNrd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfYmFja3dhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2JhY2t3YXJkXCIpXG4gIHdoaWxlIChwb3MgPj0gMCkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcy0tO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuXG4vL1Byb3ZpZGVzOiByZV9zdHJpbmdfbWF0Y2hcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc3RyaW5nX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnN0cmluZ19tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcGFydGlhbF9tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9wYXJ0aWFsX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnBhcnRpYWxfbWF0Y2hcIilcbiAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDEpO1xuICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICBlbHNlIHJldHVybiBbMF07XG59XG5cbi8vUHJvdmlkZXM6IHJlX3JlcGxhY2VtZW50X3RleHRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyBleHRlcm5hbCByZV9yZXBsYWNlbWVudF90ZXh0OiBzdHJpbmcgLT4gaW50IGFycmF5IC0+IHN0cmluZyAtPiBzdHJpbmdcbmZ1bmN0aW9uIHJlX3JlcGxhY2VtZW50X3RleHQocmVwbCxncm91cHMsb3JpZykge1xuICB2YXIgcmVwbCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVwbCk7XG4gIHZhciBsZW4gPSByZXBsLmxlbmd0aDtcbiAgdmFyIG9yaWcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9yaWcpO1xuICB2YXIgcmVzID0gXCJcIjsgLy9yZXN1bHRcbiAgdmFyIG4gPSAwOyAvLyBjdXJyZW50IHBvc2l0aW9uXG4gIHZhciBjdXI7IC8vY3VycmVudCBjaGFyXG4gIHZhciBzdGFydCwgZW5kLCBjO1xuICB3aGlsZShuIDwgbGVuKXtcbiAgICBjdXIgPSByZXBsLmNoYXJBdChuKyspO1xuICAgIGlmKGN1ciAhPSAnXFxcXCcpe1xuICAgICAgcmVzICs9IGN1cjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZihuID09IGxlbikgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiBpbGxlZ2FsIGJhY2tzbGFzaCBzZXF1ZW5jZVwiKTtcbiAgICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgICBzd2l0Y2goY3VyKXtcbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICByZXMgKz0gY3VyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzAnOiBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzpcbiAgICAgIGNhc2UgJzUnOiBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgICAgYyA9ICtjdXI7XG4gICAgICAgIGlmIChjKjIgPj0gZ3JvdXBzLmxlbmd0aCAtIDEgKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiICk7XG4gICAgICAgIHN0YXJ0ID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLGMqMik7XG4gICAgICAgIGVuZCA9IGNhbWxfYXJyYXlfZ2V0KGdyb3VwcywgYyoyICsxKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IC0xKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiKTtcbiAgICAgICAgcmVzKz1vcmlnLnNsaWNlKHN0YXJ0LGVuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzICs9ICgnXFxcXCcgICsgY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocmVzKTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX2luaXRpYWxpemVcbmZ1bmN0aW9uIGNhbWxfc3RyX2luaXRpYWxpemUodW5pdCkge1xuICByZXR1cm4gMDtcbn1cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUGFkZGluZyBwb3NpdGlvbi4gKilcbnR5cGUgcGFkdHkgPVxuICB8IExlZnQgICAoKiBUZXh0IGlzIGxlZnQganVzdGlmaWVkICgnLScgb3B0aW9uKS4gICAgICAgICAgICAgICAqKVxuICB8IFJpZ2h0ICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCAobm8gJy0nIG9wdGlvbikuICAgICAgICAgICAqKVxuICB8IFplcm9zICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCBieSB6ZXJvcyAoc2VlICcwJyBvcHRpb24pLiAqKVxuXG4oKioqKVxuXG4oKiBJbnRlZ2VyIGNvbnZlcnNpb24uICopXG50eXBlIGludF9jb252ID1cbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCAgICAgICAgKCogICVkIHwgJStkIHwgJSBkICAqKVxuICB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpICAgICAgICAoKiAgJWkgfCAlK2kgfCAlIGkgICopXG4gIHwgSW50X3ggfCBJbnRfQ3ggICAgICAgICAgICAgICAgICgqICAleCB8ICUjeCAgICAgICAgKilcbiAgfCBJbnRfWCB8IEludF9DWCAgICAgICAgICAgICAgICAgKCogICVYIHwgJSNYICAgICAgICAqKVxuICB8IEludF9vIHwgSW50X0NvICAgICAgICAgICAgICAgICAoKiAgJW8gfCAlI28gICAgICAgICopXG4gIHwgSW50X3UgICAgICAgICAgICAgICAgICAgICAgICAgICgqICAldSAgICAgICAgICAgICAgKilcbiAgfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgICAgICAgKCogICUjZCB8ICUjaSB8ICUjdSAqKVxuXG4oKiBGbG9hdCBjb252ZXJzaW9uLiAqKVxudHlwZSBmbG9hdF9mbGFnX2NvbnYgPVxuICB8IEZsb2F0X2ZsYWdfICAgICAgICAgICAgICAgICAgICAoKiAlW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcCAgICAgICAgICAgICAgICAgICAoKiAlK1tmZUVnR0ZoSF0gKilcbiAgfCBGbG9hdF9mbGFnX3MgICAgICAgICAgICAgICAgICAgKCogJSBbZmVFZ0dGaEhdICopXG50eXBlIGZsb2F0X2tpbmRfY29udiA9XG4gIHwgRmxvYXRfZiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZiB8ICUrZiB8ICUgZiAgKilcbiAgfCBGbG9hdF9lICAgICAgICAgICAgICAgICAgICAgICAgKCogICVlIHwgJStlIHwgJSBlICAqKVxuICB8IEZsb2F0X0UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUUgfCAlK0UgfCAlIEUgICopXG4gIHwgRmxvYXRfZyAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZyB8ICUrZyB8ICUgZyAgKilcbiAgfCBGbG9hdF9HICAgICAgICAgICAgICAgICAgICAgICAgKCogICVHIHwgJStHIHwgJSBHICAqKVxuICB8IEZsb2F0X0YgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUYgfCAlK0YgfCAlIEYgICopXG4gIHwgRmxvYXRfaCAgICAgICAgICAgICAgICAgICAgICAgICgqICAlaCB8ICUraCB8ICUgaCAgKilcbiAgfCBGbG9hdF9IICAgICAgICAgICAgICAgICAgICAgICAgKCogICVIIHwgJStIIHwgJSBIICAqKVxuICB8IEZsb2F0X0NGICAgICAgICAgICAgICAgICAgICAgICAoKiAgJSNGfCAlKyNGfCAlICNGICopXG50eXBlIGZsb2F0X2NvbnYgPSBmbG9hdF9mbGFnX2NvbnYgKiBmbG9hdF9raW5kX2NvbnZcblxuKCoqKilcblxuKCogQ2hhciBzZXRzIChzZWUgJVsuLi5dKSBhcmUgYml0bWFwcyBpbXBsZW1lbnRlZCBhcyAzMi1jaGFyIHN0cmluZ3MuICopXG50eXBlIGNoYXJfc2V0ID0gc3RyaW5nXG5cbigqKiopXG5cbigqIENvdW50ZXIgdXNlZCBpbiBTY2FuZi4gKilcbnR5cGUgY291bnRlciA9XG4gIHwgTGluZV9jb3VudGVyICAgICAoKiAgJWwgICAgICAqKVxuICB8IENoYXJfY291bnRlciAgICAgKCogICVuICAgICAgKilcbiAgfCBUb2tlbl9jb3VudGVyICAgICgqICAlTiwgJUwgICopXG5cbigqKiopXG5cbigqIFBhZGRpbmcgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycy4gKilcbnR5cGUgKCdhLCAnYikgcGFkZGluZyA9XG4gICgqIE5vIHBhZGRpbmcgKGV4OiBcIiVkXCIpICopXG4gIHwgTm9fcGFkZGluZyAgOiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIExpdGVyYWwgcGFkZGluZyAoZXg6IFwiJThkXCIpICopXG4gIHwgTGl0X3BhZGRpbmcgOiBwYWR0eSAqIGludCAtPiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIFBhZGRpbmcgYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqZFwiKSAqKVxuICB8IEFyZ19wYWRkaW5nIDogcGFkdHkgLT4gKGludCAtPiAnYSwgJ2EpIHBhZGRpbmdcblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZCxcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwYWRkaW5nIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHBhZF9vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIFByZWNpc2lvbiBvZiBmbG9hdHMgYW5kICcwJy1wYWRkaW5nIG9mIGludGVnZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwcmVjaXNpb24gPVxuICAoKiBObyBwcmVjaXNpb24gKGV4OiBcIiVmXCIpICopXG4gIHwgTm9fcHJlY2lzaW9uIDogKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIExpdGVyYWwgcHJlY2lzaW9uIChleDogXCIlLjNmXCIpICopXG4gIHwgTGl0X3ByZWNpc2lvbiA6IGludCAtPiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogUHJlY2lzaW9uIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpICopXG4gIHwgQXJnX3ByZWNpc2lvbiA6IChpbnQgLT4gJ2EsICdhKSBwcmVjaXNpb25cblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZixcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwcmVjaXNpb24gb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcHJlY19vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIHNlZSB0aGUgQ3VzdG9tIGZvcm1hdCBjb21iaW5hdG9yICopXG50eXBlICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgPVxuICB8IEN1c3RvbV96ZXJvIDogKCdhLCBzdHJpbmcsICdhKSBjdXN0b21fYXJpdHlcbiAgfCBDdXN0b21fc3VjYyA6ICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgLT5cbiAgICAoJ2EsICd4IC0+ICdiLCAneCAtPiAnYykgY3VzdG9tX2FyaXR5XG5cbigqKiopXG5cbigqICAgICAgICBSZWxhdGlvbmFsIGZvcm1hdCB0eXBlc1xuXG5JbiB0aGUgZmlyc3QgZm9ybWF0K2dhZHRzIGltcGxlbWVudGF0aW9uLCB0aGUgdHlwZSBmb3IgJSguLiUpIGluIHRoZVxuZm10IEdBRFQgd2FzIGFzIGZvbGxvd3M6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKiAoJ2QxLCAncTEsICdkMiwgJ3EyKSByZWFkZXJfbmJfdW5pZmllciAqXG4gICAgKCd4LCAnYiwgJ2MsICdkMSwgJ3ExLCAndSkgZm10dHkgKlxuICAgICgndSwgJ2IsICdjLCAncTEsICdlMSwgJ2YpIGZtdCAtPlxuICAgICAgKCgneCwgJ2IsICdjLCAnZDIsICdxMiwgJ3UpIGZvcm1hdDYgLT4gJ3gsICdiLCAnYywgJ2QxLCAnZTEsICdmKSBmbXRcblxuTm90aWNlIHRoYXQgdGhlICd1IHBhcmFtZXRlciBpbiAnZiBwb3NpdGlvbiBpbiB0aGUgZm9ybWF0IGFyZ3VtZW50XG4oKCd4LCAuLiwgJ3UpIGZvcm1hdDYgLT4gLi4pIGlzIGVxdWFsIHRvIHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2FcbnBvc2l0aW9uIGluIHRoZSBmb3JtYXQgdGFpbCAoKCd1LCAuLiwgJ2YpIGZtdCkuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbnR5cGUgb2YgdGhlIGV4cGVjdGVkIGZvcm1hdCBwYXJhbWV0ZXIgZGVwZW5kcyBvZiB3aGVyZSB0aGUgJSguLi4lKVxuYXJlIGluIHRoZSBmb3JtYXQgc3RyaW5nOlxuXG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSlcIlxuICAtIDogKHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IHVuaXRcbiAgPSA8ZnVuPlxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpJWRcIlxuICAtIDogKGludCAtPiB1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIGludCAtPiB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gaW50IC0+IHVuaXRcbiAgPSA8ZnVuPlxuXG5PbiB0aGUgY29udHJhcnksIHRoZSBsZWdhY3kgdHlwZXIgZ2l2ZXMgYSBjbGV2ZXIgdHlwZSB0aGF0IGRvZXMgbm90XG5kZXBlbmQgb24gdGhlIHBvc2l0aW9uIG9mICUoLi4lKSBpbiB0aGUgZm9ybWF0IHN0cmluZy4gRm9yIGV4YW1wbGUsXG4lKCUpIHdpbGwgaGF2ZSB0aGUgcG9seW1vcnBoaWMgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSk6IGl0IGNhblxuYmUgY29uY2F0ZW5hdGVkIHRvIGFueSBmb3JtYXQgdHlwZSwgYW5kIG9ubHkgZW5mb3JjZXMgdGhlIGNvbnN0cmFpbnRcbnRoYXQgaXRzICdhIGFuZCAnZiBwYXJhbWV0ZXJzIGFyZSBlcXVhbCAobm8gZm9ybWF0IGFyZ3VtZW50cykgYW5kICdkXG5hbmQgJ2UgYXJlIGVxdWFsIChubyByZWFkZXIgYXJndW1lbnQpLlxuXG5UaGUgd2Vha2VuaW5nIG9mIHRoaXMgcGFyYW1ldGVyIHR5cGUgaW4gdGhlIEdBRFQgdmVyc2lvbiBicm9rZSB1c2VyXG5jb2RlIChpbiBmYWN0IGl0IGVzc2VudGlhbGx5IG1hZGUgJSguLi4lKSB1bnVzYWJsZSBleGNlcHQgYXQgdGhlIGxhc3RcbnBvc2l0aW9uIG9mIGEgZm9ybWF0KS4gSW4gcGFydGljdWxhciwgdGhlIGZvbGxvd2luZyB3b3VsZCBub3Qgd29ya1xuYW55bW9yZTpcblxuICBmdW4gc2VwIC0+XG4gICAgRm9ybWF0LnByaW50ZiBcImZvbyUoJSliYXIlKCUpYmF6XCIgc2VwIHNlcFxuXG5BcyB0aGUgdHlwZS1jaGVja2VyIHdvdWxkIHJlcXVpcmUgdHdvICppbmNvbXBhdGlibGUqIHR5cGVzIGZvciB0aGUgJSglKVxuaW4gZGlmZmVyZW50IHBvc2l0aW9ucy5cblxuVGhlIHNvbHV0aW9uIHRvIHJlZ2FpbiBhIGdlbmVyYWwgdHlwZSBmb3IgJSguLiUpIGlzIHRvIGdlbmVyYWxpemUgdGhpc1xudGVjaG5pcXVlLCBub3Qgb25seSBvbiB0aGUgJ2QsICdlIHBhcmFtZXRlcnMsIGJ1dCBvbiBhbGwgc2l4XG5wYXJhbWV0ZXJzIG9mIGEgZm9ybWF0OiB3ZSBpbnRyb2R1Y2UgYSBcInJlbGF0aW9uYWxcIiB0eXBlXG4gICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG53aG9zZSB2YWx1ZXMgYXJlIHByb29mcyB0aGF0ICgnYTEsIC4uLCAnZjEpIGFuZCAoJ2EyLCAuLiwgJ2YyKSBtb3JhbGx5XG5jb3JyZXNwb25kIHRvIHRoZSBzYW1lIGZvcm1hdCB0eXBlOiAnYTEgaXMgb2J0YWluZWQgZnJvbSAnZjEsJ2IxLCdjMVxuaW4gdGhlIGV4YWN0IHNhbWUgd2F5IHRoYXQgJ2EyIGlzIG9idGFpbmVkIGZyb20gJ2YyLCdiMiwnYzIsIGV0Yy5cblxuRm9yIGV4YW1wbGUsIHRoZSByZWxhdGlvbiBiZXR3ZWVuIHR3byBmb3JtYXQgdHlwZXMgYmVnaW5uaW5nIHdpdGggYSBDaGFyXG5wYXJhbWV0ZXIgaXMgYXMgZm9sbG93czpcblxufCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbkluIHRoZSBnZW5lcmFsIGNhc2UsIHRoZSB0ZXJtIHN0cnVjdHVyZSBvZiBmbXR0eV9yZWwgaXMgKGFsbW9zdFsxXSlcbmlzb21vcnBoaWMgdG8gdGhlIGZtdHR5IG9mIHRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbjogZXZlcnlcbmNvbnN0cnVjdG9yIGlzIHJlLXJlYWQgd2l0aCBhIGJpbmFyeSwgcmVsYXRpb25hbCB0eXBlLCBpbnN0ZWFkIG9mIHRoZVxucHJldmlvdXMgdW5hcnkgdHlwaW5nLiBmbXR0eSBjYW4gdGhlbiBiZSByZS1kZWZpbmVkIGFzIHRoZSBkaWFnb25hbCBvZlxuZm10dHlfcmVsOlxuXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5cbk9uY2Ugd2UgaGF2ZSB0aGlzIGZtdHR5X3JlbCB0eXBlIGluIHBsYWNlLCB3ZSBjYW4gZ2l2ZSB0aGUgbW9yZVxuZ2VuZXJhbCB0eXBlIHRvICUoLi4uJSk6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG5XZSBhY2NlcHQgYW55IGZvcm1hdCAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYpICh0aGlzIGlzXG5jb21wbGV0ZWx5IHVucmVsYXRlZCB0byB0aGUgdHlwZSBvZiB0aGUgY3VycmVudCBmb3JtYXQpLCBidXQgYWxzb1xucmVxdWlyZSBhIHByb29mIHRoYXQgdGhpcyBmb3JtYXQgaXMgaW4gcmVsYXRpb24gdG8gYW5vdGhlciBmb3JtYXQgdGhhdFxuaXMgY29uY2F0ZW5hYmxlIHRvIHRoZSBmb3JtYXQgdGFpbC4gV2hlbiBleGVjdXRpbmcgYSAlKC4uLiUpIGZvcm1hdFxuKGluIGNhbWxpbnRlcm5hbEZvcm1hdC5tbDptYWtlX3ByaW50ZiBvciBzY2FuZi5tbDptYWtlX3NjYW5mKSwgd2VcbnRyYW5zdHlwZSB0aGUgZm9ybWF0IGFsb25nIHRoaXMgcmVsYXRpb24gdXNpbmcgdGhlICdyZWNhc3QnIGZ1bmN0aW9uXG50byB0cmFuc3Bvc2UgYmV0d2VlbiByZWxhdGVkIGZvcm1hdCB0eXBlcy5cblxuICB2YWwgcmVjYXN0IDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEpIGZtdFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10XG5cbk5PVEUgWzFdOiB0aGUgdHlwaW5nIG9mIEZvcm1hdF9zdWJzdF90eSByZXF1aXJlcyBub3Qgb25lIGZvcm1hdCB0eXBlLCBidXRcbnR3bywgb25lIHRvIGVzdGFibGlzaCB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXQgYXJndW1lbnQgYW5kIHRoZVxuZmlyc3Qgc2l4IHBhcmFtZXRlcnMsIGFuZCB0aGUgb3RoZXIgZm9yIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdFxuYXJndW1lbnQgYW5kIHRoZSBsYXN0IHNpeCBwYXJhbWV0ZXJzLlxuXG58IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuV2hlbiB3ZSBnZW5lcmF0ZSBhIGZvcm1hdCBBU1QsIHdlIGdlbmVyYXRlIGV4YWN0bHkgdGhlIHNhbWUgd2l0bmVzc1xuZm9yIGJvdGggcmVsYXRpb25zLCBhbmQgdGhlIHdpdG5lc3MtY29udmVyc2lvbiBmdW5jdGlvbnMgaW5cbmNhbWxpbnRlcm5hbEZvcm1hdCBkbyByZWx5IG9uIHRoaXMgaW52YXJpYW50LiBGb3IgZXhhbXBsZSwgdGhlXG5mdW5jdGlvbiB0aGF0IHByb3ZlcyB0aGF0IHRoZSByZWxhdGlvbiBpcyB0cmFuc2l0aXZlXG5cbiAgdmFsIHRyYW5zIDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcblxuZG9lcyBhc3N1bWUgdGhhdCB0aGUgdHdvIGlucHV0cyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgdGVybSBzdHJ1Y3R1cmVcbihhbmQgaXMgb25seSBldmVyeSB1c2VkIGZvciBhcmd1bWVudCB3aXRuZXNzZXMgb2YgdGhlXG5Gb3JtYXRfc3Vic3RfdHkgY29uc3RydWN0b3IpLlxuKilcblxuKCogVHlwZSBvZiBhIGJsb2NrIHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCAgICgqIEhvcml6b250YWwgYmxvY2sgbm8gbGluZSBicmVha2luZyAqKVxuICB8IFBwX3Zib3ggICAoKiBWZXJ0aWNhbCBibG9jayBlYWNoIGJyZWFrIGxlYWRzIHRvIGEgbmV3IGxpbmUgKilcbiAgfCBQcF9odmJveCAgKCogSG9yaXpvbnRhbC12ZXJ0aWNhbCBibG9jazogc2FtZSBhcyB2Ym94LCBleGNlcHQgaWYgdGhpcyBibG9ja1xuICAgICAgICAgICAgICAgICBpcyBzbWFsbCBlbm91Z2ggdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUgKilcbiAgfCBQcF9ob3Zib3ggKCogSG9yaXpvbnRhbCBvciBWZXJ0aWNhbCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2sgKilcbiAgfCBQcF9ib3ggICAgKCogSG9yaXpvbnRhbCBvciBJbmRlbnQgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrLCBvclxuICAgICAgICAgICAgICAgICB3aGVuIGl0IGxlYWRzIHRvIGEgbmV3IGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50IGxpbmUgKilcbiAgfCBQcF9maXRzICAgKCogSW50ZXJuYWwgdXNhZ2U6IHdoZW4gYSBibG9jayBmaXRzIG9uIGEgc2luZ2xlIGxpbmUgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgZm9ybWF0dGluZ19saXQgPVxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXSAgICopXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEB9ICAgKilcbiAgfCBCcmVhayBvZiBzdHJpbmcgKiBpbnQgKiBpbnQgICAgICAgICAgKCogQCwgfCBAICB8IEA7IHwgQDs8PiAqKVxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPyAgICopXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBcXG4gICopXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAuICAgKilcbiAgfCBNYWdpY19zaXplIG9mIHN0cmluZyAqIGludCAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQDxuPiAqKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAQCAgICopXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAlJSAgKilcbiAgfCBTY2FuX2luZGljIG9mIGNoYXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFggICAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW4gPVxuICB8IE9wZW5fdGFnIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAeyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG4gIHwgT3Blbl9ib3ggOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEBbICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgdHlwZSBlbGVtZW50cy4gKilcbigqIEluIHBhcnRpY3VsYXIgdXNlZCB0byByZXByZXNlbnQgJSguLi4lKSBhbmQgJXsuLi4lfSBjb250ZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuYW5kICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgPVxuICB8IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFN0cmluZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKHN0cmluZyAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIHN0cmluZyAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50MzJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50MzIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQzMiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBOYXRpdmVpbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5kICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChuYXRpdmVpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBuYXRpdmVpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50NjRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50NjQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQ2NCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBGbG9hdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWYgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChmbG9hdCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGZsb2F0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEJvb2xfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGJvb2wgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBib29sIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRm9ybWF0X2FyZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuICB8IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzLiAqKVxuICB8IEFscGhhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ3ggLT4gJ2MxKSAtPiAneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ3ggLT4gJ2MyKSAtPiAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBUaGV0YV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICdjMSkgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICdjMikgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQW55X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBVc2VkIGZvciBjdXN0b20gZm9ybWF0cyAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBSZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRW5kX29mX2ZtdHR5IDpcbiAgICAgICgnZjEsICdiMSwgJ2MxLCAnZDEsICdkMSwgJ2YxLFxuICAgICAgICdmMiwgJ2IyLCAnYzIsICdkMiwgJ2QyLCAnZjIpIGZtdHR5X3JlbFxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCBlbGVtZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ID1cbiAgfCBDaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlUyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQzMiAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IE5hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgbmF0aXZlaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQ2NCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gICAgICBmbG9hdF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgZmxvYXQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBCb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2JCXSAqKVxuICAgICAgKCd4LCBib29sIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmx1c2ggOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogYWJjICopXG4gICAgICBzdHJpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDaGFyX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiB4ICopXG4gICAgICBjaGFyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBGb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAley4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYiwgJ2MsICdqMiwgJ2QsICdhKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3IuICopXG4gIHwgQWxwaGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAneCAtPiAnYykgLT4gJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgVGhldGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAnYykgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICBmb3JtYXR0aW5nX2xpdCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdHRpbmdfZ2VuIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgKCdhMSwgJ2IsICdjLCAnZDEsICdlMSwgJ2YxKSBmb3JtYXR0aW5nX2dlbiAqXG4gICAgICAoJ2YxLCAnYiwgJ2MsICdlMSwgJ2UyLCAnZjIpIGZtdCAtPiAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UyLCAnZjIpIGZtdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3ggLT4gJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKHN0cmluZyAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW25sTkxdICopXG4gICAgICBjb3VudGVyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoaW50IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUwYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSWdub3JlZF9wYXJhbSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8gKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBpZ25vcmVkICogKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogQ3VzdG9tIHByaW50aW5nIGZvcm1hdCAoUFIjNjQ1MiwgR1BSIzE0MClcblxuICAgICBXZSBpbmNsdWRlIGEgdHlwZSBDdXN0b20gb2YgXCJjdXN0b20gY29udmVydGVyc1wiLCB3aGVyZSBhblxuICAgICBhcmJpdHJhcnkgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY29udmVydCBvbmUgb3IgbW9yZVxuICAgICBhcmd1bWVudHMuIFRoZXJlIGlzIG5vIHN5bnRheCBmb3IgY3VzdG9tIGNvbnZlcnRlcnMsIGl0IGlzIG9ubHlcbiAgICAgaW50ZW5kZWQgZm9yIGN1c3RvbSBwcm9jZXNzb3JzIHRoYXQgd2lzaCB0byByZWx5IG9uIHRoZVxuICAgICBzdGRsaWItZGVmaW5lZCBmb3JtYXQgR0FEVHMuXG5cbiAgICAgRm9yIGluc3RhbmNlIGEgcHJlLXByb2Nlc3NvciBjb3VsZCBjaG9vc2UgdG8gaW50ZXJwcmV0IHN0cmluZ3NcbiAgICAgcHJlZml4ZWQgd2l0aCBbXCIhXCJdIGFzIGZvcm1hdCBzdHJpbmdzIHdoZXJlIFsle3sgLi4uIH19XSBpc1xuICAgICBhIHNwZWNpYWwgZm9ybSB0byBwYXNzIGEgdG9fc3RyaW5nIGZ1bmN0aW9uLCBzbyB0aGF0IG9uZSBjb3VsZFxuICAgICB3cml0ZTpcblxuICAgICB7W1xuICAgICAgIHR5cGUgdCA9IHsgeCA6IGludDsgeSA6IGludCB9XG5cbiAgICAgICBsZXQgc3RyaW5nX29mX3QgdCA9IFByaW50Zi5zcHJpbnRmIFwieyB4ID0gJWQ7IHkgPSAlZCB9XCIgdC54IHQueVxuXG4gICAgICAgUHJpbnRmLnByaW50ZiAhXCJ0ID0gJXt7c3RyaW5nX29mX3R9fVwiIHsgeCA9IDQyOyB5ID0gNDIgfVxuICAgICBdfVxuICAqKVxuICB8IEN1c3RvbSA6XG4gICAgICAoJ2EsICd4LCAneSkgY3VzdG9tX2FyaXR5ICogKHVuaXQgLT4gJ3gpICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIGVuZCBvZiBhIGZvcm1hdCBzcGVjaWZpY2F0aW9uICopXG4gIHwgRW5kX29mX2Zvcm1hdCA6XG4gICAgICAgICgnZiwgJ2IsICdjLCAnZSwgJ2UsICdmKSBmbXRcblxuKCoqKilcblxuKCogVHlwZSBmb3IgaWdub3JlZCBwYXJhbWV0ZXJzIChzZWUgXCIlX1wiKS4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZCA9XG4gIHwgSWdub3JlZF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9jICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2QgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfbmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbmQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfTGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZiAqKVxuICAgICAgcGFkX29wdGlvbiAqIHByZWNfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9ib29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9CICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV97Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZFxuICB8IElnbm9yZWRfcmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfW25sTkxdICopXG4gICAgICBjb3VudGVyIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8wYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcblxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgKiBzdHJpbmdcblxubGV0IHJlYyBlcmFzZV9yZWwgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYsXG4gICBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5XG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCBfdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTEsIGVyYXNlX3JlbCByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBlIGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdCB0eXBlcy4gKilcbigqIFVzZWQgYnk6XG4gICAqIHJlYWRlcl9uYl91bmlmaWVyX29mX2ZtdHR5IHRvIGNvdW50IHJlYWRlcnMgaW4gYW4gZm10dHksXG4gICAqIFNjYW5mLnRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgdG8gZXh0cmFjdCByZWFkZXJzIGluc2lkZSAlKC4uLiUpLFxuICAgKiBDYW1saW50ZXJuYWxGb3JtYXQuZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgdG8gZXh0cmFjdCBmb3JtYXQgdHlwZS4gKilcblxuKCpcbmxldCByZWMgY29uY2F0X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXR0eSA9XG4qKVxubGV0IHJlYyBjb25jYXRfZm10dHkgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgICAgICBnMSBqMSBnMiBqMlxuICAuXG4gICAgKGcxLCBiMSwgYzEsIGoxLCBkMSwgYTEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBkMiwgYTIpIGZtdHR5X3JlbCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGUxLCBmMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGUyLCBmMikgZm10dHlfcmVsID1cbmZ1biBmbXR0eTEgZm10dHkyIC0+IG1hdGNoIGZtdHR5MSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBFbmRfb2ZfZm10dHkgLT4gZm10dHkyXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0cy4gKilcbmxldCByZWMgY29uY2F0X2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXQgPVxuZnVuIGZtdDEgZm10MiAtPiBtYXRjaCBmbXQxIHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBTdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBDYW1sX3N0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDMyIChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgQ2hhciAocmVzdCkgLT5cbiAgICBDaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIENhbWxfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIEJvb2wgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIEFscGhhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgVGhldGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgQ3VzdG9tIChhcml0eSwgZiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgUmVhZGVyIHJlc3QgLT5cbiAgICBSZWFkZXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBGbHVzaCAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZ19saXRlcmFsIChzdHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIENoYXJfbGl0ZXJhbCAgIChjaHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnICAgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgIFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fbmV4dF9jaGFyIChyZXN0KSAtPlxuICAgIFNjYW5fbmV4dF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgSWdub3JlZF9wYXJhbSAoaWduLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgZm10MlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgR2FicmllbCBTY2hlcmVyLCBwcm9qZXQgUGFydG91dCwgSU5SSUEgUGFyaXMtU2FjbGF5ICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAyMCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDYW1saW50ZXJuYWxBdG9taWMgaXMgYSBkZXBlbmRlbmN5IG9mIFN0ZGxpYiwgc28gaXQgaXMgY29tcGlsZWQgd2l0aFxuICAgLW5vcGVydmFzaXZlcy4gKilcbmV4dGVybmFsICggPT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiBXZSBhcmUgbm90IHJldXNpbmcgKCdhIHJlZikgZGlyZWN0bHkgdG8gbWFrZSBpdCBlYXNpZXIgdG8gcmVhc29uXG4gICBhYm91dCBhdG9taWNpdHkgaWYgd2Ugd2lzaCB0bzogZXZlbiBpbiBhIHNlcXVlbnRpYWwgaW1wbGVtZW50YXRpb24sXG4gICBzaWduYWxzIGFuZCBvdGhlciBhc3luY2hyb25vdXMgY2FsbGJhY2tzIG1pZ2h0IGJyZWFrIGF0b21pY2l0eS4gKilcbnR5cGUgJ2EgdCA9IHttdXRhYmxlIHY6ICdhfVxuXG5sZXQgbWFrZSB2ID0ge3Z9XG5sZXQgZ2V0IHIgPSByLnZcbmxldCBzZXQgciB2ID0gci52IDwtIHZcblxuKCogVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgYXJlIHNldCB0byBuZXZlciBiZSBpbmxpbmVkOiBGbGFtYmRhIGlzXG4gICBhbGxvd2VkIHRvIG1vdmUgc3Vycm91bmRpbmcgY29kZSBpbnNpZGUgdGhlIGNyaXRpY2FsIHNlY3Rpb24sXG4gICBpbmNsdWRpbmcgYWxsb2NhdGlvbnMuICopXG5cbmxldFtAaW5saW5lIG5ldmVyXSBleGNoYW5nZSByIHYgPVxuICAoKiBCRUdJTiBBVE9NSUMgKilcbiAgbGV0IGN1ciA9IHIudiBpblxuICByLnYgPC0gdjtcbiAgKCogRU5EIEFUT01JQyAqKVxuICBjdXJcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGNvbXBhcmVfYW5kX3NldCByIHNlZW4gdiA9XG4gICgqIEJFR0lOIEFUT01JQyAqKVxuICBsZXQgY3VyID0gci52IGluXG4gIGlmIGN1ciA9PSBzZWVuIHRoZW4gKFxuICAgIHIudiA8LSB2O1xuICAgICgqIEVORCBBVE9NSUMgKilcbiAgICB0cnVlXG4gICkgZWxzZVxuICAgIGZhbHNlXG5cbmxldFtAaW5saW5lIG5ldmVyXSBmZXRjaF9hbmRfYWRkIHIgbiA9XG4gICgqIEJFR0lOIEFUT01JQyAqKVxuICBsZXQgY3VyID0gci52IGluXG4gIHIudiA8LSAoY3VyICsgbik7XG4gICgqIEVORCBBVE9NSUMgKilcbiAgY3VyXG5cbmxldCBpbmNyIHIgPSBpZ25vcmUgKGZldGNoX2FuZF9hZGQgciAxKVxubGV0IGRlY3IgciA9IGlnbm9yZSAoZmV0Y2hfYW5kX2FkZCByICgtMSkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4Y2VwdGlvbnMgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICAoKiBmb3IgcnVudGltZS9mYWlsX25hdC5jICopXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5hcnJheV9ib3VuZF9lcnJvclwiXG4gICAgKEludmFsaWRfYXJndW1lbnQgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpXG5cbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2VcIlxuZXh0ZXJuYWwgcmFpc2Vfbm90cmFjZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlX25vdHJhY2VcIlxuXG5sZXQgZmFpbHdpdGggcyA9IHJhaXNlKEZhaWx1cmUgcylcbmxldCBpbnZhbGlkX2FyZyBzID0gcmFpc2UoSW52YWxpZF9hcmd1bWVudCBzKVxuXG5leGNlcHRpb24gRXhpdFxuZXhjZXB0aW9uIE1hdGNoX2ZhaWx1cmUgPSBNYXRjaF9mYWlsdXJlXG5leGNlcHRpb24gQXNzZXJ0X2ZhaWx1cmUgPSBBc3NlcnRfZmFpbHVyZVxuZXhjZXB0aW9uIEludmFsaWRfYXJndW1lbnQgPSBJbnZhbGlkX2FyZ3VtZW50XG5leGNlcHRpb24gRmFpbHVyZSA9IEZhaWx1cmVcbmV4Y2VwdGlvbiBOb3RfZm91bmQgPSBOb3RfZm91bmRcbmV4Y2VwdGlvbiBPdXRfb2ZfbWVtb3J5ID0gT3V0X29mX21lbW9yeVxuZXhjZXB0aW9uIFN0YWNrX292ZXJmbG93ID0gU3RhY2tfb3ZlcmZsb3dcbmV4Y2VwdGlvbiBTeXNfZXJyb3IgPSBTeXNfZXJyb3JcbmV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSA9IEVuZF9vZl9maWxlXG5leGNlcHRpb24gRGl2aXNpb25fYnlfemVybyA9IERpdmlzaW9uX2J5X3plcm9cbmV4Y2VwdGlvbiBTeXNfYmxvY2tlZF9pbyA9IFN5c19ibG9ja2VkX2lvXG5leGNlcHRpb24gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgPSBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZVxuXG4oKiBDb21wb3NpdGlvbiBvcGVyYXRvcnMgKilcblxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcbmV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5cbigqIERlYnVnZ2luZyAqKVxuXG5leHRlcm5hbCBfX0xPQ19fIDogc3RyaW5nID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0ZJTEVfXyA6IHN0cmluZyA9IFwiJWxvY19GSUxFXCJcbmV4dGVybmFsIF9fTElORV9fIDogaW50ID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19NT0RVTEVfXyA6IHN0cmluZyA9IFwiJWxvY19NT0RVTEVcIlxuZXh0ZXJuYWwgX19QT1NfXyA6IHN0cmluZyAqIGludCAqIGludCAqIGludCA9IFwiJWxvY19QT1NcIlxuZXh0ZXJuYWwgX19GVU5DVElPTl9fIDogc3RyaW5nID0gXCIlbG9jX0ZVTkNUSU9OXCJcblxuZXh0ZXJuYWwgX19MT0NfT0ZfXyA6ICdhIC0+IHN0cmluZyAqICdhID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0xJTkVfT0ZfXyA6ICdhIC0+IGludCAqICdhID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19QT1NfT0ZfXyA6ICdhIC0+IChzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQpICogJ2EgPSBcIiVsb2NfUE9TXCJcblxuKCogQ29tcGFyaXNvbnMgKilcblxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA8PiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbmV4dGVybmFsICggPCApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbmV4dGVybmFsICggPiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbmV4dGVybmFsICggPD0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuZXh0ZXJuYWwgKCA+PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5cbmxldCBtaW4geCB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggIT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcVwiXG5cbigqIEJvb2xlYW4gb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIG9yICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5cbigqIEludGVnZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCAoIH4tICkgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsICggfisgKSA6IGludCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBzdWNjIDogaW50IC0+IGludCA9IFwiJXN1Y2NpbnRcIlxuZXh0ZXJuYWwgcHJlZCA6IGludCAtPiBpbnQgPSBcIiVwcmVkaW50XCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgKCAtICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG5leHRlcm5hbCAoICogKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsICggLyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgKCBtb2QgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcblxubGV0IGFicyB4ID0gaWYgeCA+PSAwIHRoZW4geCBlbHNlIC14XG5cbmV4dGVybmFsICggbGFuZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgKCBsb3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuZXh0ZXJuYWwgKCBseG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5cbmxldCBsbm90IHggPSB4IGx4b3IgKC0xKVxuXG5leHRlcm5hbCAoIGxzbCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgKCBsc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbmV4dGVybmFsICggYXNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5cbmxldCBtYXhfaW50ID0gKC0xKSBsc3IgMVxubGV0IG1pbl9pbnQgPSBtYXhfaW50ICsgMVxuXG4oKiBGbG9hdGluZy1wb2ludCBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0uICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsICggfisuICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsICggKy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgKCAtLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCAoICouICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsICggLy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgKCAqKiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc2hfZmxvYXRcIiBcImNhbWxfYWNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5oX2Zsb2F0XCIgXCJjYW1sX2FzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbmhfZmxvYXRcIiBcImNhbWxfYXRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5leHRlcm5hbCBjb3B5c2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICAgICA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgICAgICAgICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIGZsb2F0X29mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGludF9vZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmxldCBpbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuZWdfaW5maW5pdHkgPVxuICBmbG9hdF9vZl9iaXRzIDB4RkZfRjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgbmFuID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAxTFxubGV0IG1heF9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9FRl9GRl9GRl9GRl9GRl9GRl9GRkxcbmxldCBtaW5fZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4MDBfMTBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgZXBzaWxvbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgzQ19CMF8wMF8wMF8wMF8wMF8wMF8wMExcblxudHlwZSBmcGNsYXNzID1cbiAgICBGUF9ub3JtYWxcbiAgfCBGUF9zdWJub3JtYWxcbiAgfCBGUF96ZXJvXG4gIHwgRlBfaW5maW5pdGVcbiAgfCBGUF9uYW5cbmV4dGVybmFsIGNsYXNzaWZ5X2Zsb2F0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGZwY2xhc3MgPVxuICBcImNhbWxfY2xhc3NpZnlfZmxvYXRcIiBcImNhbWxfY2xhc3NpZnlfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5cbigqIFN0cmluZyBhbmQgYnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlcyBTdHJpbmcgYW5kIEJ5dGVzICopXG5cbmV4dGVybmFsIHN0cmluZ19sZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19sZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBzdHJpbmdfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBieXRlc19ibGl0IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBieXRlc191bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcblxubGV0ICggXiApIHMxIHMyID1cbiAgbGV0IGwxID0gc3RyaW5nX2xlbmd0aCBzMSBhbmQgbDIgPSBzdHJpbmdfbGVuZ3RoIHMyIGluXG4gIGxldCBzID0gYnl0ZXNfY3JlYXRlIChsMSArIGwyKSBpblxuICBzdHJpbmdfYmxpdCBzMSAwIHMgMCBsMTtcbiAgc3RyaW5nX2JsaXQgczIgMCBzIGwxIGwyO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuKCogQ2hhcmFjdGVyIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgQ2hhciAqKVxuXG5leHRlcm5hbCBpbnRfb2ZfY2hhciA6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NoYXJfb2ZfaW50IDogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5sZXQgY2hhcl9vZl9pbnQgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcImNoYXJfb2ZfaW50XCIgZWxzZSB1bnNhZmVfY2hhcl9vZl9pbnQgblxuXG4oKiBVbml0IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbigqIFBhaXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBmc3QgOiAnYSAqICdiIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsIHNuZCA6ICdhICogJ2IgLT4gJ2IgPSBcIiVmaWVsZDFcIlxuXG4oKiBSZWZlcmVuY2VzICopXG5cbnR5cGUgJ2EgcmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuZXh0ZXJuYWwgcmVmIDogJ2EgLT4gJ2EgcmVmID0gXCIlbWFrZW11dGFibGVcIlxuZXh0ZXJuYWwgKCAhICkgOiAnYSByZWYgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgKCA6PSApIDogJ2EgcmVmIC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuZXh0ZXJuYWwgaW5jciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWluY3JcIlxuZXh0ZXJuYWwgZGVjciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWRlY3JcIlxuXG4oKiBSZXN1bHQgdHlwZSAqKVxuXG50eXBlICgnYSwnYikgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnYlxuXG4oKiBTdHJpbmcgY29udmVyc2lvbiBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0IDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuXG5sZXQgc3RyaW5nX29mX2Jvb2wgYiA9XG4gIGlmIGIgdGhlbiBcInRydWVcIiBlbHNlIFwiZmFsc2VcIlxubGV0IGJvb2xfb2Zfc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gIHwgXyAtPiBpbnZhbGlkX2FyZyBcImJvb2xfb2Zfc3RyaW5nXCJcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCA9IGZ1bmN0aW9uXG4gIHwgXCJ0cnVlXCIgLT4gU29tZSB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IFNvbWUgZmFsc2VcbiAgfCBfIC0+IE5vbmVcblxubGV0IHN0cmluZ19vZl9pbnQgbiA9XG4gIGZvcm1hdF9pbnQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5cbmxldCBpbnRfb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogcHJvdmlkZSB0aGlzIGRpcmVjdGx5IGFzIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlLiAqKVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmV4dGVybmFsIHN0cmluZ19nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuXG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gcyA9XG4gIGxldCBsID0gc3RyaW5nX2xlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID49IGwgdGhlbiBzIF4gXCIuXCIgZWxzZVxuICAgIG1hdGNoIHN0cmluZ19nZXQgcyBpIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gbG9vcCAoaSArIDEpXG4gICAgfCBfIC0+IHNcbiAgaW5cbiAgbG9vcCAwXG5cbmxldCBzdHJpbmdfb2ZfZmxvYXQgZiA9IHZhbGlkX2Zsb2F0X2xleGVtIChmb3JtYXRfZmxvYXQgXCIlLjEyZ1wiIGYpXG5cbmV4dGVybmFsIGZsb2F0X29mX3N0cmluZyA6IHN0cmluZyAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdF9vZl9zdHJpbmdcIlxuXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogcHJvdmlkZSB0aGlzIGRpcmVjdGx5IGFzIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlLiAqKVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuKCogTGlzdCBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlIExpc3QgKilcblxubGV0IHJlYyAoIEAgKSBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgICBbXSAtPiBsMlxuICB8IGhkIDo6IHRsIC0+IGhkIDo6ICh0bCBAIGwyKVxuXG4oKiBJL08gb3BlcmF0aW9ucyAqKVxuXG50eXBlIGluX2NoYW5uZWxcbnR5cGUgb3V0X2NoYW5uZWxcblxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX291dCA6IGludCAtPiBvdXRfY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XCJcbmV4dGVybmFsIG9wZW5fZGVzY3JpcHRvcl9pbiA6IGludCAtPiBpbl9jaGFubmVsID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblwiXG5cbmxldCBzdGRpbiA9IG9wZW5fZGVzY3JpcHRvcl9pbiAwXG5sZXQgc3Rkb3V0ID0gb3Blbl9kZXNjcmlwdG9yX291dCAxXG5sZXQgc3RkZXJyID0gb3Blbl9kZXNjcmlwdG9yX291dCAyXG5cbigqIEdlbmVyYWwgb3V0cHV0IGZ1bmN0aW9ucyAqKVxuXG50eXBlIG9wZW5fZmxhZyA9XG4gICAgT3Blbl9yZG9ubHkgfCBPcGVuX3dyb25seSB8IE9wZW5fYXBwZW5kXG4gIHwgT3Blbl9jcmVhdCB8IE9wZW5fdHJ1bmMgfCBPcGVuX2V4Y2xcbiAgfCBPcGVuX2JpbmFyeSB8IE9wZW5fdGV4dCB8IE9wZW5fbm9uYmxvY2tcblxuZXh0ZXJuYWwgb3Blbl9kZXNjIDogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuXG5leHRlcm5hbCBzZXRfb3V0X2NoYW5uZWxfbmFtZTogb3V0X2NoYW5uZWwgLT4gc3RyaW5nIC0+IHVuaXQgPVxuICBcImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVwiXG5cbmxldCBvcGVuX291dF9nZW4gbW9kZSBwZXJtIG5hbWUgPVxuICBsZXQgYyA9IG9wZW5fZGVzY3JpcHRvcl9vdXQob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfb3V0X2NoYW5uZWxfbmFtZSBjIG5hbWU7XG4gIGNcblxubGV0IG9wZW5fb3V0IG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX3RleHRdIDBvNjY2IG5hbWVcblxubGV0IG9wZW5fb3V0X2JpbiBuYW1lID1cbiAgb3Blbl9vdXRfZ2VuIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl90cnVuYzsgT3Blbl9iaW5hcnldIDBvNjY2IG5hbWVcblxuZXh0ZXJuYWwgZmx1c2ggOiBvdXRfY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2ZsdXNoXCJcblxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxzX2xpc3QgOiB1bml0IC0+IG91dF9jaGFubmVsIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dF9jaGFubmVsc19saXN0XCJcblxubGV0IGZsdXNoX2FsbCAoKSA9XG4gIGxldCByZWMgaXRlciA9IGZ1bmN0aW9uXG4gICAgICBbXSAtPiAoKVxuICAgIHwgYTo6bCAtPlxuICAgICAgICBiZWdpbiB0cnlcbiAgICAgICAgICAgIGZsdXNoIGFcbiAgICAgICAgd2l0aCBTeXNfZXJyb3IgXyAtPlxuICAgICAgICAgICgpICgqIGlnbm9yZSBjaGFubmVscyBjbG9zZWQgZHVyaW5nIGEgcHJlY2VkaW5nIGZsdXNoLiAqKVxuICAgICAgICBlbmQ7XG4gICAgICAgIGl0ZXIgbFxuICBpbiBpdGVyIChvdXRfY2hhbm5lbHNfbGlzdCAoKSlcblxuZXh0ZXJuYWwgdW5zYWZlX291dHB1dCA6IG91dF9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRwdXRfYnl0ZXNcIlxuZXh0ZXJuYWwgdW5zYWZlX291dHB1dF9zdHJpbmcgOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRwdXRcIlxuXG5leHRlcm5hbCBvdXRwdXRfY2hhciA6IG91dF9jaGFubmVsIC0+IGNoYXIgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfY2hhclwiXG5cbmxldCBvdXRwdXRfYnl0ZXMgb2MgcyA9XG4gIHVuc2FmZV9vdXRwdXQgb2MgcyAwIChieXRlc19sZW5ndGggcylcblxubGV0IG91dHB1dF9zdHJpbmcgb2MgcyA9XG4gIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgMCAoc3RyaW5nX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0IG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0XCJcbiAgZWxzZSB1bnNhZmVfb3V0cHV0IG9jIHMgb2ZzIGxlblxuXG5sZXQgb3V0cHV0X3N1YnN0cmluZyBvYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gc3RyaW5nX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRfc3Vic3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfb3V0cHV0X3N0cmluZyBvYyBzIG9mcyBsZW5cblxuZXh0ZXJuYWwgb3V0cHV0X2J5dGUgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfY2hhclwiXG5leHRlcm5hbCBvdXRwdXRfYmluYXJ5X2ludCA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9pbnRcIlxuXG5leHRlcm5hbCBtYXJzaGFsX3RvX2NoYW5uZWwgOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiB1bml0IGxpc3QgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVcIlxubGV0IG91dHB1dF92YWx1ZSBjaGFuIHYgPSBtYXJzaGFsX3RvX2NoYW5uZWwgY2hhbiB2IFtdXG5cbmV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19vdXRcIlxuZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9wb3Nfb3V0XCJcbmV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVcIlxuZXh0ZXJuYWwgY2xvc2Vfb3V0X2NoYW5uZWwgOiBvdXRfY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2Nsb3NlX2NoYW5uZWxcIlxubGV0IGNsb3NlX291dCBvYyA9IGZsdXNoIG9jOyBjbG9zZV9vdXRfY2hhbm5lbCBvY1xubGV0IGNsb3NlX291dF9ub2VyciBvYyA9XG4gICh0cnkgZmx1c2ggb2Mgd2l0aCBfIC0+ICgpKTtcbiAgKHRyeSBjbG9zZV9vdXRfY2hhbm5lbCBvYyB3aXRoIF8gLT4gKCkpXG5leHRlcm5hbCBzZXRfYmluYXJ5X21vZGVfb3V0IDogb3V0X2NoYW5uZWwgLT4gYm9vbCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZVwiXG5cbigqIEdlbmVyYWwgaW5wdXQgZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIHNldF9pbl9jaGFubmVsX25hbWU6IGluX2NoYW5uZWwgLT4gc3RyaW5nIC0+IHVuaXQgPVxuICBcImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVwiXG5cbmxldCBvcGVuX2luX2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX2luKG9wZW5fZGVzYyBuYW1lIG1vZGUgcGVybSkgaW5cbiAgc2V0X2luX2NoYW5uZWxfbmFtZSBjIG5hbWU7XG4gIGNcblxubGV0IG9wZW5faW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl90ZXh0XSAwIG5hbWVcblxubGV0IG9wZW5faW5fYmluIG5hbWUgPVxuICBvcGVuX2luX2dlbiBbT3Blbl9yZG9ubHk7IE9wZW5fYmluYXJ5XSAwIG5hbWVcblxuZXh0ZXJuYWwgaW5wdXRfY2hhciA6IGluX2NoYW5uZWwgLT4gY2hhciA9IFwiY2FtbF9tbF9pbnB1dF9jaGFyXCJcblxuZXh0ZXJuYWwgdW5zYWZlX2lucHV0IDogaW5fY2hhbm5lbCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2lucHV0XCJcblxubGV0IGlucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiaW5wdXRcIlxuICBlbHNlIHVuc2FmZV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYyB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIGxlbiA8PSAwIHRoZW4gKCkgZWxzZSBiZWdpblxuICAgIGxldCByID0gdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlbiBpblxuICAgIGlmIHIgPSAwXG4gICAgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZVxuICAgIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIChvZnMgKyByKSAobGVuIC0gcilcbiAgZW5kXG5cbmxldCByZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJyZWFsbHlfaW5wdXRcIlxuICBlbHNlIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuXG5cbmxldCByZWFsbHlfaW5wdXRfc3RyaW5nIGljIGxlbiA9XG4gIGxldCBzID0gYnl0ZXNfY3JlYXRlIGxlbiBpblxuICByZWFsbHlfaW5wdXQgaWMgcyAwIGxlbjtcbiAgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyBzXG5cbmV4dGVybmFsIGlucHV0X3NjYW5fbGluZSA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X3NjYW5fbGluZVwiXG5cbmxldCBpbnB1dF9saW5lIGNoYW4gPVxuICBsZXQgcmVjIGJ1aWxkX3Jlc3VsdCBidWYgcG9zID0gZnVuY3Rpb25cbiAgICBbXSAtPiBidWZcbiAgfCBoZCA6OiB0bCAtPlxuICAgICAgbGV0IGxlbiA9IGJ5dGVzX2xlbmd0aCBoZCBpblxuICAgICAgYnl0ZXNfYmxpdCBoZCAwIGJ1ZiAocG9zIC0gbGVuKSBsZW47XG4gICAgICBidWlsZF9yZXN1bHQgYnVmIChwb3MgLSBsZW4pIHRsIGluXG4gIGxldCByZWMgc2NhbiBhY2N1IGxlbiA9XG4gICAgbGV0IG4gPSBpbnB1dF9zY2FuX2xpbmUgY2hhbiBpblxuICAgIGlmIG4gPSAwIHRoZW4gYmVnaW4gICAgICAgICAgICAgICAgICAgKCogbiA9IDA6IHdlIGFyZSBhdCBFT0YgKilcbiAgICAgIG1hdGNoIGFjY3Ugd2l0aFxuICAgICAgICBbXSAtPiByYWlzZSBFbmRfb2ZfZmlsZVxuICAgICAgfCBfICAtPiBidWlsZF9yZXN1bHQgKGJ5dGVzX2NyZWF0ZSBsZW4pIGxlbiBhY2N1XG4gICAgZW5kIGVsc2UgaWYgbiA+IDAgdGhlbiBiZWdpbiAgICAgICAgICAoKiBuID4gMDogbmV3bGluZSBmb3VuZCBpbiBidWZmZXIgKilcbiAgICAgIGxldCByZXMgPSBieXRlc19jcmVhdGUgKG4gLSAxKSBpblxuICAgICAgaWdub3JlICh1bnNhZmVfaW5wdXQgY2hhbiByZXMgMCAobiAtIDEpKTtcbiAgICAgIGlnbm9yZSAoaW5wdXRfY2hhciBjaGFuKTsgICAgICAgICAgICgqIHNraXAgdGhlIG5ld2xpbmUgKilcbiAgICAgIG1hdGNoIGFjY3Ugd2l0aFxuICAgICAgICBbXSAtPiByZXNcbiAgICAgIHwgIF8gLT4gbGV0IGxlbiA9IGxlbiArIG4gLSAxIGluXG4gICAgICAgICAgICAgIGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIChyZXMgOjogYWNjdSlcbiAgICBlbmQgZWxzZSBiZWdpbiAgICAgICAgICAgICAgICAgICAgICAgICgqIG4gPCAwOiBuZXdsaW5lIG5vdCBmb3VuZCAqKVxuICAgICAgbGV0IGJlZyA9IGJ5dGVzX2NyZWF0ZSAoLW4pIGluXG4gICAgICBpZ25vcmUodW5zYWZlX2lucHV0IGNoYW4gYmVnIDAgKC1uKSk7XG4gICAgICBzY2FuIChiZWcgOjogYWNjdSkgKGxlbiAtIG4pXG4gICAgZW5kXG4gIGluIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgKHNjYW4gW10gMClcblxuZXh0ZXJuYWwgaW5wdXRfYnl0ZSA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuZXh0ZXJuYWwgaW5wdXRfYmluYXJ5X2ludCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X2ludFwiXG5leHRlcm5hbCBpbnB1dF92YWx1ZSA6IGluX2NoYW5uZWwgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVcIlxuZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19pblwiXG5leHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9wb3NfaW5cIlxuZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVcIlxuZXh0ZXJuYWwgY2xvc2VfaW4gOiBpbl9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2VfaW5fbm9lcnIgaWMgPSAodHJ5IGNsb3NlX2luIGljIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9pbiA6IGluX2NoYW5uZWwgLT4gYm9vbCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBvdXRwdXQgKilcblxubGV0IHByaW50X2NoYXIgYyA9IG91dHB1dF9jaGFyIHN0ZG91dCBjXG5sZXQgcHJpbnRfc3RyaW5nIHMgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCBzXG5sZXQgcHJpbnRfYnl0ZXMgcyA9IG91dHB1dF9ieXRlcyBzdGRvdXQgc1xubGV0IHByaW50X2ludCBpID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgKHN0cmluZ19vZl9pbnQgaSlcbmxldCBwcmludF9mbG9hdCBmID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgKHN0cmluZ19vZl9mbG9hdCBmKVxubGV0IHByaW50X2VuZGxpbmUgcyA9XG4gIG91dHB1dF9zdHJpbmcgc3Rkb3V0IHM7IG91dHB1dF9jaGFyIHN0ZG91dCAnXFxuJzsgZmx1c2ggc3Rkb3V0XG5sZXQgcHJpbnRfbmV3bGluZSAoKSA9IG91dHB1dF9jaGFyIHN0ZG91dCAnXFxuJzsgZmx1c2ggc3Rkb3V0XG5cbigqIE91dHB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgZXJyb3IgKilcblxubGV0IHByZXJyX2NoYXIgYyA9IG91dHB1dF9jaGFyIHN0ZGVyciBjXG5sZXQgcHJlcnJfc3RyaW5nIHMgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciBzXG5sZXQgcHJlcnJfYnl0ZXMgcyA9IG91dHB1dF9ieXRlcyBzdGRlcnIgc1xubGV0IHByZXJyX2ludCBpID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgKHN0cmluZ19vZl9pbnQgaSlcbmxldCBwcmVycl9mbG9hdCBmID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgKHN0cmluZ19vZl9mbG9hdCBmKVxubGV0IHByZXJyX2VuZGxpbmUgcyA9XG4gIG91dHB1dF9zdHJpbmcgc3RkZXJyIHM7IG91dHB1dF9jaGFyIHN0ZGVyciAnXFxuJzsgZmx1c2ggc3RkZXJyXG5sZXQgcHJlcnJfbmV3bGluZSAoKSA9IG91dHB1dF9jaGFyIHN0ZGVyciAnXFxuJzsgZmx1c2ggc3RkZXJyXG5cbigqIElucHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBpbnB1dCAqKVxuXG5sZXQgcmVhZF9saW5lICgpID0gZmx1c2ggc3Rkb3V0OyBpbnB1dF9saW5lIHN0ZGluXG5sZXQgcmVhZF9pbnQgKCkgPSBpbnRfb2Zfc3RyaW5nKHJlYWRfbGluZSgpKVxubGV0IHJlYWRfaW50X29wdCAoKSA9IGludF9vZl9zdHJpbmdfb3B0KHJlYWRfbGluZSgpKVxubGV0IHJlYWRfZmxvYXQgKCkgPSBmbG9hdF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdF9vcHQgKCkgPSBmbG9hdF9vZl9zdHJpbmdfb3B0KHJlYWRfbGluZSgpKVxuXG4oKiBPcGVyYXRpb25zIG9uIGxhcmdlIGZpbGVzICopXG5cbm1vZHVsZSBMYXJnZUZpbGUgPVxuICBzdHJ1Y3RcbiAgICBleHRlcm5hbCBzZWVrX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19vdXRfNjRcIlxuICAgIGV4dGVybmFsIHBvc19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9wb3Nfb3V0XzY0XCJcbiAgICBleHRlcm5hbCBvdXRfY2hhbm5lbF9sZW5ndGggOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcIlxuICAgIGV4dGVybmFsIHNlZWtfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19pbl82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX2luIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9wb3NfaW5fNjRcIlxuICAgIGV4dGVybmFsIGluX2NoYW5uZWxfbGVuZ3RoIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcIlxuICBlbmRcblxuKCogRm9ybWF0cyAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG4gICA9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxuICAgPSBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mbXRcbiAgICAgICAgICAgICAgICogc3RyaW5nXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0ID0gKCdhLCAnYiwgJ2MsICdjLCAnYywgJ2QpIGZvcm1hdDZcblxudHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0ID0gKCdhLCAnYiwgJ2MsICdjKSBmb3JtYXQ0XG5cbmxldCBzdHJpbmdfb2ZfZm9ybWF0IChGb3JtYXQgKF9mbXQsIHN0cikpID0gc3RyXG5cbmV4dGVybmFsIGZvcm1hdF9vZl9zdHJpbmcgOlxuICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPSBcIiVpZGVudGl0eVwiXG5cbmxldCAoIF5eICkgKEZvcm1hdCAoZm10MSwgc3RyMSkpIChGb3JtYXQgKGZtdDIsIHN0cjIpKSA9XG4gIEZvcm1hdCAoQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmNvbmNhdF9mbXQgZm10MSBmbXQyLFxuICAgICAgICAgIHN0cjEgXiBcIiUsXCIgXiBzdHIyKVxuXG4oKiBNaXNjZWxsYW5lb3VzICopXG5cbmV4dGVybmFsIHN5c19leGl0IDogaW50IC0+ICdhID0gXCJjYW1sX3N5c19leGl0XCJcblxubGV0IGV4aXRfZnVuY3Rpb24gPSBDYW1saW50ZXJuYWxBdG9taWMubWFrZSBmbHVzaF9hbGxcblxubGV0IHJlYyBhdF9leGl0IGYgPVxuICBsZXQgbW9kdWxlIEF0b21pYyA9IENhbWxpbnRlcm5hbEF0b21pYyBpblxuICAoKiBNUFIjNzI1MywgTVBSIzc3OTY6IG1ha2Ugc3VyZSBcImZcIiBpcyBleGVjdXRlZCBvbmx5IG9uY2UgKilcbiAgbGV0IGZfeWV0X3RvX3J1biA9IEF0b21pYy5tYWtlIHRydWUgaW5cbiAgbGV0IG9sZF9leGl0ID0gQXRvbWljLmdldCBleGl0X2Z1bmN0aW9uIGluXG4gIGxldCBuZXdfZXhpdCAoKSA9XG4gICAgaWYgQXRvbWljLmNvbXBhcmVfYW5kX3NldCBmX3lldF90b19ydW4gdHJ1ZSBmYWxzZSB0aGVuIGYgKCkgO1xuICAgIG9sZF9leGl0ICgpXG4gIGluXG4gIGxldCBzdWNjZXNzID0gQXRvbWljLmNvbXBhcmVfYW5kX3NldCBleGl0X2Z1bmN0aW9uIG9sZF9leGl0IG5ld19leGl0IGluXG4gIGlmIG5vdCBzdWNjZXNzIHRoZW4gYXRfZXhpdCBmXG5cbmxldCBkb19hdF9leGl0ICgpID0gKENhbWxpbnRlcm5hbEF0b21pYy5nZXQgZXhpdF9mdW5jdGlvbikgKClcblxubGV0IGV4aXQgcmV0Y29kZSA9XG4gIGRvX2F0X2V4aXQgKCk7XG4gIHN5c19leGl0IHJldGNvZGVcblxubGV0IF8gPSByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlBlcnZhc2l2ZXMuZG9fYXRfZXhpdFwiIGRvX2F0X2V4aXRcblxuZXh0ZXJuYWwgbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWFqb3JcIlxuZXh0ZXJuYWwgbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCA6IHVuaXQgLT4gYm9vbFxuICA9IFwiY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZFwiXG5sZXQgKCkgPSBpZiBuYWtlZF9wb2ludGVyc19jaGVja2VkICgpIHRoZW4gYXRfZXhpdCBtYWpvclxuXG4oKk1PRFVMRV9BTElBU0VTKilcbm1vZHVsZSBBcmcgICAgICAgICAgPSBBcmdcbm1vZHVsZSBBcnJheSAgICAgICAgPSBBcnJheVxubW9kdWxlIEFycmF5TGFiZWxzICA9IEFycmF5TGFiZWxzXG5tb2R1bGUgQXRvbWljICAgICAgID0gQXRvbWljXG5tb2R1bGUgQmlnYXJyYXkgICAgID0gQmlnYXJyYXlcbm1vZHVsZSBCb29sICAgICAgICAgPSBCb29sXG5tb2R1bGUgQnVmZmVyICAgICAgID0gQnVmZmVyXG5tb2R1bGUgQnl0ZXMgICAgICAgID0gQnl0ZXNcbm1vZHVsZSBCeXRlc0xhYmVscyAgPSBCeXRlc0xhYmVsc1xubW9kdWxlIENhbGxiYWNrICAgICA9IENhbGxiYWNrXG5tb2R1bGUgQ2hhciAgICAgICAgID0gQ2hhclxubW9kdWxlIENvbXBsZXggICAgICA9IENvbXBsZXhcbm1vZHVsZSBEaWdlc3QgICAgICAgPSBEaWdlc3Rcbm1vZHVsZSBFaXRoZXIgICAgICAgPSBFaXRoZXJcbm1vZHVsZSBFcGhlbWVyb24gICAgPSBFcGhlbWVyb25cbm1vZHVsZSBGaWxlbmFtZSAgICAgPSBGaWxlbmFtZVxubW9kdWxlIEZsb2F0ICAgICAgICA9IEZsb2F0XG5tb2R1bGUgRm9ybWF0ICAgICAgID0gRm9ybWF0XG5tb2R1bGUgRnVuICAgICAgICAgID0gRnVuXG5tb2R1bGUgR2MgICAgICAgICAgID0gR2Ncbm1vZHVsZSBHZW5sZXggICAgICAgPSBHZW5sZXhcbm1vZHVsZSBIYXNodGJsICAgICAgPSBIYXNodGJsXG5tb2R1bGUgSW5fY2hhbm5lbCAgID0gSW5fY2hhbm5lbFxubW9kdWxlIEludCAgICAgICAgICA9IEludFxubW9kdWxlIEludDMyICAgICAgICA9IEludDMyXG5tb2R1bGUgSW50NjQgICAgICAgID0gSW50NjRcbm1vZHVsZSBMYXp5ICAgICAgICAgPSBMYXp5XG5tb2R1bGUgTGV4aW5nICAgICAgID0gTGV4aW5nXG5tb2R1bGUgTGlzdCAgICAgICAgID0gTGlzdFxubW9kdWxlIExpc3RMYWJlbHMgICA9IExpc3RMYWJlbHNcbm1vZHVsZSBNYXAgICAgICAgICAgPSBNYXBcbm1vZHVsZSBNYXJzaGFsICAgICAgPSBNYXJzaGFsXG5tb2R1bGUgTW9yZUxhYmVscyAgID0gTW9yZUxhYmVsc1xubW9kdWxlIE5hdGl2ZWludCAgICA9IE5hdGl2ZWludFxubW9kdWxlIE9iaiAgICAgICAgICA9IE9ialxubW9kdWxlIE9vICAgICAgICAgICA9IE9vXG5tb2R1bGUgT3B0aW9uICAgICAgID0gT3B0aW9uXG5tb2R1bGUgT3V0X2NoYW5uZWwgID0gT3V0X2NoYW5uZWxcbm1vZHVsZSBQYXJzaW5nICAgICAgPSBQYXJzaW5nXG5tb2R1bGUgUGVydmFzaXZlcyAgID0gUGVydmFzaXZlc1xubW9kdWxlIFByaW50ZXhjICAgICA9IFByaW50ZXhjXG5tb2R1bGUgUHJpbnRmICAgICAgID0gUHJpbnRmXG5tb2R1bGUgUXVldWUgICAgICAgID0gUXVldWVcbm1vZHVsZSBSYW5kb20gICAgICAgPSBSYW5kb21cbm1vZHVsZSBSZXN1bHQgICAgICAgPSBSZXN1bHRcbm1vZHVsZSBTY2FuZiAgICAgICAgPSBTY2FuZlxubW9kdWxlIFNlcSAgICAgICAgICA9IFNlcVxubW9kdWxlIFNldCAgICAgICAgICA9IFNldFxubW9kdWxlIFN0YWNrICAgICAgICA9IFN0YWNrXG5tb2R1bGUgU3RkTGFiZWxzICAgID0gU3RkTGFiZWxzXG5tb2R1bGUgU3RyZWFtICAgICAgID0gU3RyZWFtXG5tb2R1bGUgU3RyaW5nICAgICAgID0gU3RyaW5nXG5tb2R1bGUgU3RyaW5nTGFiZWxzID0gU3RyaW5nTGFiZWxzXG5tb2R1bGUgU3lzICAgICAgICAgID0gU3lzXG5tb2R1bGUgVWNoYXIgICAgICAgID0gVWNoYXJcbm1vZHVsZSBVbml0ICAgICAgICAgPSBVbml0XG5tb2R1bGUgV2VhayAgICAgICAgID0gV2Vha1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgSmVyZW1pZSBEaW1pbm8sIEphbmUgU3RyZWV0IEV1cm9wZSAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNyBKYW5lIFN0cmVldCBHcm91cCBMTEMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogQGRlcHJlY2F0ZWQgVXNlIHshU3RkbGlifSAqKVxuXG5leHRlcm5hbCByYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlXCJcbmV4dGVybmFsIHJhaXNlX25vdHJhY2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZV9ub3RyYWNlXCJcbmxldCBpbnZhbGlkX2FyZyA9IGludmFsaWRfYXJnXG5sZXQgZmFpbHdpdGggPSBmYWlsd2l0aFxuZXhjZXB0aW9uIEV4aXRcbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoIDwgKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5leHRlcm5hbCAoID4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoIDw9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxubGV0IG1pbiA9IG1pblxubGV0IG1heCA9IG1heFxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggIT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcVwiXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoICYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgKCYmKSBpbnN0ZWFkLlwiXVxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuZXh0ZXJuYWwgKCBvciApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuICBbQEBvY2FtbC5kZXByZWNhdGVkIFwiVXNlICh8fCkgaW5zdGVhZC5cIl1cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcbmV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5leHRlcm5hbCAoIH4tICkgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsICggfisgKSA6IGludCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBzdWNjIDogaW50IC0+IGludCA9IFwiJXN1Y2NpbnRcIlxuZXh0ZXJuYWwgcHJlZCA6IGludCAtPiBpbnQgPSBcIiVwcmVkaW50XCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgKCAtICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG5leHRlcm5hbCAoICogKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsICggLyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgKCBtb2QgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcbmxldCBhYnMgPSBhYnNcbmxldCBtYXhfaW50ID0gbWF4X2ludFxubGV0IG1pbl9pbnQgPSBtaW5faW50XG5leHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsICggbG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxubGV0IGxub3QgPSBsbm90XG5leHRlcm5hbCAoIGxzbCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgKCBsc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbmV4dGVybmFsICggYXNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5leHRlcm5hbCAoIH4tLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCAoIH4rLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoICsuICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsICggLS4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgKCAqLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCAoIC8uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsICggKiogKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5leHRlcm5hbCBjb3B5c2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICAgICA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgICAgICAgICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIGZsb2F0X29mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGludF9vZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxubGV0IGluZmluaXR5ID0gaW5maW5pdHlcbmxldCBuZWdfaW5maW5pdHkgPSBuZWdfaW5maW5pdHlcbmxldCBuYW4gPSBuYW5cbmxldCBtYXhfZmxvYXQgPSBtYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBtaW5fZmxvYXRcbmxldCBlcHNpbG9uX2Zsb2F0ID0gZXBzaWxvbl9mbG9hdFxudHlwZSBub25yZWMgZnBjbGFzcyA9IGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmxldCAoIF4gKSA9ICggXiApXG5leHRlcm5hbCBpbnRfb2ZfY2hhciA6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxubGV0IGNoYXJfb2ZfaW50ID0gY2hhcl9vZl9pbnRcbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxubGV0IHN0cmluZ19vZl9ib29sID0gc3RyaW5nX29mX2Jvb2xcbmxldCBib29sX29mX3N0cmluZyA9IGJvb2xfb2Zfc3RyaW5nXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gYm9vbF9vZl9zdHJpbmdfb3B0XG5sZXQgc3RyaW5nX29mX2ludCA9IHN0cmluZ19vZl9pbnRcbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxubGV0IGludF9vZl9zdHJpbmdfb3B0ID0gaW50X29mX3N0cmluZ19vcHRcbmxldCBzdHJpbmdfb2ZfZmxvYXQgPSBzdHJpbmdfb2ZfZmxvYXRcbmV4dGVybmFsIGZsb2F0X29mX3N0cmluZyA6IHN0cmluZyAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdF9vZl9zdHJpbmdcIlxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgPSBmbG9hdF9vZl9zdHJpbmdfb3B0XG5leHRlcm5hbCBmc3QgOiAnYSAqICdiIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsIHNuZCA6ICdhICogJ2IgLT4gJ2IgPSBcIiVmaWVsZDFcIlxubGV0ICggQCApICA9ICggQCApXG50eXBlIG5vbnJlYyBpbl9jaGFubmVsID0gaW5fY2hhbm5lbFxudHlwZSBub25yZWMgb3V0X2NoYW5uZWwgPSBvdXRfY2hhbm5lbFxubGV0IHN0ZGluID0gc3RkaW5cbmxldCBzdGRvdXQgPSBzdGRvdXRcbmxldCBzdGRlcnIgPSBzdGRlcnJcbmxldCBwcmludF9jaGFyID0gcHJpbnRfY2hhclxubGV0IHByaW50X3N0cmluZyA9IHByaW50X3N0cmluZ1xubGV0IHByaW50X2J5dGVzID0gcHJpbnRfYnl0ZXNcbmxldCBwcmludF9pbnQgPSBwcmludF9pbnRcbmxldCBwcmludF9mbG9hdCA9IHByaW50X2Zsb2F0XG5sZXQgcHJpbnRfZW5kbGluZSA9IHByaW50X2VuZGxpbmVcbmxldCBwcmludF9uZXdsaW5lID0gcHJpbnRfbmV3bGluZVxubGV0IHByZXJyX2NoYXIgPSBwcmVycl9jaGFyXG5sZXQgcHJlcnJfc3RyaW5nID0gcHJlcnJfc3RyaW5nXG5sZXQgcHJlcnJfYnl0ZXMgPSBwcmVycl9ieXRlc1xubGV0IHByZXJyX2ludCA9IHByZXJyX2ludFxubGV0IHByZXJyX2Zsb2F0ID0gcHJlcnJfZmxvYXRcbmxldCBwcmVycl9lbmRsaW5lID0gcHJlcnJfZW5kbGluZVxubGV0IHByZXJyX25ld2xpbmUgPSBwcmVycl9uZXdsaW5lXG5sZXQgcmVhZF9saW5lID0gcmVhZF9saW5lXG5sZXQgcmVhZF9pbnQgPSByZWFkX2ludFxubGV0IHJlYWRfaW50X29wdCA9IHJlYWRfaW50X29wdFxubGV0IHJlYWRfZmxvYXQgPSByZWFkX2Zsb2F0XG5sZXQgcmVhZF9mbG9hdF9vcHQgPSByZWFkX2Zsb2F0X29wdFxudHlwZSBub25yZWMgb3Blbl9mbGFnID0gb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seVxuICB8IE9wZW5fd3Jvbmx5XG4gIHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0XG4gIHwgT3Blbl90cnVuY1xuICB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5XG4gIHwgT3Blbl90ZXh0XG4gIHwgT3Blbl9ub25ibG9ja1xubGV0IG9wZW5fb3V0ID0gb3Blbl9vdXRcbmxldCBvcGVuX291dF9iaW4gPSBvcGVuX291dF9iaW5cbmxldCBvcGVuX291dF9nZW4gPSBvcGVuX291dF9nZW5cbmxldCBmbHVzaCA9IGZsdXNoXG5sZXQgZmx1c2hfYWxsID0gZmx1c2hfYWxsXG5sZXQgb3V0cHV0X2NoYXIgPSBvdXRwdXRfY2hhclxubGV0IG91dHB1dF9zdHJpbmcgPSBvdXRwdXRfc3RyaW5nXG5sZXQgb3V0cHV0X2J5dGVzID0gb3V0cHV0X2J5dGVzXG5sZXQgb3V0cHV0ID0gb3V0cHV0XG5sZXQgb3V0cHV0X3N1YnN0cmluZyA9IG91dHB1dF9zdWJzdHJpbmdcbmxldCBvdXRwdXRfYnl0ZSA9IG91dHB1dF9ieXRlXG5sZXQgb3V0cHV0X2JpbmFyeV9pbnQgPSBvdXRwdXRfYmluYXJ5X2ludFxubGV0IG91dHB1dF92YWx1ZSA9IG91dHB1dF92YWx1ZVxubGV0IHNlZWtfb3V0ID0gc2Vla19vdXRcbmxldCBwb3Nfb3V0ID0gcG9zX291dFxubGV0IG91dF9jaGFubmVsX2xlbmd0aCA9IG91dF9jaGFubmVsX2xlbmd0aFxubGV0IGNsb3NlX291dCA9IGNsb3NlX291dFxubGV0IGNsb3NlX291dF9ub2VyciA9IGNsb3NlX291dF9ub2VyclxubGV0IHNldF9iaW5hcnlfbW9kZV9vdXQgPSBzZXRfYmluYXJ5X21vZGVfb3V0XG5sZXQgb3Blbl9pbiA9IG9wZW5faW5cbmxldCBvcGVuX2luX2JpbiA9IG9wZW5faW5fYmluXG5sZXQgb3Blbl9pbl9nZW4gPSBvcGVuX2luX2dlblxubGV0IGlucHV0X2NoYXIgPSBpbnB1dF9jaGFyXG5sZXQgaW5wdXRfbGluZSA9IGlucHV0X2xpbmVcbmxldCBpbnB1dCA9IGlucHV0XG5sZXQgcmVhbGx5X2lucHV0ID0gcmVhbGx5X2lucHV0XG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyA9IHJlYWxseV9pbnB1dF9zdHJpbmdcbmxldCBpbnB1dF9ieXRlID0gaW5wdXRfYnl0ZVxubGV0IGlucHV0X2JpbmFyeV9pbnQgPSBpbnB1dF9iaW5hcnlfaW50XG5sZXQgaW5wdXRfdmFsdWUgPSBpbnB1dF92YWx1ZVxubGV0IHNlZWtfaW4gPSBzZWVrX2luXG5sZXQgcG9zX2luID0gcG9zX2luXG5sZXQgaW5fY2hhbm5lbF9sZW5ndGggPSBpbl9jaGFubmVsX2xlbmd0aFxubGV0IGNsb3NlX2luID0gY2xvc2VfaW5cbmxldCBjbG9zZV9pbl9ub2VyciA9IGNsb3NlX2luX25vZXJyXG5sZXQgc2V0X2JpbmFyeV9tb2RlX2luID0gc2V0X2JpbmFyeV9tb2RlX2luXG5tb2R1bGUgTGFyZ2VGaWxlID0gTGFyZ2VGaWxlXG50eXBlIG5vbnJlYyAnYSByZWYgPSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG50eXBlIG5vbnJlYyAoJ2EsJ2IpIHJlc3VsdCA9ICgnYSwnYikgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnYlxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxudHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0ID0gKCdhLCAnYiwgJ2MsICdjKSBmb3JtYXQ0XG5sZXQgc3RyaW5nX29mX2Zvcm1hdCA9IHN0cmluZ19vZl9mb3JtYXRcbmV4dGVybmFsIGZvcm1hdF9vZl9zdHJpbmcgOlxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcbmxldCAoIF5eICkgPSAoIF5eIClcbmxldCBleGl0ID0gZXhpdFxubGV0IGF0X2V4aXQgPSBhdF9leGl0XG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gPSB2YWxpZF9mbG9hdF9sZXhlbVxubGV0IGRvX2F0X2V4aXQgPSBkb19hdF9leGl0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEdhYnJpZWwgU2NoZXJlciwgcHJvamV0IFBhcnNpZmFsLCBJTlJJQSBTYWNsYXkgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgKCdhLCAnYikgdCA9IExlZnQgb2YgJ2EgfCBSaWdodCBvZiAnYlxuXG5sZXQgbGVmdCB2ID0gTGVmdCB2XG5sZXQgcmlnaHQgdiA9IFJpZ2h0IHZcblxubGV0IGlzX2xlZnQgPSBmdW5jdGlvblxufCBMZWZ0IF8gLT4gdHJ1ZVxufCBSaWdodCBfIC0+IGZhbHNlXG5cbmxldCBpc19yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgXyAtPiBmYWxzZVxufCBSaWdodCBfIC0+IHRydWVcblxubGV0IGZpbmRfbGVmdCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBTb21lIHZcbnwgUmlnaHQgXyAtPiBOb25lXG5cbmxldCBmaW5kX3JpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCBfIC0+IE5vbmVcbnwgUmlnaHQgdiAtPiBTb21lIHZcblxubGV0IG1hcF9sZWZ0IGYgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gTGVmdCAoZiB2KVxufCBSaWdodCBfIGFzIGUgLT4gZVxuXG5sZXQgbWFwX3JpZ2h0IGYgPSBmdW5jdGlvblxufCBMZWZ0IF8gYXMgZSAtPiBlXG58IFJpZ2h0IHYgLT4gUmlnaHQgKGYgdilcblxubGV0IG1hcCB+bGVmdCB+cmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gTGVmdCAobGVmdCB2KVxufCBSaWdodCB2IC0+IFJpZ2h0IChyaWdodCB2KVxuXG5sZXQgZm9sZCB+bGVmdCB+cmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gbGVmdCB2XG58IFJpZ2h0IHYgLT4gcmlnaHQgdlxuXG5sZXQgaXRlciA9IGZvbGRcblxubGV0IGZvcl9hbGwgPSBmb2xkXG5cbmxldCBlcXVhbCB+bGVmdCB+cmlnaHQgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxufCBMZWZ0IHYxLCBMZWZ0IHYyIC0+IGxlZnQgdjEgdjJcbnwgUmlnaHQgdjEsIFJpZ2h0IHYyIC0+IHJpZ2h0IHYxIHYyXG58IExlZnQgXywgUmlnaHQgXyB8IFJpZ2h0IF8sIExlZnQgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSB+bGVmdCB+cmlnaHQgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxufCBMZWZ0IHYxLCBMZWZ0IHYyIC0+IGxlZnQgdjEgdjJcbnwgUmlnaHQgdjEsIFJpZ2h0IHYyIC0+IHJpZ2h0IHYxIHYyXG58IExlZnQgXywgUmlnaHQgXyAtPiAoLTEpXG58IFJpZ2h0IF8sIExlZnQgXyAtPiAxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE9wZXJhdGlvbnMgb24gaW50ZXJuYWwgcmVwcmVzZW50YXRpb25zIG9mIHZhbHVlcyAqKVxuXG50eXBlIHRcblxudHlwZSByYXdfZGF0YSA9IG5hdGl2ZWludFxuXG5leHRlcm5hbCByZXByIDogJ2EgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG9iaiA6IHQgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBtYWdpYyA6ICdhIC0+ICdiID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgaXNfaW50IDogdCAtPiBib29sID0gXCIlb2JqX2lzX2ludFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBpc19ibG9jayBhID0gbm90IChpc19pbnQgYSlcbmV4dGVybmFsIHRhZyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial90YWdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2V0X3RhZyA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3NldF90YWdcIlxuZXh0ZXJuYWwgc2l6ZSA6IHQgLT4gaW50ID0gXCIlb2JqX3NpemVcIlxuZXh0ZXJuYWwgcmVhY2hhYmxlX3dvcmRzIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1wiXG5leHRlcm5hbCBmaWVsZCA6IHQgLT4gaW50IC0+IHQgPSBcIiVvYmpfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X2ZpZWxkIDogdCAtPiBpbnQgLT4gdCAtPiB1bml0ID0gXCIlb2JqX3NldF9maWVsZFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfZ2V0XCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfc2V0IDpcbiAgICBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfc2V0XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGRvdWJsZV9maWVsZCB4IGkgPSBmbG9hdGFycmF5X2dldCAob2JqIHggOiBmbG9hdGFycmF5KSBpXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBzZXRfZG91YmxlX2ZpZWxkIHggaSB2ID1cbiAgZmxvYXRhcnJheV9zZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaSB2XG5leHRlcm5hbCByYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSA9IFwiY2FtbF9vYmpfcmF3X2ZpZWxkXCJcbmV4dGVybmFsIHNldF9yYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZFwiXG5cbmV4dGVybmFsIG5ld19ibG9jayA6IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9vYmpfYmxvY2tcIlxuZXh0ZXJuYWwgZHVwIDogdCAtPiB0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5leHRlcm5hbCBhZGRfb2Zmc2V0IDogdCAtPiBJbnQzMi50IC0+IHQgPSBcImNhbWxfb2JqX2FkZF9vZmZzZXRcIlxuZXh0ZXJuYWwgd2l0aF90YWcgOiBpbnQgLT4gdCAtPiB0ID0gXCJjYW1sX29ial93aXRoX3RhZ1wiXG5cbmxldCBmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMFxubGV0IGxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDI0NVxuXG5sZXQgbGF6eV90YWcgPSAyNDZcbmxldCBjbG9zdXJlX3RhZyA9IDI0N1xubGV0IG9iamVjdF90YWcgPSAyNDhcbmxldCBpbmZpeF90YWcgPSAyNDlcbmxldCBmb3J3YXJkX3RhZyA9IDI1MFxuXG5sZXQgbm9fc2Nhbl90YWcgPSAyNTFcblxubGV0IGFic3RyYWN0X3RhZyA9IDI1MVxubGV0IHN0cmluZ190YWcgPSAyNTJcbmxldCBkb3VibGVfdGFnID0gMjUzXG5sZXQgZG91YmxlX2FycmF5X3RhZyA9IDI1NFxubGV0IGN1c3RvbV90YWcgPSAyNTVcbmxldCBmaW5hbF90YWcgPSBjdXN0b21fdGFnXG5cblxubGV0IGludF90YWcgPSAxMDAwXG5sZXQgb3V0X29mX2hlYXBfdGFnID0gMTAwMVxubGV0IHVuYWxpZ25lZF90YWcgPSAxMDAyXG5cbm1vZHVsZSBDbG9zdXJlID0gc3RydWN0XG4gIHR5cGUgaW5mbyA9IHtcbiAgICBhcml0eTogaW50O1xuICAgIHN0YXJ0X2VudjogaW50O1xuICB9XG5cbiAgbGV0IGluZm9fb2ZfcmF3IChpbmZvIDogbmF0aXZlaW50KSA9XG4gICAgbGV0IG9wZW4gTmF0aXZlaW50IGluXG4gICAgbGV0IGFyaXR5ID1cbiAgICAgICgqIHNpZ25lZDogbmVnYXRpdmUgZm9yIHR1cGxlZCBmdW5jdGlvbnMgKilcbiAgICAgIGlmIFN5cy53b3JkX3NpemUgPSA2NCB0aGVuXG4gICAgICAgIHRvX2ludCAoc2hpZnRfcmlnaHQgaW5mbyA1NilcbiAgICAgIGVsc2VcbiAgICAgICAgdG9faW50IChzaGlmdF9yaWdodCBpbmZvIDI0KVxuICAgIGluXG4gICAgbGV0IHN0YXJ0X2VudiA9XG4gICAgICAoKiBzdGFydF9lbnYgaXMgdW5zaWduZWQsIGJ1dCB3ZSBrbm93IGl0IGNhbiBhbHdheXMgZml0IGFuIE9DYW1sXG4gICAgICAgICBpbnRlZ2VyIHNvIHdlIHVzZSBbdG9faW50XSBpbnN0ZWFkIG9mIFt1bnNpZ25lZF90b19pbnRdLiAqKVxuICAgICAgdG9faW50IChzaGlmdF9yaWdodF9sb2dpY2FsIChzaGlmdF9sZWZ0IGluZm8gOCkgOSkgaW5cbiAgICB7IGFyaXR5OyBzdGFydF9lbnYgfVxuXG4gICgqIG5vdGU6IHdlIGV4cGVjdCBhIGNsb3N1cmUsIG5vdCBhbiBpbmZpeCBwb2ludGVyICopXG4gIGxldCBpbmZvIChvYmogOiB0KSA9XG4gICAgYXNzZXJ0ICh0YWcgb2JqID0gY2xvc3VyZV90YWcpO1xuICAgIGluZm9fb2ZfcmF3IChyYXdfZmllbGQgb2JqIDEpXG5lbmRcblxubW9kdWxlIEV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9XG5zdHJ1Y3RcbiAgdHlwZSB0ID0gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXG4gIGxldCBvZl92YWwgeCA9XG4gICAgbGV0IHggPSByZXByIHggaW5cbiAgICBsZXQgc2xvdCA9XG4gICAgICBpZiAoaXNfYmxvY2sgeCkgJiYgKHRhZyB4KSA8PiBvYmplY3RfdGFnICYmIChzaXplIHgpID49IDEgdGhlbiBmaWVsZCB4IDBcbiAgICAgIGVsc2UgeFxuICAgIGluXG4gICAgbGV0IG5hbWUgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHNsb3QpICYmICh0YWcgc2xvdCkgPSBvYmplY3RfdGFnIHRoZW4gZmllbGQgc2xvdCAwXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG4gICAgaW5cbiAgICAgIGlmICh0YWcgbmFtZSkgPSBzdHJpbmdfdGFnIHRoZW4gKG9iaiBzbG90IDogdClcbiAgICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBuYW1lIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDApIDogc3RyaW5nKVxuXG4gIGxldCBbQGlubGluZSBhbHdheXNdIGlkIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDEpIDogaW50KVxuZW5kXG5cbmxldCBleHRlbnNpb25fY29uc3RydWN0b3IgPSBFeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsXG5sZXQgZXh0ZW5zaW9uX25hbWUgPSBFeHRlbnNpb25fY29uc3RydWN0b3IubmFtZVxubGV0IGV4dGVuc2lvbl9pZCA9IEV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZFxuXG5tb2R1bGUgRXBoZW1lcm9uID0gc3RydWN0XG4gIHR5cGUgb2JqX3QgPSB0XG5cbiAgdHlwZSB0ICgqKiBlcGhlbWVyb24gKilcblxuICAgKCoqIFRvIGNoYW5nZSBpbiBzeW5jIHdpdGggd2Vhay5oICopXG4gIGxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDJcbiAgbGV0IG1heF9lcGhlX2xlbmd0aCA9IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gdCA9IFwiY2FtbF9lcGhlX2NyZWF0ZVwiOztcbiAgbGV0IGNyZWF0ZSBsID1cbiAgICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IG1heF9lcGhlX2xlbmd0aCkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJPYmouRXBoZW1lcm9uLmNyZWF0ZVwiO1xuICAgIGNyZWF0ZSBsXG5cbiAgbGV0IGxlbmd0aCB4ID0gc2l6ZShyZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBsZXQgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIG1zZyA9XG4gICAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBtc2dcblxuICBleHRlcm5hbCBnZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5XCJcbiAgbGV0IGdldF9rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlcIjtcbiAgICBnZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGdldF9rZXlfY29weTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XCJcbiAgbGV0IGdldF9rZXlfY29weSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uZ2V0X2tleV9jb3B5XCI7XG4gICAgZ2V0X2tleV9jb3B5IGUgb1xuXG4gIGV4dGVybmFsIHNldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbiAgbGV0IHNldF9rZXkgZSBvIHggPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uc2V0X2tleVwiO1xuICAgIHNldF9rZXkgZSBvIHhcblxuICBleHRlcm5hbCB1bnNldF9rZXk6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxuICBsZXQgdW5zZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi51bnNldF9rZXlcIjtcbiAgICB1bnNldF9rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgY2hlY2tfa2V5OiB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfa2V5XCJcbiAgbGV0IGNoZWNrX2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uY2hlY2tfa2V5XCI7XG4gICAgY2hlY2tfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGJsaXRfa2V5IDogdCAtPiBpbnQgLT4gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9lcGhlX2JsaXRfa2V5XCJcblxuICBsZXQgYmxpdF9rZXkgZTEgbzEgZTIgbzIgbCA9XG4gICAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5ibGl0X2tleVwiXG4gICAgZWxzZSBpZiBsIDw+IDAgdGhlbiBibGl0X2tleSBlMSBvMSBlMiBvMiBsXG5cbiAgZXh0ZXJuYWwgZ2V0X2RhdGE6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFcIlxuICBleHRlcm5hbCBnZXRfZGF0YV9jb3B5OiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcIlxuICBleHRlcm5hbCBzZXRfZGF0YTogdCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2RhdGFcIlxuICBleHRlcm5hbCB1bnNldF9kYXRhOiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9kYXRhXCJcbiAgZXh0ZXJuYWwgY2hlY2tfZGF0YTogdCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfZGF0YVwiXG4gIGV4dGVybmFsIGJsaXRfZGF0YSA6IHQgLT4gdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfYmxpdF9kYXRhXCJcblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEludGVybmFscyBvZiBmb3JjaW5nIGxhenkgdmFsdWVzLiAqKVxuXG50eXBlICdhIHQgPSAnYSBsYXp5X3RcblxuZXhjZXB0aW9uIFVuZGVmaW5lZFxuXG5sZXQgcmFpc2VfdW5kZWZpbmVkID0gT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBVbmRlZmluZWQpXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6IE9iai50IC0+IE9iai50IC0+IHVuaXQgPSBcImNhbWxfb2JqX21ha2VfZm9yd2FyZFwiXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV9sYXp5X2Jsb2NrIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgKE9iai5yZXByIGJsaykgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCByYWlzZV91bmRlZmluZWQ7XG4gIHRyeVxuICAgIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gICAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICAgIHJlc3VsdFxuICB3aXRoIGUgLT5cbiAgICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgKE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgZSkpO1xuICAgIHJhaXNlIGVcblxuXG4oKiBBc3N1bWUgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBsYXp5ICopXG5sZXQgZm9yY2VfdmFsX2xhenlfYmxvY2sgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCAoT2JqLnJlcHIgYmxrKSAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIHJhaXNlX3VuZGVmaW5lZDtcbiAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICByZXN1bHRcblxuXG4oKiBbZm9yY2VdIGlzIG5vdCB1c2VkLCBzaW5jZSBbTGF6eS5mb3JjZV0gaXMgZGVjbGFyZWQgYXMgYSBwcmltaXRpdmVcbiAgIHdob3NlIGNvZGUgaW5saW5lcyB0aGUgdGFnIHRlc3RzIG9mIGl0cyBhcmd1bWVudCwgZXhjZXB0IHdoZW4gYWZsXG4gICBpbnN0cnVtZW50YXRpb24gaXMgdHVybmVkIG9uLiAqKVxuXG5sZXQgZm9yY2UgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gICgqIFVzaW5nIFtTeXMub3BhcXVlX2lkZW50aXR5XSBwcmV2ZW50cyB0d28gcG90ZW50aWFsIHByb2JsZW1zOlxuICAgICAtIElmIHRoZSB2YWx1ZSBpcyBrbm93biB0byBoYXZlIEZvcndhcmRfdGFnLCB0aGVuIGl0cyB0YWcgY291bGQgaGF2ZVxuICAgICAgIGNoYW5nZWQgZHVyaW5nIEdDLCBzbyB0aGF0IGluZm9ybWF0aW9uIG11c3QgYmUgZm9yZ290dGVuIChzZWUgR1BSIzcxM1xuICAgICAgIGFuZCBpc3N1ZSAjNzMwMSlcbiAgICAgLSBJZiB0aGUgdmFsdWUgaXMga25vd24gdG8gYmUgaW1tdXRhYmxlLCB0aGVuIGlmIHRoZSBjb21waWxlclxuICAgICAgIGNhbm5vdCBwcm92ZSB0aGF0IHRoZSBsYXN0IGJyYW5jaCBpcyBub3QgdGFrZW4gaXQgd2lsbCBpc3N1ZSBhXG4gICAgICAgd2FybmluZyA1OSAobW9kaWZpY2F0aW9uIG9mIGFuIGltbXV0YWJsZSB2YWx1ZSkgKilcbiAgbGV0IGx6diA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgbHp2IGluXG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlbiAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKSBlbHNlXG4gIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfbGF6eV9ibG9jayBsenZcblxuXG5sZXQgZm9yY2VfdmFsIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW4gKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZykgZWxzZVxuICBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX3ZhbF9sYXp5X2Jsb2NrIGx6dlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0xhenldOiBkZWZlcnJlZCBjb21wdXRhdGlvbnMgKilcblxuXG4oKlxuICAgV0FSTklORzogc29tZSBwdXJwbGUgbWFnaWMgaXMgZ29pbmcgb24gaGVyZS4gIERvIG5vdCB0YWtlIHRoaXMgZmlsZVxuICAgYXMgYW4gZXhhbXBsZSBvZiBob3cgdG8gcHJvZ3JhbSBpbiBPQ2FtbC5cbiopXG5cblxuKCogV2UgbWFrZSB1c2Ugb2YgdHdvIHNwZWNpYWwgdGFncyBwcm92aWRlZCBieSB0aGUgcnVudGltZTpcbiAgIFtsYXp5X3RhZ10gYW5kIFtmb3J3YXJkX3RhZ10uXG5cbiAgIEEgdmFsdWUgb2YgdHlwZSBbJ2EgTGF6eS50XSBjYW4gYmUgb25lIG9mIHRocmVlIHRoaW5nczpcbiAgIDEuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtsYXp5X3RhZ10uICBJdHMgZmllbGQgaXMgYSBjbG9zdXJlIG9mXG4gICAgICB0eXBlIFt1bml0IC0+ICdhXSB0aGF0IGNvbXB1dGVzIHRoZSB2YWx1ZS5cbiAgIDIuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtmb3J3YXJkX3RhZ10uICBJdHMgZmllbGQgaXMgdGhlIHZhbHVlXG4gICAgICBvZiB0eXBlIFsnYV0gdGhhdCB3YXMgY29tcHV0ZWQuXG4gICAzLiBBbnl0aGluZyBlbHNlIGV4Y2VwdCBhIGZsb2F0LiAgVGhpcyBoYXMgdHlwZSBbJ2FdIGFuZCBpcyB0aGUgdmFsdWVcbiAgICAgIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgRXhjZXB0aW9ucyBhcmUgc3RvcmVkIGluIGZvcm1hdCAoMSkuXG4gICBUaGUgR0Mgd2lsbCBtYWdpY2FsbHkgY2hhbmdlIHRoaW5ncyBmcm9tICgyKSB0byAoMykgYWNjb3JkaW5nIHRvIGl0c1xuICAgZmFuY3kuXG5cbiAgIElmIE9DYW1sIHdhcyBjb25maWd1cmVkIHdpdGggdGhlIC1mbGF0LWZsb2F0LWFycmF5IG9wdGlvbiAod2hpY2ggaXNcbiAgIGN1cnJlbnRseSB0aGUgZGVmYXVsdCksIHRoZSBmb2xsb3dpbmcgaXMgYWxzbyB0cnVlOlxuICAgV2UgY2Fubm90IHVzZSByZXByZXNlbnRhdGlvbiAoMykgZm9yIGEgW2Zsb2F0IExhenkudF0gYmVjYXVzZVxuICAgW2NhbWxfbWFrZV9hcnJheV0gYXNzdW1lcyB0aGF0IG9ubHkgYSBbZmxvYXRdIHZhbHVlIGNhbiBoYXZlIHRhZ1xuICAgW0RvdWJsZV90YWddLlxuXG4gICBXZSBoYXZlIHRvIHVzZSB0aGUgYnVpbHQtaW4gdHlwZSBjb25zdHJ1Y3RvciBbbGF6eV90XSB0b1xuICAgbGV0IHRoZSBjb21waWxlciBpbXBsZW1lbnQgdGhlIHNwZWNpYWwgdHlwaW5nIGFuZCBjb21waWxhdGlvblxuICAgcnVsZXMgZm9yIHRoZSBbbGF6eV0ga2V5d29yZC5cbiopXG5cbnR5cGUgJ2EgdCA9ICdhIENhbWxpbnRlcm5hbExhenkudFxuXG5leGNlcHRpb24gVW5kZWZpbmVkID0gQ2FtbGludGVybmFsTGF6eS5VbmRlZmluZWRcblxuZXh0ZXJuYWwgbWFrZV9mb3J3YXJkIDogJ2EgLT4gJ2EgbGF6eV90ID0gXCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkXCJcblxuZXh0ZXJuYWwgZm9yY2UgOiAnYSB0IC0+ICdhID0gXCIlbGF6eV9mb3JjZVwiXG5cblxubGV0IGZvcmNlX3ZhbCA9IENhbWxpbnRlcm5hbExhenkuZm9yY2VfdmFsXG5cbmxldCBmcm9tX2Z1biAoZiA6IHVuaXQgLT4gJ2FyZykgPVxuICBsZXQgeCA9IE9iai5uZXdfYmxvY2sgT2JqLmxhenlfdGFnIDEgaW5cbiAgT2JqLnNldF9maWVsZCB4IDAgKE9iai5yZXByIGYpO1xuICAoT2JqLm9iaiB4IDogJ2FyZyB0KVxuXG5sZXQgZnJvbV92YWwgKHYgOiAnYXJnKSA9XG4gIGxldCB0ID0gT2JqLnRhZyAoT2JqLnJlcHIgdikgaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB8fCB0ID0gT2JqLmxhenlfdGFnIHx8IHQgPSBPYmouZG91YmxlX3RhZyB0aGVuIGJlZ2luXG4gICAgbWFrZV9mb3J3YXJkIHZcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICAoT2JqLm1hZ2ljIHYgOiAnYXJnIHQpXG4gIGVuZFxuXG5cbmxldCBpc192YWwgKGwgOiAnYXJnIHQpID0gT2JqLnRhZyAoT2JqLnJlcHIgbCkgPD4gT2JqLmxhenlfdGFnXG5cbmxldCBsYXp5X2Zyb21fZnVuID0gZnJvbV9mdW5cblxubGV0IGxhenlfZnJvbV92YWwgPSBmcm9tX3ZhbFxuXG5sZXQgbGF6eV9pc192YWwgPSBpc192YWxcblxuXG5sZXQgbWFwIGYgeCA9XG4gIGxhenkgKGYgKGZvcmNlIHgpKVxuXG5sZXQgbWFwX3ZhbCBmIHggPVxuICBpZiBpc192YWwgeFxuICB0aGVuIGxhenlfZnJvbV92YWwgKGYgKGZvcmNlIHgpKVxuICBlbHNlIGxhenkgKGYgKGZvcmNlIHgpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgIFNpbW9uIENydWFuZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW1NlcV06IGZ1bmN0aW9uYWwgaXRlcmF0b3JzICopXG5cbnR5cGUgKydhIG5vZGUgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgJ2EgKiAnYSB0XG5cbmFuZCAnYSB0ID0gdW5pdCAtPiAnYSBub2RlXG5cbmxldCBlbXB0eSAoKSA9IE5pbFxuXG5sZXQgcmV0dXJuIHggKCkgPSBDb25zICh4LCBlbXB0eSlcblxubGV0IGNvbnMgeCBuZXh0ICgpID0gQ29ucyAoeCwgbmV4dClcblxubGV0IHJlYyBhcHBlbmQgc2VxMSBzZXEyICgpID1cbiAgbWF0Y2ggc2VxMSgpIHdpdGhcbiAgfCBOaWwgLT4gc2VxMigpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMilcblxubGV0IHJlYyBtYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+IENvbnMgKGYgeCwgbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXJfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBuZXh0ICgpXG4gICAgICAgIHwgU29tZSB5IC0+IENvbnMgKHksIGZpbHRlcl9tYXAgZiBuZXh0KVxuXG5sZXQgcmVjIGZpbHRlciBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGlmIGYgeFxuICAgICAgdGhlbiBDb25zICh4LCBmaWx0ZXIgZiBuZXh0KVxuICAgICAgZWxzZSBmaWx0ZXIgZiBuZXh0ICgpXG5cbmxldCByZWMgY29uY2F0IHNlcSAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgIGFwcGVuZCB4IChjb25jYXQgbmV4dCkgKClcblxubGV0IHJlYyBmbGF0X21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgYXBwZW5kIChmIHgpIChmbGF0X21hcCBmIG5leHQpICgpXG5cbmxldCBjb25jYXRfbWFwID0gZmxhdF9tYXBcblxubGV0IHJlYyBmb2xkX2xlZnQgZiBhY2Mgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGZvbGRfbGVmdCBmIGFjYyBuZXh0XG5cbmxldCByZWMgaXRlciBmIHNlcSA9XG4gIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgaXRlciBmIG5leHRcblxubGV0IHJlYyB1bmZvbGQgZiB1ICgpID1cbiAgbWF0Y2ggZiB1IHdpdGhcbiAgfCBOb25lIC0+IE5pbFxuICB8IFNvbWUgKHgsIHUnKSAtPiBDb25zICh4LCB1bmZvbGQgZiB1JylcblxubGV0IGlzX2VtcHR5IHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoXywgXykgLT5cbiAgICAgIGZhbHNlXG5cbmxldCB1bmNvbnMgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIFNvbWUgKHgsIHhzKVxuICB8IE5pbCAtPlxuICAgICAgTm9uZVxuXG5cblxubGV0IHJlYyBsZW5ndGhfYXV4IGFjY3UgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGFjY3VcbiAgfCBDb25zIChfLCB4cykgLT5cbiAgICAgIGxlbmd0aF9hdXggKGFjY3UgKyAxKSB4c1xuXG5sZXRbQGlubGluZV0gbGVuZ3RoIHhzID1cbiAgbGVuZ3RoX2F1eCAwIHhzXG5cbmxldCByZWMgaXRlcmlfYXV4IGYgaSB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGYgaSB4O1xuICAgICAgaXRlcmlfYXV4IGYgKGkrMSkgeHNcblxubGV0W0BpbmxpbmVdIGl0ZXJpIGYgeHMgPVxuICBpdGVyaV9hdXggZiAwIHhzXG5cbmxldCByZWMgZm9sZF9sZWZ0aV9hdXggZiBhY2N1IGkgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGFjY3VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGkgeCBpblxuICAgICAgZm9sZF9sZWZ0aV9hdXggZiBhY2N1IChpKzEpIHhzXG5cbmxldFtAaW5saW5lXSBmb2xkX2xlZnRpIGYgYWNjdSB4cyA9XG4gIGZvbGRfbGVmdGlfYXV4IGYgYWNjdSAwIHhzXG5cbmxldCByZWMgZm9yX2FsbCBwIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBwIHggJiYgZm9yX2FsbCBwIHhzXG5cbmxldCByZWMgZXhpc3RzIHAgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGZhbHNlXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBwIHggfHwgZXhpc3RzIHAgeHNcblxubGV0IHJlYyBmaW5kIHAgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5vbmVcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGlmIHAgeCB0aGVuIFNvbWUgeCBlbHNlIGZpbmQgcCB4c1xuXG5sZXQgcmVjIGZpbmRfbWFwIGYgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5vbmVcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBmaW5kX21hcCBmIHhzXG4gICAgICB8IFNvbWUgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICByZXN1bHRcblxuKCogW2l0ZXIyXSwgW2ZvbGRfbGVmdDJdLCBbZm9yX2FsbDJdLCBbZXhpc3RzMl0sIFttYXAyXSwgW3ppcF0gd29yayBhbHNvIGluXG4gICB0aGUgY2FzZSB3aGVyZSB0aGUgdHdvIHNlcXVlbmNlcyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzLiBUaGV5IHN0b3AgYXMgc29vblxuICAgYXMgb25lIHNlcXVlbmNlIGlzIGV4aGF1c3RlZC4gVGhlaXIgYmVoYXZpb3IgaXMgc2xpZ2h0bHkgYXN5bW1ldHJpYzogd2hlblxuICAgW3hzXSBpcyBlbXB0eSwgdGhleSBkbyBub3QgZm9yY2UgW3lzXTsgaG93ZXZlciwgd2hlbiBbeXNdIGlzIGVtcHR5LCBbeHNdIGlzXG4gICBmb3JjZWQsIGV2ZW4gdGhvdWdoIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uIFt4cygpXSB0dXJucyBvdXRcbiAgIHRvIGJlIHVzZWxlc3MuICopXG5cbmxldCByZWMgaXRlcjIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICAoKVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeTtcbiAgICAgICAgICBpdGVyMiBmIHhzIHlzXG5cbmxldCByZWMgZm9sZF9sZWZ0MiBmIGFjY3UgeHMgeXMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGFjY3VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICBhY2N1XG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIGxldCBhY2N1ID0gZiBhY2N1IHggeSBpblxuICAgICAgICAgIGZvbGRfbGVmdDIgZiBhY2N1IHhzIHlzXG5cbmxldCByZWMgZm9yX2FsbDIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICAgICAgZiB4IHkgJiYgZm9yX2FsbDIgZiB4cyB5c1xuXG5sZXQgcmVjIGV4aXN0czIgZiB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIHlzKCkgd2l0aFxuICAgICAgfCBOaWwgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeSB8fCBleGlzdHMyIGYgeHMgeXNcblxubGV0IHJlYyBlcXVhbCBlcSB4cyB5cyA9XG4gIG1hdGNoIHhzKCksIHlzKCkgd2l0aFxuICB8IE5pbCwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoeCwgeHMpLCBDb25zICh5LCB5cykgLT5cbiAgICAgIGVxIHggeSAmJiBlcXVhbCBlcSB4cyB5c1xuICB8IE5pbCwgQ29ucyAoXywgXylcbiAgfCBDb25zIChfLCBfKSwgTmlsIC0+XG4gICAgICBmYWxzZVxuXG5sZXQgcmVjIGNvbXBhcmUgY21wIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSwgeXMoKSB3aXRoXG4gIHwgTmlsLCBOaWwgLT5cbiAgICAgIDBcbiAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgbGV0IGMgPSBjbXAgeCB5IGluXG4gICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2UgY29tcGFyZSBjbXAgeHMgeXNcbiAgfCBOaWwsIENvbnMgKF8sIF8pIC0+XG4gICAgICAtMVxuICB8IENvbnMgKF8sIF8pLCBOaWwgLT5cbiAgICAgICsxXG5cblxuXG4oKiBbaW5pdF9hdXggZiBpIGpdIGlzIHRoZSBzZXF1ZW5jZSBbZiBpLCAuLi4sIGYgKGotMSldLiAqKVxuXG5sZXQgcmVjIGluaXRfYXV4IGYgaSBqICgpID1cbiAgaWYgaSA8IGogdGhlbiBiZWdpblxuICAgIENvbnMgKGYgaSwgaW5pdF9hdXggZiAoaSArIDEpIGopXG4gIGVuZFxuICBlbHNlXG4gICAgTmlsXG5cbmxldCBpbml0IG4gZiA9XG4gIGlmIG4gPCAwIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlNlcS5pbml0XCJcbiAgZWxzZVxuICAgIGluaXRfYXV4IGYgMCBuXG5cbmxldCByZWMgcmVwZWF0IHggKCkgPVxuICBDb25zICh4LCByZXBlYXQgeClcblxubGV0IHJlYyBmb3JldmVyIGYgKCkgPVxuICBDb25zIChmKCksIGZvcmV2ZXIgZilcblxuKCogVGhpcyBwcmVsaW1pbmFyeSBkZWZpbml0aW9uIG9mIFtjeWNsZV0gcmVxdWlyZXMgdGhlIHNlcXVlbmNlIFt4c11cbiAgIHRvIGJlIG5vbmVtcHR5LiBBcHBseWluZyBpdCB0byBhbiBlbXB0eSBzZXF1ZW5jZSB3b3VsZCBwcm9kdWNlIGFcbiAgIHNlcXVlbmNlIHRoYXQgZGl2ZXJnZXMgd2hlbiBpdCBpcyBmb3JjZWQuICopXG5cbmxldCByZWMgY3ljbGVfbm9uZW1wdHkgeHMgKCkgPVxuICBhcHBlbmQgeHMgKGN5Y2xlX25vbmVtcHR5IHhzKSAoKVxuXG4oKiBbY3ljbGUgeHNdIGNoZWNrcyB3aGV0aGVyIFt4c10gaXMgZW1wdHkgYW5kLCBpZiBzbywgcmV0dXJucyBhbiBlbXB0eVxuICAgc2VxdWVuY2UuIE90aGVyd2lzZSwgW2N5Y2xlIHhzXSBwcm9kdWNlcyBvbmUgY29weSBvZiBbeHNdIGZvbGxvd2VkXG4gICB3aXRoIHRoZSBpbmZpbml0ZSBzZXF1ZW5jZSBbY3ljbGVfbm9uZW1wdHkgeHNdLiBUaHVzLCB0aGUgbm9uZW1wdGluZXNzXG4gICBjaGVjayBpcyBwZXJmb3JtZWQganVzdCBvbmNlLiAqKVxuXG5sZXQgY3ljbGUgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzJykgLT5cbiAgICAgIENvbnMgKHgsIGFwcGVuZCB4cycgKGN5Y2xlX25vbmVtcHR5IHhzKSlcblxuKCogW2l0ZXJhdGUxIGYgeF0gaXMgdGhlIHNlcXVlbmNlIFtmIHgsIGYgKGYgeCksIC4uLl0uXG4gICBJdCBpcyBlcXVpdmFsZW50IHRvIFt0YWlsIChpdGVyYXRlIGYgeCldLlxuICAgW2l0ZXJhdGUxXSBpcyB1c2VkIGFzIGEgYnVpbGRpbmcgYmxvY2sgaW4gdGhlIGRlZmluaXRpb24gb2YgW2l0ZXJhdGVdLiAqKVxuXG5sZXQgcmVjIGl0ZXJhdGUxIGYgeCAoKSA9XG4gIGxldCB5ID0gZiB4IGluXG4gIENvbnMgKHksIGl0ZXJhdGUxIGYgeSlcblxuKCogW2l0ZXJhdGUgZiB4XSBpcyB0aGUgc2VxdWVuY2UgW3gsIGYgeCwgLi4uXS4gKilcblxuKCogVGhlIHJlYXNvbiB3aHkgd2UgZ2l2ZSB0aGlzIHNsaWdodGx5IGluZGlyZWN0IGRlZmluaXRpb24gb2YgW2l0ZXJhdGVdLFxuICAgYXMgb3Bwb3NlZCB0byB0aGUgbW9yZSBuYWl2ZSBkZWZpbml0aW9uIHRoYXQgbWF5IGNvbWUgdG8gbWluZCwgaXMgdGhhdFxuICAgd2UgYXJlIGNhcmVmdWwgdG8gYXZvaWQgZXZhbHVhdGluZyBbZiB4XSB1bnRpbCB0aGlzIGZ1bmN0aW9uIGNhbGwgaXNcbiAgIGFjdHVhbGx5IG5lY2Vzc2FyeS4gVGhlIG5haXZlIGRlZmluaXRpb24gKG5vdCBzaG93biBoZXJlKSBjb21wdXRlcyB0aGVcbiAgIHNlY29uZCBhcmd1bWVudCBvZiB0aGUgc2VxdWVuY2UsIFtmIHhdLCB3aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBpc1xuICAgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyLiAqKVxuXG5sZXQgaXRlcmF0ZSBmIHggPVxuICBjb25zIHggKGl0ZXJhdGUxIGYgeClcblxuXG5cbmxldCByZWMgbWFwaV9hdXggZiBpIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIENvbnMgKGYgaSB4LCBtYXBpX2F1eCBmIChpKzEpIHhzKVxuXG5sZXRbQGlubGluZV0gbWFwaSBmIHhzID1cbiAgbWFwaV9hdXggZiAwIHhzXG5cbigqIFt0YWlsX3NjYW4gZiBzIHhzXSBpcyBlcXVpdmFsZW50IHRvIFt0YWlsIChzY2FuIGYgcyB4cyldLlxuICAgW3RhaWxfc2Nhbl0gaXMgdXNlZCBhcyBhIGJ1aWxkaW5nIGJsb2NrIGluIHRoZSBkZWZpbml0aW9uIG9mIFtzY2FuXS4gKilcblxuKCogVGhpcyBzbGlnaHRseSBpbmRpcmVjdCBkZWZpbml0aW9uIG9mIFtzY2FuXSBpcyBtZWFudCB0byBhdm9pZCBjb21wdXRpbmdcbiAgIGVsZW1lbnRzIHRvbyBlYXJseTsgc2VlIHRoZSBhYm92ZSBjb21tZW50IGFib3V0IFtpdGVyYXRlMV0gYW5kIFtpdGVyYXRlXS4gKilcblxubGV0IHJlYyB0YWlsX3NjYW4gZiBzIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGxldCBzID0gZiBzIHggaW5cbiAgICAgIENvbnMgKHMsIHRhaWxfc2NhbiBmIHMgeHMpXG5cbmxldCBzY2FuIGYgcyB4cyA9XG4gIGNvbnMgcyAodGFpbF9zY2FuIGYgcyB4cylcblxuKCogW3Rha2VdIGlzIGRlZmluZWQgaW4gc3VjaCBhIHdheSB0aGF0IFt0YWtlIDAgeHNdIHJldHVybnMgW2VtcHR5XVxuICAgaW1tZWRpYXRlbHksIHdpdGhvdXQgYWxsb2NhdGluZyBhbnkgbWVtb3J5LiAqKVxuXG5sZXQgcmVjIHRha2VfYXV4IG4geHMgPVxuICBpZiBuID0gMCB0aGVuXG4gICAgZW1wdHlcbiAgZWxzZVxuICAgIGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggeHMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgICBDb25zICh4LCB0YWtlX2F1eCAobi0xKSB4cylcblxubGV0IHRha2UgbiB4cyA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJTZXEudGFrZVwiO1xuICB0YWtlX2F1eCBuIHhzXG5cbigqIFtmb3JjZV9kcm9wIG4geHNdIGlzIGVxdWl2YWxlbnQgdG8gW2Ryb3AgbiB4cyAoKV0uXG4gICBbZm9yY2VfZHJvcCBuIHhzXSByZXF1aXJlcyBbbiA+IDBdLlxuICAgW2ZvcmNlX2Ryb3BdIGlzIHVzZWQgYXMgYSBidWlsZGluZyBibG9jayBpbiB0aGUgZGVmaW5pdGlvbiBvZiBbZHJvcF0uICopXG5cbmxldCByZWMgZm9yY2VfZHJvcCBuIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zIChfLCB4cykgLT5cbiAgICAgIGxldCBuID0gbiAtIDEgaW5cbiAgICAgIGlmIG4gPSAwIHRoZW5cbiAgICAgICAgeHMoKVxuICAgICAgZWxzZVxuICAgICAgICBmb3JjZV9kcm9wIG4geHNcblxuKCogW2Ryb3BdIGlzIGRlZmluZWQgaW4gc3VjaCBhIHdheSB0aGF0IFtkcm9wIDAgeHNdIHJldHVybnMgW3hzXSBpbW1lZGlhdGVseSxcbiAgIHdpdGhvdXQgYWxsb2NhdGluZyBhbnkgbWVtb3J5LiAqKVxuXG5sZXQgZHJvcCBuIHhzID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcS5kcm9wXCJcbiAgZWxzZSBpZiBuID0gMCB0aGVuXG4gICAgeHNcbiAgZWxzZVxuICAgIGZ1biAoKSAtPlxuICAgICAgZm9yY2VfZHJvcCBuIHhzXG5cbmxldCByZWMgdGFrZV93aGlsZSBwIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGlmIHAgeCB0aGVuIENvbnMgKHgsIHRha2Vfd2hpbGUgcCB4cykgZWxzZSBOaWxcblxubGV0IHJlYyBkcm9wX3doaWxlIHAgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSBhcyBub2RlIC0+XG4gICAgICBpZiBwIHggdGhlbiBkcm9wX3doaWxlIHAgeHMgKCkgZWxzZSBub2RlXG5cbmxldCByZWMgZ3JvdXAgZXEgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgQ29ucyAoY29ucyB4ICh0YWtlX3doaWxlIChlcSB4KSB4cyksIGdyb3VwIGVxIChkcm9wX3doaWxlIChlcSB4KSB4cykpXG5cbmV4Y2VwdGlvbiBGb3JjZWRfdHdpY2VcblxubW9kdWxlIFN1c3BlbnNpb24gPSBzdHJ1Y3RcblxuICB0eXBlICdhIHN1c3BlbnNpb24gPVxuICAgIHVuaXQgLT4gJ2FcblxuICAoKiBDb252ZXJzaW9ucy4gKilcblxuICBsZXQgdG9fbGF6eSA6ICdhIHN1c3BlbnNpb24gLT4gJ2EgTGF6eS50ID1cbiAgICBMYXp5LmZyb21fZnVuXG4gICAgKCogZnVuIHMgLT4gbGF6eSAocygpKSAqKVxuXG4gIGxldCBmcm9tX2xhenkgKHMgOiAnYSBMYXp5LnQpIDogJ2Egc3VzcGVuc2lvbiA9XG4gICAgZnVuICgpIC0+IExhenkuZm9yY2Ugc1xuXG4gICgqIFttZW1vaXplXSB0dXJucyBhbiBhcmJpdHJhcnkgc3VzcGVuc2lvbiBpbnRvIGEgcGVyc2lzdGVudCBzdXNwZW5zaW9uLiAqKVxuXG4gIGxldCBtZW1vaXplIChzIDogJ2Egc3VzcGVuc2lvbikgOiAnYSBzdXNwZW5zaW9uID1cbiAgICBmcm9tX2xhenkgKHRvX2xhenkgcylcblxuICAoKiBbZmFpbHVyZV0gaXMgYSBzdXNwZW5zaW9uIHRoYXQgZmFpbHMgd2hlbiBmb3JjZWQuICopXG5cbiAgbGV0IGZhaWx1cmUgOiBfIHN1c3BlbnNpb24gPVxuICAgIGZ1biAoKSAtPlxuICAgICAgKCogQSBzdXNwZW5zaW9uIGNyZWF0ZWQgYnkgW29uY2VdIGhhcyBiZWVuIGZvcmNlZCB0d2ljZS4gKilcbiAgICAgIHJhaXNlIEZvcmNlZF90d2ljZVxuXG4gICgqIElmIFtmXSBpcyBhIHN1c3BlbnNpb24sIHRoZW4gW29uY2UgZl0gaXMgYSBzdXNwZW5zaW9uIHRoYXQgY2FuIGJlIGZvcmNlZFxuICAgICBhdCBtb3N0IG9uY2UuIElmIGl0IGlzIGZvcmNlZCBtb3JlIHRoYW4gb25jZSwgdGhlbiBbRm9yY2VkX3R3aWNlXSBpc1xuICAgICByYWlzZWQuICopXG5cbiAgbGV0IG9uY2UgKGYgOiAnYSBzdXNwZW5zaW9uKSA6ICdhIHN1c3BlbnNpb24gPVxuICAgIGxldCBhY3Rpb24gPSBDYW1saW50ZXJuYWxBdG9taWMubWFrZSBmIGluXG4gICAgZnVuICgpIC0+XG4gICAgICAoKiBHZXQgdGhlIGZ1bmN0aW9uIGN1cnJlbnRseSBzdG9yZWQgaW4gW2FjdGlvbl0sIGFuZCB3cml0ZSB0aGVcbiAgICAgICAgIGZ1bmN0aW9uIFtmYWlsdXJlXSBpbiBpdHMgcGxhY2UsIHNvIHRoZSBuZXh0IGFjY2VzcyB3aWxsIHJlc3VsdFxuICAgICAgICAgaW4gYSBjYWxsIHRvIFtmYWlsdXJlKCldLiAqKVxuICAgICAgbGV0IGYgPSBDYW1saW50ZXJuYWxBdG9taWMuZXhjaGFuZ2UgYWN0aW9uIGZhaWx1cmUgaW5cbiAgICAgIGYoKVxuXG5lbmQgKCogU3VzcGVuc2lvbiAqKVxuXG5sZXQgcmVjIG1lbW9pemUgeHMgPVxuICBTdXNwZW5zaW9uLm1lbW9pemUgKGZ1biAoKSAtPlxuICAgIG1hdGNoIHhzKCkgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICAgIE5pbFxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIENvbnMgKHgsIG1lbW9pemUgeHMpXG4gIClcblxubGV0IHJlYyBvbmNlIHhzID1cbiAgU3VzcGVuc2lvbi5vbmNlIChmdW4gKCkgLT5cbiAgICBtYXRjaCB4cygpIHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgICBOaWxcbiAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICBDb25zICh4LCBvbmNlIHhzKVxuICApXG5cblxubGV0IHJlYyB6aXAgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBDb25zICgoeCwgeSksIHppcCB4cyB5cylcblxubGV0IHJlYyBtYXAyIGYgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIE5pbFxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBDb25zIChmIHggeSwgbWFwMiBmIHhzIHlzKVxuXG5sZXQgcmVjIGludGVybGVhdmUgeHMgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIHlzKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIENvbnMgKHgsIGludGVybGVhdmUgeXMgeHMpXG5cbigqIFtzb3J0ZWRfbWVyZ2UxbCBjbXAgeCB4cyB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCAoY29ucyB4IHhzKSB5c10uXG5cbiAgIFtzb3J0ZWRfbWVyZ2UxciBjbXAgeHMgeSB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCB4cyAoY29ucyB5IHlzKV0uXG5cbiAgIFtzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNdIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgW3NvcnRlZF9tZXJnZSBjbXAgKGNvbnMgeCB4cykgKGNvbnMgeSB5cyldLlxuXG4gICBUaGVzZSB0aHJlZSBmdW5jdGlvbnMgYXJlIHVzZWQgYXMgYnVpbGRpbmcgYmxvY2tzIGluIHRoZSBkZWZpbml0aW9uXG4gICBvZiBbc29ydGVkX21lcmdlXS4gKilcblxubGV0IHJlYyBzb3J0ZWRfbWVyZ2UxbCBjbXAgeCB4cyB5cyAoKSA9XG4gIG1hdGNoIHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgQ29ucyAoeCwgeHMpXG4gIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNcblxuYW5kIHNvcnRlZF9tZXJnZTFyIGNtcCB4cyB5IHlzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBDb25zICh5LCB5cylcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIHNvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c1xuXG5hbmQgc29ydGVkX21lcmdlMSBjbXAgeCB4cyB5IHlzID1cbiAgaWYgY21wIHggeSA8PSAwIHRoZW5cbiAgICBDb25zICh4LCBzb3J0ZWRfbWVyZ2UxciBjbXAgeHMgeSB5cylcbiAgZWxzZVxuICAgIENvbnMgKHksIHNvcnRlZF9tZXJnZTFsIGNtcCB4IHhzIHlzKVxuXG5sZXQgc29ydGVkX21lcmdlIGNtcCB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCksIHlzKCkgd2l0aFxuICAgIHwgTmlsLCBOaWwgLT5cbiAgICAgICAgTmlsXG4gICAgfCBOaWwsIGNcbiAgICB8IGMsIE5pbCAtPlxuICAgICAgICBjXG4gICAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgICBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXNcblxuXG5sZXQgcmVjIG1hcF9mc3QgeHlzICgpID1cbiAgbWF0Y2ggeHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoKHgsIF8pLCB4eXMpIC0+XG4gICAgICBDb25zICh4LCBtYXBfZnN0IHh5cylcblxubGV0IHJlYyBtYXBfc25kIHh5cyAoKSA9XG4gIG1hdGNoIHh5cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKChfLCB5KSwgeHlzKSAtPlxuICAgICAgQ29ucyAoeSwgbWFwX3NuZCB4eXMpXG5cbmxldCB1bnppcCB4eXMgPVxuICBtYXBfZnN0IHh5cywgbWFwX3NuZCB4eXNcblxubGV0IHNwbGl0ID1cbiAgdW56aXBcblxuKCogW2ZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzXSBpcyBlcXVpdmFsZW50IHRvXG4gICBbZmlsdGVyX21hcCBFaXRoZXIuZmluZF9sZWZ0IChtYXAgZiB4cyldLiAqKVxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IEVpdGhlci5MZWZ0IHkgLT5cbiAgICAgICAgICBDb25zICh5LCBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cylcbiAgICAgIHwgRWl0aGVyLlJpZ2h0IF8gLT5cbiAgICAgICAgICBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cyAoKVxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfZmluZF9yaWdodF9tYXAgZiB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgfCBFaXRoZXIuTGVmdCBfIC0+XG4gICAgICAgICAgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzICgpXG4gICAgICB8IEVpdGhlci5SaWdodCB6IC0+XG4gICAgICAgICAgQ29ucyAoeiwgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzKVxuXG5sZXQgcGFydGl0aW9uX21hcCBmIHhzID1cbiAgZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIGYgeHMsXG4gIGZpbHRlcl9tYXBfZmluZF9yaWdodF9tYXAgZiB4c1xuXG5sZXQgcGFydGl0aW9uIHAgeHMgPVxuICBmaWx0ZXIgcCB4cywgZmlsdGVyIChmdW4geCAtPiBub3QgKHAgeCkpIHhzXG5cbigqIElmIFt4c3NdIGlzIGEgbWF0cml4IChhIHNlcXVlbmNlIG9mIHJvd3MpLCB0aGVuIFtwZWVsIHhzc10gaXMgYSBwYWlyIG9mXG4gICB0aGUgZmlyc3QgY29sdW1uIChhIHNlcXVlbmNlIG9mIGVsZW1lbnRzKSBhbmQgb2YgdGhlIHJlbWFpbmRlciBvZiB0aGVcbiAgIG1hdHJpeCAoYSBzZXF1ZW5jZSBvZiBzaG9ydGVyIHJvd3MpLiBUaGVzZSB0d28gc2VxdWVuY2VzIGhhdmUgdGhlIHNhbWVcbiAgIGxlbmd0aC4gVGhlIHJvd3Mgb2YgdGhlIG1hdHJpeCBbeHNzXSBhcmUgbm90IHJlcXVpcmVkIHRvIGhhdmUgdGhlIHNhbWVcbiAgIGxlbmd0aC4gQW4gZW1wdHkgcm93IGlzIGlnbm9yZWQuICopXG5cbigqIEJlY2F1c2UgW3BlZWxdIHVzZXMgW3VuemlwXSwgaXRzIGFyZ3VtZW50IG11c3QgYmUgcGVyc2lzdGVudC4gVGhlIHNhbWVcbiAgIHJlbWFyayBhcHBsaWVzIHRvIFt0cmFuc3Bvc2VdLCBbZGlhZ29uYWxzXSwgW3Byb2R1Y3RdLCBldGMuICopXG5cbmxldCBwZWVsIHhzcyA9XG4gIHVuemlwIChmaWx0ZXJfbWFwIHVuY29ucyB4c3MpXG5cbmxldCByZWMgdHJhbnNwb3NlIHhzcyAoKSA9XG4gIGxldCBoZWFkcywgdGFpbHMgPSBwZWVsIHhzcyBpblxuICBpZiBpc19lbXB0eSBoZWFkcyB0aGVuIGJlZ2luXG4gICAgYXNzZXJ0IChpc19lbXB0eSB0YWlscyk7XG4gICAgTmlsXG4gIGVuZFxuICBlbHNlXG4gICAgQ29ucyAoaGVhZHMsIHRyYW5zcG9zZSB0YWlscylcblxuKCogVGhlIGludGVybmFsIGZ1bmN0aW9uIFtkaWFnb25hbHNdIHRha2VzIGFuIGV4dHJhIGFyZ3VtZW50LCBbcmVtYWluZGVyc10sXG4gICB3aGljaCBjb250YWlucyB0aGUgcmVtYWluZGVycyBvZiB0aGUgcm93cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuXG4gICBkaXNjb3ZlcmVkLiAqKVxuXG5sZXQgcmVjIGRpYWdvbmFscyByZW1haW5kZXJzIHhzcyAoKSA9XG4gIG1hdGNoIHhzcygpIHdpdGhcbiAgfCBDb25zICh4cywgeHNzKSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggeHMoKSB3aXRoXG4gICAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICAgICgqIFdlIGRpc2NvdmVyIGEgbmV3IG5vbmVtcHR5IHJvdyBbeCA6OiB4c10uIFRodXMsIHRoZSBuZXh0IGRpYWdvbmFsXG4gICAgICAgICAgICAgaXMgW3ggOjogaGVhZHNdOiB0aGlzIGRpYWdvbmFsIGJlZ2lucyB3aXRoIFt4XSBhbmQgY29udGludWVzIHdpdGhcbiAgICAgICAgICAgICB0aGUgZmlyc3QgZWxlbWVudCBvZiBldmVyeSByb3cgaW4gW3JlbWFpbmRlcnNdLiBJbiB0aGUgcmVjdXJzaXZlXG4gICAgICAgICAgICAgY2FsbCwgdGhlIGFyZ3VtZW50IFtyZW1haW5kZXJzXSBpcyBpbnN0YW50aWF0ZWQgd2l0aCBbeHMgOjpcbiAgICAgICAgICAgICB0YWlsc10sIHdoaWNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBvbmUgbW9yZSByZW1haW5pbmcgcm93LCBbeHNdLFxuICAgICAgICAgICAgIGFuZCB0aGF0IHdlIGtlZXAgdGhlIHRhaWxzIG9mIHRoZSBwcmUtZXhpc3RpbmcgcmVtYWluaW5nIHJvd3MuICopXG4gICAgICAgICAgbGV0IGhlYWRzLCB0YWlscyA9IHBlZWwgcmVtYWluZGVycyBpblxuICAgICAgICAgIENvbnMgKGNvbnMgeCBoZWFkcywgZGlhZ29uYWxzIChjb25zIHhzIHRhaWxzKSB4c3MpXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgICgqIFdlIGRpc2NvdmVyIGEgbmV3IGVtcHR5IHJvdy4gSW4gdGhpcyBjYXNlLCB0aGUgbmV3IGRpYWdvbmFsIGlzXG4gICAgICAgICAgICAganVzdCBbaGVhZHNdLCBhbmQgW3JlbWFpbmRlcnNdIGlzIGluc3RhbnRpYXRlZCB3aXRoIGp1c3QgW3RhaWxzXSxcbiAgICAgICAgICAgICBhcyB3ZSBkbyBub3QgaGF2ZSBvbmUgbW9yZSByZW1haW5pbmcgcm93LiAqKVxuICAgICAgICAgIGxldCBoZWFkcywgdGFpbHMgPSBwZWVsIHJlbWFpbmRlcnMgaW5cbiAgICAgICAgICBDb25zIChoZWFkcywgZGlhZ29uYWxzIHRhaWxzIHhzcylcbiAgICAgIGVuZFxuICB8IE5pbCAtPlxuICAgICAgKCogVGhlcmUgYXJlIG5vIG1vcmUgcm93cyB0byBiZSBkaXNjb3ZlcmVkLiBUaGVyZSByZW1haW5zIHRvIGV4aGF1c3RcbiAgICAgICAgIHRoZSByZW1haW5pbmcgcm93cy4gKilcbiAgICAgIHRyYW5zcG9zZSByZW1haW5kZXJzICgpXG5cbigqIElmIFt4c3NdIGlzIGEgbWF0cml4IChhIHNlcXVlbmNlIG9mIHJvd3MpLCB0aGVuIFtkaWFnb25hbHMgeHNzXSBpc1xuICAgdGhlIHNlcXVlbmNlIG9mIGl0cyBkaWFnb25hbHMuXG5cbiAgIFRoZSBmaXJzdCBkaWFnb25hbCBjb250YWlucyBqdXN0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZVxuICAgZmlyc3Qgcm93LiBUaGUgc2Vjb25kIGRpYWdvbmFsIGNvbnRhaW5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZVxuICAgc2Vjb25kIHJvdyBhbmQgdGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSBmaXJzdCByb3c7IGFuZCBzbyBvbi5cbiAgIFRoaXMga2luZCBvZiBkaWFnb25hbCBpcyBpbiBmYWN0IHNvbWV0aW1lcyBrbm93biBhcyBhbiBhbnRpZGlhZ29uYWwuXG5cbiAgIC0gRXZlcnkgZGlhZ29uYWwgaXMgYSBmaW5pdGUgc2VxdWVuY2UuXG4gICAtIFRoZSByb3dzIG9mIHRoZSBtYXRyaXggW3hzc10gYXJlIG5vdCByZXF1aXJlZCB0byBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbiAgIC0gVGhlIG1hdHJpeCBbeHNzXSBpcyBub3QgcmVxdWlyZWQgdG8gYmUgZmluaXRlIChpbiBlaXRoZXIgZGlyZWN0aW9uKS5cbiAgIC0gVGhlIG1hdHJpeCBbeHNzXSBtdXN0IGJlIHBlcnNpc3RlbnQuICopXG5cbmxldCBkaWFnb25hbHMgeHNzID1cbiAgZGlhZ29uYWxzIGVtcHR5IHhzc1xuXG5sZXQgbWFwX3Byb2R1Y3QgZiB4cyB5cyA9XG4gIGNvbmNhdCAoZGlhZ29uYWxzIChcbiAgICBtYXAgKGZ1biB4IC0+XG4gICAgICBtYXAgKGZ1biB5IC0+XG4gICAgICAgIGYgeCB5XG4gICAgICApIHlzXG4gICAgKSB4c1xuICApKVxuXG5sZXQgcHJvZHVjdCB4cyB5cyA9XG4gIG1hcF9wcm9kdWN0IChmdW4geCB5IC0+ICh4LCB5KSkgeHMgeXNcblxubGV0IG9mX2Rpc3BlbnNlciBpdCA9XG4gIGxldCByZWMgYyAoKSA9XG4gICAgbWF0Y2ggaXQoKSB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICAgIE5pbFxuICAgIHwgU29tZSB4IC0+XG4gICAgICAgIENvbnMgKHgsIGMpXG4gIGluXG4gIGNcblxubGV0IHRvX2Rpc3BlbnNlciB4cyA9XG4gIGxldCBzID0gcmVmIHhzIGluXG4gIGZ1biAoKSAtPlxuICAgIG1hdGNoICghcykoKSB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgICAgTm9uZVxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIHMgOj0geHM7XG4gICAgICAgIFNvbWUgeFxuXG5cblxubGV0IHJlYyBpbnRzIGkgKCkgPVxuICBDb25zIChpLCBpbnRzIChpICsgMSkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9ICdhIG9wdGlvbiA9IE5vbmUgfCBTb21lIG9mICdhXG5cbmxldCBub25lID0gTm9uZVxubGV0IHNvbWUgdiA9IFNvbWUgdlxubGV0IHZhbHVlIG8gfmRlZmF1bHQgPSBtYXRjaCBvIHdpdGggU29tZSB2IC0+IHYgfCBOb25lIC0+IGRlZmF1bHRcbmxldCBnZXQgPSBmdW5jdGlvbiBTb21lIHYgLT4gdiB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJvcHRpb24gaXMgTm9uZVwiXG5sZXQgYmluZCBvIGYgPSBtYXRjaCBvIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSB2IC0+IGYgdlxubGV0IGpvaW4gPSBmdW5jdGlvbiBTb21lIG8gLT4gbyB8IE5vbmUgLT4gTm9uZVxubGV0IG1hcCBmIG8gPSBtYXRjaCBvIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSB2IC0+IFNvbWUgKGYgdilcbmxldCBmb2xkIH5ub25lIH5zb21lID0gZnVuY3Rpb24gU29tZSB2IC0+IHNvbWUgdiB8IE5vbmUgLT4gbm9uZVxubGV0IGl0ZXIgZiA9IGZ1bmN0aW9uIFNvbWUgdiAtPiBmIHYgfCBOb25lIC0+ICgpXG5sZXQgaXNfbm9uZSA9IGZ1bmN0aW9uIE5vbmUgLT4gdHJ1ZSB8IFNvbWUgXyAtPiBmYWxzZVxubGV0IGlzX3NvbWUgPSBmdW5jdGlvbiBOb25lIC0+IGZhbHNlIHwgU29tZSBfIC0+IHRydWVcblxubGV0IGVxdWFsIGVxIG8wIG8xID0gbWF0Y2ggbzAsIG8xIHdpdGhcbnwgU29tZSB2MCwgU29tZSB2MSAtPiBlcSB2MCB2MVxufCBOb25lLCBOb25lIC0+IHRydWVcbnwgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSBjbXAgbzAgbzEgPSBtYXRjaCBvMCwgbzEgd2l0aFxufCBTb21lIHYwLCBTb21lIHYxIC0+IGNtcCB2MCB2MVxufCBOb25lLCBOb25lIC0+IDBcbnwgTm9uZSwgU29tZSBfIC0+IC0xXG58IFNvbWUgXywgTm9uZSAtPiAxXG5cbmxldCB0b19yZXN1bHQgfm5vbmUgPSBmdW5jdGlvbiBOb25lIC0+IEVycm9yIG5vbmUgfCBTb21lIHYgLT4gT2sgdlxubGV0IHRvX2xpc3QgPSBmdW5jdGlvbiBOb25lIC0+IFtdIHwgU29tZSB2IC0+IFt2XVxubGV0IHRvX3NlcSA9IGZ1bmN0aW9uIE5vbmUgLT4gU2VxLmVtcHR5IHwgU29tZSB2IC0+IFNlcS5yZXR1cm4gdlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdlXG5cbmxldCBvayB2ID0gT2sgdlxubGV0IGVycm9yIGUgPSBFcnJvciBlXG5sZXQgdmFsdWUgciB+ZGVmYXVsdCA9IG1hdGNoIHIgd2l0aCBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGRlZmF1bHRcbmxldCBnZXRfb2sgPSBmdW5jdGlvbiBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGludmFsaWRfYXJnIFwicmVzdWx0IGlzIEVycm9yIF9cIlxubGV0IGdldF9lcnJvciA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gZSB8IE9rIF8gLT4gaW52YWxpZF9hcmcgXCJyZXN1bHQgaXMgT2sgX1wiXG5sZXQgYmluZCByIGYgPSBtYXRjaCByIHdpdGggT2sgdiAtPiBmIHYgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IGpvaW4gPSBmdW5jdGlvbiBPayByIC0+IHIgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IG1hcCBmID0gZnVuY3Rpb24gT2sgdiAtPiBPayAoZiB2KSB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgbWFwX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IEVycm9yIChmIGUpIHwgT2sgXyBhcyB2IC0+IHZcbmxldCBmb2xkIH5vayB+ZXJyb3IgPSBmdW5jdGlvbiBPayB2IC0+IG9rIHYgfCBFcnJvciBlIC0+IGVycm9yIGVcbmxldCBpdGVyIGYgPSBmdW5jdGlvbiBPayB2IC0+IGYgdiB8IEVycm9yIF8gLT4gKClcbmxldCBpdGVyX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IGYgZSB8IE9rIF8gLT4gKClcbmxldCBpc19vayA9IGZ1bmN0aW9uIE9rIF8gLT4gdHJ1ZSB8IEVycm9yIF8gLT4gZmFsc2VcbmxldCBpc19lcnJvciA9IGZ1bmN0aW9uIEVycm9yIF8gLT4gdHJ1ZSB8IE9rIF8gLT4gZmFsc2VcblxubGV0IGVxdWFsIH5vayB+ZXJyb3IgcjAgcjEgPSBtYXRjaCByMCwgcjEgd2l0aFxufCBPayB2MCwgT2sgdjEgLT4gb2sgdjAgdjFcbnwgRXJyb3IgZTAsIEVycm9yIGUxIC0+IGVycm9yIGUwIGUxXG58IF8sIF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgfm9rIH5lcnJvciByMCByMSA9IG1hdGNoIHIwLCByMSB3aXRoXG58IE9rIHYwLCBPayB2MSAtPiBvayB2MCB2MVxufCBFcnJvciBlMCwgRXJyb3IgZTEgLT4gZXJyb3IgZTAgZTFcbnwgT2sgXywgRXJyb3IgXyAtPiAtMVxufCBFcnJvciBfLCBPayBfIC0+IDFcblxubGV0IHRvX29wdGlvbiA9IGZ1bmN0aW9uIE9rIHYgLT4gU29tZSB2IHwgRXJyb3IgXyAtPiBOb25lXG5sZXQgdG9fbGlzdCA9IGZ1bmN0aW9uIE9rIHYgLT4gW3ZdIHwgRXJyb3IgXyAtPiBbXVxubGV0IHRvX3NlcSA9IGZ1bmN0aW9uIE9rIHYgLT4gU2VxLnJldHVybiB2IHwgRXJyb3IgXyAtPiBTZXEuZW1wdHlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gYm9vbCA9IGZhbHNlIHwgdHJ1ZVxuXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5sZXQgZXF1YWwgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGJvb2wgLT4gYm9vbCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxuZXh0ZXJuYWwgdG9faW50IDogYm9vbCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5sZXQgdG9fZmxvYXQgPSBmdW5jdGlvbiBmYWxzZSAtPiAwLiB8IHRydWUgLT4gMS5cblxuKCpcbmxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxufCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxufCBcInRydWVcIiAtPiBTb21lIHRydWVcbnwgXyAtPiBOb25lXG4qKVxuXG5sZXQgdG9fc3RyaW5nID0gZnVuY3Rpb24gZmFsc2UgLT4gXCJmYWxzZVwiIHwgdHJ1ZSAtPiBcInRydWVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBjb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgY2hyIG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJDaGFyLmNoclwiIGVsc2UgdW5zYWZlX2NociBuXG5cbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZTogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBieXRlc191bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgZXNjYXBlZCA9IGZ1bmN0aW9uXG4gIHwgJ1xcJycgLT4gXCJcXFxcJ1wiXG4gIHwgJ1xcXFwnIC0+IFwiXFxcXFxcXFxcIlxuICB8ICdcXG4nIC0+IFwiXFxcXG5cIlxuICB8ICdcXHQnIC0+IFwiXFxcXHRcIlxuICB8ICdcXHInIC0+IFwiXFxcXHJcIlxuICB8ICdcXGInIC0+IFwiXFxcXGJcIlxuICB8ICcgJyAuLiAnficgYXMgYyAtPlxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgMSBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgYztcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuICB8IGMgLT5cbiAgICAgIGxldCBuID0gY29kZSBjIGluXG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSA0IGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCAnXFxcXCc7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMSAodW5zYWZlX2NociAoNDggKyBuIC8gMTAwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMiAodW5zYWZlX2NociAoNDggKyAobiAvIDEwKSBtb2QgMTApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAzICh1bnNhZmVfY2hyICg0OCArIG4gbW9kIDEwKSk7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcblxubGV0IGxvd2VyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ0EnIC4uICdaJ1xuICB8ICdcXDE5MicgLi4gJ1xcMjE0J1xuICB8ICdcXDIxNicgLi4gJ1xcMjIyJyBhcyBjIC0+XG4gICAgdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgfCBjIC0+IGNcblxubGV0IHVwcGVyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6J1xuICB8ICdcXDIyNCcgLi4gJ1xcMjQ2J1xuICB8ICdcXDI0OCcgLi4gJ1xcMjU0JyBhcyBjIC0+XG4gICAgdW5zYWZlX2Nocihjb2RlIGMgLSAzMilcbiAgfCBjIC0+IGNcblxubGV0IGxvd2VyY2FzZV9hc2NpaSA9IGZ1bmN0aW9uXG4gIHwgJ0EnIC4uICdaJyBhcyBjIC0+IHVuc2FmZV9jaHIoY29kZSBjICsgMzIpXG4gIHwgYyAtPiBjXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgYXMgYyAtPiB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICB8IGMgLT4gY1xuXG50eXBlIHQgPSBjaGFyXG5cbmxldCBjb21wYXJlIGMxIGMyID0gY29kZSBjMSAtIGNvZGUgYzJcbmxldCBlcXVhbCAoYzE6IHQpIChjMjogdCkgPSBjb21wYXJlIGMxIGMyID0gMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBEYW5pZWwgQy4gQnVlbnpsaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5cbmxldCBlcnJfbm9fcHJlZCA9IFwiVSswMDAwIGhhcyBubyBwcmVkZWNlc3NvclwiXG5sZXQgZXJyX25vX3N1Y2MgPSBcIlUrMTBGRkZGIGhhcyBubyBzdWNjZXNzb3JcIlxubGV0IGVycl9ub3Rfc3YgaSA9IGZvcm1hdF9pbnQgXCIlWFwiIGkgXiBcIiBpcyBub3QgYW4gVW5pY29kZSBzY2FsYXIgdmFsdWVcIlxubGV0IGVycl9ub3RfbGF0aW4xIHUgPSBcIlUrXCIgXiBmb3JtYXRfaW50IFwiJTA0WFwiIHUgXiBcIiBpcyBub3QgYSBsYXRpbjEgY2hhcmFjdGVyXCJcblxudHlwZSB0ID0gaW50XG5cbmxldCBtaW4gPSAweDAwMDBcbmxldCBtYXggPSAweDEwRkZGRlxubGV0IGxvX2JvdW5kID0gMHhEN0ZGXG5sZXQgaGlfYm91bmQgPSAweEUwMDBcblxubGV0IGJvbSA9IDB4RkVGRlxubGV0IHJlcCA9IDB4RkZGRFxuXG5sZXQgc3VjYyB1ID1cbiAgaWYgdSA9IGxvX2JvdW5kIHRoZW4gaGlfYm91bmQgZWxzZVxuICBpZiB1ID0gbWF4IHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3N1Y2MgZWxzZVxuICB1ICsgMVxuXG5sZXQgcHJlZCB1ID1cbiAgaWYgdSA9IGhpX2JvdW5kIHRoZW4gbG9fYm91bmQgZWxzZVxuICBpZiB1ID0gbWluIHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3ByZWQgZWxzZVxuICB1IC0gMVxuXG5sZXQgaXNfdmFsaWQgaSA9IChtaW4gPD0gaSAmJiBpIDw9IGxvX2JvdW5kKSB8fCAoaGlfYm91bmQgPD0gaSAmJiBpIDw9IG1heClcbmxldCBvZl9pbnQgaSA9IGlmIGlzX3ZhbGlkIGkgdGhlbiBpIGVsc2UgaW52YWxpZF9hcmcgKGVycl9ub3Rfc3YgaSlcbmV4dGVybmFsIHVuc2FmZV9vZl9pbnQgOiBpbnQgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHRvX2ludCA6IHQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfY2hhciB1ID0gdSA8IDI1NlxubGV0IG9mX2NoYXIgYyA9IENoYXIuY29kZSBjXG5sZXQgdG9fY2hhciB1ID1cbiAgaWYgdSA+IDI1NSB0aGVuIGludmFsaWRfYXJnIChlcnJfbm90X2xhdGluMSB1KSBlbHNlXG4gIENoYXIudW5zYWZlX2NociB1XG5cbmxldCB1bnNhZmVfdG9fY2hhciA9IENoYXIudW5zYWZlX2NoclxuXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5sZXQgaGFzaCA9IHRvX2ludFxuXG4oKiBVVEYgY29kZWNzIHRvb2xzICopXG5cbnR5cGUgdXRmX2RlY29kZSA9IGludFxuKCogVGhpcyBpcyBhbiBpbnQgWzB4RFVVVVVVVV0gZGVjb21wb3NlZCBhcyBmb2xsb3dzOlxuICAgLSBbRF0gaXMgZm91ciBiaXRzIGZvciBkZWNvZGUgaW5mb3JtYXRpb24sIHRoZSBoaWdoZXN0IGJpdCBpcyBzZXQgaWYgdGhlXG4gICAgIGRlY29kZSBpcyB2YWxpZC4gVGhlIHRocmVlIGxvd2VyIGJpdHMgaW5kaWNhdGUgdGhlIG51bWJlciBvZiBlbGVtZW50c1xuICAgICBmcm9tIHRoZSBzb3VyY2UgdGhhdCB3ZXJlIGNvbnN1bWVkIGJ5IHRoZSBkZWNvZGUuXG4gICAtIFtVVVVVVVVdIGlzIHRoZSBkZWNvZGVkIFVuaWNvZGUgY2hhcmFjdGVyIG9yIHRoZSBVbmljb2RlIHJlcGxhY2VtZW50XG4gICAgIGNoYXJhY3RlciBVK0ZGRkQgaWYgZm9yIGludmFsaWQgZGVjb2Rlcy4gKilcblxubGV0IHZhbGlkX2JpdCA9IDI3XG5sZXQgZGVjb2RlX2JpdHMgPSAyNFxuXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV9pc192YWxpZCBkID0gKGQgbHNyIHZhbGlkX2JpdCkgPSAxXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV9sZW5ndGggZCA9IChkIGxzciBkZWNvZGVfYml0cykgbGFuZCAwYjExMVxubGV0W0BpbmxpbmVdIHV0Zl9kZWNvZGVfdWNoYXIgZCA9IHVuc2FmZV9vZl9pbnQgKGQgbGFuZCAweEZGRkZGRilcbmxldFtAaW5saW5lXSB1dGZfZGVjb2RlIG4gdSA9ICgoOCBsb3IgbikgbHNsIGRlY29kZV9iaXRzKSBsb3IgKHRvX2ludCB1KVxubGV0W0BpbmxpbmVdIHV0Zl9kZWNvZGVfaW52YWxpZCBuID0gKG4gbHNsIGRlY29kZV9iaXRzKSBsb3IgcmVwXG5cbmxldCB1dGZfOF9ieXRlX2xlbmd0aCB1ID0gbWF0Y2ggdG9faW50IHUgd2l0aFxufCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG58IHUgd2hlbiB1IDw9IDB4MDA3RiAtPiAxXG58IHUgd2hlbiB1IDw9IDB4MDdGRiAtPiAyXG58IHUgd2hlbiB1IDw9IDB4RkZGRiAtPiAzXG58IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+IDRcbnwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHV0Zl8xNl9ieXRlX2xlbmd0aCB1ID0gbWF0Y2ggdG9faW50IHUgd2l0aFxufCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG58IHUgd2hlbiB1IDw9IDB4RkZGRiAtPiAyXG58IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+IDRcbnwgXyAtPiBhc3NlcnQgZmFsc2VcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIGxpc3RzLiAqKVxudHlwZSAnYSB0ID0gJ2EgbGlzdCA9IFtdIHwgKDo6KSBvZiAnYSAqICdhIGxpc3RcblxuKCogTGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZWMgbGVuZ3RoX2F1eCBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGxlblxuICB8IF86OmwgLT4gbGVuZ3RoX2F1eCAobGVuICsgMSkgbFxuXG5sZXQgbGVuZ3RoIGwgPSBsZW5ndGhfYXV4IDAgbFxuXG5sZXQgY29ucyBhIGwgPSBhOjpsXG5cbmxldCBoZCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJoZFwiXG4gIHwgYTo6XyAtPiBhXG5cbmxldCB0bCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJ0bFwiXG4gIHwgXzo6bCAtPiBsXG5cbmxldCBudGggbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGZhaWx3aXRoIFwibnRoXCJcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBudGhfb3B0IGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBhcHBlbmQgPSAoQClcblxubGV0IHJlYyByZXZfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgYSA6OiBsIC0+IHJldl9hcHBlbmQgbCAoYSA6OiBsMilcblxubGV0IHJldiBsID0gcmV2X2FwcGVuZCBsIFtdXG5cbmxldCByZWMgaW5pdF90YWlscmVjX2F1eCBhY2MgaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBhY2NcbiAgZWxzZSBpbml0X3RhaWxyZWNfYXV4IChmIGkgOjogYWNjKSAoaSsxKSBuIGZcblxubGV0IHJlYyBpbml0X2F1eCBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgciA9IGYgaSBpblxuICAgIHIgOjogaW5pdF9hdXggKGkrMSkgbiBmXG5cbmxldCByZXZfaW5pdF90aHJlc2hvbGQgPVxuICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBTeXMuTmF0aXZlIHwgU3lzLkJ5dGVjb2RlIC0+IDEwXzAwMFxuICAoKiBXZSBkb24ndCBrbm93IHRoZSBzaXplIG9mIHRoZSBzdGFjaywgYmV0dGVyIGJlIHNhZmUgYW5kIGFzc3VtZSBpdCdzXG4gICAgIHNtYWxsLiAqKVxuICB8IFN5cy5PdGhlciBfIC0+IDUwXG5cbmxldCBpbml0IGxlbiBmID1cbiAgaWYgbGVuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5pbml0XCIgZWxzZVxuICBpZiBsZW4gPiByZXZfaW5pdF90aHJlc2hvbGQgdGhlbiByZXYgKGluaXRfdGFpbHJlY19hdXggW10gMCBsZW4gZilcbiAgZWxzZSBpbml0X2F1eCAwIGxlbiBmXG5cbmxldCByZWMgZmxhdHRlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBsOjpyIC0+IGwgQCBmbGF0dGVuIHJcblxubGV0IGNvbmNhdCA9IGZsYXR0ZW5cblxubGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBhIGluIHIgOjogbWFwIGYgbFxuXG5sZXQgcmVjIG1hcGkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGE6OmwgLT4gbGV0IHIgPSBmIGkgYSBpbiByIDo6IG1hcGkgKGkgKyAxKSBmIGxcblxubGV0IG1hcGkgZiBsID0gbWFwaSAwIGYgbFxuXG5sZXQgcmV2X21hcCBmIGwgPVxuICBsZXQgcmVjIHJtYXBfZiBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IGE6OmwgLT4gcm1hcF9mIChmIGEgOjogYWNjdSkgbFxuICBpblxuICBybWFwX2YgW10gbFxuXG5cbmxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBhOyBpdGVyIGYgbFxuXG5sZXQgcmVjIGl0ZXJpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgaSBhOyBpdGVyaSAoaSArIDEpIGYgbFxuXG5sZXQgaXRlcmkgZiBsID0gaXRlcmkgMCBmIGxcblxubGV0IHJlYyBmb2xkX2xlZnQgZiBhY2N1IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmb2xkX2xlZnQgZiAoZiBhY2N1IGEpIGxcblxubGV0IHJlYyBmb2xkX3JpZ2h0IGYgbCBhY2N1ID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZiBhIChmb2xkX3JpZ2h0IGYgbCBhY2N1KVxuXG5sZXQgcmVjIG1hcDIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gbGV0IHIgPSBmIGExIGEyIGluIHIgOjogbWFwMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5tYXAyXCJcblxubGV0IHJldl9tYXAyIGYgbDEgbDIgPVxuICBsZXQgcmVjIHJtYXAyX2YgYWNjdSBsMSBsMiA9XG4gICAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIHwgKFtdLCBbXSkgLT4gYWNjdVxuICAgIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBybWFwMl9mIChmIGExIGEyIDo6IGFjY3UpIGwxIGwyXG4gICAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJldl9tYXAyXCJcbiAgaW5cbiAgcm1hcDJfZiBbXSBsMSBsMlxuXG5cbmxldCByZWMgaXRlcjIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiAoKVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMjsgaXRlcjIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuaXRlcjJcIlxuXG5sZXQgcmVjIGZvbGRfbGVmdDIgZiBhY2N1IGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGZvbGRfbGVmdDIgZiAoZiBhY2N1IGExIGEyKSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9sZWZ0MlwiXG5cbmxldCByZWMgZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1ID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTIgKGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSlcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfcmlnaHQyXCJcblxubGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IHRydWVcbiAgfCBhOjpsIC0+IHAgYSAmJiBmb3JfYWxsIHAgbFxuXG5sZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gcCBhIHx8IGV4aXN0cyBwIGxcblxubGV0IHJlYyBmb3JfYWxsMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IHRydWVcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgJiYgZm9yX2FsbDIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9yX2FsbDJcIlxuXG5sZXQgcmVjIGV4aXN0czIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBmYWxzZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiB8fCBleGlzdHMyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmV4aXN0czJcIlxuXG5sZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbSB4IGxcblxubGV0IHJlYyBtZW1xIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBhID09IHggfHwgbWVtcSB4IGxcblxubGV0IHJlYyBhc3NvYyB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBiIGVsc2UgYXNzb2MgeCBsXG5cbmxldCByZWMgYXNzb2Nfb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBTb21lIGIgZWxzZSBhc3NvY19vcHQgeCBsXG5cbmxldCByZWMgYXNzcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBiIGVsc2UgYXNzcSB4IGxcblxubGV0IHJlYyBhc3NxX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gU29tZSBiIGVsc2UgYXNzcV9vcHQgeCBsXG5cbmxldCByZWMgbWVtX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbV9hc3NvYyB4IGxcblxubGV0IHJlYyBtZW1fYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGEgPT0geCB8fCBtZW1fYXNzcSB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+XG4gICAgICBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzb2MgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+IGlmIGEgPT0geCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NxIHggbFxuXG5sZXQgcmVjIGZpbmQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHggZWxzZSBmaW5kIHAgbFxuXG5sZXQgcmVjIGZpbmRfb3B0IHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gU29tZSB4IGVsc2UgZmluZF9vcHQgcCBsXG5cbmxldCByZWMgZmluZF9tYXAgZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPlxuICAgICBiZWdpbiBtYXRjaCBmIHggd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPiByZXN1bHRcbiAgICAgICB8IE5vbmUgLT4gZmluZF9tYXAgZiBsXG4gICAgIGVuZFxuXG5sZXQgZmluZF9hbGwgcCA9XG4gIGxldCByZWMgZmluZCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjdVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBmaW5kICh4IDo6IGFjY3UpIGwgZWxzZSBmaW5kIGFjY3UgbCBpblxuICBmaW5kIFtdXG5cbmxldCBmaWx0ZXIgPSBmaW5kX2FsbFxuXG5sZXQgZmlsdGVyaSBwIGwgPVxuICBsZXQgcmVjIGF1eCBpIGFjYyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmV2IGFjY1xuICB8IHg6OmwgLT4gYXV4IChpICsgMSkgKGlmIHAgaSB4IHRoZW4geDo6YWNjIGVsc2UgYWNjKSBsXG4gIGluXG4gIGF1eCAwIFtdIGxcblxubGV0IGZpbHRlcl9tYXAgZiA9XG4gIGxldCByZWMgYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY3VcbiAgICB8IHggOjogbCAtPlxuICAgICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgICB8IE5vbmUgLT4gYXV4IGFjY3UgbFxuICAgICAgICB8IFNvbWUgdiAtPiBhdXggKHYgOjogYWNjdSkgbFxuICBpblxuICBhdXggW11cblxubGV0IGNvbmNhdF9tYXAgZiBsID1cbiAgbGV0IHJlYyBhdXggZiBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgbGV0IHhzID0gZiB4IGluXG4gICAgICAgYXV4IGYgKHJldl9hcHBlbmQgeHMgYWNjKSBsXG4gIGluIGF1eCBmIFtdIGxcblxubGV0IGZvbGRfbGVmdF9tYXAgZiBhY2N1IGwgPVxuICBsZXQgcmVjIGF1eCBhY2N1IGxfYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1LCByZXYgbF9hY2N1XG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICAgbGV0IGFjY3UsIHggPSBmIGFjY3UgeCBpblxuICAgICAgICBhdXggYWNjdSAoeCA6OiBsX2FjY3UpIGwgaW5cbiAgYXV4IGFjY3UgW10gbFxuXG5sZXQgcGFydGl0aW9uIHAgbCA9XG4gIGxldCByZWMgcGFydCB5ZXMgbm8gPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgeWVzLCByZXYgbm8pXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHBhcnQgKHggOjogeWVzKSBubyBsIGVsc2UgcGFydCB5ZXMgKHggOjogbm8pIGwgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCBwYXJ0aXRpb25fbWFwIHAgbCA9XG4gIGxldCByZWMgcGFydCBsZWZ0IHJpZ2h0ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAocmV2IGxlZnQsIHJldiByaWdodClcbiAgfCB4IDo6IGwgLT5cbiAgICAgYmVnaW4gbWF0Y2ggcCB4IHdpdGhcbiAgICAgICB8IEVpdGhlci5MZWZ0IHYgLT4gcGFydCAodiA6OiBsZWZ0KSByaWdodCBsXG4gICAgICAgfCBFaXRoZXIuUmlnaHQgdiAtPiBwYXJ0IGxlZnQgKHYgOjogcmlnaHQpIGxcbiAgICAgZW5kXG4gIGluXG4gIHBhcnQgW10gW10gbFxuXG5sZXQgcmVjIHNwbGl0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoW10sIFtdKVxuICB8ICh4LHkpOjpsIC0+XG4gICAgICBsZXQgKHJ4LCByeSkgPSBzcGxpdCBsIGluICh4OjpyeCwgeTo6cnkpXG5cbmxldCByZWMgY29tYmluZSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gKGExLCBhMikgOjogY29tYmluZSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuY29tYmluZVwiXG5cbigqKiBzb3J0aW5nICopXG5cbmxldCByZWMgbWVyZ2UgY21wIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgbDIgLT4gbDJcbiAgfCBsMSwgW10gLT4gbDFcbiAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICAgIGlmIGNtcCBoMSBoMiA8PSAwXG4gICAgICB0aGVuIGgxIDo6IG1lcmdlIGNtcCB0MSBsMlxuICAgICAgZWxzZSBoMiA6OiBtZXJnZSBjbXAgbDEgdDJcblxuXG5sZXQgc3RhYmxlX3NvcnQgY21wIGwgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyIDw9IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuXG4gICAgICAgICAgICBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2VfcmV2IHMxIHMyIFtdLCB0bClcbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9IGlmIGNtcCB4MSB4MiA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBpZiBjbXAgeDEgeDIgPiAwIHRoZW5cbiAgICAgICAgICAgIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA+IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZSBzMSBzMiBbXSwgdGwpXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcblxuXG5sZXQgc29ydCA9IHN0YWJsZV9zb3J0XG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCogTm90ZTogb24gYSBsaXN0IG9mIGxlbmd0aCBiZXR3ZWVuIGFib3V0IDEwMDAwMCAoZGVwZW5kaW5nIG9uIHRoZSBtaW5vclxuICAgaGVhcCBzaXplIGFuZCB0aGUgdHlwZSBvZiB0aGUgbGlzdCkgYW5kIFN5cy5tYXhfYXJyYXlfc2l6ZSwgaXQgaXNcbiAgIGFjdHVhbGx5IGZhc3RlciB0byB1c2UgdGhlIGZvbGxvd2luZywgYnV0IGl0IG1pZ2h0IGFsc28gdXNlIG1vcmUgbWVtb3J5XG4gICBiZWNhdXNlIHRoZSBhcmd1bWVudCBsaXN0IGNhbm5vdCBiZSBkZWFsbG9jYXRlZCBpbmNyZW1lbnRhbGx5LlxuXG4gICBBbHNvLCB0aGVyZSBzZWVtcyB0byBiZSBhIGJ1ZyBpbiB0aGlzIGNvZGUgb3IgaW4gdGhlXG4gICBpbXBsZW1lbnRhdGlvbiBvZiBvYmpfdHJ1bmNhdGUuXG5cbmV4dGVybmFsIG9ial90cnVuY2F0ZSA6ICdhIGFycmF5IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5cbmxldCBhcnJheV90b19saXN0X2luX3BsYWNlIGEgPVxuICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBhY2N1IG4gcCA9XG4gICAgaWYgcCA8PSAwIHRoZW4gYWNjdSBlbHNlIGJlZ2luXG4gICAgICBpZiBwID0gbiB0aGVuIGJlZ2luXG4gICAgICAgIG9ial90cnVuY2F0ZSBhIHA7XG4gICAgICAgIGxvb3AgKGEuKHAtMSkgOjogYWNjdSkgKG4tMTAwMCkgKHAtMSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxvb3AgKGEuKHAtMSkgOjogYWNjdSkgbiAocC0xKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgW10gKGwtMTAwMCkgbFxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCBhID0gQXJyYXkub2ZfbGlzdCBsIGluXG4gIEFycmF5LnN0YWJsZV9zb3J0IGNtcCBhO1xuICBhcnJheV90b19saXN0X2luX3BsYWNlIGFcblxuKilcblxuXG4oKiogc29ydGluZyArIHJlbW92aW5nIGR1cGxpY2F0ZXMgKilcblxubGV0IHNvcnRfdW5pcSBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZSB0MSB0MiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgbGV0IGMgPSBjbXAgaDEgaDIgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXSBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZV9yZXYgczEgczIgW10sIHRsKVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXSBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2UgczEgczIgW10sIHRsKVxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBmc3QgKHNvcnQgbGVuIGwpXG5cblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aHMgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgXyA6OiBsMSwgXyA6OiBsMiAtPiBjb21wYXJlX2xlbmd0aHMgbDEgbDJcbjs7XG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhfd2l0aCBsIG4gPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIGlmIG4gPSAwIHRoZW4gMCBlbHNlXG4gICAgICBpZiBuID4gMCB0aGVuIC0xIGVsc2UgMVxuICB8IF8gOjogbCAtPlxuICAgIGlmIG4gPD0gMCB0aGVuIDEgZWxzZVxuICAgICAgY29tcGFyZV9sZW5ndGhfd2l0aCBsIChuLTEpXG47O1xuXG4oKiogezEgQ29tcGFyaXNvbn0gKilcblxuKCogTm90ZTogd2UgYXJlICpub3QqIHNob3J0Y3V0dGluZyB0aGUgbGlzdCBieSB1c2luZ1xuICAgW0xpc3QuY29tcGFyZV9sZW5ndGhzXSBmaXJzdDsgdGhpcyBtYXkgYmUgc2xvd2VyIG9uIGxvbmcgbGlzdHNcbiAgIGltbWVkaWF0ZWx5IHN0YXJ0IHdpdGggZGlzdGluY3QgZWxlbWVudHMuIEl0IGlzIGFsc28gaW5jb3JyZWN0IGZvclxuICAgW2NvbXBhcmVdIGJlbG93LCBhbmQgaXQgaXMgYmV0dGVyIChwcmluY2lwbGUgb2YgbGVhc3Qgc3VycHJpc2UpIHRvXG4gICB1c2UgdGhlIHNhbWUgYXBwcm9hY2ggZm9yIGJvdGggZnVuY3Rpb25zLiAqKVxubGV0IHJlYyBlcXVhbCBlcSBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IHRydWVcbiAgfCBbXSwgXzo6XyB8IF86Ol8sIFtdIC0+IGZhbHNlXG4gIHwgYTE6OmwxLCBhMjo6bDIgLT4gZXEgYTEgYTIgJiYgZXF1YWwgZXEgbDEgbDJcblxubGV0IHJlYyBjb21wYXJlIGNtcCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXzo6XyAtPiAtMVxuICB8IF86Ol8sIFtdIC0+IDFcbiAgfCBhMTo6bDEsIGEyOjpsMiAtPlxuICAgIGxldCBjID0gY21wIGExIGEyIGluXG4gICAgaWYgYyA8PiAwIHRoZW4gY1xuICAgIGVsc2UgY29tcGFyZSBjbXAgbDEgbDJcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBsID1cbiAgbGV0IHJlYyBhdXggbCAoKSA9IG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gU2VxLk5pbFxuICAgIHwgeCA6OiB0YWlsIC0+IFNlcS5Db25zICh4LCBhdXggdGFpbClcbiAgaW5cbiAgYXV4IGxcblxubGV0IG9mX3NlcSBzZXEgPVxuICBsZXQgcmVjIGRpcmVjdCBkZXB0aCBzZXEgOiBfIGxpc3QgPVxuICAgIGlmIGRlcHRoPTBcbiAgICB0aGVuXG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBzZXFcbiAgICAgIHw+IHJldiAoKiB0YWlscmVjICopXG4gICAgZWxzZSBtYXRjaCBzZXEoKSB3aXRoXG4gICAgICB8IFNlcS5OaWwgLT4gW11cbiAgICAgIHwgU2VxLkNvbnMgKHgsIG5leHQpIC0+IHggOjogZGlyZWN0IChkZXB0aC0xKSBuZXh0XG4gIGluXG4gIGRpcmVjdCA1MDAgc2VxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGludFxuXG5sZXQgemVybyA9IDBcbmxldCBvbmUgPSAxXG5sZXQgbWludXNfb25lID0gLTFcbmV4dGVybmFsIG5lZyA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgYWRkIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgc3ViIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgbXVsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgZGl2IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgcmVtIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcbmxldCBtYXhfaW50ID0gKC0xKSBsc3IgMVxubGV0IG1pbl9pbnQgPSBtYXhfaW50ICsgMVxuZXh0ZXJuYWwgbG9nYW5kIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsIGxvZ3hvciA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcbmxldCBsb2dub3QgeCA9IGxvZ3hvciB4ICgtMSlcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5sZXQgbWluIHggeSA6IHQgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgOiB0ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuXG4oKlxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nIHMgPSB0cnkgU29tZSAoaW50X29mX3N0cmluZyBzKSB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG4qKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5sZXQgdG9fc3RyaW5nIHggPSBmb3JtYXRfaW50IFwiJWRcIiB4XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIHN0cmluZy5tbC5cbiAgIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIGEgXCJkdXBsaWNhdGVkXCIgY29tbWVudCBhYm92ZSB0aGVpciBkZWZpbml0aW9uLlxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIHN0cmluZ19sZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2ZpbGxfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGJ5dGVzID0gXCIlYnl0ZXNfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV9ibGl0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbmxldCBtYWtlIG4gYyA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgdW5zYWZlX2ZpbGwgcyAwIG4gYztcbiAgc1xuXG5sZXQgaW5pdCBuIGYgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgcyBpIChmIGkpXG4gIGRvbmU7XG4gIHNcblxubGV0IGVtcHR5ID0gY3JlYXRlIDBcblxubGV0IGNvcHkgcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgdW5zYWZlX2JsaXQgcyAwIHIgMCBsZW47XG4gIHJcblxubGV0IHRvX3N0cmluZyBiID0gdW5zYWZlX3RvX3N0cmluZyAoY29weSBiKVxubGV0IG9mX3N0cmluZyBzID0gY29weSAodW5zYWZlX29mX3N0cmluZyBzKVxuXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLnN1YiAvIEJ5dGVzLnN1YlwiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBzIG9mcyByIDAgbGVuO1xuICAgIHJcbiAgZW5kXG5cbmxldCBzdWJfc3RyaW5nIGIgb2ZzIGxlbiA9IHVuc2FmZV90b19zdHJpbmcgKHN1YiBiIG9mcyBsZW4pXG5cbigqIGFkZGl0aW9uIHdpdGggYW4gb3ZlcmZsb3cgY2hlY2sgKilcbmxldCAoKyspIGEgYiA9XG4gIGxldCBjID0gYSArIGIgaW5cbiAgbWF0Y2ggYSA8IDAsIGIgPCAwLCBjIDwgMCB3aXRoXG4gIHwgdHJ1ZSAsIHRydWUgLCBmYWxzZVxuICB8IGZhbHNlLCBmYWxzZSwgdHJ1ZSAgLT4gaW52YWxpZF9hcmcgXCJCeXRlcy5leHRlbmRcIiAoKiBvdmVyZmxvdyAqKVxuICB8IF8gLT4gY1xuXG5sZXQgZXh0ZW5kIHMgbGVmdCByaWdodCA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyArKyBsZWZ0ICsrIHJpZ2h0IGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICBsZXQgKHNyY29mZiwgZHN0b2ZmKSA9IGlmIGxlZnQgPCAwIHRoZW4gLWxlZnQsIDAgZWxzZSAwLCBsZWZ0IGluXG4gIGxldCBjcHlsZW4gPSBJbnQubWluIChsZW5ndGggcyAtIHNyY29mZikgKGxlbiAtIGRzdG9mZikgaW5cbiAgaWYgY3B5bGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IHMgc3Jjb2ZmIHIgZHN0b2ZmIGNweWxlbjtcbiAgclxuXG5sZXQgZmlsbCBzIG9mcyBsZW4gYyA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmZpbGwgLyBCeXRlcy5maWxsXCJcbiAgZWxzZSB1bnNhZmVfZmlsbCBzIG9mcyBsZW4gY1xuXG5sZXQgYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnl0ZXMuYmxpdFwiXG4gIGVsc2UgdW5zYWZlX2JsaXQgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG5sZXQgYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IHN0cmluZ19sZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuYmxpdCAvIEJ5dGVzLmJsaXRfc3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlcmkgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiQnl0ZXMuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBlbXB0eVxuICB8IGwgLT4gbGV0IHNlcGxlbiA9IGxlbmd0aCBzZXAgaW5cbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChjcmVhdGUgKHN1bV9sZW5ndGhzIDAgc2VwbGVuIGwpKVxuICAgICAgICAgICAgMCBzZXAgc2VwbGVuIGxcblxubGV0IGNhdCBzMSBzMiA9XG4gIGxldCBsMSA9IGxlbmd0aCBzMSBpblxuICBsZXQgbDIgPSBsZW5ndGggczIgaW5cbiAgbGV0IHIgPSBjcmVhdGUgKGwxICsgbDIpIGluXG4gIHVuc2FmZV9ibGl0IHMxIDAgciAwIGwxO1xuICB1bnNhZmVfYmxpdCBzMiAwIHIgbDEgbDI7XG4gIHJcblxuXG5leHRlcm5hbCBjaGFyX2NvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgY2hhcl9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWkpIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGxldCBqID0gcmVmIChsZW4gLSAxKSBpblxuICB3aGlsZSAhaiA+PSAhaSAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFqKSBkb1xuICAgIGRlY3IgalxuICBkb25lO1xuICBpZiAhaiA+PSAhaSB0aGVuXG4gICAgc3ViIHMgIWkgKCFqIC0gIWkgKyAxKVxuICBlbHNlXG4gICAgZW1wdHlcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgIG4gOj0gIW4gK1xuICAgICAgKG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXG4nIHwgJ1xcdCcgfCAnXFxyJyB8ICdcXGInIC0+IDJcbiAgICAgICB8ICcgJyAuLiAnficgLT4gMVxuICAgICAgIHwgXyAtPiA0KVxuICBkb25lO1xuICBpZiAhbiA9IGxlbmd0aCBzIHRoZW4gY29weSBzIGVsc2UgYmVnaW5cbiAgICBsZXQgcycgPSBjcmVhdGUgIW4gaW5cbiAgICBuIDo9IDA7XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgICAgYmVnaW4gbWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAoJ1xcXCInIHwgJ1xcXFwnKSBhcyBjIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnbidcbiAgICAgIHwgJ1xcdCcgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICd0J1xuICAgICAgfCAnXFxyJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3InXG4gICAgICB8ICdcXGInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnYidcbiAgICAgIHwgKCcgJyAuLiAnficpIGFzIGMgLT4gdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8IGMgLT5cbiAgICAgICAgICBsZXQgYSA9IGNoYXJfY29kZSBjIGluXG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgLyAxMDApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgKGEgLyAxMCkgbW9kIDEwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgbW9kIDEwKSk7XG4gICAgICBlbmQ7XG4gICAgICBpbmNyIG5cbiAgICBkb25lO1xuICAgIHMnXG4gIGVuZFxuXG5sZXQgbWFwIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcGkgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhclxuXG5sZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICBkb25lO1xuICAhclxuXG5sZXQgZXhpc3RzIHAgcyA9XG4gIGxldCBuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgcyBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsIHAgcyA9XG4gIGxldCBuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBzIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG5sZXQgYXBwbHkxIGYgcyA9XG4gIGlmIGxlbmd0aCBzID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY29weSBzIGluXG4gICAgdW5zYWZlX3NldCByIDAgKGYodW5zYWZlX2dldCBzIDApKTtcbiAgICByXG4gIGVuZFxuXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCB1bmNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgc3RhcnRzX3dpdGggfnByZWZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9wcmUgPSBsZW5ndGggcHJlZml4IGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fcHJlIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIGkgPD4gdW5zYWZlX2dldCBwcmVmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBsZW5fcyA+PSBsZW5fcHJlICYmIGF1eCAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgZW5kc193aXRoIH5zdWZmaXggcyA9XG4gIGxldCBsZW5fcyA9IGxlbmd0aCBzXG4gIGFuZCBsZW5fc3VmID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBsZXQgZGlmZiA9IGxlbl9zIC0gbGVuX3N1ZiBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gbGVuX3N1ZiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHVuc2FmZV9nZXQgcyAoZGlmZiArIGkpIDw+IHVuc2FmZV9nZXQgc3VmZml4IGkgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXV4IChpICsgMSlcbiAgaW4gZGlmZiA+PSAwICYmIGF1eCAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlYyBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIHJpbmRleF9yZWMgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlY19vcHQgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSByaW5kZXhfcmVjX29wdCBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJjb250YWluc19mcm9tIHMgaSBjID1cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5yY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChyaW5kZXhfcmVjIHMgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbnR5cGUgdCA9IGJ5dGVzXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2wgPSBcImNhbWxfYnl0ZXNfZXF1YWxcIiBbQEBub2FsbG9jXVxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHNwbGl0X29uX2NoYXIgc2VwIHMgPVxuICBsZXQgciA9IHJlZiBbXSBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHMpIGluXG4gIGZvciBpID0gbGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgaWYgdW5zYWZlX2dldCBzIGkgPSBzZXAgdGhlbiBiZWdpblxuICAgICAgciA6PSBzdWIgcyAoaSArIDEpICghaiAtIGkgLSAxKSA6OiAhcjtcbiAgICAgIGogOj0gaVxuICAgIGVuZFxuICBkb25lO1xuICBzdWIgcyAwICFqIDo6ICFyXG5cbigqIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGltcGxlbWVudGVkIHZpYSBvdGhlciBkZXByZWNhdGVkIGZ1bmN0aW9ucyAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubGV0IHVwcGVyY2FzZSBzID0gbWFwIENoYXIudXBwZXJjYXNlIHNcbmxldCBsb3dlcmNhc2UgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZSBzXG5cbmxldCBjYXBpdGFsaXplIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2Ugc1xubGV0IHVuY2FwaXRhbGl6ZSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlIHNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgcyA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPSBsZW5ndGggcyB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IGdldCBzIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGxldCBidWYgPSByZWYgKG1ha2UgMjU2ICdcXDAwMCcpIGluXG4gIGxldCByZXNpemUgKCkgPVxuICAgICgqIHJlc2l6ZSAqKVxuICAgIGxldCBuZXdfbGVuID0gSW50Lm1pbiAoMiAqIGxlbmd0aCAhYnVmKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICBpZiBsZW5ndGggIWJ1ZiA9IG5ld19sZW4gdGhlbiBmYWlsd2l0aCBcIkJ5dGVzLm9mX3NlcTogY2Fubm90IGdyb3cgYnl0ZXNcIjtcbiAgICBsZXQgbmV3X2J1ZiA9IG1ha2UgbmV3X2xlbiAnXFwwMDAnIGluXG4gICAgYmxpdCAhYnVmIDAgbmV3X2J1ZiAwICFuO1xuICAgIGJ1ZiA6PSBuZXdfYnVmXG4gIGluXG4gIFNlcS5pdGVyXG4gICAgKGZ1biBjIC0+XG4gICAgICAgaWYgIW4gPSBsZW5ndGggIWJ1ZiB0aGVuIHJlc2l6ZSgpO1xuICAgICAgIHNldCAhYnVmICFuIGM7XG4gICAgICAgaW5jciBuKVxuICAgIGk7XG4gIHN1YiAhYnVmIDAgIW5cblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuKCogVGhlIGdldF8gZnVuY3Rpb25zIGFyZSBhbGwgZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcblxuZXh0ZXJuYWwgdW5zYWZlX2dldF91aW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9nZXRfdWludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfYnl0ZXNfZ2V0MTZ1XCJcbmV4dGVybmFsIGdldF91aW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBnZXRfdWludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfYnl0ZXNfZ2V0MTZcIlxuZXh0ZXJuYWwgZ2V0X2ludDMyX25lIDogYnl0ZXMgLT4gaW50IC0+IGludDMyID0gXCIlY2FtbF9ieXRlc19nZXQzMlwiXG5leHRlcm5hbCBnZXRfaW50NjRfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgPSBcIiVjYW1sX2J5dGVzX2dldDY0XCJcblxuZXh0ZXJuYWwgdW5zYWZlX3NldF91aW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCIlY2FtbF9ieXRlc19zZXQxNnVcIlxuZXh0ZXJuYWwgc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBzZXRfaW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2XCJcbmV4dGVybmFsIHNldF9pbnQzMl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQzMlwiXG5leHRlcm5hbCBzZXRfaW50NjRfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjRcIlxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIlxuZXh0ZXJuYWwgc3dhcDMyIDogaW50MzIgLT4gaW50MzIgPSBcIiVic3dhcF9pbnQzMlwiXG5leHRlcm5hbCBzd2FwNjQgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWJzd2FwX2ludDY0XCJcblxubGV0IHVuc2FmZV9nZXRfdWludDE2X2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gc3dhcDE2ICh1bnNhZmVfZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgdW5zYWZlX2dldF91aW50MTZfbmUgYiBpXG5cbmxldCB1bnNhZmVfZ2V0X3VpbnQxNl9iZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhblxuICB0aGVuIHVuc2FmZV9nZXRfdWludDE2X25lIGIgaVxuICBlbHNlIHN3YXAxNiAodW5zYWZlX2dldF91aW50MTZfbmUgYiBpKVxuXG5sZXQgZ2V0X2ludDggYiBpID1cbiAgKChnZXRfdWludDggYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDgpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDgpXG5cbmxldCBnZXRfdWludDE2X2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IChnZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSBnZXRfdWludDE2X25lIGIgaVxuXG5sZXQgZ2V0X3VpbnQxNl9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgKGdldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIGdldF91aW50MTZfbmUgYiBpXG5cbmxldCBnZXRfaW50MTZfbmUgYiBpID1cbiAgKChnZXRfdWludDE2X25lIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MTZfbGUgYiBpID1cbiAgKChnZXRfdWludDE2X2xlIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MTZfYmUgYiBpID1cbiAgKChnZXRfdWludDE2X2JlIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MzJfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgKGdldF9pbnQzMl9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDMyX25lIGIgaVxuXG5sZXQgZ2V0X2ludDMyX2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiAoZ2V0X2ludDMyX25lIGIgaSlcbiAgZWxzZSBnZXRfaW50MzJfbmUgYiBpXG5cbmxldCBnZXRfaW50NjRfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgKGdldF9pbnQ2NF9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDY0X25lIGIgaVxuXG5sZXQgZ2V0X2ludDY0X2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCAoZ2V0X2ludDY0X25lIGIgaSlcbiAgZWxzZSBnZXRfaW50NjRfbmUgYiBpXG5cbmxldCB1bnNhZmVfc2V0X3VpbnQxNl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gdW5zYWZlX3NldF91aW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSB1bnNhZmVfc2V0X3VpbnQxNl9uZSBiIGkgeFxuXG5sZXQgdW5zYWZlX3NldF91aW50MTZfYmUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhblxuICB0aGVuIHVuc2FmZV9zZXRfdWludDE2X25lIGIgaSB4IGVsc2VcbiAgdW5zYWZlX3NldF91aW50MTZfbmUgYiBpIChzd2FwMTYgeClcblxubGV0IHNldF9pbnQxNl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDE2X25lIGIgaSAoc3dhcDE2IHgpXG4gIGVsc2Ugc2V0X2ludDE2X25lIGIgaSB4XG5cbmxldCBzZXRfaW50MTZfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDMyX25lIGIgaSAoc3dhcDMyIHgpXG4gIGVsc2Ugc2V0X2ludDMyX25lIGIgaSB4XG5cbmxldCBzZXRfaW50MzJfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDY0X25lIGIgaSAoc3dhcDY0IHgpXG4gIGVsc2Ugc2V0X2ludDY0X25lIGIgaSB4XG5cbmxldCBzZXRfaW50NjRfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF91aW50OCA9IHNldF9pbnQ4XG5sZXQgc2V0X3VpbnQxNl9uZSA9IHNldF9pbnQxNl9uZVxubGV0IHNldF91aW50MTZfYmUgPSBzZXRfaW50MTZfYmVcbmxldCBzZXRfdWludDE2X2xlID0gc2V0X2ludDE2X2xlXG5cbigqIFVURiBjb2RlY3MgYW5kIHZhbGlkYXRpb25zICopXG5cbmxldCBkZWNfaW52YWxpZCA9IFVjaGFyLnV0Zl9kZWNvZGVfaW52YWxpZFxubGV0W0BpbmxpbmVdIGRlY19yZXQgbiB1ID0gVWNoYXIudXRmX2RlY29kZSBuIChVY2hhci51bnNhZmVfb2ZfaW50IHUpXG5cbigqIEluIGNhc2Ugb2YgZGVjb2RpbmcgZXJyb3IsIGlmIHdlIGVycm9yIG9uIHRoZSBmaXJzdCBieXRlLCB3ZVxuICAgY29uc3VtZSB0aGUgYnl0ZSwgb3RoZXJ3aXNlIHdlIGNvbnN1bWUgdGhlIFtuXSBieXRlcyBwcmVjZWVkaW5nXG4gICB0aGUgZXJyb3JpbmcgYnl0ZS5cblxuICAgVGhpcyBtZWFucyB0aGF0IGlmIGEgY2xpZW50IHVzZXMgZGVjb2RlcyB3aXRob3V0IGNhcmluZyBhYm91dFxuICAgdmFsaWRpdHkgaXQgbmF0dXJhbGx5IHJlcGxhY2UgYm9ndXMgZGF0YSB3aXRoIFVjaGFyLnJlcCBhY2NvcmRpbmdcbiAgIHRvIHRoZSBXSEFUV0cgRW5jb2Rpbmcgc3RhbmRhcmQuIE90aGVyIHNjaGVtZXMgYXJlIHBvc3NpYmxlIGJ5XG4gICBjb25zdWx0aW5nIHRoZSBudW1iZXIgb2YgdXNlZCBieXRlcyBvbiBpbnZhbGlkIGRlY29kZXMuIEZvciBtb3JlXG4gICBkZXRhaWxzIHNlZSBodHRwczovL2hzaXZvbmVuLmZpL2Jyb2tlbi11dGYtOC9cblxuICAgRm9yIHRoaXMgcmVhc29uIGluIFtnZXRfdXRmXzhfdWNoYXJdIHdlIGdyYWR1YWxseSBjaGVjayB0aGUgbmV4dFxuICAgYnl0ZSBpcyBhdmFpbGFibGUgcmF0aGVyIHRoYW4gZG9pbmcgaXQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlXG4gICBmaXJzdCBieXRlLiBDb250cmFzdCB3aXRoIFtpc192YWxpZF91dGZfOF0uICopXG5cbigqIFVURi04ICopXG5cbmxldFtAaW5saW5lXSBub3RfaW5feDgwX3RvX3hCRiBiID0gYiBsc3IgNiA8PiAwYjEwXG5sZXRbQGlubGluZV0gbm90X2luX3hBMF90b194QkYgYiA9IGIgbHNyIDUgPD4gMGIxMDFcbmxldFtAaW5saW5lXSBub3RfaW5feDgwX3RvX3g5RiBiID0gYiBsc3IgNSA8PiAwYjEwMFxubGV0W0BpbmxpbmVdIG5vdF9pbl94OTBfdG9feEJGIGIgPSBiIDwgMHg5MCB8fCAweEJGIDwgYlxubGV0W0BpbmxpbmVdIG5vdF9pbl94ODBfdG9feDhGIGIgPSBiIGxzciA0IDw+IDB4OFxuXG5sZXRbQGlubGluZV0gdXRmXzhfdWNoYXJfMiBiMCBiMSA9XG4gICgoYjAgbGFuZCAweDFGKSBsc2wgNikgbG9yXG4gICgoYjEgbGFuZCAweDNGKSlcblxubGV0W0BpbmxpbmVdIHV0Zl84X3VjaGFyXzMgYjAgYjEgYjIgPVxuICAoKGIwIGxhbmQgMHgwRikgbHNsIDEyKSBsb3JcbiAgKChiMSBsYW5kIDB4M0YpIGxzbCA2KSBsb3JcbiAgKChiMiBsYW5kIDB4M0YpKVxuXG5sZXRbQGlubGluZV0gdXRmXzhfdWNoYXJfNCBiMCBiMSBiMiBiMyA9XG4gICgoYjAgbGFuZCAweDA3KSBsc2wgMTgpIGxvclxuICAoKGIxIGxhbmQgMHgzRikgbHNsIDEyKSBsb3JcbiAgKChiMiBsYW5kIDB4M0YpIGxzbCA2KSBsb3JcbiAgKChiMyBsYW5kIDB4M0YpKVxuXG5sZXQgZ2V0X3V0Zl84X3VjaGFyIGIgaSA9XG4gIGxldCBiMCA9IGdldF91aW50OCBiIGkgaW4gKCogcmFpc2VzIGlmIFtpXSBpcyBub3QgYSB2YWxpZCBpbmRleC4gKilcbiAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDggaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBtYXRjaCBDaGFyLnVuc2FmZV9jaHIgYjAgd2l0aCAoKiBTZWUgVGhlIFVuaWNvZGUgU3RhbmRhcmQsIFRhYmxlIDMuNyAqKVxuICB8ICdcXHgwMCcgLi4gJ1xceDdGJyAtPiBkZWNfcmV0IDEgYjBcbiAgfCAnXFx4QzInIC4uICdcXHhERicgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgZGVjX3JldCAyICh1dGZfOF91Y2hhcl8yIGIwIGIxKVxuICB8ICdcXHhFMCcgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feEEwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBkZWNfcmV0IDMgKHV0Zl84X3VjaGFyXzMgYjAgYjEgYjIpXG4gIHwgJ1xceEUxJyAuLiAnXFx4RUMnIHwgJ1xceEVFJyAuLiAnXFx4RUYnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgZGVjX3JldCAzICh1dGZfOF91Y2hhcl8zIGIwIGIxIGIyKVxuICB8ICdcXHhFRCcgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3g5RiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBkZWNfcmV0IDMgKHV0Zl84X3VjaGFyXzMgYjAgYjEgYjIpXG4gIHwgJ1xceEYwJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94OTBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgbGV0IGIzID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMyB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgZGVjX3JldCA0ICh1dGZfOF91Y2hhcl80IGIwIGIxIGIyIGIzKVxuICB8ICdcXHhGMScgLi4gJ1xceEYzJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgbGV0IGIzID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMyB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgZGVjX3JldCA0ICh1dGZfOF91Y2hhcl80IGIwIGIxIGIyIGIzKVxuICB8ICdcXHhGNCcgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3g4RiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGxldCBiMyA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjMgdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGRlY19yZXQgNCAodXRmXzhfdWNoYXJfNCBiMCBiMSBiMiBiMylcbiAgfCBfIC0+IGRlY19pbnZhbGlkIDFcblxubGV0IHNldF91dGZfOF91Y2hhciBiIGkgdSA9XG4gIGxldCBzZXQgPSB1bnNhZmVfc2V0X3VpbnQ4IGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuICB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiAgfCB1IHdoZW4gdSA8PSAweDAwN0YgLT5cbiAgICAgIHNldF91aW50OCBiIGkgdTtcbiAgICAgIDFcbiAgfCB1IHdoZW4gdSA8PSAweDA3RkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDEgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIChzZXRfdWludDggYiBpICgweEMwIGxvciAodSBsc3IgNikpO1xuICAgICAgIHNldCBiIGxhc3QgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpO1xuICAgICAgIDIpXG4gIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAyIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICAoc2V0X3VpbnQ4IGIgaSAoMHhFMCBsb3IgKHUgbHNyIDEyKSk7XG4gICAgICAgc2V0IGIgKGkgKyAxKSAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKTtcbiAgICAgICBzZXQgYiBsYXN0ICgweDgwIGxvciAodSBsYW5kIDB4M0YpKTtcbiAgICAgICAzKVxuICB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICAoc2V0X3VpbnQ4IGIgaSAoMHhGMCBsb3IgKHUgbHNyIDE4KSk7XG4gICAgICAgc2V0IGIgKGkgKyAxKSAoMHg4MCBsb3IgKCh1IGxzciAxMikgbGFuZCAweDNGKSk7XG4gICAgICAgc2V0IGIgKGkgKyAyKSAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKTtcbiAgICAgICBzZXQgYiBsYXN0ICgweDgwIGxvciAodSBsYW5kIDB4M0YpKTtcbiAgICAgICA0KVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBpc192YWxpZF91dGZfOCBiID1cbiAgbGV0IHJlYyBsb29wIG1heCBiIGkgPVxuICAgIGlmIGkgPiBtYXggdGhlbiB0cnVlIGVsc2VcbiAgICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50OCBpblxuICAgIG1hdGNoIENoYXIudW5zYWZlX2NociAoZ2V0IGIgaSkgd2l0aFxuICAgIHwgJ1xceDAwJyAuLiAnXFx4N0YnIC0+IGxvb3AgbWF4IGIgKGkgKyAxKVxuICAgIHwgJ1xceEMyJyAuLiAnXFx4REYnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDEgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEUwJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAyIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3hBMF90b194QkYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RTEnIC4uICdcXHhFQycgfCAnXFx4RUUnIC4uICdcXHhFRicgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMiBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEVEJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAyIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194OUYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RjAnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDkwX3RvX3hCRiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMikpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RjEnIC4uICdcXHhGMycgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAyKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhGNCcgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feDhGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAyKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8IF8gLT4gZmFsc2VcbiAgaW5cbiAgbG9vcCAobGVuZ3RoIGIgLSAxKSBiIDBcblxuKCogVVRGLTE2QkUgKilcblxubGV0IGdldF91dGZfMTZiZV91Y2hhciBiIGkgPVxuICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50MTZfYmUgaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBpZiBpIDwgMCB8fCBpID4gbWF4IHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgZWxzZVxuICBpZiBpID0gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gIG1hdGNoIGdldCBiIGkgd2l0aFxuICB8IHUgd2hlbiB1IDwgMHhEODAwIHx8IHUgPiAweERGRkYgLT4gZGVjX3JldCAyIHVcbiAgfCB1IHdoZW4gdSA+IDB4REJGRiAtPiBkZWNfaW52YWxpZCAyXG4gIHwgaGkgLT4gKCogY29tYmluZSBbaGldIHdpdGggYSBsb3cgc3Vycm9nYXRlICopXG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgKG1heCAtIGkgKyAxKSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiAoaSArIDIpIHdpdGhcbiAgICAgIHwgdSB3aGVuIHUgPCAweERDMDAgfHwgdSA+IDB4REZGRiAtPiBkZWNfaW52YWxpZCAyICgqIHJldHJ5IGhlcmUgKilcbiAgICAgIHwgbG8gLT5cbiAgICAgICAgICBsZXQgdSA9ICgoKGhpIGxhbmQgMHgzRkYpIGxzbCAxMCkgbG9yIChsbyBsYW5kIDB4M0ZGKSkgKyAweDEwMDAwIGluXG4gICAgICAgICAgZGVjX3JldCA0IHVcblxubGV0IHNldF91dGZfMTZiZV91Y2hhciBiIGkgdSA9XG4gIGxldCBzZXQgPSB1bnNhZmVfc2V0X3VpbnQxNl9iZSBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBtYXggdGhlbiBpbnZhbGlkX2FyZyBcImluZGV4IG91dCBvZiBib3VuZHNcIiBlbHNlXG4gIG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiAgfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAxIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlIChzZXQgYiBpIHU7IDIpXG4gIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgICBsZXQgaGkgPSAoMHhEODAwIGxvciAodScgbHNyIDEwKSkgaW5cbiAgICAgIGxldCBsbyA9ICgweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSkgaW5cbiAgICAgIHNldCBiIGkgaGk7IHNldCBiIChpICsgMikgbG87IDRcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgaXNfdmFsaWRfdXRmXzE2YmUgYiA9XG4gIGxldCByZWMgbG9vcCBtYXggYiBpID1cbiAgICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50MTZfYmUgaW5cbiAgICBpZiBpID4gbWF4IHRoZW4gdHJ1ZSBlbHNlXG4gICAgaWYgaSA9IG1heCB0aGVuIGZhbHNlIGVsc2VcbiAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICB8IHUgd2hlbiB1IDwgMHhEODAwIHx8IHUgPiAweERGRkYgLT4gbG9vcCBtYXggYiAoaSArIDIpXG4gICAgfCB1IHdoZW4gdSA+IDB4REJGRiAtPiBmYWxzZVxuICAgIHwgX2hpIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIGZhbHNlIGVsc2VcbiAgICAgICAgbWF0Y2ggZ2V0IGIgKGkgKyAyKSB3aXRoXG4gICAgICAgIHwgdSB3aGVuIHUgPCAweERDMDAgfHwgdSA+IDB4REZGRiAtPiBmYWxzZVxuICAgICAgICB8IF9sbyAtPiBsb29wIG1heCBiIChpICsgNClcbiAgaW5cbiAgbG9vcCAobGVuZ3RoIGIgLSAxKSBiIDBcblxuKCogVVRGLTE2TEUgKilcblxubGV0IGdldF91dGZfMTZsZV91Y2hhciBiIGkgPVxuICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50MTZfbGUgaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBpZiBpIDwgMCB8fCBpID4gbWF4IHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgZWxzZVxuICBpZiBpID0gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gIG1hdGNoIGdldCBiIGkgd2l0aFxuICB8IHUgd2hlbiB1IDwgMHhEODAwIHx8IHUgPiAweERGRkYgLT4gZGVjX3JldCAyIHVcbiAgfCB1IHdoZW4gdSA+IDB4REJGRiAtPiBkZWNfaW52YWxpZCAyXG4gIHwgaGkgLT4gKCogY29tYmluZSBbaGldIHdpdGggYSBsb3cgc3Vycm9nYXRlICopXG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgKG1heCAtIGkgKyAxKSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiAoaSArIDIpIHdpdGhcbiAgICAgIHwgdSB3aGVuIHUgPCAweERDMDAgfHwgdSA+IDB4REZGRiAtPiBkZWNfaW52YWxpZCAyICgqIHJldHJ5IGhlcmUgKilcbiAgICAgIHwgbG8gLT5cbiAgICAgICAgICBsZXQgdSA9ICgoKGhpIGxhbmQgMHgzRkYpIGxzbCAxMCkgbG9yIChsbyBsYW5kIDB4M0ZGKSkgKyAweDEwMDAwIGluXG4gICAgICAgICAgZGVjX3JldCA0IHVcblxubGV0IHNldF91dGZfMTZsZV91Y2hhciBiIGkgdSA9XG4gIGxldCBzZXQgPSB1bnNhZmVfc2V0X3VpbnQxNl9sZSBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBtYXggdGhlbiBpbnZhbGlkX2FyZyBcImluZGV4IG91dCBvZiBib3VuZHNcIiBlbHNlXG4gIG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiAgfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAxIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlIChzZXQgYiBpIHU7IDIpXG4gIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgICBsZXQgaGkgPSAoMHhEODAwIGxvciAodScgbHNyIDEwKSkgaW5cbiAgICAgIGxldCBsbyA9ICgweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSkgaW5cbiAgICAgIHNldCBiIGkgaGk7IHNldCBiIChpICsgMikgbG87IDRcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgaXNfdmFsaWRfdXRmXzE2bGUgYiA9XG4gIGxldCByZWMgbG9vcCBtYXggYiBpID1cbiAgICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50MTZfbGUgaW5cbiAgICBpZiBpID4gbWF4IHRoZW4gdHJ1ZSBlbHNlXG4gICAgaWYgaSA9IG1heCB0aGVuIGZhbHNlIGVsc2VcbiAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICB8IHUgd2hlbiB1IDwgMHhEODAwIHx8IHUgPiAweERGRkYgLT4gbG9vcCBtYXggYiAoaSArIDIpXG4gICAgfCB1IHdoZW4gdSA+IDB4REJGRiAtPiBmYWxzZVxuICAgIHwgX2hpIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIGZhbHNlIGVsc2VcbiAgICAgICAgbWF0Y2ggZ2V0IGIgKGkgKyAyKSB3aXRoXG4gICAgICAgIHwgdSB3aGVuIHUgPCAweERDMDAgfHwgdSA+IDB4REZGRiAtPiBmYWxzZVxuICAgICAgICB8IF9sbyAtPiBsb29wIG1heCBiIChpICsgNClcbiAgaW5cbiAgbG9vcCAobGVuZ3RoIGIgLSAxKSBiIDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IEdhbGxpdW0sIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU3RyaW5nIG9wZXJhdGlvbnMsIGJhc2VkIG9uIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gYnl0ZXMubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlc3RyaW5nX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogc3RyaW5nIC0+IGludCAtPiAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbm1vZHVsZSBCID0gQnl0ZXNcblxubGV0IGJ0cyA9IEIudW5zYWZlX3RvX3N0cmluZ1xubGV0IGJvcyA9IEIudW5zYWZlX29mX3N0cmluZ1xuXG5sZXQgbWFrZSBuIGMgPVxuICBCLm1ha2UgbiBjIHw+IGJ0c1xubGV0IGluaXQgbiBmID1cbiAgQi5pbml0IG4gZiB8PiBidHNcbmxldCBlbXB0eSA9IFwiXCJcbmxldCBjb3B5IHMgPVxuICBCLmNvcHkgKGJvcyBzKSB8PiBidHNcbmxldCBvZl9ieXRlcyA9IEIudG9fc3RyaW5nXG5sZXQgdG9fYnl0ZXMgPSBCLm9mX3N0cmluZ1xubGV0IHN1YiBzIG9mcyBsZW4gPVxuICBCLnN1YiAoYm9zIHMpIG9mcyBsZW4gfD4gYnRzXG5sZXQgZmlsbCA9XG4gIEIuZmlsbFxubGV0IGJsaXQgPVxuICBCLmJsaXRfc3RyaW5nXG5cbmxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gXCJcIlxuICB8IGwgLT4gbGV0IHNlcGxlbiA9IGxlbmd0aCBzZXAgaW4gYnRzIEBAXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoQi5jcmVhdGUgKHN1bV9sZW5ndGhzIDAgc2VwbGVuIGwpKVxuICAgICAgICAgICAgMCBzZXAgc2VwbGVuIGxcblxubGV0IGNhdCA9ICggXiApXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGl0ZXJpIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IHMgaSkgZG9uZVxuXG5sZXQgbWFwIGYgcyA9XG4gIEIubWFwIGYgKGJvcyBzKSB8PiBidHNcbmxldCBtYXBpIGYgcyA9XG4gIEIubWFwaSBmIChib3MgcykgfD4gYnRzXG5sZXQgZm9sZF9yaWdodCBmIHggYSA9XG4gIEIuZm9sZF9yaWdodCBmIChib3MgeCkgYVxubGV0IGZvbGRfbGVmdCBmIGEgeCA9XG4gIEIuZm9sZF9sZWZ0IGYgYSAoYm9zIHgpXG5sZXQgZXhpc3RzIGYgcyA9XG4gIEIuZXhpc3RzIGYgKGJvcyBzKVxubGV0IGZvcl9hbGwgZiBzID1cbiAgQi5mb3JfYWxsIGYgKGJvcyBzKVxuXG4oKiBCZXdhcmU6IHdlIGNhbm5vdCB1c2UgQi50cmltIG9yIEIuZXNjYXBlIGJlY2F1c2UgdGhleSBhbHdheXMgbWFrZSBhXG4gICBjb3B5LCBidXQgU3RyaW5nLm1saSBzcGVsbHMgb3V0IHNvbWUgY2FzZXMgd2hlcmUgd2UgYXJlIG5vdCBhbGxvd2VkXG4gICB0byBtYWtlIGEgY29weS4gKilcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBpZiBzID0gXCJcIiB0aGVuIHNcbiAgZWxzZSBpZiBpc19zcGFjZSAodW5zYWZlX2dldCBzIDApIHx8IGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgKGxlbmd0aCBzIC0gMSkpXG4gICAgdGhlbiBidHMgKEIudHJpbSAoYm9zIHMpKVxuICBlbHNlIHNcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCByZWMgZXNjYXBlX2lmX25lZWRlZCBzIG4gaSA9XG4gICAgaWYgaSA+PSBuIHRoZW4gcyBlbHNlXG4gICAgICBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXDAwMCcuLidcXDAzMScgfCAnXFwxMjcnLi4gJ1xcMjU1JyAtPlxuICAgICAgICAgIGJ0cyAoQi5lc2NhcGVkIChib3MgcykpXG4gICAgICB8IF8gLT4gZXNjYXBlX2lmX25lZWRlZCBzIG4gKGkrMSlcbiAgaW5cbiAgZXNjYXBlX2lmX25lZWRlZCBzIChsZW5ndGggcykgMFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gICAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9XG4gIEIudXBwZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPVxuICBCLmxvd2VyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi51bmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHN0YXJ0c193aXRoIH5wcmVmaXggcyA9XG4gIGxldCBsZW5fcyA9IGxlbmd0aCBzXG4gIGFuZCBsZW5fcHJlID0gbGVuZ3RoIHByZWZpeCBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gbGVuX3ByZSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHVuc2FmZV9nZXQgcyBpIDw+IHVuc2FmZV9nZXQgcHJlZml4IGkgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXV4IChpICsgMSlcbiAgaW4gbGVuX3MgPj0gbGVuX3ByZSAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgZW5kc193aXRoIH5zdWZmaXggcyA9XG4gIGxldCBsZW5fcyA9IGxlbmd0aCBzXG4gIGFuZCBsZW5fc3VmID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBsZXQgZGlmZiA9IGxlbl9zIC0gbGVuX3N1ZiBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gbGVuX3N1ZiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHVuc2FmZV9nZXQgcyAoZGlmZiArIGkpIDw+IHVuc2FmZV9nZXQgc3VmZml4IGkgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXV4IChpICsgMSlcbiAgaW4gZGlmZiA+PSAwICYmIGF1eCAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBzcGxpdF9vbl9jaGFyIHNlcCBzID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCBzKSBpblxuICBmb3IgaSA9IGxlbmd0aCBzIC0gMSBkb3dudG8gMCBkb1xuICAgIGlmIHVuc2FmZV9nZXQgcyBpID0gc2VwIHRoZW4gYmVnaW5cbiAgICAgIHIgOj0gc3ViIHMgKGkgKyAxKSAoIWogLSBpIC0gMSkgOjogIXI7XG4gICAgICBqIDo9IGlcbiAgICBlbmRcbiAgZG9uZTtcbiAgc3ViIHMgMCAhaiA6OiAhclxuXG4oKiBEZXByZWNhdGVkIGZ1bmN0aW9ucyBpbXBsZW1lbnRlZCB2aWEgb3RoZXIgZGVwcmVjYXRlZCBmdW5jdGlvbnMgKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmxldCB1cHBlcmNhc2UgcyA9XG4gIEIudXBwZXJjYXNlIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlIHMgPVxuICBCLmxvd2VyY2FzZSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemUgcyA9XG4gIEIuY2FwaXRhbGl6ZSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZSBzID1cbiAgQi51bmNhcGl0YWxpemUgKGJvcyBzKSB8PiBidHNcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sID0gXCJjYW1sX3N0cmluZ19lcXVhbFwiIFtAQG5vYWxsb2NdXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9IGJvcyBzIHw+IEIudG9fc2VxXG5cbmxldCB0b19zZXFpIHMgPSBib3MgcyB8PiBCLnRvX3NlcWlcblxubGV0IG9mX3NlcSBnID0gQi5vZl9zZXEgZyB8PiBidHNcblxuKCogVVRGIGRlY29kZXJzIGFuZCB2YWxpZGF0b3JzICopXG5cbmxldCBnZXRfdXRmXzhfdWNoYXIgcyBpID0gQi5nZXRfdXRmXzhfdWNoYXIgKGJvcyBzKSBpXG5sZXQgaXNfdmFsaWRfdXRmXzggcyA9IEIuaXNfdmFsaWRfdXRmXzggKGJvcyBzKVxuXG5sZXQgZ2V0X3V0Zl8xNmJlX3VjaGFyIHMgaSA9IEIuZ2V0X3V0Zl8xNmJlX3VjaGFyIChib3MgcykgaVxubGV0IGlzX3ZhbGlkX3V0Zl8xNmJlIHMgPSBCLmlzX3ZhbGlkX3V0Zl8xNmJlIChib3MgcylcblxubGV0IGdldF91dGZfMTZsZV91Y2hhciBzIGkgPSBCLmdldF91dGZfMTZsZV91Y2hhciAoYm9zIHMpIGlcbmxldCBpc192YWxpZF91dGZfMTZsZSBzID0gQi5pc192YWxpZF91dGZfMTZsZSAoYm9zIHMpXG5cbigqKiB7NiBCaW5hcnkgZW5jb2RpbmcvZGVjb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbmV4dGVybmFsIGdldF91aW50OCA6IHN0cmluZyAtPiBpbnQgLT4gaW50ID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbmV4dGVybmFsIGdldF91aW50MTZfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfc3RyaW5nX2dldDE2XCJcbmV4dGVybmFsIGdldF9pbnQzMl9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50MzIgPSBcIiVjYW1sX3N0cmluZ19nZXQzMlwiXG5leHRlcm5hbCBnZXRfaW50NjRfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDY0ID0gXCIlY2FtbF9zdHJpbmdfZ2V0NjRcIlxuXG5sZXQgZ2V0X2ludDggcyBpID0gQi5nZXRfaW50OCAoYm9zIHMpIGlcbmxldCBnZXRfdWludDE2X2xlIHMgaSA9IEIuZ2V0X3VpbnQxNl9sZSAoYm9zIHMpIGlcbmxldCBnZXRfdWludDE2X2JlIHMgaSA9IEIuZ2V0X3VpbnQxNl9iZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MTZfbmUgcyBpID0gQi5nZXRfaW50MTZfbmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDE2X2xlIHMgaSA9IEIuZ2V0X2ludDE2X2xlIChib3MgcykgaVxubGV0IGdldF9pbnQxNl9iZSBzIGkgPSBCLmdldF9pbnQxNl9iZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MzJfbGUgcyBpID0gQi5nZXRfaW50MzJfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDMyX2JlIHMgaSA9IEIuZ2V0X2ludDMyX2JlIChib3MgcykgaVxubGV0IGdldF9pbnQ2NF9sZSBzIGkgPSBCLmdldF9pbnQ2NF9sZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50NjRfYmUgcyBpID0gQi5nZXRfaW50NjRfYmUgKGJvcyBzKSBpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IHVuaXQgPSAoKVxuXG5sZXQgZXF1YWwgKCkgKCkgPSB0cnVlXG5sZXQgY29tcGFyZSAoKSAoKSA9IDBcbmxldCB0b19zdHJpbmcgKCkgPSBcIigpXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBleHRlcm5fZmxhZ3MgPVxuICAgIE5vX3NoYXJpbmdcbiAgfCBDbG9zdXJlc1xuICB8IENvbXBhdF8zMlxuKCogbm90ZTogdGhpcyB0eXBlIGRlZmluaXRpb24gaXMgdXNlZCBpbiAncnVudGltZS9kZWJ1Z2dlci5jJyAqKVxuXG5leHRlcm5hbCB0b19jaGFubmVsOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiB1bml0XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmV4dGVybmFsIHRvX2J5dGVzOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBieXRlc1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlc1wiXG5leHRlcm5hbCB0b19zdHJpbmc6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHN0cmluZ1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmdcIlxuZXh0ZXJuYWwgdG9fYnVmZmVyX3Vuc2FmZTpcbiAgICAgIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gaW50XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclwiXG5cbmxldCB0b19idWZmZXIgYnVmZiBvZnMgbGVuIHYgZmxhZ3MgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwudG9fYnVmZmVyOiBzdWJzdHJpbmcgb3V0IG9mIGJvdW5kc1wiXG4gIGVsc2UgdG9fYnVmZmVyX3Vuc2FmZSBidWZmIG9mcyBsZW4gdiBmbGFnc1xuXG4oKiBUaGUgZnVuY3Rpb25zIGJlbG93IHVzZSBieXRlIHNlcXVlbmNlcyBhcyBpbnB1dCwgbmV2ZXIgdXNpbmcgYW55XG4gICBtdXRhdGlvbi4gSXQgbWFrZXMgc2Vuc2UgdG8gdXNlIG5vbi1tdXRhdGVkIFtieXRlc10gcmF0aGVyIHRoYW5cbiAgIFtzdHJpbmddLCBiZWNhdXNlIHdlIHJlYWxseSB3b3JrIHdpdGggc2VxdWVuY2VzIG9mIGJ5dGVzLCBub3RcbiAgIGEgdGV4dCByZXByZXNlbnRhdGlvbi5cbiopXG5cbmV4dGVybmFsIGZyb21fY2hhbm5lbDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBmcm9tX2J5dGVzX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXNcIlxuZXh0ZXJuYWwgZGF0YV9zaXplX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZVwiXG5cbmxldCBoZWFkZXJfc2l6ZSA9IDIwXG5sZXQgZGF0YV9zaXplIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmRhdGFfc2l6ZVwiXG4gIGVsc2UgZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mc1xubGV0IHRvdGFsX3NpemUgYnVmZiBvZnMgPSBoZWFkZXJfc2l6ZSArIGRhdGFfc2l6ZSBidWZmIG9mc1xuXG5sZXQgZnJvbV9ieXRlcyBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCBsZW4gPSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzIGluXG4gICAgaWYgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSAoaGVhZGVyX3NpemUgKyBsZW4pXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gICAgZWxzZSBmcm9tX2J5dGVzX3Vuc2FmZSBidWZmIG9mc1xuICBlbmRcblxubGV0IGZyb21fc3RyaW5nIGJ1ZmYgb2ZzID1cbiAgKCogQnl0ZXMudW5zYWZlX29mX3N0cmluZyBpcyBzYWZlIGhlcmUsIGFzIHRoZSBwcm9kdWNlZCBieXRlXG4gICAgIHNlcXVlbmNlIGlzIG5ldmVyIG11dGF0ZWQgKilcbiAgZnJvbV9ieXRlcyAoQnl0ZXMudW5zYWZlX29mX3N0cmluZyBidWZmKSBvZnNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIGFycmF5cy4gKilcbnR5cGUgJ2EgdCA9ICdhIGFycmF5XG5cbigqIEFycmF5IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogJ2EgYXJyYXkgLT4gaW50ID0gXCIlYXJyYXlfbGVuZ3RoXCJcbmV4dGVybmFsIGdldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3NhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9nZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSA9IFwiJWFycmF5X3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVhcnJheV91bnNhZmVfc2V0XCJcbmV4dGVybmFsIG1ha2U6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgY3JlYXRlOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbmV4dGVybmFsIHVuc2FmZV9zdWIgOiAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X3N1YlwiXG5leHRlcm5hbCBhcHBlbmRfcHJpbSA6ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X2FwcGVuZFwiXG5leHRlcm5hbCBjb25jYXQgOiAnYSBhcnJheSBsaXN0IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X2NvbmNhdFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6XG4gICdhIGFycmF5IC0+IGludCAtPiAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfYXJyYXlfYmxpdFwiXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6XG4gICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9maWxsXCJcbmV4dGVybmFsIGNyZWF0ZV9mbG9hdDogaW50IC0+IGZsb2F0IGFycmF5ID0gXCJjYW1sX21ha2VfZmxvYXRfdmVjdFwiXG5sZXQgbWFrZV9mbG9hdCA9IGNyZWF0ZV9mbG9hdFxuXG5tb2R1bGUgRmxvYXRhcnJheSA9IHN0cnVjdFxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gZmxvYXRhcnJheSA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IGZsb2F0YXJyYXkgLT4gaW50ID0gXCIlZmxvYXRhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBnZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV9zYWZlX3NldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0XG4gICAgICA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5lbmRcblxubGV0IGluaXQgbCBmID1cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2VcbiAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmluaXRcIlxuICAoKiBTZWUgIzY1NzUuIFdlIGNvdWxkIGFsc28gY2hlY2sgZm9yIG1heGltdW0gYXJyYXkgc2l6ZSwgYnV0IHRoaXMgZGVwZW5kc1xuICAgICBvbiB3aGV0aGVyIHdlIGNyZWF0ZSBhIGZsb2F0IGFycmF5IG9yIGEgcmVndWxhciBvbmUuLi4gKilcbiAgZWxzZVxuICAgbGV0IHJlcyA9IGNyZWF0ZSBsIChmIDApIGluXG4gICBmb3IgaSA9IDEgdG8gcHJlZCBsIGRvXG4gICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgIGRvbmU7XG4gICByZXNcblxubGV0IG1ha2VfbWF0cml4IHN4IHN5IGluaXQgPVxuICBsZXQgcmVzID0gY3JlYXRlIHN4IFt8fF0gaW5cbiAgZm9yIHggPSAwIHRvIHByZWQgc3ggZG9cbiAgICB1bnNhZmVfc2V0IHJlcyB4IChjcmVhdGUgc3kgaW5pdClcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBjcmVhdGVfbWF0cml4ID0gbWFrZV9tYXRyaXhcblxubGV0IGNvcHkgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW4gaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgdW5zYWZlX3N1YiBhIDAgbFxuXG5sZXQgYXBwZW5kIGExIGEyID1cbiAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gIGlmIGwxID0gMCB0aGVuIGNvcHkgYTJcbiAgZWxzZSBpZiBsZW5ndGggYTIgPSAwIHRoZW4gdW5zYWZlX3N1YiBhMSAwIGwxXG4gIGVsc2UgYXBwZW5kX3ByaW0gYTEgYTJcblxubGV0IHN1YiBhIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LnN1YlwiXG4gIGVsc2UgdW5zYWZlX3N1YiBhIG9mcyBsZW5cblxubGV0IGZpbGwgYSBvZnMgbGVuIHYgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZpbGxcIlxuICBlbHNlIHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2XG5cbmxldCBibGl0IGExIG9mczEgYTIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggYTEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIGEyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuXG5cbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgaXRlcjIgZiBhIGIgPVxuICBpZiBsZW5ndGggYSA8PiBsZW5ndGggYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSBkb25lXG5cbmxldCBtYXAgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcDIgZiBhIGIgPVxuICBsZXQgbGEgPSBsZW5ndGggYSBpblxuICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2UgYmVnaW5cbiAgICBpZiBsYSA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIChmICh1bnNhZmVfZ2V0IGEgMCkgKHVuc2FmZV9nZXQgYiAwKSkgaW5cbiAgICAgIGZvciBpID0gMSB0byBsYSAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcbiAgZW5kXG5cbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IG1hcGkgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYgMCAodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHRvX2xpc3QgYSA9XG4gIGxldCByZWMgdG9saXN0IGkgcmVzID1cbiAgICBpZiBpIDwgMCB0aGVuIHJlcyBlbHNlIHRvbGlzdCAoaSAtIDEpICh1bnNhZmVfZ2V0IGEgaSA6OiByZXMpIGluXG4gIHRvbGlzdCAobGVuZ3RoIGEgLSAxKSBbXVxuXG4oKiBDYW5ub3QgdXNlIExpc3QubGVuZ3RoIGhlcmUgYmVjYXVzZSB0aGUgTGlzdCBtb2R1bGUgZGVwZW5kcyBvbiBBcnJheS4gKilcbmxldCByZWMgbGlzdF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjdVxuICB8IF86OnQgLT4gbGlzdF9sZW5ndGggKHN1Y2MgYWNjdSkgdFxuXG5sZXQgb2ZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgYSA9IGNyZWF0ZSAobGlzdF9sZW5ndGggMCBsKSBoZCBpblxuICAgICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICAgIFtdIC0+IGFcbiAgICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGkrMSkgdGwgaW5cbiAgICAgIGZpbGwgMSB0bFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfbGVmdF9tYXAgZiBhY2MgaW5wdXRfYXJyYXkgPVxuICBsZXQgbGVuID0gbGVuZ3RoIGlucHV0X2FycmF5IGluXG4gIGlmIGxlbiA9IDAgdGhlbiAoYWNjLCBbfHxdKSBlbHNlIGJlZ2luXG4gICAgbGV0IGFjYywgZWx0ID0gZiBhY2MgKHVuc2FmZV9nZXQgaW5wdXRfYXJyYXkgMCkgaW5cbiAgICBsZXQgb3V0cHV0X2FycmF5ID0gY3JlYXRlIGxlbiBlbHQgaW5cbiAgICBsZXQgYWNjID0gcmVmIGFjYyBpblxuICAgIGZvciBpID0gMSB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgYWNjJywgZWx0ID0gZiAhYWNjICh1bnNhZmVfZ2V0IGlucHV0X2FycmF5IGkpIGluXG4gICAgICBhY2MgOj0gYWNjJztcbiAgICAgIHVuc2FmZV9zZXQgb3V0cHV0X2FycmF5IGkgZWx0O1xuICAgIGRvbmU7XG4gICAgIWFjYywgb3V0cHV0X2FycmF5XG4gIGVuZFxuXG5sZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICBkb25lO1xuICAhclxuXG5sZXQgZXhpc3RzIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsMiBwIGwxIGwyID1cbiAgbGV0IG4xID0gbGVuZ3RoIGwxXG4gIGFuZCBuMiA9IGxlbmd0aCBsMiBpblxuICBpZiBuMSA8PiBuMiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZm9yX2FsbDJcIlxuICBlbHNlIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbjEgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGwxIGkpICh1bnNhZmVfZ2V0IGwyIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCBleGlzdHMyIHAgbDEgbDIgPVxuICBsZXQgbjEgPSBsZW5ndGggbDFcbiAgYW5kIG4yID0gbGVuZ3RoIGwyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5leGlzdHMyXCJcbiAgZWxzZSBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4xIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgbDEgaSkgKHVuc2FmZV9nZXQgbDIgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW1xIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHggPT0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmaW5kX29wdCBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIE5vbmVcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBpZiBwIHggdGhlbiBTb21lIHhcbiAgICAgIGVsc2UgbG9vcCAoc3VjYyBpKVxuICBpblxuICBsb29wIDBcblxubGV0IGZpbmRfbWFwIGYgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gTm9uZVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGYgKHVuc2FmZV9nZXQgYSBpKSB3aXRoXG4gICAgICB8IE5vbmUgLT4gbG9vcCAoc3VjYyBpKVxuICAgICAgfCBTb21lIF8gYXMgciAtPiByXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgc3BsaXQgeCA9XG4gIGlmIHggPSBbfHxdIHRoZW4gW3x8XSwgW3x8XVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IGEwLCBiMCA9IHVuc2FmZV9nZXQgeCAwIGluXG4gICAgbGV0IG4gPSBsZW5ndGggeCBpblxuICAgIGxldCBhID0gY3JlYXRlIG4gYTAgaW5cbiAgICBsZXQgYiA9IGNyZWF0ZSBuIGIwIGluXG4gICAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgICBsZXQgYWksIGJpID0gdW5zYWZlX2dldCB4IGkgaW5cbiAgICAgIHVuc2FmZV9zZXQgYSBpIGFpO1xuICAgICAgdW5zYWZlX3NldCBiIGkgYmlcbiAgICBkb25lO1xuICAgIGEsIGJcbiAgZW5kXG5cbmxldCBjb21iaW5lIGEgYiA9XG4gIGxldCBuYSA9IGxlbmd0aCBhIGluXG4gIGxldCBuYiA9IGxlbmd0aCBiIGluXG4gIGlmIG5hIDw+IG5iIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5jb21iaW5lXCI7XG4gIGlmIG5hID0gMCB0aGVuIFt8fF1cbiAgZWxzZSBiZWdpblxuICAgIGxldCB4ID0gY3JlYXRlIG5hICh1bnNhZmVfZ2V0IGEgMCwgdW5zYWZlX2dldCBiIDApIGluXG4gICAgZm9yIGkgPSAxIHRvIG5hIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCB4IGkgKHVuc2FmZV9nZXQgYSBpLCB1bnNhZmVfZ2V0IGIgaSlcbiAgICBkb25lO1xuICAgIHhcbiAgZW5kXG5cbmV4Y2VwdGlvbiBCb3R0b20gb2YgaW50XG5sZXQgc29ydCBjbXAgYSA9XG4gIGxldCBtYXhzb24gbCBpID1cbiAgICBsZXQgaTMxID0gaStpK2krMSBpblxuICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICBpZiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMCB0aGVuIHggOj0gaTMxKzE7XG4gICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICF4XG4gICAgZW5kIGVsc2VcbiAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgdGhlbiBpMzErMVxuICAgICAgZWxzZSBpZiBpMzEgPCBsIHRoZW4gaTMxIGVsc2UgcmFpc2UgKEJvdHRvbSBpKVxuICBpblxuICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgdHJpY2tsZWRvd24gbCBqIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gIGxldCByZWMgYnViYmxlZG93biBsIGkgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgIGJ1YmJsZWRvd24gbCBqXG4gIGluXG4gIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICBsZXQgcmVjIHRyaWNrbGV1cCBpIGUgPVxuICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgIGlmIGNtcCAoZ2V0IGEgZmF0aGVyKSBlIDwgMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gIGZvciBpID0gbCAtIDEgZG93bnRvIDIgZG9cbiAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgIHRyaWNrbGV1cCAoYnViYmxlIGkgMCkgZTtcbiAgZG9uZTtcbiAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuXG5sZXQgY3V0b2ZmID0gNVxubGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgbGV0IG1lcmdlIHNyYzFvZnMgc3JjMWxlbiBzcmMyIHNyYzJvZnMgc3JjMmxlbiBkc3QgZHN0b2ZzID1cbiAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgIGlmIGNtcCBzMSBzMiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgaWYgaTEgPCBzcmMxciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgc3JjMiBpMiBkc3QgKGQgKyAxKSAoc3JjMnIgLSBpMilcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgbGV0IGkyID0gaTIgKyAxIGluXG4gICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICBlbmRcbiAgICBpbiBsb29wIHNyYzFvZnMgKGdldCBhIHNyYzFvZnMpIHNyYzJvZnMgKGdldCBzcmMyIHNyYzJvZnMpIGRzdG9mcztcbiAgaW5cbiAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgd2hpbGUgKCFqID49IGRzdG9mcyAmJiBjbXAgKGdldCBkc3QgIWopIGUgPiAwKSBkb1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgZGVjciBqO1xuICAgICAgZG9uZTtcbiAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICBkb25lO1xuICBpblxuICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsZW4gLyAyIGluXG4gICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICBzb3J0dG8gc3Jjb2ZzIGEgKHNyY29mcyArIGwyKSBsMTtcbiAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgIGxldCBsMSA9IGwgLyAyIGluXG4gICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgbGV0IHQgPSBtYWtlIGwyIChnZXQgYSAwKSBpblxuICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgc29ydHRvIDAgYSBsMiBsMTtcbiAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICBlbmRcblxuXG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICBlbHNlIFNlcS5OaWxcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYSA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPCBsZW5ndGggYVxuICAgIHRoZW5cbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgb2ZfcmV2X2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGxlbiA9IGxpc3RfbGVuZ3RoIDAgbCBpblxuICAgICAgbGV0IGEgPSBjcmVhdGUgbGVuIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaS0xKSB0bFxuICAgICAgaW5cbiAgICAgIGZpbGwgKGxlbi0yKSB0bFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbCA9IFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIGkgaW5cbiAgb2ZfcmV2X2xpc3QgbFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICBOaWNvbGFzIE9qZWRhIEJhciwgTGV4aUZpICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBuZWcgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsIGFkZCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgc3ViIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCBtdWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsIGRpdiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgcmVtIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbWEgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbWFfZmxvYXRcIiBcImNhbWxfZm1hXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFicyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuXG5sZXQgemVybyA9IDAuXG5sZXQgb25lID0gMS5cbmxldCBtaW51c19vbmUgPSAtMS5cbmxldCBpbmZpbml0eSA9IFN0ZGxpYi5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IFN0ZGxpYi5uZWdfaW5maW5pdHlcbmxldCBuYW4gPSBTdGRsaWIubmFuXG5sZXQgaXNfZmluaXRlICh4OiBmbG9hdCkgPSB4IC0uIHggPSAwLlxubGV0IGlzX2luZmluaXRlICh4OiBmbG9hdCkgPSAxLiAvLiB4ID0gMC5cbmxldCBpc19uYW4gKHg6IGZsb2F0KSA9IHggPD4geFxuXG5sZXQgcGkgPSAweDEuOTIxZmI1NDQ0MmQxOHArMVxubGV0IG1heF9mbG9hdCA9IFN0ZGxpYi5tYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBTdGRsaWIubWluX2Zsb2F0XG5sZXQgZXBzaWxvbiA9IFN0ZGxpYi5lcHNpbG9uX2Zsb2F0XG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nX29wdCA9IFN0ZGxpYi5mbG9hdF9vZl9zdHJpbmdfb3B0XG5sZXQgdG9fc3RyaW5nID0gU3RkbGliLnN0cmluZ19vZl9mbG9hdFxudHlwZSBmcGNsYXNzID0gU3RkbGliLmZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHBvdyA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2JydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NicnRfZmxvYXRcIiBcImNhbWxfY2JydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAyIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwMl9mbG9hdFwiIFwiY2FtbF9leHAyXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzIgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cyX2Zsb2F0XCIgXCJjYW1sX2xvZzJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc2hfZmxvYXRcIiBcImNhbWxfYWNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luaF9mbG9hdFwiIFwiY2FtbF9hc2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5oX2Zsb2F0XCIgXCJjYW1sX2F0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGVyZiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2VyZl9mbG9hdFwiIFwiY2FtbF9lcmZcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXJmYyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2VyZmNfZmxvYXRcIiBcImNhbWxfZXJmY1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0cnVuYyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RydW5jX2Zsb2F0XCIgXCJjYW1sX3RydW5jXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHJvdW5kIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcm91bmRfZmxvYXRcIiBcImNhbWxfcm91bmRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IGlzX2ludGVnZXIgeCA9IHggPSB0cnVuYyB4ICYmIGlzX2Zpbml0ZSB4XG5cbmV4dGVybmFsIG5leHRfYWZ0ZXIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICA9IFwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXRcIiBcImNhbWxfbmV4dGFmdGVyXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IHN1Y2MgeCA9IG5leHRfYWZ0ZXIgeCBpbmZpbml0eVxubGV0IHByZWQgeCA9IG5leHRfYWZ0ZXIgeCBuZWdfaW5maW5pdHlcblxuZXh0ZXJuYWwgY29weV9zaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaWduX2JpdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBib29sXG4gID0gXCJjYW1sX3NpZ25iaXRfZmxvYXRcIiBcImNhbWxfc2lnbmJpdFwiIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG50eXBlIHQgPSBmbG9hdFxuZXh0ZXJuYWwgY29tcGFyZSA6IGZsb2F0IC0+IGZsb2F0IC0+IGludCA9IFwiJWNvbXBhcmVcIlxubGV0IGVxdWFsIHggeSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXRbQGlubGluZV0gbWluICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcbiAgZWxzZSBpZiBpc19uYW4geCB0aGVuIHggZWxzZSB5XG5cbmxldFtAaW5saW5lXSBtYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcblxubGV0W0BpbmxpbmVdIG1pbl9tYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggfHwgaXNfbmFuIHkgdGhlbiAobmFuLCBuYW4pXG4gIGVsc2UgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuICh4LCB5KSBlbHNlICh5LCB4KVxuXG5sZXRbQGlubGluZV0gbWluX251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSB4XG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgeVxuXG5sZXRbQGlubGluZV0gbWF4X251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSB5XG4gIGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgeFxuXG5sZXRbQGlubGluZV0gbWluX21heF9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggdGhlbiAoeSx5KVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4gKHgseClcbiAgZWxzZSBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW4gKHgseSkgZWxzZSAoeSx4KVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6IGludCAtPiBpbnQgLT4gaW50IC0+IGZsb2F0IC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfaGFzaFwiIFtAQG5vYWxsb2NdXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxuXG5tb2R1bGUgQXJyYXkgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSBmbG9hdGFycmF5XG5cbiAgZXh0ZXJuYWwgbGVuZ3RoIDogdCAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IHQgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IHQgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5cbiAgbGV0IHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBmb3IgaSA9IG9mcyB0byBvZnMgKyBsZW4gLSAxIGRvIHVuc2FmZV9zZXQgYSBpIHYgZG9uZVxuXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0OiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9XG4gICAgXCJjYW1sX2Zsb2F0YXJyYXlfYmxpdFwiIFtAQG5vYWxsb2NdXG5cbiAgbGV0IGNoZWNrIGEgb2ZzIGxlbiBtc2cgPVxuICAgIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IGxlbmd0aCBhIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIG1zZ1xuXG4gIGxldCBtYWtlIG4gdiA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBuIGluXG4gICAgdW5zYWZlX2ZpbGwgcmVzdWx0IDAgbiB2O1xuICAgIHJlc3VsdFxuXG4gIGxldCBpbml0IGwgZiA9XG4gICAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5LmluaXRcIlxuICAgIGVsc2VcbiAgICAgIGxldCByZXMgPSBjcmVhdGUgbCBpblxuICAgICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgICAgIGRvbmU7XG4gICAgICByZXNcblxuICBsZXQgYXBwZW5kIGExIGEyID1cbiAgICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgICBsZXQgbDIgPSBsZW5ndGggYTIgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChsMSArIGwyKSBpblxuICAgIHVuc2FmZV9ibGl0IGExIDAgcmVzdWx0IDAgbDE7XG4gICAgdW5zYWZlX2JsaXQgYTIgMCByZXN1bHQgbDEgbDI7XG4gICAgcmVzdWx0XG5cbiAgKCogbmV4dCAzIGZ1bmN0aW9uczogbW9kaWZpZWQgY29weSBvZiBjb2RlIGZyb20gc3RyaW5nLm1sICopXG4gIGxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID1cbiAgICBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5jb25jYXRcIlxuXG4gIGxldCByZWMgc3VtX2xlbmd0aHMgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgYWNjKSBhY2MpIHRsXG5cbiAgbGV0IGNvbmNhdCBsID1cbiAgICBsZXQgbGVuID0gc3VtX2xlbmd0aHMgMCBsIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgbCBpID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgKGkgPSBsZW4pXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGxldCBobGVuID0gbGVuZ3RoIGhkIGluXG4gICAgICAgIHVuc2FmZV9ibGl0IGhkIDAgcmVzdWx0IGkgaGxlbjtcbiAgICAgICAgbG9vcCB0bCAoaSArIGhsZW4pXG4gICAgaW5cbiAgICBsb29wIGwgMDtcbiAgICByZXN1bHRcblxuICBsZXQgc3ViIGEgb2ZzIGxlbiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuc3ViXCI7XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBhIG9mcyByZXN1bHQgMCBsZW47XG4gICAgcmVzdWx0XG5cbiAgbGV0IGNvcHkgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbCBpblxuICAgIHVuc2FmZV9ibGl0IGEgMCByZXN1bHQgMCBsO1xuICAgIHJlc3VsdFxuXG4gIGxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBjaGVjayBhIG9mcyBsZW4gXCJGbG9hdC5BcnJheS5maWxsXCI7XG4gICAgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxuICBsZXQgYmxpdCBzcmMgc29mcyBkc3QgZG9mcyBsZW4gPVxuICAgIGNoZWNrIHNyYyBzb2ZzIGxlbiBcIkZsb2F0LmFycmF5LmJsaXRcIjtcbiAgICBjaGVjayBkc3QgZG9mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgdW5zYWZlX2JsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuXG5cbiAgbGV0IHRvX2xpc3QgYSA9XG4gICAgTGlzdC5pbml0IChsZW5ndGggYSkgKHVuc2FmZV9nZXQgYSlcblxuICBsZXQgb2ZfbGlzdCBsID1cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICAgIGxldCByZWMgZmlsbCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IHJlc3VsdFxuICAgICAgfCBoIDo6IHQgLT4gdW5zYWZlX3NldCByZXN1bHQgaSBoOyBmaWxsIChpICsgMSkgdFxuICAgIGluXG4gICAgZmlsbCAwIGxcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXIgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyMiBmIGEgYiA9XG4gICAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2VcbiAgICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG4gIGxldCBtYXAgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICBsZXQgbWFwMiBmIGEgYiA9XG4gICAgbGV0IGxhID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICAgIGlmIGxhIDw+IGxiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkubWFwMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGEgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyaSBmIGEgPVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4gIGxldCBtYXBpIGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gICAgZG9uZTtcbiAgICAhclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICAgIGRvbmU7XG4gICAgIXJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGV4aXN0cyBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb3JfYWxsIHAgYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChpICsgMSlcbiAgICAgIGVsc2UgZmFsc2UgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG1lbSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sLCBidXQgc2xpZ2h0bHkgZGlmZmVyZW50ICopXG4gIGxldCBtZW1faWVlZSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHggPSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBleGNlcHRpb24gQm90dG9tIG9mIGludFxuICBsZXQgc29ydCBjbXAgYSA9XG4gICAgbGV0IG1heHNvbiBsIGkgPVxuICAgICAgbGV0IGkzMSA9IGkraStpKzEgaW5cbiAgICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgICAgaWYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDAgdGhlbiB4IDo9IGkzMSsxO1xuICAgICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICAgIXhcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgICB0aGVuIGkzMSsxXG4gICAgICAgIGVsc2UgaWYgaTMxIDwgbCB0aGVuIGkzMSBlbHNlIHJhaXNlIChCb3R0b20gaSlcbiAgICBpblxuICAgIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICAgIHRyaWNrbGVkb3duIGwgaiBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgICBsZXQgcmVjIGJ1YmJsZWRvd24gbCBpID1cbiAgICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICBidWJibGVkb3duIGwgalxuICAgIGluXG4gICAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gICAgbGV0IHJlYyB0cmlja2xldXAgaSBlID1cbiAgICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgICBpZiBjbXAgKGdldCBhIGZhdGhlcikgZSA8IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgICBmb3IgaSA9IGwgLSAxIGRvd250byAyIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgICB0cmlja2xldXAgKGJ1YmJsZSBpIDApIGU7XG4gICAgZG9uZTtcbiAgICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCwgZXhjZXB0IGZvciB0aGUgY2FsbCB0byBbY3JlYXRlXSAqKVxuICBsZXQgY3V0b2ZmID0gNVxuICBsZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICAgIGxldCBtZXJnZSBzcmMxb2ZzIHNyYzFsZW4gc3JjMiBzcmMyb2ZzIHNyYzJsZW4gZHN0IGRzdG9mcyA9XG4gICAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgICBpZiBjbXAgczEgczIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICAgIGlmIGkxIDwgc3JjMXIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IHNyYzIgaTIgZHN0IChkICsgMSkgKHNyYzJyIC0gaTIpXG4gICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICAgIGxldCBpMiA9IGkyICsgMSBpblxuICAgICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICAgIGVuZFxuICAgICAgaW4gbG9vcCBzcmMxb2ZzIChnZXQgYSBzcmMxb2ZzKSBzcmMyb2ZzIChnZXQgc3JjMiBzcmMyb2ZzKSBkc3RvZnM7XG4gICAgaW5cbiAgICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICAgIHdoaWxlICghaiA+PSBkc3RvZnMgJiYgY21wIChnZXQgZHN0ICFqKSBlID4gMCkgZG9cbiAgICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgICBkZWNyIGo7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICAgIGRvbmU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGwxID0gbGVuIC8gMiBpblxuICAgICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgICAgc29ydHRvIHNyY29mcyBhIChzcmNvZnMgKyBsMikgbDE7XG4gICAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsIC8gMiBpblxuICAgICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgICBsZXQgdCA9IGNyZWF0ZSBsMiBpblxuICAgICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICAgIHNvcnR0byAwIGEgbDIgbDE7XG4gICAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICAgIGVuZFxuXG4gIGxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgdG9fc2VxIGEgPVxuICAgIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgICB0aGVuXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IHRvX3NlcWkgYSA9XG4gICAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICAgIHRoZW5cbiAgICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9yZXZfbGlzdCBsID1cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCBhID0gY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgW10gLT4gYVxuICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGktMSkgdGxcbiAgICBpblxuICAgIGZpbGwgKGxlbi0xKSBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9zZXEgaSA9XG4gICAgbGV0IGwgPSBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBpIGluXG4gICAgb2ZfcmV2X2xpc3QgbFxuXG5cbiAgbGV0IG1hcF90b19hcnJheSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsID0gMCB0aGVuIFt8IHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gQXJyYXkubWFrZSBsIChmICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgICAgQXJyYXkudW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgbGV0IG1hcF9mcm9tX2FycmF5IGYgYSA9XG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIChBcnJheS51bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbmVuZFxuXG5tb2R1bGUgQXJyYXlMYWJlbHMgPSBBcnJheVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDMyXTogMzItYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDMyID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDMyIC0+IGludCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl90b19mbG9hdFwiIFwiY2FtbF9pbnQzMl90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgemVybyA9IDBsXG5sZXQgb25lID0gMWxcbmxldCBtaW51c19vbmUgPSAtMWxcbmxldCBzdWNjIG4gPSBhZGQgbiAxbFxubGV0IHByZWQgbiA9IHN1YiBuIDFsXG5sZXQgYWJzIG4gPSBpZiBuID49IDBsIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgbWluX2ludCA9IDB4ODAwMDAwMDBsXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZsXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFsKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbWF0Y2ggU3lzLndvcmRfc2l6ZSB3aXRoXG4gIHwgMzIgLT5cbiAgICAgIGxldCBtYXhfaW50ID0gb2ZfaW50IFN0ZGxpYi5tYXhfaW50IGluXG4gICAgICBmdW4gbiAtPlxuICAgICAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgICAgIFNvbWUgKHRvX2ludCBuKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgTm9uZVxuICB8IDY0IC0+XG4gICAgICAoKiBTbyB0aGF0IGl0IGNvbXBpbGVzIGluIDMyLWJpdCAqKVxuICAgICAgbGV0IG1hc2sgPSAweEZGRkYgbHNsIDE2IGxvciAweEZGRkYgaW5cbiAgICAgIGZ1biBuIC0+IFNvbWUgKHRvX2ludCBuIGxhbmQgbWFzaylcbiAgfCBfIC0+XG4gICAgICBhc3NlcnQgZmFsc2VcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZyA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMiA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxudHlwZSB0ID0gaW50MzJcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDY0XTogNjQtYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDY0IC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF90b19mbG9hdFwiIFwiY2FtbF9pbnQ2NF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyIDogaW50MzIgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnQzMlwiXG5leHRlcm5hbCB0b19pbnQzMiA6IGludDY0IC0+IGludDMyID0gXCIlaW50NjRfdG9faW50MzJcIlxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfbmF0aXZlaW50XCJcbmV4dGVybmFsIHRvX25hdGl2ZWludCA6IGludDY0IC0+IG5hdGl2ZWludCA9IFwiJWludDY0X3RvX25hdGl2ZWludFwiXG5cbmxldCB6ZXJvID0gMExcbmxldCBvbmUgPSAxTFxubGV0IG1pbnVzX29uZSA9IC0xTFxubGV0IHN1Y2MgbiA9IGFkZCBuIDFMXG5sZXQgcHJlZCBuID0gc3ViIG4gMUxcbmxldCBhYnMgbiA9IGlmIG4gPj0gMEwgdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBtaW5faW50ID0gMHg4MDAwMDAwMDAwMDAwMDAwTFxubGV0IG1heF9pbnQgPSAweDdGRkZGRkZGRkZGRkZGRkZMXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFMKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgZnVuIG4gLT5cbiAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgU29tZSAodG9faW50IG4pXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0ID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5cblxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbnR5cGUgdCA9IGludDY0XG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldCB1bnNpZ25lZF9jb21wYXJlIG4gbSA9XG4gIGNvbXBhcmUgKHN1YiBuIG1pbl9pbnQpIChzdWIgbSBtaW5faW50KVxuXG5sZXQgbWluIHggeSA6IHQgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgOiB0ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtOYXRpdmVpbnRdOiBwcm9jZXNzb3ItbmF0aXZlIGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZzogbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9uZWdcIlxuZXh0ZXJuYWwgYWRkOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hZGRcIlxuZXh0ZXJuYWwgc3ViOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9zdWJcIlxuZXh0ZXJuYWwgbXVsOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tdWxcIlxuZXh0ZXJuYWwgZGl2OiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9kaXZcIlxuZXh0ZXJuYWwgcmVtOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29yXCJcbmV4dGVybmFsIGxvZ3hvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWw6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzclwiXG5leHRlcm5hbCBvZl9pbnQ6IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludDogbmF0aXZlaW50IC0+IGludCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogbmF0aXZlaW50IC0+IGZsb2F0XG4gID0gXCJjYW1sX25hdGl2ZWludF90b19mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMjogaW50MzIgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyOiBuYXRpdmVpbnQgLT4gaW50MzIgPSBcIiVuYXRpdmVpbnRfdG9faW50MzJcIlxuXG5sZXQgemVybyA9IDBuXG5sZXQgb25lID0gMW5cbmxldCBtaW51c19vbmUgPSAtMW5cbmxldCBzdWNjIG4gPSBhZGQgbiAxblxubGV0IHByZWQgbiA9IHN1YiBuIDFuXG5sZXQgYWJzIG4gPSBpZiBuID49IDBuIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgc2l6ZSA9IFN5cy53b3JkX3NpemVcbmxldCBtaW5faW50ID0gc2hpZnRfbGVmdCAxbiAoc2l6ZSAtIDEpXG5sZXQgbWF4X2ludCA9IHN1YiBtaW5faW50IDFuXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFuKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgZnVuIG4gLT5cbiAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgU29tZSAodG9faW50IG4pXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZyA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmc6IHN0cmluZyAtPiBuYXRpdmVpbnQgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBuYXRpdmVpbnRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4ICopXG5cbnR5cGUgcG9zaXRpb24gPSB7XG4gIHBvc19mbmFtZSA6IHN0cmluZztcbiAgcG9zX2xudW0gOiBpbnQ7XG4gIHBvc19ib2wgOiBpbnQ7XG4gIHBvc19jbnVtIDogaW50O1xufVxuXG5sZXQgZHVtbXlfcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDA7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IC0xO1xufVxuXG50eXBlIGxleGJ1ZiA9XG4gIHsgcmVmaWxsX2J1ZmYgOiBsZXhidWYgLT4gdW5pdDtcbiAgICBtdXRhYmxlIGxleF9idWZmZXIgOiBieXRlcztcbiAgICBtdXRhYmxlIGxleF9idWZmZXJfbGVuIDogaW50O1xuICAgIG11dGFibGUgbGV4X2Fic19wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2N1cnJfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfYWN0aW9uIDogaW50O1xuICAgIG11dGFibGUgbGV4X2VvZl9yZWFjaGVkIDogYm9vbDtcbiAgICBtdXRhYmxlIGxleF9tZW0gOiBpbnQgYXJyYXk7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcCA6IHBvc2l0aW9uO1xuICAgIG11dGFibGUgbGV4X2N1cnJfcCA6IHBvc2l0aW9uO1xuICB9XG5cbnR5cGUgbGV4X3RhYmxlcyA9XG4gIHsgbGV4X2Jhc2U6IHN0cmluZztcbiAgICBsZXhfYmFja3Ryazogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0OiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrOiBzdHJpbmc7XG4gICAgbGV4X2Jhc2VfY29kZSA6IHN0cmluZztcbiAgICBsZXhfYmFja3Rya19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0X2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NvZGU6IHN0cmluZzt9XG5cbmV4dGVybmFsIGNfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludCA9IFwiY2FtbF9sZXhfZW5naW5lXCJcbmV4dGVybmFsIGNfbmV3X2VuZ2luZSA6IGxleF90YWJsZXMgLT4gaW50IC0+IGxleGJ1ZiAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9uZXdfbGV4X2VuZ2luZVwiXG5cbmxldCBlbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IG5ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX25ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiBpblxuICBpZiByZXN1bHQgPj0gMCAmJiBidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3MgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5sZXQgbGV4X3JlZmlsbCByZWFkX2Z1biBhdXhfYnVmZmVyIGxleGJ1ZiA9XG4gIGxldCByZWFkID1cbiAgICByZWFkX2Z1biBhdXhfYnVmZmVyIChCeXRlcy5sZW5ndGggYXV4X2J1ZmZlcikgaW5cbiAgbGV0IG4gPVxuICAgIGlmIHJlYWQgPiAwXG4gICAgdGhlbiByZWFkXG4gICAgZWxzZSAobGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlOyAwKSBpblxuICAoKiBDdXJyZW50IHN0YXRlIG9mIHRoZSBidWZmZXI6XG4gICAgICAgIDwtLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLT5cbiAgICAgICAgfCAganVuayB8ICAgICAgdmFsaWQgZGF0YSAgICAgfCAgIGp1bmsgICAgfFxuICAgICAgICBeICAgICAgIF4gICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICBeXG4gICAgICAgIDAgICAgc3RhcnRfcG9zICAgICAgICAgICAgIGJ1ZmZlcl9lbmQgICAgQnl0ZXMubGVuZ3RoIGJ1ZmZlclxuICAqKVxuICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gKyBuID4gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyIHRoZW4gYmVnaW5cbiAgICAoKiBUaGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgblxuICAgICAgIDw9IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlclxuICAgIHRoZW4gYmVnaW5cbiAgICAgICgqIEJ1dCB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgaWYgd2UgcmVjbGFpbSB0aGUganVuayBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICBvZiB0aGUgYnVmZmVyICopXG4gICAgICBCeXRlcy5ibGl0IGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICBsZXhidWYubGV4X2J1ZmZlciAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICgqIFdlIG11c3QgZ3JvdyB0aGUgYnVmZmVyLiAgRG91YmxpbmcgaXRzIHNpemUgd2lsbCBwcm92aWRlIGVub3VnaFxuICAgICAgICAgc3BhY2Ugc2luY2UgbiA8PSBTdHJpbmcubGVuZ3RoIGF1eF9idWZmZXIgPD0gU3RyaW5nLmxlbmd0aCBidWZmZXIuXG4gICAgICAgICBXYXRjaCBvdXQgZm9yIHN0cmluZyBsZW5ndGggb3ZlcmZsb3csIHRob3VnaC4gKilcbiAgICAgIGxldCBuZXdsZW4gPVxuICAgICAgICBJbnQubWluICgyICogQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgbiA+IG5ld2xlblxuICAgICAgdGhlbiBmYWlsd2l0aCBcIkxleGluZy5sZXhfcmVmaWxsOiBjYW5ub3QgZ3JvdyBidWZmZXJcIjtcbiAgICAgIGxldCBuZXdidWYgPSBCeXRlcy5jcmVhdGUgbmV3bGVuIGluXG4gICAgICAoKiBDb3B5IHRoZSB2YWxpZCBkYXRhIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIG5ld2J1ZiAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpO1xuICAgICAgbGV4YnVmLmxleF9idWZmZXIgPC0gbmV3YnVmXG4gICAgZW5kO1xuICAgICgqIFJlYWxsb2NhdGlvbiBvciBub3QsIHdlIGhhdmUgc2hpZnRlZCB0aGUgZGF0YSBsZWZ0IGJ5XG4gICAgICAgc3RhcnRfcG9zIGNoYXJhY3RlcnM7IHVwZGF0ZSB0aGUgcG9zaXRpb25zICopXG4gICAgbGV0IHMgPSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICAgIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBsZXhidWYubGV4X2Fic19wb3MgKyBzO1xuICAgIGxleGJ1Zi5sZXhfY3Vycl9wb3MgPC0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9zdGFydF9wb3MgPC0gMDtcbiAgICBsZXhidWYubGV4X2xhc3RfcG9zIDwtIGxleGJ1Zi5sZXhfbGFzdF9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBzIDtcbiAgICBsZXQgdCA9IGxleGJ1Zi5sZXhfbWVtIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LTEgZG9cbiAgICAgIGxldCB2ID0gdC4oaSkgaW5cbiAgICAgIGlmIHYgPj0gMCB0aGVuXG4gICAgICAgIHQuKGkpIDwtIHYtc1xuICAgIGRvbmVcbiAgZW5kO1xuICAoKiBUaGVyZSBpcyBub3cgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICBCeXRlcy5ibGl0IGF1eF9idWZmZXIgMCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X2J1ZmZlcl9sZW4gbjtcbiAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG5cblxubGV0IHplcm9fcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDE7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IDA7XG59XG5cbmxldCBmcm9tX2Z1bmN0aW9uID8od2l0aF9wb3NpdGlvbnMgPSB0cnVlKSBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBmcm9tX2NoYW5uZWwgP3dpdGhfcG9zaXRpb25zIGljID1cbiAgZnJvbV9mdW5jdGlvbiA/d2l0aF9wb3NpdGlvbnMgKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIHMgPVxuICB7IHJlZmlsbF9idWZmID0gKGZ1biBsZXhidWYgLT4gbGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMub2Zfc3RyaW5nIHM7ICgqIGhhdmUgdG8gbWFrZSBhIGNvcHkgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdW5zYWZlLXN0cmluZyBtb2RlICopXG4gICAgbGV4X2J1ZmZlcl9sZW4gPSBTdHJpbmcubGVuZ3RoIHM7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IHRydWU7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBzZXRfcG9zaXRpb24gbGV4YnVmIHBvc2l0aW9uID1cbiAgbGV4YnVmLmxleF9jdXJyX3AgIDwtIHtwb3NpdGlvbiB3aXRoIHBvc19mbmFtZSA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19mbmFtZX07XG4gIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBwb3NpdGlvbi5wb3NfY251bVxuXG5sZXQgc2V0X2ZpbGVuYW1lIGxleGJ1ZiBmbmFtZSA9XG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHtsZXhidWYubGV4X2N1cnJfcCB3aXRoIHBvc19mbmFtZSA9IGZuYW1lfVxuXG5sZXQgd2l0aF9wb3NpdGlvbnMgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zXG5cbmxldCBsZXhlbWUgbGV4YnVmID1cbiAgbGV0IGxlbiA9IGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGxlblxuXG5sZXQgc3ViX2xleGVtZSBsZXhidWYgaTEgaTIgPVxuICBsZXQgbGVuID0gaTItaTEgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW5cblxubGV0IHN1Yl9sZXhlbWVfb3B0IGxleGJ1ZiBpMSBpMiA9XG4gIGlmIGkxID49IDAgdGhlbiBiZWdpblxuICAgIGxldCBsZW4gPSBpMi1pMSBpblxuICAgIFNvbWUgKEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuKVxuICBlbmQgZWxzZSBiZWdpblxuICAgIE5vbmVcbiAgZW5kXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPSBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaVxuXG5sZXQgc3ViX2xleGVtZV9jaGFyX29wdCBsZXhidWYgaSA9XG4gIGlmIGkgPj0gMCB0aGVuXG4gICAgU29tZSAoQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGkpXG4gIGVsc2VcbiAgICBOb25lXG5cblxubGV0IGxleGVtZV9jaGFyIGxleGJ1ZiBpID1cbiAgQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIChsZXhidWYubGV4X3N0YXJ0X3BvcyArIGkpXG5cbmxldCBsZXhlbWVfc3RhcnQgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wLnBvc19jbnVtXG5sZXQgbGV4ZW1lX2VuZCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcC5wb3NfY251bVxuXG5sZXQgbGV4ZW1lX3N0YXJ0X3AgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wXG5sZXQgbGV4ZW1lX2VuZF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wXG5cbmxldCBuZXdfbGluZSBsZXhidWYgPVxuICBsZXQgbGNwID0gbGV4YnVmLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGV4YnVmLmxleF9jdXJyX3AgPC1cbiAgICAgIHsgbGNwIHdpdGhcbiAgICAgICAgcG9zX2xudW0gPSBsY3AucG9zX2xudW0gKyAxO1xuICAgICAgICBwb3NfYm9sID0gbGNwLnBvc19jbnVtO1xuICAgICAgfVxuXG5cblxuKCogRGlzY2FyZCBkYXRhIGxlZnQgaW4gbGV4ZXIgYnVmZmVyLiAqKVxuXG5sZXQgZmx1c2hfaW5wdXQgbGIgPVxuICBsYi5sZXhfY3Vycl9wb3MgPC0gMDtcbiAgbGIubGV4X2Fic19wb3MgPC0gMDtcbiAgbGV0IGxjcCA9IGxiLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGIubGV4X2N1cnJfcCA8LSB7emVyb19wb3Mgd2l0aCBwb3NfZm5hbWUgPSBsY3AucG9zX2ZuYW1lfTtcbiAgbGIubGV4X2J1ZmZlcl9sZW4gPC0gMDtcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHBhcnNpbmcgZW5naW5lICopXG5cbm9wZW4gTGV4aW5nXG5cbigqIEludGVybmFsIGludGVyZmFjZSB0byB0aGUgcGFyc2luZyBlbmdpbmUgKilcblxudHlwZSBwYXJzZXJfZW52ID1cbiAgeyBtdXRhYmxlIHNfc3RhY2sgOiBpbnQgYXJyYXk7ICAgICAgICAoKiBTdGF0ZXMgKilcbiAgICBtdXRhYmxlIHZfc3RhY2sgOiBPYmoudCBhcnJheTsgICAgICAoKiBTZW1hbnRpYyBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0X3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICgqIFN0YXJ0IHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3ltYl9lbmRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgICAoKiBFbmQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzdGFja3NpemUgOiBpbnQ7ICAgICAgICAgICAgKCogU2l6ZSBvZiB0aGUgc3RhY2tzICopXG4gICAgbXV0YWJsZSBzdGFja2Jhc2UgOiBpbnQ7ICAgICAgICAgICAgKCogQmFzZSBzcCBmb3IgY3VycmVudCBwYXJzZSAqKVxuICAgIG11dGFibGUgY3Vycl9jaGFyIDogaW50OyAgICAgICAgICAgICgqIExhc3QgdG9rZW4gcmVhZCAqKVxuICAgIG11dGFibGUgbHZhbCA6IE9iai50OyAgICAgICAgICAgICAgICgqIEl0cyBzZW1hbnRpYyBhdHRyaWJ1dGUgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnQgOiBwb3NpdGlvbjsgICAgICAoKiBTdGFydCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCopXG4gICAgbXV0YWJsZSBzeW1iX2VuZCA6IHBvc2l0aW9uOyAgICAgICAgKCogRW5kIHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sICopXG4gICAgbXV0YWJsZSBhc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogVGhlIHN0YWNrIHBvaW50ZXIgZm9yIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHJ1bGVfbGVuIDogaW50OyAgICAgICAgICAgICAoKiBOdW1iZXIgb2YgcmhzIGl0ZW1zIGluIHRoZSBydWxlICopXG4gICAgbXV0YWJsZSBydWxlX251bWJlciA6IGludDsgICAgICAgICAgKCogUnVsZSBudW1iZXIgdG8gcmVkdWNlIGJ5ICopXG4gICAgbXV0YWJsZSBzcCA6IGludDsgICAgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3AgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgc3RhdGUgOiBpbnQ7ICAgICAgICAgICAgICAgICgqIFNhdmVkIHN0YXRlIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIGVycmZsYWcgOiBpbnQgfSAgICAgICAgICAgICAoKiBTYXZlZCBlcnJvciBmbGFnIGZvciBwYXJzZV9lbmdpbmUgKilcbltAQHdhcm5pbmcgXCItdW51c2VkLWZpZWxkXCJdXG5cbnR5cGUgcGFyc2VfdGFibGVzID1cbiAgeyBhY3Rpb25zIDogKHBhcnNlcl9lbnYgLT4gT2JqLnQpIGFycmF5O1xuICAgIHRyYW5zbF9jb25zdCA6IGludCBhcnJheTtcbiAgICB0cmFuc2xfYmxvY2sgOiBpbnQgYXJyYXk7XG4gICAgbGhzIDogc3RyaW5nO1xuICAgIGxlbiA6IHN0cmluZztcbiAgICBkZWZyZWQgOiBzdHJpbmc7XG4gICAgZGdvdG8gOiBzdHJpbmc7XG4gICAgc2luZGV4IDogc3RyaW5nO1xuICAgIHJpbmRleCA6IHN0cmluZztcbiAgICBnaW5kZXggOiBzdHJpbmc7XG4gICAgdGFibGVzaXplIDogaW50O1xuICAgIHRhYmxlIDogc3RyaW5nO1xuICAgIGNoZWNrIDogc3RyaW5nO1xuICAgIGVycm9yX2Z1bmN0aW9uIDogc3RyaW5nIC0+IHVuaXQ7XG4gICAgbmFtZXNfY29uc3QgOiBzdHJpbmc7XG4gICAgbmFtZXNfYmxvY2sgOiBzdHJpbmcgfVxuXG5leGNlcHRpb24gWVlleGl0IG9mIE9iai50XG5leGNlcHRpb24gUGFyc2VfZXJyb3JcblxudHlwZSBwYXJzZXJfaW5wdXQgPVxuICAgIFN0YXJ0XG4gIHwgVG9rZW5fcmVhZFxuICB8IFN0YWNrc19ncm93bl8xXG4gIHwgU3RhY2tzX2dyb3duXzJcbiAgfCBTZW1hbnRpY19hY3Rpb25fY29tcHV0ZWRcbiAgfCBFcnJvcl9kZXRlY3RlZFxuXG50eXBlIHBhcnNlcl9vdXRwdXQgPVxuICAgIFJlYWRfdG9rZW5cbiAgfCBSYWlzZV9wYXJzZV9lcnJvclxuICB8IEdyb3dfc3RhY2tzXzFcbiAgfCBHcm93X3N0YWNrc18yXG4gIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb25cbiAgfCBDYWxsX2Vycm9yX2Z1bmN0aW9uXG5cbigqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5sZXQgXyA9IFtSZWFkX3Rva2VuOyBSYWlzZV9wYXJzZV9lcnJvcjsgR3Jvd19zdGFja3NfMTsgR3Jvd19zdGFja3NfMjtcbiAgICAgICAgIENvbXB1dGVfc2VtYW50aWNfYWN0aW9uOyBDYWxsX2Vycm9yX2Z1bmN0aW9uXVxuXG5leHRlcm5hbCBwYXJzZV9lbmdpbmUgOlxuICAgIHBhcnNlX3RhYmxlcyAtPiBwYXJzZXJfZW52IC0+IHBhcnNlcl9pbnB1dCAtPiBPYmoudCAtPiBwYXJzZXJfb3V0cHV0XG4gICAgPSBcImNhbWxfcGFyc2VfZW5naW5lXCJcblxuZXh0ZXJuYWwgc2V0X3RyYWNlOiBib29sIC0+IGJvb2xcbiAgICA9IFwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlXCJcblxubGV0IGVudiA9XG4gIHsgc19zdGFjayA9IEFycmF5Lm1ha2UgMTAwIDA7XG4gICAgdl9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIChPYmoucmVwciAoKSk7XG4gICAgc3ltYl9zdGFydF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzeW1iX2VuZF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzdGFja3NpemUgPSAxMDA7XG4gICAgc3RhY2tiYXNlID0gMDtcbiAgICBjdXJyX2NoYXIgPSAwO1xuICAgIGx2YWwgPSBPYmoucmVwciAoKTtcbiAgICBzeW1iX3N0YXJ0ID0gZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kID0gZHVtbXlfcG9zO1xuICAgIGFzcCA9IDA7XG4gICAgcnVsZV9sZW4gPSAwO1xuICAgIHJ1bGVfbnVtYmVyID0gMDtcbiAgICBzcCA9IDA7XG4gICAgc3RhdGUgPSAwO1xuICAgIGVycmZsYWcgPSAwIH1cblxubGV0IGdyb3dfc3RhY2tzKCkgPVxuICBsZXQgb2xkc2l6ZSA9IGVudi5zdGFja3NpemUgaW5cbiAgbGV0IG5ld3NpemUgPSBvbGRzaXplICogMiBpblxuICBsZXQgbmV3X3MgPSBBcnJheS5tYWtlIG5ld3NpemUgMFxuICBhbmQgbmV3X3YgPSBBcnJheS5tYWtlIG5ld3NpemUgKE9iai5yZXByICgpKVxuICBhbmQgbmV3X3N0YXJ0ID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3Bvc1xuICBhbmQgbmV3X2VuZCA9IEFycmF5Lm1ha2UgbmV3c2l6ZSBkdW1teV9wb3MgaW5cbiAgICBBcnJheS5ibGl0IGVudi5zX3N0YWNrIDAgbmV3X3MgMCBvbGRzaXplO1xuICAgIGVudi5zX3N0YWNrIDwtIG5ld19zO1xuICAgIEFycmF5LmJsaXQgZW52LnZfc3RhY2sgMCBuZXdfdiAwIG9sZHNpemU7XG4gICAgZW52LnZfc3RhY2sgPC0gbmV3X3Y7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9zdGFydF9zdGFjayAwIG5ld19zdGFydCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfc3RhcnRfc3RhY2sgPC0gbmV3X3N0YXJ0O1xuICAgIEFycmF5LmJsaXQgZW52LnN5bWJfZW5kX3N0YWNrIDAgbmV3X2VuZCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfZW5kX3N0YWNrIDwtIG5ld19lbmQ7XG4gICAgZW52LnN0YWNrc2l6ZSA8LSBuZXdzaXplXG5cbmxldCBjbGVhcl9wYXJzZXIoKSA9XG4gIEFycmF5LmZpbGwgZW52LnZfc3RhY2sgMCBlbnYuc3RhY2tzaXplIChPYmoucmVwciAoKSk7XG4gIGVudi5sdmFsIDwtIE9iai5yZXByICgpXG5cbmxldCBjdXJyZW50X2xvb2thaGVhZF9mdW4gPSByZWYgKGZ1biAoXyA6IE9iai50KSAtPiBmYWxzZSlcblxubGV0IHl5cGFyc2UgdGFibGVzIHN0YXJ0IGxleGVyIGxleGJ1ZiA9XG4gIGxldCByZWMgbG9vcCBjbWQgYXJnID1cbiAgICBtYXRjaCBwYXJzZV9lbmdpbmUgdGFibGVzIGVudiBjbWQgYXJnIHdpdGhcbiAgICAgIFJlYWRfdG9rZW4gLT5cbiAgICAgICAgbGV0IHQgPSBPYmoucmVwcihsZXhlciBsZXhidWYpIGluXG4gICAgICAgIGVudi5zeW1iX3N0YXJ0IDwtIGxleGJ1Zi5sZXhfc3RhcnRfcDtcbiAgICAgICAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICAgICAgICBsb29wIFRva2VuX3JlYWQgdFxuICAgIHwgUmFpc2VfcGFyc2VfZXJyb3IgLT5cbiAgICAgICAgcmFpc2UgUGFyc2VfZXJyb3JcbiAgICB8IENvbXB1dGVfc2VtYW50aWNfYWN0aW9uIC0+XG4gICAgICAgIGxldCAoYWN0aW9uLCB2YWx1ZSkgPVxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgKFNlbWFudGljX2FjdGlvbl9jb21wdXRlZCwgdGFibGVzLmFjdGlvbnMuKGVudi5ydWxlX251bWJlcikgZW52KVxuICAgICAgICAgIHdpdGggUGFyc2VfZXJyb3IgLT5cbiAgICAgICAgICAgIChFcnJvcl9kZXRlY3RlZCwgT2JqLnJlcHIgKCkpIGluXG4gICAgICAgIGxvb3AgYWN0aW9uIHZhbHVlXG4gICAgfCBHcm93X3N0YWNrc18xIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzEgKE9iai5yZXByICgpKVxuICAgIHwgR3Jvd19zdGFja3NfMiAtPlxuICAgICAgICBncm93X3N0YWNrcygpOyBsb29wIFN0YWNrc19ncm93bl8yIChPYmoucmVwciAoKSlcbiAgICB8IENhbGxfZXJyb3JfZnVuY3Rpb24gLT5cbiAgICAgICAgdGFibGVzLmVycm9yX2Z1bmN0aW9uIFwic3ludGF4IGVycm9yXCI7XG4gICAgICAgIGxvb3AgRXJyb3JfZGV0ZWN0ZWQgKE9iai5yZXByICgpKSBpblxuICBsZXQgaW5pdF9hc3AgPSBlbnYuYXNwXG4gIGFuZCBpbml0X3NwID0gZW52LnNwXG4gIGFuZCBpbml0X3N0YWNrYmFzZSA9IGVudi5zdGFja2Jhc2VcbiAgYW5kIGluaXRfc3RhdGUgPSBlbnYuc3RhdGVcbiAgYW5kIGluaXRfY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhclxuICBhbmQgaW5pdF9sdmFsID0gZW52Lmx2YWxcbiAgYW5kIGluaXRfZXJyZmxhZyA9IGVudi5lcnJmbGFnIGluXG4gIGVudi5zdGFja2Jhc2UgPC0gZW52LnNwICsgMTtcbiAgZW52LmN1cnJfY2hhciA8LSBzdGFydDtcbiAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICB0cnlcbiAgICBsb29wIFN0YXJ0IChPYmoucmVwciAoKSlcbiAgd2l0aCBleG4gLT5cbiAgICBsZXQgY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhciBpblxuICAgIGVudi5hc3AgPC0gaW5pdF9hc3A7XG4gICAgZW52LnNwIDwtIGluaXRfc3A7XG4gICAgZW52LnN0YWNrYmFzZSA8LSBpbml0X3N0YWNrYmFzZTtcbiAgICBlbnYuc3RhdGUgPC0gaW5pdF9zdGF0ZTtcbiAgICBlbnYuY3Vycl9jaGFyIDwtIGluaXRfY3Vycl9jaGFyO1xuICAgIGVudi5sdmFsIDwtIGluaXRfbHZhbDtcbiAgICBlbnYuZXJyZmxhZyA8LSBpbml0X2VycmZsYWc7XG4gICAgbWF0Y2ggZXhuIHdpdGhcbiAgICAgIFlZZXhpdCB2IC0+XG4gICAgICAgIE9iai5tYWdpYyB2XG4gICAgfCBfIC0+XG4gICAgICAgIGN1cnJlbnRfbG9va2FoZWFkX2Z1biA6PVxuICAgICAgICAgIChmdW4gdG9rIC0+XG4gICAgICAgICAgICBpZiBPYmouaXNfYmxvY2sgdG9rXG4gICAgICAgICAgICB0aGVuIHRhYmxlcy50cmFuc2xfYmxvY2suKE9iai50YWcgdG9rKSA9IGN1cnJfY2hhclxuICAgICAgICAgICAgZWxzZSB0YWJsZXMudHJhbnNsX2NvbnN0LihPYmoubWFnaWMgdG9rKSA9IGN1cnJfY2hhcik7XG4gICAgICAgIHJhaXNlIGV4blxuXG5sZXQgcGVla192YWwgZW52IG4gPVxuICBPYmoubWFnaWMgZW52LnZfc3RhY2suKGVudi5hc3AgLSBuKVxuXG5sZXQgc3ltYm9sX3N0YXJ0X3BvcyAoKSA9XG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpIDw9IDAgdGhlbiBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHN0ID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSBpICsgMSkgaW5cbiAgICAgIGxldCBlbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgaWYgc3QgPD4gZW4gdGhlbiBzdCBlbHNlIGxvb3AgKGkgLSAxKVxuICAgIGVuZFxuICBpblxuICBsb29wIGVudi5ydWxlX2xlblxuXG5sZXQgc3ltYm9sX2VuZF9wb3MgKCkgPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG5sZXQgcmhzX3N0YXJ0X3BvcyBuID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSAoZW52LnJ1bGVfbGVuIC0gbikpXG5sZXQgcmhzX2VuZF9wb3MgbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcblxubGV0IHN5bWJvbF9zdGFydCAoKSA9IChzeW1ib2xfc3RhcnRfcG9zICgpKS5wb3NfY251bVxubGV0IHN5bWJvbF9lbmQgKCkgPSAoc3ltYm9sX2VuZF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgcmhzX3N0YXJ0IG4gPSAocmhzX3N0YXJ0X3BvcyBuKS5wb3NfY251bVxubGV0IHJoc19lbmQgbiA9IChyaHNfZW5kX3BvcyBuKS5wb3NfY251bVxuXG5sZXQgaXNfY3VycmVudF9sb29rYWhlYWQgdG9rID1cbiAgKCFjdXJyZW50X2xvb2thaGVhZF9mdW4pKE9iai5yZXByIHRvaylcblxubGV0IHBhcnNlX2Vycm9yIChfIDogc3RyaW5nKSA9ICgpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFNldHMgb3ZlciBvcmRlcmVkIHR5cGVzICopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGVsdFxuICAgIHR5cGUgdFxuICAgIHZhbCBlbXB0eTogdFxuICAgIHZhbCBpc19lbXB0eTogdCAtPiBib29sXG4gICAgdmFsIG1lbTogZWx0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBhZGQ6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgc2luZ2xldG9uOiBlbHQgLT4gdFxuICAgIHZhbCByZW1vdmU6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgdW5pb246IHQgLT4gdCAtPiB0XG4gICAgdmFsIGludGVyOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBkaXNqb2ludDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZGlmZjogdCAtPiB0IC0+IHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgc3Vic2V0OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoZWx0IC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICAgIHZhbCBtYXA6IChlbHQgLT4gZWx0KSAtPiB0IC0+IHRcbiAgICB2YWwgZm9sZDogKGVsdCAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICAgIHZhbCBmb3JfYWxsOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGVsdCAtPiBlbHQgb3B0aW9uKSAtPiB0IC0+IHRcbiAgICB2YWwgcGFydGl0aW9uOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdCAqIHRcbiAgICB2YWwgY2FyZGluYWw6IHQgLT4gaW50XG4gICAgdmFsIGVsZW1lbnRzOiB0IC0+IGVsdCBsaXN0XG4gICAgdmFsIG1pbl9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1pbl9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgbWF4X2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWF4X2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBjaG9vc2U6IHQgLT4gZWx0XG4gICAgdmFsIGNob29zZV9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBzcGxpdDogZWx0IC0+IHQgLT4gdCAqIGJvb2wgKiB0XG4gICAgdmFsIGZpbmQ6IGVsdCAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX29wdDogZWx0IC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgb2ZfbGlzdDogZWx0IGxpc3QgLT4gdFxuICAgIHZhbCB0b19zZXFfZnJvbSA6IGVsdCAtPiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19zZXEgOiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19yZXZfc2VxIDogdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6IGVsdCBTZXEudCAtPiB0IC0+IHRcbiAgICB2YWwgb2Zfc2VxIDogZWx0IFNlcS50IC0+IHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID1cbiAgc3RydWN0XG4gICAgdHlwZSBlbHQgPSBPcmQudFxuICAgIHR5cGUgdCA9IEVtcHR5IHwgTm9kZSBvZiB7bDp0OyB2OmVsdDsgcjp0OyBoOmludH1cblxuICAgICgqIFNldHMgYXJlIHJlcHJlc2VudGVkIGJ5IGJhbGFuY2VkIGJpbmFyeSB0cmVlcyAodGhlIGhlaWdodHMgb2YgdGhlXG4gICAgICAgY2hpbGRyZW4gZGlmZmVyIGJ5IGF0IG1vc3QgMiAqKVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICAgIGwgYW5kIHIgbXVzdCBiZSBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gICAgbGV0IGNyZWF0ZSBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSwgYnV0IHBlcmZvcm1zIG9uZSBzdGVwIG9mIHJlYmFsYW5jaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgICBBc3N1bWVzIGwgYW5kIHIgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDMuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBjcmVhdGUgZm9yIGJldHRlciBzcGVlZCBpbiB0aGUgbW9zdCBmcmVxdWVudCBjYXNlXG4gICAgICAgd2hlcmUgbm8gcmViYWxhbmNpbmcgaXMgcmVxdWlyZWQuICopXG5cbiAgICBsZXQgYmFsIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogSW5zZXJ0aW9uIG9mIG9uZSBlbGVtZW50ICopXG5cbiAgICBsZXQgcmVjIGFkZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHQgZWxzZVxuICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0IGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0IGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHNpbmdsZXRvbiB4ID0gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgdiBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBlbGVtZW50cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBlbGVtZW50LlxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fZWxlbWVudCB4IGwpIHYgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgKGFkZF9tYXhfZWxlbWVudCB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9lbGVtZW50IHYgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfZWxlbWVudCB2IGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgcj1scjsgaD1saH0sIE5vZGV7bD1ybDsgdj1ydjsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgKGpvaW4gbHIgdiByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IHJsKSBydiByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiByXG5cbiAgICAoKiBTbWFsbGVzdCBhbmQgZ3JlYXRlc3QgZWxlbWVudCBvZiBhIHNldCAqKVxuXG4gICAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHQgbFxuXG4gICAgbGV0IHJlYyBtaW5fZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0X29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdCByXG5cbiAgICBsZXQgcmVjIG1heF9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHRfb3B0IHJcblxuICAgICgqIFJlbW92ZSB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2V0ICopXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIEFzc3VtZSB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLiAqKVxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gYmFsIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGpvaW4gdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIFNwbGl0dGluZy4gIHNwbGl0IHggcyByZXR1cm5zIGEgdHJpcGxlIChsLCBwcmVzZW50LCByKSB3aGVyZVxuICAgICAgICAtIGwgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlIDwgeFxuICAgICAgICAtIHIgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlID4geFxuICAgICAgICAtIHByZXNlbnQgaXMgZmFsc2UgaWYgcyBjb250YWlucyBubyBlbGVtZW50IGVxdWFsIHRvIHgsXG4gICAgICAgICAgb3IgdHJ1ZSBpZiBzIGNvbnRhaW5zIGFuIGVsZW1lbnQgZXF1YWwgdG8geC4gKilcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBmYWxzZSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIHRydWUsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGxyLCBwcmVzLCBycilcblxuICAgICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0gYXMgdCkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluXG4gICAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluXG4gICAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHJlYyB1bmlvbiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdDIpIC0+IHQyXG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjE7IGg9aDF9LCBOb2Rle2w9bDI7IHY9djI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGlmIGgyID0gMSB0aGVuIGFkZCB2MiBzMSBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDIsIF8sIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBoMSA9IDEgdGhlbiBhZGQgdjEgczIgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwxLCBfLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAoXywgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoaW50ZXIgbDEgbDIpIHYxIChpbnRlciByMSByMilcblxuICAgICgqIFNhbWUgYXMgc3BsaXQsIGJ1dCBjb21wdXRlIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlc1xuICAgICAgIG9ubHkgaWYgdGhlIHBpdm90IGVsZW1lbnQgaXMgbm90IGluIHRoZSBzZXQuICBUaGUgcmlnaHQgc3VidHJlZVxuICAgICAgIGlzIGNvbXB1dGVkIG9uIGRlbWFuZC4gKilcblxuICAgIHR5cGUgc3BsaXRfYmlzID1cbiAgICAgIHwgRm91bmRcbiAgICAgIHwgTm90Rm91bmQgb2YgdCAqICh1bml0IC0+IHQpXG5cbiAgICBsZXQgcmVjIHNwbGl0X2JpcyB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb3RGb3VuZCAoRW1wdHksIChmdW4gKCkgLT4gRW1wdHkpKVxuICAgICAgfCBOb2Rle2w7IHY7IHI7IF99IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIEZvdW5kXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBtYXRjaCBzcGxpdF9iaXMgeCBsIHdpdGhcbiAgICAgICAgICAgIHwgRm91bmQgLT4gRm91bmRcbiAgICAgICAgICAgIHwgTm90Rm91bmQgKGxsLCBybCkgLT4gTm90Rm91bmQgKGxsLCAoZnVuICgpIC0+IGpvaW4gKHJsICgpKSB2IHIpKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIHNwbGl0X2JpcyB4IHIgd2l0aFxuICAgICAgICAgICAgfCBGb3VuZCAtPiBGb3VuZFxuICAgICAgICAgICAgfCBOb3RGb3VuZCAobHIsIHJyKSAtPiBOb3RGb3VuZCAoam9pbiBsIHYgbHIsIHJyKVxuXG4gICAgbGV0IHJlYyBkaXNqb2ludCBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgfCAoXywgRW1wdHkpIC0+IHRydWVcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIGlmIHMxID09IHMyIHRoZW4gZmFsc2VcbiAgICAgICAgICBlbHNlIG1hdGNoIHNwbGl0X2JpcyB2MSB0MiB3aXRoXG4gICAgICAgICAgICAgIE5vdEZvdW5kKGwyLCByMikgLT4gZGlzam9pbnQgbDEgbDIgJiYgZGlzam9pbnQgcjEgKHIyICgpKVxuICAgICAgICAgICAgfCBGb3VuZCAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBkaWZmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGRpZmYgbDEgbDIpIHYxIChkaWZmIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChkaWZmIGwxIGwyKSAoZGlmZiByMSByMilcblxuICAgIHR5cGUgZW51bWVyYXRpb24gPSBFbmQgfCBNb3JlIG9mIGVsdCAqIHQgKiBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gcyBlID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gY29uc19lbnVtIGwgKE1vcmUodiwgciwgZSkpXG5cbiAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICB8IChfLCBFbmQpIC0+IDFcbiAgICAgIHwgKE1vcmUodjEsIHIxLCBlMSksIE1vcmUodjIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcblxuICAgIGxldCBjb21wYXJlIHMxIHMyID1cbiAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gczEgRW5kKSAoY29uc19lbnVtIHMyIEVuZClcblxuICAgIGxldCBlcXVhbCBzMSBzMiA9XG4gICAgICBjb21wYXJlIHMxIHMyID0gMFxuXG4gICAgbGV0IHJlYyBzdWJzZXQgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICBFbXB0eSwgXyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgXywgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsPWwxOyB2PXYxOyByPXIxfSwgKE5vZGUge2w9bDI7IHY9djI7IHI9cjJ9IGFzIHQyKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgbDEgbDIgJiYgc3Vic2V0IHIxIHIyXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9bDE7IHY9djE7IHI9RW1wdHk7IGg9MH0pIGwyICYmIHN1YnNldCByMSB0MlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1FbXB0eTsgdj12MTsgcj1yMTsgaD0wfSkgcjIgJiYgc3Vic2V0IGwxIHQyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gaXRlciBmIGw7IGYgdjsgaXRlciBmIHJcblxuICAgIGxldCByZWMgZm9sZCBmIHMgYWNjdSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGZvbGQgZiByIChmIHYgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2ICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0pIGFzIHQgLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHYgdGhlblxuICAgICAgICAgICAgaWYgbD09bCcgJiYgcj09cicgdGhlbiB0IGVsc2Ugam9pbiBsJyB2IHInXG4gICAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgKGx0LCBsZikgPSBwYXJ0aXRpb24gcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IChydCwgcmYpID0gcGFydGl0aW9uIHAgciBpblxuICAgICAgICAgIGlmIHB2XG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IHJ0LCBjb25jYXQgbGYgcmYpXG4gICAgICAgICAgZWxzZSAoY29uY2F0IGx0IHJ0LCBqb2luIGxmIHYgcmYpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2Rle2w7IHJ9IC0+IGNhcmRpbmFsIGwgKyAxICsgY2FyZGluYWwgclxuXG4gICAgbGV0IHJlYyBlbGVtZW50c19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBlbGVtZW50c19hdXggKHYgOjogZWxlbWVudHNfYXV4IGFjY3UgcikgbFxuXG4gICAgbGV0IGVsZW1lbnRzIHMgPVxuICAgICAgZWxlbWVudHNfYXV4IFtdIHNcblxuICAgIGxldCBjaG9vc2UgPSBtaW5fZWx0XG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9lbHRfb3B0XG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHZcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIHZcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgdHJ5X2pvaW4gbCB2IHIgPVxuICAgICAgKCogW2pvaW4gbCB2IHJdIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIChlbGVtZW50cyBvZiBsIDwgdiA8XG4gICAgICAgICBlbGVtZW50cyBvZiByKTsgdXNlIFt0cnlfam9pbiBsIHYgcl0gd2hlbiB0aGlzIHByb3BlcnR5IG1heVxuICAgICAgICAgbm90IGhvbGQsIGJ1dCB5b3UgaG9wZSBpdCBkb2VzIGhvbGQgaW4gdGhlIGNvbW1vbiBjYXNlICopXG4gICAgICBpZiAobCA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIChtYXhfZWx0IGwpIHYgPCAwKVxuICAgICAgJiYgKHIgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSB2IChtaW5fZWx0IHIpIDwgMClcbiAgICAgIHRoZW4gam9pbiBsIHYgclxuICAgICAgZWxzZSB1bmlvbiBsIChhZGQgdiByKVxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgIGxldCB2JyA9IGYgdiBpblxuICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgaWYgbCA9PSBsJyAmJiB2ID09IHYnICYmIHIgPT0gcicgdGhlbiB0XG4gICAgICAgICBlbHNlIHRyeV9qb2luIGwnIHYnIHInXG5cbiAgICBsZXQgdHJ5X2NvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IHRyeV9qb2luIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IGZpbHRlcl9tYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICBiZWdpbiBtYXRjaCB2JyB3aXRoXG4gICAgICAgICAgIHwgU29tZSB2JyAtPlxuICAgICAgICAgICAgICBpZiBsID09IGwnICYmIHYgPT0gdicgJiYgciA9PSByJyB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgdHJ5X2NvbmNhdCBsJyByJ1xuICAgICAgICAgZW5kXG5cbiAgICBsZXQgb2Zfc29ydGVkX2xpc3QgbCA9XG4gICAgICBsZXQgcmVjIHN1YiBuIGwgPVxuICAgICAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICAgICAgfCAwLCBsIC0+IEVtcHR5LCBsXG4gICAgICAgIHwgMSwgeDAgOjogbCAtPiBOb2RlIHtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9LCBsXG4gICAgICAgIHwgMiwgeDAgOjogeDEgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTsgcj1FbXB0eTsgaD0yfSwgbFxuICAgICAgICB8IDMsIHgwIDo6IHgxIDo6IHgyIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7XG4gICAgICAgICAgICAgICAgIHI9Tm9kZXtsPUVtcHR5OyB2PXgyOyByPUVtcHR5OyBoPTF9OyBoPTJ9LCBsXG4gICAgICAgIHwgbiwgbCAtPlxuICAgICAgICAgIGxldCBubCA9IG4gLyAyIGluXG4gICAgICAgICAgbGV0IGxlZnQsIGwgPSBzdWIgbmwgbCBpblxuICAgICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBtaWQgOjogbCAtPlxuICAgICAgICAgICAgbGV0IHJpZ2h0LCBsID0gc3ViIChuIC0gbmwgLSAxKSBsIGluXG4gICAgICAgICAgICBjcmVhdGUgbGVmdCBtaWQgcmlnaHQsIGxcbiAgICAgIGluXG4gICAgICBmc3QgKHN1YiAoTGlzdC5sZW5ndGggbCkgbClcblxuICAgIGxldCBvZl9saXN0IGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGVtcHR5XG4gICAgICB8IFt4MF0gLT4gc2luZ2xldG9uIHgwXG4gICAgICB8IFt4MDsgeDFdIC0+IGFkZCB4MSAoc2luZ2xldG9uIHgwKVxuICAgICAgfCBbeDA7IHgxOyB4Ml0gLT4gYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4M10gLT4gYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4MzsgeDRdIC0+IGFkZCB4NCAoYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpKVxuICAgICAgfCBfIC0+IG9mX3NvcnRlZF9saXN0IChMaXN0LnNvcnRfdW5pcSBPcmQuY29tcGFyZSBsKVxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBzIHggLT4gYWRkIHggcykgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIGMgPSBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSBjIEVuZClcblxuICAgIGxldCByZWMgc25vY19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHNub2NfZW51bSByIChNb3JlKHYsIGwsIGUpKVxuXG4gICAgbGV0IHJlYyByZXZfc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3Jldl9zZXEgYyA9IHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSBjIEVuZClcblxuICAgIGxldCB0b19zZXFfZnJvbSBsb3cgcyA9XG4gICAgICBsZXQgcmVjIGF1eCBsb3cgcyBjID0gbWF0Y2ggcyB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gY1xuICAgICAgICB8IE5vZGUge2w7IHI7IHY7IF99IC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBPcmQuY29tcGFyZSB2IGxvdyB3aXRoXG4gICAgICAgICAgICAgIHwgMCAtPiBNb3JlICh2LCByLCBjKVxuICAgICAgICAgICAgICB8IG4gd2hlbiBuPDAgLT4gYXV4IGxvdyByIGNcbiAgICAgICAgICAgICAgfCBfIC0+IGF1eCBsb3cgbCAoTW9yZSAodiwgciwgYykpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBzZXFfb2ZfZW51bV8gKGF1eCBsb3cgcyBFbmQpXG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICErJ2EgdFxuICAgIHZhbCBlbXB0eTogJ2EgdFxuICAgIHZhbCBpc19lbXB0eTogJ2EgdCAtPiBib29sXG4gICAgdmFsIG1lbTogIGtleSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBrZXkgLT4gJ2EgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHVwZGF0ZToga2V5IC0+ICgnYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgc2luZ2xldG9uOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICAgIHZhbCByZW1vdmU6IGtleSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgbWVyZ2U6XG4gICAgICAgICAgKGtleSAtPiAnYSBvcHRpb24gLT4gJ2Igb3B0aW9uIC0+ICdjIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0IC0+ICdjIHRcbiAgICB2YWwgdW5pb246IChrZXkgLT4gJ2EgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjb21wYXJlOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBmb3JfYWxsOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGtleSAtPiAnYSAtPiAnYiBvcHRpb24pIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBwYXJ0aXRpb246IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0ICogJ2EgdFxuICAgIHZhbCBjYXJkaW5hbDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgYmluZGluZ3M6ICdhIHQgLT4gKGtleSAqICdhKSBsaXN0XG4gICAgdmFsIG1pbl9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWluX2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1heF9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWF4X2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGNob29zZTogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIGNob29zZV9vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGtleSAtPiAnYSB0IC0+ICdhIHQgKiAnYSBvcHRpb24gKiAnYSB0XG4gICAgdmFsIGZpbmQ6IGtleSAtPiAnYSB0IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiBrZXkgLT4gJ2EgdCAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1hcDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgbWFwaTogKGtleSAtPiAnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19yZXZfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9mcm9tIDoga2V5IC0+ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9IHN0cnVjdFxuXG4gICAgdHlwZSBrZXkgPSBPcmQudFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSBvZiB7bDonYSB0OyB2OmtleTsgZDonYTsgcjonYSB0OyBoOmludH1cblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgIGxldCBjcmVhdGUgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBoZWlnaHQgbCBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBzaW5nbGV0b24geCBkID0gTm9kZXtsPUVtcHR5OyB2PXg7IGQ7IHI9RW1wdHk7IGg9MX1cblxuICAgIGxldCBiYWwgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IGQ9bHJkOyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgbHJsKSBscnYgbHJkIChjcmVhdGUgbHJyIHggZCByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsKSBydiByZCByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgZD1ybGQ7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmxsKSBybHYgcmxkIChjcmVhdGUgcmxyIHJ2IHJkIHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGFkZCB4IGRhdGEgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBkYXRhIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggZGF0YSByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBkXG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSBkXG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0gLT4gbWluX2JpbmRpbmcgbFxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge2x9LT4gbWluX2JpbmRpbmdfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nIHJcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZ19vcHQgclxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2JpbmRpbmcgbCkgdiBkIHJcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgYmFsIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgKE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0pIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpbiBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW4gaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgdXBkYXRlIHggZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZiBOb25lIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gRW1wdHlcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICAgICAgZW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IG1lcmdlIGwgclxuICAgICAgICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbmQgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSB1cGRhdGUgeCBmIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gdXBkYXRlIHggZiByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGl0ZXIgZiBsOyBmIHYgZDsgaXRlciBmIHJcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIG1hcGkgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXBpIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwaSBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIGZvbGQgZiBtIGFjY3UgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBmb2xkIGYgciAoZiB2IGQgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIGsgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQga2V5cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBrZXkuXG5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9iaW5kaW5nIGsgeCBsKSB2IGQgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgbCB2IGQgKGFkZF9tYXhfYmluZGluZyBrIHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IGQgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fYmluZGluZyB2IGQgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfYmluZGluZyB2IGQgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyOyBoPWxofSxcbiAgICAgICAgIE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgbGQgKGpvaW4gbHIgdiBkIHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgZCBybCkgcnYgcmQgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgZCByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgam9pbiB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCBjb25jYXRfb3Jfam9pbiB0MSB2IGQgdDIgPVxuICAgICAgbWF0Y2ggZCB3aXRoXG4gICAgICB8IFNvbWUgZCAtPiBqb2luIHQxIHYgZCB0MlxuICAgICAgfCBOb25lIC0+IGNvbmNhdCB0MSB0MlxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIE5vbmUsIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgU29tZSBkLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IGQgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGQgbHIsIHByZXMsIHJyKVxuXG4gICAgbGV0IHJlYyBtZXJnZSBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LCBfKSB3aGVuIGgxID49IGhlaWdodCBzMiAtPlxuICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MSAoZiB2MSAoU29tZSBkMSkgZDIpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCAoXywgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMn0pIC0+XG4gICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYyIChmIHYyIGQxIChTb21lIGQyKSkgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IF8gLT5cbiAgICAgICAgICBhc3NlcnQgZmFsc2VcblxuICAgIGxldCByZWMgdW5pb24gZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICB8IChFbXB0eSwgcykgfCAocywgRW1wdHkpIC0+IHNcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LFxuICAgICAgICAgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMiB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYxIGQxIHJcbiAgICAgICAgICAgIHwgU29tZSBkMiAtPiBjb25jYXRfb3Jfam9pbiBsIHYxIChmIHYxIGQxIGQyKSByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYyIGQyIHJcbiAgICAgICAgICAgIHwgU29tZSBkMSAtPiBjb25jYXRfb3Jfam9pbiBsIHYyIChmIHYyIGQxIGQyKSByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdmQgdGhlbiBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIG0gZWxzZSBqb2luIGwnIHYgZCByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbZl0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBmdmQgPSBmIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZnZkIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBkJyAtPiBqb2luIGwnIHYgZCcgcidcbiAgICAgICAgICAgIHwgTm9uZSAtPiBjb25jYXQgbCcgcidcbiAgICAgICAgICBlbmRcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdmRcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgZCBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IGQgcmYpXG5cbiAgICB0eXBlICdhIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBrZXkgKiAnYSAqICdhIHQgKiAnYSBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gbSBlID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIGQsIHIsIGUpKVxuXG4gICAgbGV0IGNvbXBhcmUgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICAgIHwgKE1vcmUodjEsIGQxLCByMSwgZTEpLCBNb3JlKHYyLCBkMiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGNvbXBhcmVfYXV4IChjb25zX2VudW0gbTEgRW5kKSAoY29uc19lbnVtIG0yIEVuZClcblxuICAgIGxldCBlcXVhbCBjbXAgbTEgbTIgPVxuICAgICAgbGV0IHJlYyBlcXVhbF9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IHRydWVcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gZmFsc2VcbiAgICAgICAgfCAoXywgRW5kKSAtPiBmYWxzZVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBPcmQuY29tcGFyZSB2MSB2MiA9IDAgJiYgY21wIGQxIGQyICYmXG4gICAgICAgICAgICBlcXVhbF9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGVxdWFsX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgYmluZGluZ3NfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJpbmRpbmdzX2F1eCAoKHYsIGQpIDo6IGJpbmRpbmdzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBiaW5kaW5ncyBzID1cbiAgICAgIGJpbmRpbmdzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2JpbmRpbmdcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2JpbmRpbmdfb3B0XG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIG0gKGssdikgLT4gYWRkIGsgdiBtKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlIChrLHYsdCxyZXN0KSAtPiBTZXEuQ29ucyAoKGssdiksIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIG0gPVxuICAgICAgc2VxX29mX2VudW1fIChjb25zX2VudW0gbSBFbmQpXG5cbiAgICBsZXQgcmVjIHNub2NfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyBkOyByfSAtPiBzbm9jX2VudW0gciAoTW9yZSh2LCBkLCBsLCBlKSlcblxuICAgIGxldCByZWMgcmV2X3NlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKGssdix0LHJlc3QpIC0+XG4gICAgICAgICAgU2VxLkNvbnMgKChrLHYpLCByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19yZXZfc2VxIGMgPVxuICAgICAgcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBtID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBtIGMgPSBtYXRjaCBtIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIGQsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCBkLCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBtIEVuZClcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSB7IG11dGFibGUgYyA6ICdhIGxpc3Q7IG11dGFibGUgbGVuIDogaW50OyB9XG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgY3JlYXRlICgpID0geyBjID0gW107IGxlbiA9IDA7IH1cblxubGV0IGNsZWFyIHMgPSBzLmMgPC0gW107IHMubGVuIDwtIDBcblxubGV0IGNvcHkgcyA9IHsgYyA9IHMuYzsgbGVuID0gcy5sZW47IH1cblxubGV0IHB1c2ggeCBzID0gcy5jIDwtIHggOjogcy5jOyBzLmxlbiA8LSBzLmxlbiArIDFcblxubGV0IHBvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCBwb3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgU29tZSBoZFxuICB8IFtdICAgICAtPiBOb25lXG5cbmxldCB0b3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gaGRcbiAgfCBbXSAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgdG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBTb21lIGhkXG4gIHwgW10gICAgLT4gTm9uZVxuXG5sZXQgaXNfZW1wdHkgcyA9IChzLmMgPSBbXSlcblxubGV0IGxlbmd0aCBzID0gcy5sZW5cblxubGV0IGl0ZXIgZiBzID0gTGlzdC5pdGVyIGYgcy5jXG5cbmxldCBmb2xkIGYgYWNjIHMgPSBMaXN0LmZvbGRfbGVmdCBmIGFjYyBzLmNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gTGlzdC50b19zZXEgcy5jXG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcyA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcyBnO1xuICBzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgcGVla19vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBTb21lIGNvbnRlbnRcblxubGV0IHRvcCA9XG4gIHBlZWtcblxubGV0IHRha2UgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBjb250ZW50XG5cbmxldCB0YWtlX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBTb21lIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBTb21lIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHEgPVxuICBsZXQgcmVjIGF1eCBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgfCBOaWwgLT4gU2VxLk5pbFxuICAgIHwgQ29ucyB7IGNvbnRlbnQ9eDsgbmV4dDsgfSAtPiBTZXEuQ29ucyAoeCwgYXV4IG5leHQpXG4gIGluXG4gIGF1eCBxLmZpcnN0XG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcSA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcSBnO1xuICBxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIERhbmllbCBkZSBSYXVnbGF1ZHJlLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9ICdhIGNlbGwgb3B0aW9uXG5hbmQgJ2EgY2VsbCA9IHsgbXV0YWJsZSBjb3VudCA6IGludDsgbXV0YWJsZSBkYXRhIDogJ2EgZGF0YSB9XG5hbmQgJ2EgZGF0YSA9XG4gICAgU2VtcHR5XG4gIHwgU2NvbnMgb2YgJ2EgKiAnYSBkYXRhXG4gIHwgU2FwcCBvZiAnYSBkYXRhICogJ2EgZGF0YVxuICB8IFNsYXp5IG9mICdhIGRhdGEgTGF6eS50XG4gIHwgU2dlbiBvZiAnYSBnZW5cbiAgfCBTYnVmZmlvIDogYnVmZmlvIC0+IGNoYXIgZGF0YVxuYW5kICdhIGdlbiA9IHsgbXV0YWJsZSBjdXJyIDogJ2Egb3B0aW9uIG9wdGlvbjsgZnVuYyA6IGludCAtPiAnYSBvcHRpb24gfVxuYW5kIGJ1ZmZpbyA9XG4gIHsgaWMgOiBpbl9jaGFubmVsOyBidWZmIDogYnl0ZXM7IG11dGFibGUgbGVuIDogaW50OyBtdXRhYmxlIGluZCA6IGludCB9XG5cbmV4Y2VwdGlvbiBGYWlsdXJlXG5leGNlcHRpb24gRXJyb3Igb2Ygc3RyaW5nXG5cbmxldCBjb3VudCA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAwXG4gIHwgU29tZSB7IGNvdW50IH0gLT4gY291bnRcbmxldCBkYXRhID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFNlbXB0eVxuICB8IFNvbWUgeyBkYXRhIH0gLT4gZGF0YVxuXG5sZXQgZmlsbF9idWZmIGIgPVxuICBiLmxlbiA8LSBpbnB1dCBiLmljIGIuYnVmZiAwIChCeXRlcy5sZW5ndGggYi5idWZmKTsgYi5pbmQgPC0gMFxuXG5cbmxldCByZWMgZ2V0X2RhdGEgOiB0eXBlIHYuIGludCAtPiB2IGRhdGEgLT4gdiBkYXRhID0gZnVuIGNvdW50IGQgLT4gbWF0Y2ggZCB3aXRoXG4gKCogUmV0dXJucyBlaXRoZXIgU2VtcHR5IG9yIFNjb25zKGEsIF8pIGV2ZW4gd2hlbiBkIGlzIGEgZ2VuZXJhdG9yXG4gICAgb3IgYSBidWZmZXIuIEluIHRob3NlIGNhc2VzLCB0aGUgaXRlbSBhIGlzIHNlZW4gYXMgZXh0cmFjdGVkIGZyb21cbiB0aGUgZ2VuZXJhdG9yL2J1ZmZlci5cbiBUaGUgY291bnQgcGFyYW1ldGVyIGlzIHVzZWQgZm9yIGNhbGxpbmcgYFNnZW4tZnVuY3Rpb25zJy4gICopXG4gICBTZW1wdHkgfCBTY29ucyAoXywgXykgLT4gZFxuIHwgU2FwcCAoZDEsIGQyKSAtPlxuICAgICBiZWdpbiBtYXRjaCBnZXRfZGF0YSBjb3VudCBkMSB3aXRoXG4gICAgICAgU2NvbnMgKGEsIGQxMSkgLT4gU2NvbnMgKGEsIFNhcHAgKGQxMSwgZDIpKVxuICAgICB8IFNlbXB0eSAtPiBnZXRfZGF0YSBjb3VudCBkMlxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2dlbiB7Y3VyciA9IFNvbWUgTm9uZX0gLT4gU2VtcHR5XG4gfCBTZ2VuICh7Y3VyciA9IFNvbWUoU29tZSBhKX0gYXMgZykgLT5cbiAgICAgZy5jdXJyIDwtIE5vbmU7IFNjb25zKGEsIGQpXG4gfCBTZ2VuIGcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZy5mdW5jIGNvdW50IHdpdGhcbiAgICAgICBOb25lIC0+IGcuY3VyciA8LSBTb21lKE5vbmUpOyBTZW1wdHlcbiAgICAgfCBTb21lIGEgLT4gU2NvbnMoYSwgZClcbiAgICAgICAgICgqIFdhcm5pbmc6IGFueW9uZSB1c2luZyBnIHRoaW5rcyB0aGF0IGFuIGl0ZW0gaGFzIGJlZW4gcmVhZCAqKVxuICAgICBlbmRcbiB8IFNidWZmaW8gYiAtPlxuICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gU2VtcHR5IGVsc2VcbiAgICAgICBsZXQgciA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmIGIuaW5kIGluXG4gICAgICAgKCogV2FybmluZzogYW55b25lIHVzaW5nIGcgdGhpbmtzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZWFkICopXG4gICAgICAgYi5pbmQgPC0gc3VjYyBiLmluZDsgU2NvbnMociwgZClcbiB8IFNsYXp5IGYgLT4gZ2V0X2RhdGEgY291bnQgKExhenkuZm9yY2UgZilcblxuXG5sZXQgcmVjIHBlZWtfZGF0YSA6IHR5cGUgdi4gdiBjZWxsIC0+IHYgb3B0aW9uID0gZnVuIHMgLT5cbiAoKiBjb25zdWx0IHRoZSBmaXJzdCBpdGVtIG9mIHMgKilcbiBtYXRjaCBzLmRhdGEgd2l0aFxuICAgU2VtcHR5IC0+IE5vbmVcbiB8IFNjb25zIChhLCBfKSAtPiBTb21lIGFcbiB8IFNhcHAgKF8sIF8pIC0+XG4gICAgIGJlZ2luIG1hdGNoIGdldF9kYXRhIHMuY291bnQgcy5kYXRhIHdpdGhcbiAgICAgICBTY29ucyhhLCBfKSBhcyBkIC0+IHMuZGF0YSA8LSBkOyBTb21lIGFcbiAgICAgfCBTZW1wdHkgLT4gTm9uZVxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2xhenkgZiAtPiBzLmRhdGEgPC0gKExhenkuZm9yY2UgZik7IHBlZWtfZGF0YSBzXG4gfCBTZ2VuIHtjdXJyID0gU29tZSBhfSAtPiBhXG4gfCBTZ2VuIGcgLT4gbGV0IHggPSBnLmZ1bmMgcy5jb3VudCBpbiBnLmN1cnIgPC0gU29tZSB4OyB4XG4gfCBTYnVmZmlvIGIgLT5cbiAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIGJlZ2luIHMuZGF0YSA8LSBTZW1wdHk7IE5vbmUgZW5kXG4gICAgIGVsc2UgU29tZSAoQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmYgYi5pbmQpXG5cblxubGV0IHBlZWsgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgcyAtPiBwZWVrX2RhdGEgc1xuXG5cbmxldCByZWMganVua19kYXRhIDogdHlwZSB2LiB2IGNlbGwgLT4gdW5pdCA9IGZ1biBzIC0+XG4gIG1hdGNoIHMuZGF0YSB3aXRoXG4gICAgU2NvbnMgKF8sIGQpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IHMuZGF0YSA8LSBkXG4gIHwgU2dlbiAoe2N1cnIgPSBTb21lIF99IGFzIGcpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGcuY3VyciA8LSBOb25lXG4gIHwgU2J1ZmZpbyBiIC0+XG4gICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIHMuZGF0YSA8LSBTZW1wdHlcbiAgICAgIGVsc2UgKHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGIuaW5kIDwtIHN1Y2MgYi5pbmQpXG4gIHwgXyAtPlxuICAgICAgbWF0Y2ggcGVla19kYXRhIHMgd2l0aFxuICAgICAgICBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyAtPiBqdW5rX2RhdGEgc1xuXG5cbmxldCBqdW5rID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBkYXRhIC0+IGp1bmtfZGF0YSBkYXRhXG5cbmxldCByZWMgbmdldF9kYXRhIG4gcyA9XG4gIGlmIG4gPD0gMCB0aGVuIFtdLCBzLmRhdGEsIDBcbiAgZWxzZVxuICAgIG1hdGNoIHBlZWtfZGF0YSBzIHdpdGhcbiAgICAgIFNvbWUgYSAtPlxuICAgICAgICBqdW5rX2RhdGEgcztcbiAgICAgICAgbGV0IChhbCwgZCwgaykgPSBuZ2V0X2RhdGEgKHByZWQgbikgcyBpbiBhIDo6IGFsLCBTY29ucyAoYSwgZCksIHN1Y2Mga1xuICAgIHwgTm9uZSAtPiBbXSwgcy5kYXRhLCAwXG5cblxubGV0IG5wZWVrX2RhdGEgbiBzID1cbiAgbGV0IChhbCwgZCwgbGVuKSA9IG5nZXRfZGF0YSBuIHMgaW5cbiAgcy5jb3VudCA8LSAocy5jb3VudCAtIGxlbik7XG4gIHMuZGF0YSA8LSBkO1xuICBhbFxuXG5cbmxldCBucGVlayBuID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSBkIC0+IG5wZWVrX2RhdGEgbiBkXG5cbmxldCBuZXh0IHMgPVxuICBtYXRjaCBwZWVrIHMgd2l0aFxuICAgIFNvbWUgYSAtPiBqdW5rIHM7IGFcbiAgfCBOb25lIC0+IHJhaXNlIEZhaWx1cmVcblxuXG5sZXQgZW1wdHkgcyA9XG4gIG1hdGNoIHBlZWsgcyB3aXRoXG4gICAgU29tZSBfIC0+IHJhaXNlIEZhaWx1cmVcbiAgfCBOb25lIC0+ICgpXG5cblxubGV0IGl0ZXIgZiBzdHJtID1cbiAgbGV0IHJlYyBkb19yZWMgKCkgPVxuICAgIG1hdGNoIHBlZWsgc3RybSB3aXRoXG4gICAgICBTb21lIGEgLT4ganVuayBzdHJtOyBpZ25vcmUoZiBhKTsgZG9fcmVjICgpXG4gICAgfCBOb25lIC0+ICgpXG4gIGluXG4gIGRvX3JlYyAoKVxuXG5cbigqIFN0cmVhbSBidWlsZGluZyBmdW5jdGlvbnMgKilcblxubGV0IGZyb20gZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNnZW4ge2N1cnIgPSBOb25lOyBmdW5jID0gZn19XG5cbmxldCBvZl9saXN0IGwgPVxuICBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBMaXN0LmZvbGRfcmlnaHQgKGZ1biB4IGwgLT4gU2NvbnMgKHgsIGwpKSBsIFNlbXB0eX1cblxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgICgqIFdlIGNhbm5vdCB1c2UgdGhlIGluZGV4IHBhc3NlZCBieSB0aGUgW2Zyb21dIGZ1bmN0aW9uIGRpcmVjdGx5XG4gICAgICAgYmVjYXVzZSBpdCByZXR1cm5zIHRoZSBjdXJyZW50IHN0cmVhbSBjb3VudCwgd2l0aCBhYnNvbHV0ZWx5IG5vXG4gICAgICAgZ3VhcmFudGVlIHRoYXQgaXQgd2lsbCBzdGFydCBmcm9tIDAuIEZvciBleGFtcGxlLCBpbiB0aGUgY2FzZVxuICAgICAgIG9mIFtTdHJlYW0uaWNvbnMgJ2MnIChTdHJlYW0uZnJvbV9zdHJpbmcgXCJhYlwiKV0sIHRoZSBmaXJzdFxuICAgICAgIGFjY2VzcyB0byB0aGUgc3RyaW5nIHdpbGwgYmUgbWFkZSB3aXRoIGNvdW50IFsxXSBhbHJlYWR5LlxuICAgICopXG4gICAgbGV0IGMgPSAhY291bnQgaW5cbiAgICBpZiBjIDwgU3RyaW5nLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSBzLltjXSlcbiAgICBlbHNlIE5vbmUpXG5cblxubGV0IG9mX2J5dGVzIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgIGxldCBjID0gIWNvdW50IGluXG4gICAgaWYgYyA8IEJ5dGVzLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSAoQnl0ZXMuZ2V0IHMgYykpXG4gICAgZWxzZSBOb25lKVxuXG5cbmxldCBvZl9jaGFubmVsIGljID1cbiAgU29tZSB7Y291bnQgPSAwO1xuICAgICAgICBkYXRhID0gU2J1ZmZpbyB7aWMgPSBpYzsgYnVmZiA9IEJ5dGVzLmNyZWF0ZSA0MDk2OyBsZW4gPSAwOyBpbmQgPSAwfX1cblxuXG4oKiBTdHJlYW0gZXhwcmVzc2lvbnMgYnVpbGRlcnMgKilcblxubGV0IGlhcHAgaSBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2FwcCAoZGF0YSBpLCBkYXRhIHMpfVxubGV0IGljb25zIGkgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNjb25zIChpLCBkYXRhIHMpfVxubGV0IGlzaW5nIGkgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTY29ucyAoaSwgU2VtcHR5KX1cblxubGV0IGxhcHAgZiBzID1cbiAgU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2FwcCAoZGF0YSAoZiAoKSksIGRhdGEgcykpKX1cblxubGV0IGxjb25zIGYgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBkYXRhIHMpKSl9XG5sZXQgbHNpbmcgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBTZW1wdHkpKSl9XG5cbmxldCBzZW1wdHkgPSBOb25lXG5sZXQgc2xhenkgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KGRhdGEgKGYgKCkpKSl9XG5cbigqIEZvciBkZWJ1Z2dpbmcgdXNlICopXG5cbmxldCByZWMgZHVtcCA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiB0IC0+IHVuaXQgPSBmdW4gZiBzIC0+XG4gIHByaW50X3N0cmluZyBcIntjb3VudCA9IFwiO1xuICBwcmludF9pbnQgKGNvdW50IHMpO1xuICBwcmludF9zdHJpbmcgXCI7IGRhdGEgPSBcIjtcbiAgZHVtcF9kYXRhIGYgKGRhdGEgcyk7XG4gIHByaW50X3N0cmluZyBcIn1cIjtcbiAgcHJpbnRfbmV3bGluZSAoKVxuYW5kIGR1bXBfZGF0YSA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiBkYXRhIC0+IHVuaXQgPSBmdW4gZiAtPlxuICBmdW5jdGlvblxuICAgIFNlbXB0eSAtPiBwcmludF9zdHJpbmcgXCJTZW1wdHlcIlxuICB8IFNjb25zIChhLCBkKSAtPlxuICAgICAgcHJpbnRfc3RyaW5nIFwiU2NvbnMgKFwiO1xuICAgICAgZiBhO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQ7XG4gICAgICBwcmludF9zdHJpbmcgXCIpXCJcbiAgfCBTYXBwIChkMSwgZDIpIC0+XG4gICAgICBwcmludF9zdHJpbmcgXCJTYXBwIChcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQxO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQyO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiKVwiXG4gIHwgU2xhenkgXyAtPiBwcmludF9zdHJpbmcgXCJTbGF6eVwiXG4gIHwgU2dlbiBfIC0+IHByaW50X3N0cmluZyBcIlNnZW5cIlxuICB8IFNidWZmaW8gXyAtPiBwcmludF9zdHJpbmcgXCJTYnVmZmlvXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgIFBpZXJyZSBXZWlzIGFuZCBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTkgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXh0ZW5zaWJsZSBidWZmZXJzICopXG5cbnR5cGUgdCA9XG4ge211dGFibGUgYnVmZmVyIDogYnl0ZXM7XG4gIG11dGFibGUgcG9zaXRpb24gOiBpbnQ7XG4gIG11dGFibGUgbGVuZ3RoIDogaW50O1xuICBpbml0aWFsX2J1ZmZlciA6IGJ5dGVzfVxuKCogSW52YXJpYW50czogYWxsIHBhcnRzIG9mIHRoZSBjb2RlIHByZXNlcnZlIHRoZSBpbnZhcmlhbnRzIHRoYXQ6XG4gICAtIFswIDw9IGIucG9zaXRpb24gPD0gYi5sZW5ndGhdXG4gICAtIFtiLmxlbmd0aCA9IEJ5dGVzLmxlbmd0aCBiLmJ1ZmZlcl1cblxuICAgTm90ZSBpbiBwYXJ0aWN1bGFyIHRoYXQgW2IucG9zaXRpb24gPSBiLmxlbmd0aF0gaXMgbGVnYWwsXG4gICBpdCBtZWFucyB0aGF0IHRoZSBidWZmZXIgaXMgZnVsbCBhbmQgd2lsbCBoYXZlIHRvIGJlIGV4dGVuZGVkXG4gICBiZWZvcmUgYW55IGZ1cnRoZXIgYWRkaXRpb24uICopXG5cbmxldCBjcmVhdGUgbiA9XG4gbGV0IG4gPSBpZiBuIDwgMSB0aGVuIDEgZWxzZSBuIGluXG4gbGV0IG4gPSBpZiBuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGVsc2UgbiBpblxuIGxldCBzID0gQnl0ZXMuY3JlYXRlIG4gaW5cbiB7YnVmZmVyID0gczsgcG9zaXRpb24gPSAwOyBsZW5ndGggPSBuOyBpbml0aWFsX2J1ZmZlciA9IHN9XG5cbmxldCBjb250ZW50cyBiID0gQnl0ZXMuc3ViX3N0cmluZyBiLmJ1ZmZlciAwIGIucG9zaXRpb25cbmxldCB0b19ieXRlcyBiID0gQnl0ZXMuc3ViIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgc3ViIGIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBiLnBvc2l0aW9uIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuc3ViXCJcbiAgZWxzZSBCeXRlcy5zdWJfc3RyaW5nIGIuYnVmZmVyIG9mcyBsZW5cblxuXG5sZXQgYmxpdCBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBzcmNvZmYgPCAwIHx8IHNyY29mZiA+IHNyYy5wb3NpdGlvbiAtIGxlblxuICAgICAgICAgICAgIHx8IGRzdG9mZiA8IDAgfHwgZHN0b2ZmID4gKEJ5dGVzLmxlbmd0aCBkc3QpIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYmxpdFwiXG4gIGVsc2VcbiAgICBCeXRlcy51bnNhZmVfYmxpdCBzcmMuYnVmZmVyIHNyY29mZiBkc3QgZHN0b2ZmIGxlblxuXG5cbmxldCBudGggYiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+PSBiLnBvc2l0aW9uIHRoZW5cbiAgIGludmFsaWRfYXJnIFwiQnVmZmVyLm50aFwiXG4gIGVsc2UgQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBvZnNcblxuXG5sZXQgbGVuZ3RoIGIgPSBiLnBvc2l0aW9uXG5cbmxldCBjbGVhciBiID0gYi5wb3NpdGlvbiA8LSAwXG5cbmxldCByZXNldCBiID1cbiAgYi5wb3NpdGlvbiA8LSAwO1xuICBiLmJ1ZmZlciA8LSBiLmluaXRpYWxfYnVmZmVyO1xuICBiLmxlbmd0aCA8LSBCeXRlcy5sZW5ndGggYi5idWZmZXJcblxuKCogW3Jlc2l6ZSBiIG1vcmVdIGVuc3VyZXMgdGhhdCBbYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGhdIGhvbGRzXG4gICBieSBkeW5hbWljYWxseSBleHRlbmRpbmcgW2IuYnVmZmVyXSBpZiBuZWNlc3NhcnkgLS0gYW5kIHRodXNcbiAgIGluY3JlYXNpbmcgW2IubGVuZ3RoXS5cblxuICAgSW4gcGFydGljdWxhciwgYWZ0ZXIgW3Jlc2l6ZSBiIG1vcmVdIGlzIGNhbGxlZCwgYSBkaXJlY3QgYWNjZXNzIG9mXG4gICBzaXplIFttb3JlXSBhdCBbYi5wb3NpdGlvbl0gd2lsbCBhbHdheXMgYmUgaW4tYm91bmRzLCBzbyB0aGF0XG4gICAodW5zYWZlX3tnZXQsc2V0fSkgbWF5IGJlIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuKilcbmxldCByZXNpemUgYiBtb3JlID1cbiAgbGV0IG9sZF9wb3MgPSBiLnBvc2l0aW9uIGluXG4gIGxldCBvbGRfbGVuID0gYi5sZW5ndGggaW5cbiAgbGV0IG5ld19sZW4gPSByZWYgb2xkX2xlbiBpblxuICB3aGlsZSBvbGRfcG9zICsgbW9yZSA+ICFuZXdfbGVuIGRvIG5ld19sZW4gOj0gMiAqICFuZXdfbGVuIGRvbmU7XG4gIGlmICFuZXdfbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBpZiBvbGRfcG9zICsgbW9yZSA8PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICB0aGVuIG5ld19sZW4gOj0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgZWxzZSBmYWlsd2l0aCBcIkJ1ZmZlci5hZGQ6IGNhbm5vdCBncm93IGJ1ZmZlclwiXG4gIGVuZDtcbiAgbGV0IG5ld19idWZmZXIgPSBCeXRlcy5jcmVhdGUgIW5ld19sZW4gaW5cbiAgKCogUFIjNjE0ODogbGV0J3Mga2VlcCB1c2luZyBbYmxpdF0gcmF0aGVyIHRoYW4gW3Vuc2FmZV9ibGl0XSBpblxuICAgICB0aGlzIHRyaWNreSBmdW5jdGlvbiB0aGF0IGlzIHNsb3cgYW55d2F5LiAqKVxuICBCeXRlcy5ibGl0IGIuYnVmZmVyIDAgbmV3X2J1ZmZlciAwIGIucG9zaXRpb247XG4gIGIuYnVmZmVyIDwtIG5ld19idWZmZXI7XG4gIGIubGVuZ3RoIDwtICFuZXdfbGVuO1xuICBhc3NlcnQgKGIucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoKTtcbiAgYXNzZXJ0IChvbGRfcG9zICsgbW9yZSA8PSBiLmxlbmd0aCk7XG4gICgpXG4gICgqIE5vdGU6IHRoZXJlIGFyZSB2YXJpb3VzIHNpdHVhdGlvbnMgKHByZWVtcHRpdmUgdGhyZWFkcywgc2lnbmFscyBhbmRcbiAgICAgZ2MgZmluYWxpemVycykgd2hlcmUgT0NhbWwgY29kZSBtYXkgYmUgcnVuIGFzeW5jaHJvbm91c2x5OyBpblxuICAgICBwYXJ0aWN1bGFyLCB0aGVyZSBtYXkgYmUgYSByYWNlIHdpdGggYW5vdGhlciB1c2VyIG9mIFtiXSwgY2hhbmdpbmdcbiAgICAgaXRzIG11dGFibGUgZmllbGRzIGluIHRoZSBtaWRkbGUgb2YgdGhlIFtyZXNpemVdIGNhbGwuIFRoZSBCdWZmZXJcbiAgICAgbW9kdWxlIGRvZXMgbm90IHByb3ZpZGUgYW55IGNvcnJlY3RuZXNzIGd1YXJhbnRlZSBpZiB0aGF0IGhhcHBlbnMsXG4gICAgIGJ1dCB3ZSBtdXN0IHN0aWxsIGVuc3VyZSB0aGF0IHRoZSBkYXRhc3RydWN0dXJlIGludmFyaWFudHMgaG9sZCBmb3JcbiAgICAgbWVtb3J5LXNhZmV0eSAtLSBhcyB3ZSBwbGFuIHRvIHVzZSBbdW5zYWZlX3tnZXQsc2V0fV0uXG5cbiAgICAgVGhlcmUgYXJlIHR3byBwb3RlbnRpYWwgYWxsb2NhdGlvbiBwb2ludHMgaW4gdGhpcyBmdW5jdGlvbixcbiAgICAgW3JlZl0gYW5kIFtCeXRlcy5jcmVhdGVdLCBidXQgYWxsIHJlYWRzIGFuZCB3cml0ZXMgdG8gdGhlIGZpZWxkc1xuICAgICBvZiBbYl0gaGFwcGVuIGJlZm9yZSBib3RoIG9mIHRoZW0gb3IgYWZ0ZXIgYm90aCBvZiB0aGVtLlxuXG4gICAgIFdlIHRoZXJlZm9yZSBhc3N1bWUgdGhhdCBbYi5wb3NpdGlvbl0gbWF5IGNoYW5nZSBhdCB0aGVzZSBhbGxvY2F0aW9ucyxcbiAgICAgYW5kIGNoZWNrIHRoYXQgdGhlIFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aF0gcG9zdGNvbmRpdGlvblxuICAgICBob2xkcyBmb3IgYm90aCB2YWx1ZXMgb2YgW2IucG9zaXRpb25dLCBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGZ1bmN0aW9uXG4gICAgIGlzIGNhbGxlZC4gTW9yZSBwcmVjaXNlbHksIHRoZSBmb2xsb3dpbmcgaW52YXJpYW50cyBtdXN0IGhvbGQgaWYgdGhlXG4gICAgIGZ1bmN0aW9uIHJldHVybnMgY29ycmVjdGx5LCBpbiBhZGRpdGlvbiB0byB0aGUgdXN1YWwgYnVmZmVyIGludmFyaWFudHM6XG4gICAgIC0gW29sZChiLnBvc2l0aW9uKSArIG1vcmUgPD0gbmV3KGIubGVuZ3RoKV1cbiAgICAgLSBbbmV3KGIucG9zaXRpb24pICsgbW9yZSA8PSBuZXcoYi5sZW5ndGgpXVxuICAgICAtIFtvbGQoYi5sZW5ndGgpIDw9IG5ldyhiLmxlbmd0aCldXG5cbiAgICAgTm90ZTogW2IucG9zaXRpb24gKyBtb3JlIDw9IG9sZChiLmxlbmd0aCldIGRvZXMgKm5vdCpcbiAgICAgaG9sZCBpbiBnZW5lcmFsLCBhcyBpdCBpcyBwcmVjaXNlbHkgdGhlIGNhc2Ugd2hlcmUgeW91IG5lZWRcbiAgICAgdG8gY2FsbCBbcmVzaXplXSB0byBpbmNyZWFzZSBbYi5sZW5ndGhdLlxuXG4gICAgIE5vdGU6IFthc3NlcnRdIGFib3ZlIGRvZXMgbm90IG1lYW4gdGhhdCB3ZSBrbm93IHRoZSBjb25kaXRpb25zXG4gICAgIGFsd2F5cyBob2xkLCBidXQgdGhhdCB0aGUgZnVuY3Rpb24gbWF5IHJldHVybiBjb3JyZWN0bHlcbiAgICAgb25seSBpZiB0aGV5IGhvbGQuXG5cbiAgICAgTm90ZTogdGhlIG90aGVyIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSBkb2VzIG5vdCBuZWVkXG4gICAgIHRvIGJlIGNoZWNrZWQgd2l0aCB0aGlzIGxldmVsIG9mIHNjcnV0aW55LCBnaXZlbiB0aGF0IHRoZXlcbiAgICAgcmVhZC93cml0ZSB0aGUgYnVmZmVyIGltbWVkaWF0ZWx5IGFmdGVyIGNoZWNraW5nIHRoYXRcbiAgICAgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoXSBob2xkIG9yIGNhbGxpbmcgW3Jlc2l6ZV0uXG4gICopXG5cbmxldCBhZGRfY2hhciBiIGMgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5sZW5ndGggdGhlbiByZXNpemUgYiAxO1xuICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIHBvcyBjO1xuICBiLnBvc2l0aW9uIDwtIHBvcyArIDFcblxubGV0IHVjaGFyX3V0Zl84X2J5dGVfbGVuZ3RoX21heCA9IDRcbmxldCB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4ID0gNFxuXG5sZXQgcmVjIGFkZF91dGZfOF91Y2hhciBiIHUgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5sZW5ndGggdGhlbiByZXNpemUgYiB1Y2hhcl91dGZfOF9ieXRlX2xlbmd0aF9tYXg7XG4gIGxldCBuID0gQnl0ZXMuc2V0X3V0Zl84X3VjaGFyIGIuYnVmZmVyIHBvcyB1IGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gKHJlc2l6ZSBiIHVjaGFyX3V0Zl84X2J5dGVfbGVuZ3RoX21heDsgYWRkX3V0Zl84X3VjaGFyIGIgdSlcbiAgZWxzZSAoYi5wb3NpdGlvbiA8LSBwb3MgKyBuKVxuXG5sZXQgcmVjIGFkZF91dGZfMTZiZV91Y2hhciBiIHUgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5sZW5ndGggdGhlbiByZXNpemUgYiB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4O1xuICBsZXQgbiA9IEJ5dGVzLnNldF91dGZfMTZiZV91Y2hhciBiLmJ1ZmZlciBwb3MgdSBpblxuICBpZiBuID0gMFxuICB0aGVuIChyZXNpemUgYiB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4OyBhZGRfdXRmXzE2YmVfdWNoYXIgYiB1KVxuICBlbHNlIChiLnBvc2l0aW9uIDwtIHBvcyArIG4pXG5cbmxldCByZWMgYWRkX3V0Zl8xNmxlX3VjaGFyIGIgdSA9XG4gIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gIGlmIHBvcyA+PSBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIHVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXg7XG4gIGxldCBuID0gQnl0ZXMuc2V0X3V0Zl8xNmxlX3VjaGFyIGIuYnVmZmVyIHBvcyB1IGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gKHJlc2l6ZSBiIHVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXg7IGFkZF91dGZfMTZsZV91Y2hhciBiIHUpXG4gIGVsc2UgKGIucG9zaXRpb24gPC0gcG9zICsgbilcblxubGV0IGFkZF9zdWJzdHJpbmcgYiBzIG9mZnNldCBsZW4gPVxuICBpZiBvZmZzZXQgPCAwIHx8IGxlbiA8IDAgfHwgb2Zmc2V0ID4gU3RyaW5nLmxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX3N1YnN0cmluZy9hZGRfc3ViYnl0ZXNcIjtcbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIG9mZnNldCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9zdWJieXRlcyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGFkZF9zdWJzdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKSBvZmZzZXQgbGVuXG5cbmxldCBhZGRfc3RyaW5nIGIgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIDAgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfYnl0ZXMgYiBzID0gYWRkX3N0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpXG5cbmxldCBhZGRfYnVmZmVyIGIgYnMgPVxuICBhZGRfc3ViYnl0ZXMgYiBicy5idWZmZXIgMCBicy5wb3NpdGlvblxuXG4oKiB0aGlzIChwcml2YXRlKSBmdW5jdGlvbiBjb3VsZCBtb3ZlIGludG8gdGhlIHN0YW5kYXJkIGxpYnJhcnkgKilcbmxldCByZWFsbHlfaW5wdXRfdXBfdG8gaWMgYnVmIG9mcyBsZW4gPVxuICBsZXQgcmVjIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQgfm9mcyB+dG9fcmVhZCA9XG4gICAgaWYgdG9fcmVhZCA9IDAgdGhlbiBhbHJlYWR5X3JlYWRcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGlucHV0IGljIGJ1ZiBvZnMgdG9fcmVhZCBpblxuICAgICAgaWYgciA9IDAgdGhlbiBhbHJlYWR5X3JlYWRcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGFscmVhZHlfcmVhZCA9IGFscmVhZHlfcmVhZCArIHIgaW5cbiAgICAgICAgbGV0IG9mcyA9IG9mcyArIHIgaW5cbiAgICAgICAgbGV0IHRvX3JlYWQgPSB0b19yZWFkIC0gciBpblxuICAgICAgICBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkIH5vZnMgfnRvX3JlYWRcbiAgICAgIGVuZFxuICAgIGVuZFxuICBpbiBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkOjAgfm9mcyB+dG9fcmVhZDpsZW5cblxuXG5sZXQgdW5zYWZlX2FkZF9jaGFubmVsX3VwX3RvIGIgaWMgbGVuID1cbiAgaWYgYi5wb3NpdGlvbiArIGxlbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBsZXQgbiA9IHJlYWxseV9pbnB1dF91cF90byBpYyBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbiBpblxuICAoKiBUaGUgYXNzZXJ0aW9uIGJlbG93IG1heSBmYWlsIGluIHdlaXJkIHNjZW5hcmlvIHdoZXJlXG4gICAgIHRocmVhZGVkL2ZpbmFsaXplciBjb2RlLCBydW4gYXN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZVxuICAgICBbcmVhbGx5X2lucHV0X3VwX3RvXSBjYWxsLCByYWNlcyBvbiB0aGUgYnVmZmVyOyB3ZSBkb24ndCBlbnN1cmVcbiAgICAgY29ycmVjdG5lc3MgaW4gdGhpcyBjYXNlLCBidXQgbmVlZCB0byBwcmVzZXJ2ZSB0aGUgaW52YXJpYW50cyBmb3JcbiAgICAgbWVtb3J5LXNhZmV0eSAoc2VlIGRpc2N1c3Npb24gb2YgW3Jlc2l6ZV0pLiAqKVxuICBhc3NlcnQgKGIucG9zaXRpb24gKyBuIDw9IGIubGVuZ3RoKTtcbiAgYi5wb3NpdGlvbiA8LSBiLnBvc2l0aW9uICsgbjtcbiAgblxuXG5sZXQgYWRkX2NoYW5uZWwgYiBpYyBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IGxlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuICAgKCogUFIjNTAwNCAqKVxuICAgIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9jaGFubmVsXCI7XG4gIGxldCBuID0gdW5zYWZlX2FkZF9jaGFubmVsX3VwX3RvIGIgaWMgbGVuIGluXG4gICgqIEl0IGlzIGludGVudGlvbmFsIHRoYXQgYSBjb25zdW1lciBjYXRjaGluZyBFbmRfb2ZfZmlsZVxuICAgICB3aWxsIHNlZSB0aGUgZGF0YSB3cml0dGVuIChzZWUgIzY3MTksICM3MTM2KS4gKilcbiAgaWYgbiA8IGxlbiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAoKVxuXG5sZXQgb3V0cHV0X2J1ZmZlciBvYyBiID1cbiAgb3V0cHV0IG9jIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgY2xvc2luZyA9IGZ1bmN0aW9uXG4gIHwgJygnIC0+ICcpJ1xuICB8ICd7JyAtPiAnfSdcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4oKiBvcGVuaW5nIGFuZCBjbG9zaW5nOiBvcGVuIGFuZCBjbG9zZSBjaGFyYWN0ZXJzLCB0eXBpY2FsbHkgKCBhbmQgKVxuICAgazogYmFsYW5jZSBvZiBvcGVuaW5nIGFuZCBjbG9zaW5nIGNoYXJzXG4gICBzOiB0aGUgc3RyaW5nIHdoZXJlIHdlIGFyZSBzZWFyY2hpbmdcbiAgIHN0YXJ0OiB0aGUgaW5kZXggd2hlcmUgd2Ugc3RhcnQgdGhlIHNlYXJjaC4gKilcbmxldCBhZHZhbmNlX3RvX2Nsb3Npbmcgb3BlbmluZyBjbG9zaW5nIGsgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBrIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gICAgaWYgcy5baV0gPSBvcGVuaW5nIHRoZW4gYWR2YW5jZSAoayArIDEpIChpICsgMSkgbGltIGVsc2VcbiAgICBpZiBzLltpXSA9IGNsb3NpbmcgdGhlblxuICAgICAgaWYgayA9IDAgdGhlbiBpIGVsc2UgYWR2YW5jZSAoayAtIDEpIChpICsgMSkgbGltXG4gICAgZWxzZSBhZHZhbmNlIGsgKGkgKyAxKSBsaW0gaW5cbiAgYWR2YW5jZSBrIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbmxldCBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIGxpbSBlbHNlXG4gICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknIHwgJ18nIC0+IGFkdmFuY2UgKGkgKyAxKSBsaW1cbiAgICB8IF8gLT4gaSBpblxuICBhZHZhbmNlIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbigqIFdlIGFyZSBqdXN0IGF0IHRoZSBiZWdpbm5pbmcgb2YgYW4gaWRlbnQgaW4gcywgc3RhcnRpbmcgYXQgc3RhcnQuICopXG5sZXQgZmluZF9pZGVudCBzIHN0YXJ0IGxpbSA9XG4gIGlmIHN0YXJ0ID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIG1hdGNoIHMuW3N0YXJ0XSB3aXRoXG4gICgqIFBhcmVudGhlc2l6ZWQgaWRlbnQgPyAqKVxuICB8ICcoJyB8ICd7JyBhcyBjIC0+XG4gICAgIGxldCBuZXdfc3RhcnQgPSBzdGFydCArIDEgaW5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX2Nsb3NpbmcgYyAoY2xvc2luZyBjKSAwIHMgbmV3X3N0YXJ0IGluXG4gICAgIFN0cmluZy5zdWIgcyBuZXdfc3RhcnQgKHN0b3AgLSBzdGFydCAtIDEpLCBzdG9wICsgMVxuICAoKiBSZWd1bGFyIGlkZW50ICopXG4gIHwgXyAtPlxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgKHN0YXJ0ICsgMSkgaW5cbiAgICAgU3RyaW5nLnN1YiBzIHN0YXJ0IChzdG9wIC0gc3RhcnQpLCBzdG9wXG5cbigqIFN1YnN0aXR1dGUgJGlkZW50LCAkKGlkZW50KSwgb3IgJHtpZGVudH0gaW4gcyxcbiAgICBhY2NvcmRpbmcgdG8gdGhlIGZ1bmN0aW9uIG1hcHBpbmcgZi4gKilcbmxldCBhZGRfc3Vic3RpdHV0ZSBiIGYgcyA9XG4gIGxldCBsaW0gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBzdWJzdCBwcmV2aW91cyBpID1cbiAgICBpZiBpIDwgbGltIHRoZW4gYmVnaW5cbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJyQnIGFzIGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJyQnIC0+XG4gICAgICAgICBsZXQgaiA9IGkgKyAxIGluXG4gICAgICAgICBsZXQgaWRlbnQsIG5leHRfaSA9IGZpbmRfaWRlbnQgcyBqIGxpbSBpblxuICAgICAgICAgYWRkX3N0cmluZyBiIChmIGlkZW50KTtcbiAgICAgICAgIHN1YnN0ICcgJyBuZXh0X2lcbiAgICAgIHwgY3VycmVudCB3aGVuIHByZXZpb3VzID09ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiAnXFxcXCc7XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnXFxcXCcgYXMgY3VycmVudCAtPlxuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgICB8IGN1cnJlbnQgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgIGVuZCBlbHNlXG4gICAgaWYgcHJldmlvdXMgPSAnXFxcXCcgdGhlbiBhZGRfY2hhciBiIHByZXZpb3VzIGluXG4gIHN1YnN0ICcgJyAwXG5cbmxldCB0cnVuY2F0ZSBiIGxlbiA9XG4gICAgaWYgbGVuIDwgMCB8fCBsZW4gPiBsZW5ndGggYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci50cnVuY2F0ZVwiXG4gICAgZWxzZVxuICAgICAgYi5wb3NpdGlvbiA8LSBsZW5cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgKCogTm90ZSB0aGF0IGIucG9zaXRpb24gaXMgbm90IGEgY29uc3RhbnQgYW5kIGNhbm5vdCBiZSBsaWZ0ZWQgb3V0IG9mIGF1eCAqKVxuICAgIGlmIGkgPj0gYi5wb3NpdGlvbiB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICgqIE5vdGUgdGhhdCBiLnBvc2l0aW9uIGlzIG5vdCBhIGNvbnN0YW50IGFuZCBjYW5ub3QgYmUgbGlmdGVkIG91dCBvZiBhdXggKilcbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgYWRkX3NlcSBiIHNlcSA9IFNlcS5pdGVyIChhZGRfY2hhciBiKSBzZXFcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IGIgPSBjcmVhdGUgMzIgaW5cbiAgYWRkX3NlcSBiIGk7XG4gIGJcblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDE2IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQxNnVcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQzMiA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQzMnVcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ2NCA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NHVcIlxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIlxuZXh0ZXJuYWwgc3dhcDMyIDogaW50MzIgLT4gaW50MzIgPSBcIiVic3dhcF9pbnQzMlwiXG5leHRlcm5hbCBzd2FwNjQgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWJzd2FwX2ludDY0XCJcblxuXG5sZXQgYWRkX2ludDggYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyAxIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMTtcbiAgdW5zYWZlX3NldF9pbnQ4IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDIgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICB1bnNhZmVfc2V0X2ludDE2IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQzMl9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDQgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICB1bnNhZmVfc2V0X2ludDMyIGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQ2NF9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDggaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA4O1xuICB1bnNhZmVfc2V0X2ludDY0IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9sZSBiIHggPVxuICBhZGRfaW50MTZfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50MTZfYmUgYiB4ID1cbiAgYWRkX2ludDE2X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXAxNiB4KVxuXG5sZXQgYWRkX2ludDMyX2xlIGIgeCA9XG4gIGFkZF9pbnQzMl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQzMl9iZSBiIHggPVxuICBhZGRfaW50MzJfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDMyIHgpXG5cbmxldCBhZGRfaW50NjRfbGUgYiB4ID1cbiAgYWRkX2ludDY0X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDY0X2JlIGIgeCA9XG4gIGFkZF9pbnQ2NF9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwNjQgeClcblxubGV0IGFkZF91aW50OCA9IGFkZF9pbnQ4XG5sZXQgYWRkX3VpbnQxNl9uZSA9IGFkZF9pbnQxNl9uZVxubGV0IGFkZF91aW50MTZfbGUgPSBhZGRfaW50MTZfbGVcbmxldCBhZGRfdWludDE2X2JlID0gYWRkX2ludDE2X2JlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICgqIFRvb2xzIHRvIG1hbmlwdWxhdGUgc2Nhbm5pbmcgc2V0IG9mIGNoYXJzIChzZWUgJVsuLi5dKSAqKVxuXG50eXBlIG11dGFibGVfY2hhcl9zZXQgPSBieXRlc1xuXG4oKiBDcmVhdGUgYSBmcmVzaCwgZW1wdHksIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgY3JlYXRlX2NoYXJfc2V0ICgpID0gQnl0ZXMubWFrZSAzMiAnXFwwMDAnXG5cbigqIEFkZCBhIGNoYXIgaW4gYSBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIEJ5dGVzLnNldCBjaGFyX3NldCBzdHJfaW5kXG4gICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoQnl0ZXMuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxvciBtYXNrKSlcblxubGV0IGZyZWV6ZV9jaGFyX3NldCBjaGFyX3NldCA9XG4gIEJ5dGVzLnRvX3N0cmluZyBjaGFyX3NldFxuXG4oKiBDb21wdXRlIHRoZSBjb21wbGVtZW50IG9mIGEgY2hhciBzZXQuICopXG5sZXQgcmV2X2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgbGV0IGNoYXJfc2V0JyA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICBmb3IgaSA9IDAgdG8gMzEgZG9cbiAgICBCeXRlcy5zZXQgY2hhcl9zZXQnIGlcbiAgICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgaSkgbHhvciAweEZGKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY2hhcl9zZXQnXG5cbigqIFJldHVybiB0cnVlIGlmIGEgYGMnIGlzIGluIGBjaGFyX3NldCcuICopXG5sZXQgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbGFuZCBtYXNrKSA8PiAwXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBJZ25vcmVkIHBhcmFtIGNvbnZlcnNpb24gKilcblxuKCogR0FEVCB1c2VkIHRvIGFic3RyYWN0IGFuIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVyLiAqKVxuKCogU2VlIHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdC4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmIgPSBQYXJhbV9mb3JtYXRfRUJCIDpcbiAgICAoJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmJcblxuKCogQ29tcHV0ZSBhIHBhZGRpbmcgYXNzb2NpYXRlZCB0byBhIHBhZF9vcHRpb24gKHNlZSBcIiVfNDJkXCIpLiAqKVxubGV0IHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3BhZGRpbmdcbiAgfCBTb21lIHdpZHRoIC0+IExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpXG5cbigqIENvbXB1dGUgYSBwcmVjaXNpb24gYXNzb2NpYXRlZCB0byBhIHByZWNfb3B0aW9uIChzZWUgXCIlXy40MmZcIikuICopXG5sZXQgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCA9IG1hdGNoIHByZWNfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3ByZWNpc2lvblxuICB8IFNvbWUgbmRlYyAtPiBMaXRfcHJlY2lzaW9uIG5kZWNcblxuKCogVHVybiBhbiBpZ25vcmVkIHBhcmFtIGludG8gaXRzIGVxdWl2YWxlbnQgbm90LWlnbm9yZWQgZm9ybWF0IG5vZGUuICopXG4oKiBVc2VkIGZvciBmb3JtYXQgcHJldHR5LXByaW50aW5nIGFuZCBTY2FuZi4gKilcbmxldCBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT4gKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhcmFtX2Zvcm1hdF9lYmIgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDaGFyIGZtdClcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfY2hhciBmbXQpXG4gIHwgSWdub3JlZF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFN0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX3N0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2ludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoSW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50MzIgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQzMiAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKE5hdGl2ZWludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDY0IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50NjQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9mbG9hdCAocGFkX29wdCwgcHJlY19vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZsb2F0ICgoRmxvYXRfZmxhZ18sIEZsb2F0X2YpLFxuICAgICAgICAgICAgICBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfYm9vbCBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQm9vbCAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX3JlYWRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFJlYWRlciBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX25leHRfY2hhciBmbXQpXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGVzICopXG5cbnR5cGUgKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuID1cbiAgfCBBY2Nfb3Blbl90YWcgb2YgKCdiLCAnYykgYWNjXG4gIHwgQWNjX29wZW5fYm94IG9mICgnYiwgJ2MpIGFjY1xuXG4oKiBSZXZlcnNlZCBsaXN0IG9mIHByaW50aW5nIGF0b21zLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHByaW50ZiBhcmd1bWVudHMuICopXG5hbmQgKCdiLCAnYykgYWNjID1cbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgb2YgKCdiLCAnYykgYWNjICogZm9ybWF0dGluZ19saXRcbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW5cbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIExpdGVyYWwgc3RyaW5nICopXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogTGl0ZXJhbCBjaGFyICopXG4gIHwgQWNjX2RhdGFfc3RyaW5nICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogR2VuZXJhdGVkIHN0cmluZyAqKVxuICB8IEFjY19kYXRhX2NoYXIgICAgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIEdlbmVyYXRlZCBjaGFyICopXG4gIHwgQWNjX2RlbGF5ICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAqICgnYiAtPiAnYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIERlbGF5ZWQgcHJpbnRpbmcgKCVhLCAldCkgKilcbiAgfCBBY2NfZmx1c2ggICAgICAgICAgb2YgKCdiLCAnYykgYWNjICAgICAgICAgICAgICAoKiBGbHVzaCAqKVxuICB8IEFjY19pbnZhbGlkX2FyZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmdcbiAgICAgICgqIFJhaXNlIEludmFsaWRfYXJndW1lbnQgbXNnICopXG4gIHwgRW5kX29mX2FjY1xuXG4oKiBMaXN0IG9mIGhldGVyb2dlbmVvdXMgdmFsdWVzLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHNjYW5mIGNhbGxiYWNrIGFyZ3VtZW50cy4gKilcbnR5cGUgKCdhLCAnYikgaGV0ZXJfbGlzdCA9XG4gIHwgQ29ucyA6ICdjICogKCdhLCAnYikgaGV0ZXJfbGlzdCAtPiAoJ2MgLT4gJ2EsICdiKSBoZXRlcl9saXN0XG4gIHwgTmlsIDogKCdiLCAnYikgaGV0ZXJfbGlzdFxuXG4oKiBFeGlzdGVudGlhbCBCbGFjayBCb3hlcy4gKilcbigqIFVzZWQgdG8gYWJzdHJhY3Qgc29tZSBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlcnMuICopXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZGRpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9IFBhZGRpbmdfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZHByZWMgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9IFBhZHByZWNfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3opIHByZWNpc2lvbiAqICgneiwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkZGluZ19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmIgPSBQYWRkaW5nX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHBhZGRpbmcgKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYiA9IFByZWNpc2lvbl9mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYiA9IFBhZHByZWNfZm10X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdwIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCB0aGUgJ2EgYW5kICdkIHBhcmFtZXRlcnMgb2YgYW4gZm10LiAqKVxuKCogT3V0cHV0IHR5cGUgb2YgdGhlIGZvcm1hdCBwYXJzaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmIgPSBGbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfZm9ybWF0X2dlbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgPSBGbXRfZm10dHlfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdCAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiID0gRm10dHlfZm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXR0eSAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXRfZm10dHlfZWJiIC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBmbXR0eSB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgZm9ybWF0IHR5cGVzLiAqKVxudHlwZSBmbXR0eV9lYmIgPSBGbXR0eV9FQkIgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT4gZm10dHlfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwYWRkaW5nIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwYWRkaW5ncy4gKilcbnR5cGUgcGFkZGluZ19lYmIgPSBQYWRkaW5nX0VCQiA6ICgnYSwgJ2IpIHBhZGRpbmcgLT4gcGFkZGluZ19lYmJcblxuKCogQWJzdHJhY3QgYWxsIHByZWNpc2lvbiB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcHJlY2lzaW9ucy4gKilcbnR5cGUgcHJlY2lzaW9uX2ViYiA9IFByZWNpc2lvbl9FQkIgOiAoJ2EsICdiKSBwcmVjaXNpb24gLT4gcHJlY2lzaW9uX2ViYlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnN0YW50cyAqKVxuXG4oKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgZmxvYXQgcHJpbnRpbmcuICopXG5sZXQgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYgPVxuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HIHwgRmxvYXRfaCB8IEZsb2F0X0hcbiAgfCBGbG9hdF9DRiAtPiAtNlxuICAoKiBGb3IgJWggJUggYW5kICUjRiBmb3JtYXRzLCBhIG5lZ2F0aXZlIHByZWNpc2lvbiBtZWFucyBcImFzIG1hbnkgZGlnaXRzIGFzXG4gICAgIG5lY2Vzc2FyeVwiLiAgRm9yIHRoZSBvdGhlciBGUCBmb3JtYXRzLCB3ZSB0YWtlIHRoZSBhYnNvbHV0ZSB2YWx1ZVxuICAgICBvZiB0aGUgcHJlY2lzaW9uLCBoZW5jZSA2IGRpZ2l0cyBieSBkZWZhdWx0LiAqKVxuICB8IEZsb2F0X0YgLT4gMTJcbiAgKCogRGVmYXVsdCBwcmVjaXNpb24gZm9yIE9DYW1sIGZsb2F0IHByaW50aW5nICglRikuICopXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXh0ZXJuYWxzICopXG5cbmV4dGVybmFsIGZvcm1hdF9mbG9hdDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfaW50MzI6IHN0cmluZyAtPiBpbnQzMiAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50MzJfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9uYXRpdmVpbnQ6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDY0OiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5leHRlcm5hbCBoZXhzdHJpbmdfb2ZfZmxvYXQ6IGZsb2F0IC0+IGludCAtPiBjaGFyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXRcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgKCogVG9vbHMgdG8gcHJldHR5LXByaW50IGZvcm1hdHMgKilcblxuKCogVHlwZSBvZiBleHRlbnNpYmxlIGNoYXJhY3RlciBidWZmZXJzLiAqKVxudHlwZSBidWZmZXIgPSB7XG4gIG11dGFibGUgaW5kIDogaW50O1xuICBtdXRhYmxlIGJ5dGVzIDogYnl0ZXM7XG59XG5cbigqIENyZWF0ZSBhIGZyZXNoIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY3JlYXRlIGluaXRfc2l6ZSA9IHsgaW5kID0gMDsgYnl0ZXMgPSBCeXRlcy5jcmVhdGUgaW5pdF9zaXplIH1cblxuKCogQ2hlY2sgc2l6ZSBvZiB0aGUgYnVmZmVyIGFuZCBncm93IGl0IGlmIG5lZWRlZC4gKilcbmxldCBidWZmZXJfY2hlY2tfc2l6ZSBidWYgb3ZlcmhlYWQgPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJ1Zi5ieXRlcyBpblxuICBsZXQgbWluX2xlbiA9IGJ1Zi5pbmQgKyBvdmVyaGVhZCBpblxuICBpZiBtaW5fbGVuID4gbGVuIHRoZW4gKFxuICAgIGxldCBuZXdfbGVuID0gSW50Lm1heCAobGVuICogMikgbWluX2xlbiBpblxuICAgIGxldCBuZXdfc3RyID0gQnl0ZXMuY3JlYXRlIG5ld19sZW4gaW5cbiAgICBCeXRlcy5ibGl0IGJ1Zi5ieXRlcyAwIG5ld19zdHIgMCBsZW47XG4gICAgYnVmLmJ5dGVzIDwtIG5ld19zdHI7XG4gIClcblxuKCogQWRkIHRoZSBjaGFyYWN0ZXIgYGMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjID1cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIDE7XG4gIEJ5dGVzLnNldCBidWYuYnl0ZXMgYnVmLmluZCBjO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyAxXG5cbigqIEFkZCB0aGUgc3RyaW5nIGBzJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzID1cbiAgbGV0IHN0cl9sZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIHN0cl9sZW47XG4gIFN0cmluZy5ibGl0IHMgMCBidWYuYnl0ZXMgYnVmLmluZCBzdHJfbGVuO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyBzdHJfbGVuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiB0aGUgYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jb250ZW50cyBidWYgPVxuICBCeXRlcy5zdWJfc3RyaW5nIGJ1Zi5ieXRlcyAwIGJ1Zi5pbmRcblxuKCoqKilcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIGNvbnZlcnNpb24gdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2ljb252IGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkIHwgSW50X0NkIC0+ICdkJyB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpXG4gIHwgSW50X0NpIC0+ICdpJyB8IEludF94IHwgSW50X0N4IC0+ICd4JyB8IEludF9YIHwgSW50X0NYIC0+ICdYJyB8IEludF9vXG4gIHwgSW50X0NvIC0+ICdvJyB8IEludF91IHwgSW50X0N1IC0+ICd1J1xuXG4oKiBDb252ZXJ0IGEgZmxvYXQgY29udmVyc2lvbiB0byBjaGFyLiAqKVxuKCogYGNGJyB3aWxsIGJlICdGJyBmb3IgZGlzcGxheWluZyBmb3JtYXQgYW5kICdnJyB0byBjYWxsIGxpYmMgcHJpbnRmICopXG5sZXQgY2hhcl9vZl9mY29udiA/KGNGPSdGJykgZmNvbnYgPSBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2YgLT4gJ2YnIHwgRmxvYXRfZSAtPiAnZSdcbiAgfCBGbG9hdF9FIC0+ICdFJyB8IEZsb2F0X2cgLT4gJ2cnXG4gIHwgRmxvYXRfRyAtPiAnRycgfCBGbG9hdF9GIC0+IGNGXG4gIHwgRmxvYXRfaCAtPiAnaCcgfCBGbG9hdF9IIC0+ICdIJ1xuICB8IEZsb2F0X0NGIC0+ICdGJ1xuXG5cbigqIENvbnZlcnQgYSBzY2FubmluZyBjb3VudGVyIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIgPSBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgIC0+ICdsJ1xuICB8IENoYXJfY291bnRlciAgLT4gJ24nXG4gIHwgVG9rZW5fY291bnRlciAtPiAnTidcblxuKCoqKilcblxuKCogUHJpbnQgYSBjaGFyX3NldCBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBPQ2FtbCBmb3JtYXQgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQgPVxuICBsZXQgcmVjIHByaW50X3N0YXJ0IHNldCA9XG4gICAgbGV0IGlzX2Fsb25lIGMgPVxuICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIgPSBDaGFyLihjaHIgKGNvZGUgYyAtIDEpLCBjaHIgKGNvZGUgYyArIDEpKSBpblxuICAgICAgaXNfaW5fY2hhcl9zZXQgc2V0IGNcbiAgICAgICYmIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IGJlZm9yZSAmJiBpc19pbl9jaGFyX3NldCBzZXQgYWZ0ZXIpIGluXG4gICAgaWYgaXNfYWxvbmUgJ10nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSc7XG4gICAgcHJpbnRfb3V0IHNldCAxO1xuICAgIGlmIGlzX2Fsb25lICctJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nO1xuICBhbmQgcHJpbnRfb3V0IHNldCBpID1cbiAgICBpZiBpIDwgMjU2IHRoZW5cbiAgICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlbiBwcmludF9maXJzdCBzZXQgaVxuICAgICAgZWxzZSBwcmludF9vdXQgc2V0IChpICsgMSlcbiAgYW5kIHByaW50X2ZpcnN0IHNldCBpID1cbiAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICdcXDI1NScgLT4gcHJpbnRfY2hhciBidWYgMjU1O1xuICAgIHwgJ10nIHwgJy0nIC0+IHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICB8IF8gLT4gcHJpbnRfc2Vjb25kIHNldCAoaSArIDEpO1xuICBhbmQgcHJpbnRfc2Vjb25kIHNldCBpID1cbiAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW5cbiAgICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgICAgfCAnXFwyNTUnIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NDtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU1O1xuICAgICAgfCAnXScgfCAnLScgd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICAgIHwgXyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDIpO1xuICAgICAgfCBfIC0+XG4gICAgICAgIHByaW50X2luIHNldCAoaSAtIDEpIChpICsgMik7XG4gICAgZWxzZSAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIClcbiAgYW5kIHByaW50X2luIHNldCBpIGogPVxuICAgIGlmIGogPSAyNTYgfHwgbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGopKSB0aGVuIChcbiAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaW50X29mX2NoYXIgJy0nKTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChqIC0gMSk7XG4gICAgICBpZiBqIDwgMjU2IHRoZW4gcHJpbnRfb3V0IHNldCAoaiArIDEpO1xuICAgICkgZWxzZVxuICAgICAgcHJpbnRfaW4gc2V0IGkgKGogKyAxKTtcbiAgYW5kIHByaW50X2NoYXIgYnVmIGkgPSBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICclJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgfCAnQCcgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0AnO1xuICAgIHwgYyAgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgaW5cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnWyc7XG4gIHByaW50X3N0YXJ0IChcbiAgICBpZiBpc19pbl9jaGFyX3NldCBjaGFyX3NldCAnXFwwMDAnXG4gICAgdGhlbiAoIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ14nOyByZXZfY2hhcl9zZXQgY2hhcl9zZXQgKVxuICAgIGVsc2UgY2hhcl9zZXRcbiAgKTtcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSdcblxuKCoqKilcblxuKCogUHJpbnQgYSBwYWR0eSBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eSA9IG1hdGNoIHBhZHR5IHdpdGhcbiAgfCBMZWZ0ICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICctJ1xuICB8IFJpZ2h0IC0+ICgpXG4gIHwgWmVyb3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnMCdcblxuKCogUHJpbnQgdGhlICdfJyBvZiBhbiBpZ25vcmVkIGZsYWcgaWYgbmVlZGVkLiAqKVxubGV0IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnID1cbiAgaWYgaWduX2ZsYWcgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICdfJ1xuXG4oKioqKVxuXG5sZXQgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSB3aWR0aCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgd2lkdGgpXG5cbigqKiopXG5cbigqIFByaW50IHBhZGRpbmcgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWRkaW5nIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHBhZGRpbmcgLT4gdW5pdCA9XG5mdW4gYnVmIHBhZCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT4gKClcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIG4pIC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyonXG5cbigqIFByaW50IHByZWNpc2lvbiBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3ByZWNpc2lvbiA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwcmVjaXNpb24gLT4gdW5pdCA9XG4gIGZ1biBidWYgcHJlYyAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gLT4gKClcbiAgfCBMaXRfcHJlY2lzaW9uIG4gLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIi4qXCJcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIG9yICcjJyBhc3NvY2lhdGVkIHRvIGFuIGludCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfcGQgfCBJbnRfcGkgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBJbnRfc2QgfCBJbnRfc2kgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBJbnRfQ3ggfCBJbnRfQ1ggfCBJbnRfQ28gfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyMnXG4gIHwgSW50X2QgfCBJbnRfaSB8IEludF94IHwgSW50X1ggfCBJbnRfbyB8IEludF91IC0+ICgpXG5cbigqIFByaW50IGFuIGNvbXBsZXRlIGludCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUzLipkXCIpLiAqKVxubGV0IGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyBjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIGFuZC9vciAnIycgYXNzb2NpYXRlZCB0byBhIGZsb2F0IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252ID1cbiAgYmVnaW4gbWF0Y2ggZnN0IGZjb252IHdpdGhcbiAgfCBGbG9hdF9mbGFnX3AgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBGbG9hdF9mbGFnX3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBGbG9hdF9mbGFnXyAtPiAoKSBlbmQ7XG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfQ0YgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfR1xuICB8IEZsb2F0X0YgfCBGbG9hdF9oIHwgRmxvYXRfSCAtPiAoKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZsb2F0IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJSsqLjNmXCIpLiAqKVxubGV0IGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfZmNvbnYgZmNvbnYpXG5cbigqIENvbXB1dGUgdGhlIGxpdGVyYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRm9ybWF0dGluZ19saXQuICopXG4oKiBVc2VkIGJ5IFByaW50ZiBhbmQgU2NhbmYgd2hlcmUgZm9ybWF0dGluZyBpcyBub3QgaW50ZXJwcmV0ZWQuICopXG5sZXQgc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0ID0gbWF0Y2ggZm9ybWF0dGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgIC0+IFwiQF1cIlxuICB8IENsb3NlX3RhZyAgICAgICAgICAgIC0+IFwiQH1cIlxuICB8IEJyZWFrIChzdHIsIF8sIF8pICAgIC0+IHN0clxuICB8IEZGbHVzaCAgICAgICAgICAgICAgIC0+IFwiQD9cIlxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgIC0+IFwiQFxcblwiXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgLT4gXCJALlwiXG4gIHwgTWFnaWNfc2l6ZSAoc3RyLCBfKSAgLT4gc3RyXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgLT4gXCJAQFwiXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgLT4gXCJAJVwiXG4gIHwgU2Nhbl9pbmRpYyBjIC0+IFwiQFwiIF4gKFN0cmluZy5tYWtlIDEgYylcblxuKCoqKilcblxuKCogUHJpbnQgYSBsaXRlcmFsIGNoYXIgaW4gYSBidWZmZXIsIGVzY2FwZSAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNociA9IG1hdGNoIGNociB3aXRoXG4gIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUlXCJcbiAgfCBfIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgY2hyXG5cbigqIFByaW50IGEgbGl0ZXJhbCBzdHJpbmcgaW4gYSBidWZmZXIsIGVzY2FwZSBhbGwgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0ciA9XG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHN0ciAtIDEgZG9cbiAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBzdHIuW2ldXG4gIGRvbmVcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHByZXR0eS1wcmludGluZyAqKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCB0eXBlIChhbiBmbXR0eSkgaW4gYSBidWZmZXIuICopXG5sZXQgcmVjIGJwcmludF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAgIGJ1ZmZlciAtPiAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IHVuaXQgPVxuZnVuIGJ1ZiBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlc1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludF90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVpXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbmlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDY0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVMaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWZcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBCb29sX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlQlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFscGhhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVhXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXRcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlP1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFJlYWRlcl90eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVyXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJV9yXCI7XG4gICAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV7XCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV9XCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eSwgXywgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKFwiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBFbmRfb2ZfZm10dHkgLT4gKClcblxuKCoqKilcblxubGV0IHJlYyBpbnRfb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSBhIGIgYyAuXG4gIChhLCBiLCBjKSBjdXN0b21fYXJpdHkgLT4gaW50ID1cbiAgZnVuY3Rpb25cbiAgfCBDdXN0b21femVybyAtPiAwXG4gIHwgQ3VzdG9tX3N1Y2MgeCAtPiAxICsgaW50X29mX2N1c3RvbV9hcml0eSB4XG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9mbXQgYnVmIGZtdCA9XG4gIGxldCByZWMgZm10aXRlciA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBib29sIC0+IHVuaXQgPVxuICBmdW4gZm10IGlnbl9mbGFnIC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ24nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ0wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdjJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdCJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2EnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICd0JzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgIGZvciBfaSA9IDEgdG8gaW50X29mX2N1c3RvbV9hcml0eSBhcml0eSBkb1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJz8nO1xuICAgICAgZG9uZTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFJlYWRlciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdyJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSFcIjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3snO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ30nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICcoJztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICcpJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiB3aWR0aF9vcHQ7IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQ7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIpO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBcIjBjXCI7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgbGV0IFBhcmFtX2Zvcm1hdF9FQkIgZm10JyA9IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdCBpblxuICAgICAgZm10aXRlciBmbXQnIHRydWU7XG5cbiAgICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQpO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgICBiZWdpbiBtYXRjaCBmbXRpbmdfZ2VuIHdpdGhcbiAgICAgIHwgT3Blbl90YWcgKEZvcm1hdCAoXywgc3RyKSkgLT5cbiAgICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiQHtcIjsgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHN0clxuICAgICAgfCBPcGVuX2JveCAoRm9ybWF0IChfLCBzdHIpKSAtPlxuICAgICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCJAW1wiOyBidWZmZXJfYWRkX3N0cmluZyBidWYgc3RyXG4gICAgICBlbmQ7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEVuZF9vZl9mb3JtYXQgLT4gKClcblxuICBpbiBmbXRpdGVyIGZtdCBmYWxzZVxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHRvIHN0cmluZy4gKilcbmxldCBzdHJpbmdfb2ZfZm10IGZtdCA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXQgYnVmIGZtdDtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlIGV4dHJhY3Rpb24gKilcblxudHlwZSAoXywgXykgZXEgPSBSZWZsIDogKCdhLCAnYSkgZXFcblxuKCogSW52YXJpYW50OiB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBpZGVudGl0eSBvbiB2YWx1ZXMuXG5cbiAgIEluIHBhcnRpY3VsYXIsIGlmICh0eTEsIHR5MikgaGF2ZSBlcXVhbCB2YWx1ZXMsIHRoZW5cbiAgICh0cmFucyAoc3ltbSB0eTEpIHR5MikgcmVzcGVjdHMgdGhlICd0cmFucycgcHJlY29uZGl0aW9uLiAqKVxubGV0IHJlYyBzeW1tIDogdHlwZSBhMSBiMSBjMSBkMSBlMSBmMSBhMiBiMiBjMiBkMiBlMiBmMiAuXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdHR5X3JlbFxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPiBDaGFyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT4gSW50X3R5IChzeW1tIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPiBJbnQzMl90eSAoc3ltbSByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT4gSW50NjRfdHkgKHN5bW0gcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBOYXRpdmVpbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+IEZsb2F0X3R5IChzeW1tIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+IEJvb2xfdHkgKHN5bW0gcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPiBTdHJpbmdfdHkgKHN5bW0gcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+IFRoZXRhX3R5IChzeW1tIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPiBBbHBoYV90eSAoc3ltbSByZXN0KVxuICB8IEFueV90eSByZXN0IC0+IEFueV90eSAoc3ltbSByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+IFJlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT4gSWdub3JlZF9yZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgc3ltbSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIsIHR5MSwgc3ltbSByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxubGV0IHJlYyBmbXR0eV9yZWxfZGV0IDogdHlwZSBhMSBiIGMgZDEgZTEgZjEgYTIgZDIgZTIgZjIgLlxuICAoYTEsIGIsIGMsIGQxLCBlMSwgZjEsXG4gICBhMiwgYiwgYywgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKChmMSwgZjIpIGVxIC0+IChhMSwgYTIpIGVxKVxuICAqICgoYTEsIGEyKSBlcSAtPiAoZjEsIGYyKSBlcSlcbiAgKiAoKGUxLCBlMikgZXEgLT4gKGQxLCBkMikgZXEpXG4gICogKChkMSwgZDIpIGVxIC0+IChlMSwgZTIpIGVxKVxuPSBmdW5jdGlvblxuICB8IEVuZF9vZl9mbXR0eSAtPlxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKVxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG5cbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBGb3JtYXRfYXJnX3R5IChfdHksIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBsZXQgYWcsIGdhLCBkaiwgamQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBsZXQgUmVmbCA9IGFnIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZ2EgUmVmbCBpbiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBsZXQgUmVmbCA9IGRqIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gamQgUmVmbCBpbiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcblxuKCogUHJlY29uZGl0aW9uOiB3ZSBhc3N1bWUgdGhhdCB0aGUgdHdvIGZtdHR5X3JlbCBhcmd1bWVudHMgaGF2ZSBlcXVhbFxuICAgdmFsdWVzIChhdCBwb3NzaWJseSBkaXN0aW5jdCB0eXBlcyk7IHRoaXMgaW52YXJpYW50IGNvbWVzIGZyb20gdGhlIHdheVxuICAgZm10dHlfcmVsIHdpdG5lc3NlcyBhcmUgcHJvZHVjZWQgYnkgdGhlIHR5cGUtY2hlY2tlclxuXG4gICBUaGUgY29kZSBiZWxvdyB1c2VzIChhc3NlcnQgZmFsc2UpIHdoZW4gdGhpcyBhc3N1bXB0aW9uIGlzIGJyb2tlbi4gVGhlXG4gICBjb2RlIHBhdHRlcm4gaXMgdGhlIGZvbGxvd2luZzpcblxuICAgICB8IEZvbyB4LCBGb28geSAtPlxuICAgICAgICgqIGNhc2Ugd2hlcmUgaW5kZWVkIGJvdGggdmFsdWVzXG4gICAgICAgICAgc3RhcnQgd2l0aCBjb25zdHJ1Y3RvciBGb28gKilcbiAgICAgfCBGb28gXywgX1xuICAgICB8IF8sIEZvbyBfIC0+XG4gICAgICAgKCogZGlmZmVyZW50IGhlYWQgY29uc3RydWN0b3JzOiBicm9rZW4gcHJlY29uZGl0aW9uICopXG4gICAgICAgYXNzZXJ0IGZhbHNlXG4qKVxuYW5kIHRyYW5zIDogdHlwZVxuICBhMSBiMSBjMSBkMSBlMSBmMVxuICBhMiBiMiBjMiBkMiBlMiBmMlxuICBhMyBiMyBjMyBkMyBlMyBmM1xuLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbi0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuPSBmdW4gdHkxIHR5MiAtPiBtYXRjaCB0eTEsIHR5MiB3aXRoXG4gIHwgQ2hhcl90eSByZXN0MSwgQ2hhcl90eSByZXN0MiAtPiBDaGFyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBTdHJpbmdfdHkgcmVzdDEsIFN0cmluZ190eSByZXN0MiAtPiBTdHJpbmdfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEJvb2xfdHkgcmVzdDEsIEJvb2xfdHkgcmVzdDIgLT4gQm9vbF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50X3R5IHJlc3QxLCBJbnRfdHkgcmVzdDIgLT4gSW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQzMl90eSByZXN0MSwgSW50MzJfdHkgcmVzdDIgLT4gSW50MzJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDY0X3R5IHJlc3QxLCBJbnQ2NF90eSByZXN0MiAtPiBJbnQ2NF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QxLCBOYXRpdmVpbnRfdHkgcmVzdDIgLT4gTmF0aXZlaW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBGbG9hdF90eSByZXN0MSwgRmxvYXRfdHkgcmVzdDIgLT4gRmxvYXRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuXG4gIHwgQWxwaGFfdHkgcmVzdDEsIEFscGhhX3R5IHJlc3QyIC0+IEFscGhhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbHBoYV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFscGhhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBUaGV0YV90eSByZXN0MSwgVGhldGFfdHkgcmVzdDIgLT4gVGhldGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFRoZXRhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgVGhldGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEFueV90eSByZXN0MSwgQW55X3R5IHJlc3QyIC0+IEFueV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQW55X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQW55X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBSZWFkZXJfdHkgcmVzdDEsIFJlYWRlcl90eSByZXN0MiAtPiBSZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFJlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFJlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDEsIElnbm9yZWRfcmVhZGVyX3R5IHJlc3QyIC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgSWdub3JlZF9yZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9hcmdfdHkgKHR5MSwgcmVzdDEpLCBGb3JtYXRfYXJnX3R5ICh0eTIsIHJlc3QyKSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHRyYW5zIHR5MSB0eTIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9hcmdfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfYXJnX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MTIsIHJlc3QxKSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MjEsIHR5MjIsIHJlc3QyKSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MTIpIHR5MjEgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkyMiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X3N1YnN0X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBFbmRfb2ZfZm10dHksIEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcbiAgfCBFbmRfb2ZfZm10dHksIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRW5kX29mX2ZtdHR5IC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcmVjIGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm9ybWF0dGluZ19nZW4gLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEV4dHJhY3QgdGhlIHR5cGUgcmVwcmVzZW50YXRpb24gKGFuIGZtdHR5KSBvZiBhIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG5cbiAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDMyX3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChOYXRpdmVpbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50NjRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoRmxvYXRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG5cbiAgfCBDaGFyIHJlc3QgICAgICAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBCb29sIChwYWQsIHJlc3QpICAgICAgICAgICAtPlxuICAgICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKEJvb2xfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAtPiBBbHBoYV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgVGhldGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gVGhldGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpICAgIC0+IGZtdHR5X29mX2N1c3RvbSBhcml0eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgUmVhZGVyIHJlc3QgICAgICAgICAgICAgICAgLT4gUmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHksIHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT4gU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPiBJbnRfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgIC0+IGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0XG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgIC0+XG4gICAgY29uY2F0X2ZtdHR5IChmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiBmbXRpbmdfZ2VuKSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0ICAgICAgICAgICAgICAtPiBFbmRfb2ZfZm10dHlcblxuYW5kIGZtdHR5X29mX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgKHksIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBhcml0eSBmbXR0eSAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gZm10dHlcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPiBBbnlfdHkgKGZtdHR5X29mX2N1c3RvbSBhcml0eSBmbXR0eSlcblxuKCogRXh0cmFjdCB0aGUgZm10dHkgb2YgYW4gaWdub3JlZCBwYXJhbWV0ZXIgZm9sbG93ZWQgYnkgdGhlIHJlc3Qgb2ZcbiAgIHRoZSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBjb25jYXRfZm10dHkgZm10dHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBJZ25vcmVkX3JlYWRlcl90eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHBhZGRpbmcgaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqc1wiKS4gKilcbmFuZCBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3BhZGRpbmcgXyAtPiBmbXR0eVxuICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBJbnRfdHkgZm10dHlcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHByZWNpc2lvbiBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJS4qZlwiKS4qKVxuYW5kIGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgfCBOb19wcmVjaXNpb24gICAgLT4gZm10dHlcbiAgICB8IExpdF9wcmVjaXNpb24gXyAtPiBmbXR0eVxuICAgIHwgQXJnX3ByZWNpc2lvbiAgIC0+IEludF90eSBmbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBpbmcgKilcblxuKCogRXhjZXB0aW9uIHJhaXNlZCB3aGVuIGEgZm9ybWF0IGRvZXMgbm90IG1hdGNoIGEgZ2l2ZW4gZm9ybWF0IHR5cGUuICopXG5leGNlcHRpb24gVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgcGFkZGluZy4gKilcbigqIFRha2UgYW4gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIHRoZSBpbnRlZ2VyIHNob3VsZCBiZSBrZXB0IGFzIGFyZ3VtZW50LiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRkaW5nIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZGRpbmdfZm10dHlfZWJiID1cbmZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkLCBmbXR0eSB3aXRoXG4gIHwgTm9fcGFkZGluZywgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTm9fcGFkZGluZywgZm10dHkpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTGl0X3BhZGRpbmcgKHBhZHR5LHcpLGZtdHR5KVxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBJbnRfdHkgcmVzdCAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoQXJnX3BhZGRpbmcgcGFkdHkscmVzdClcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogQ29udmVydCBhICh1cGFkZGluZywgdXByZWNpc2lvbikgdG8gYSAocGFkZGluZywgcHJlY2lzaW9uKS4gKilcbigqIFRha2Ugb25lIG9yIHR3byBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgbmVlZGVkLiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRwcmVjIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgeiAuXG4gICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6KSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZHByZWNfZm10dHlfZWJiID1cbmZ1biBwYWQgcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjLCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgfCBOb19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTm9fcHJlY2lzaW9uLCByZXN0KVxuICB8IExpdF9wcmVjaXNpb24gcCwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBMaXRfcHJlY2lzaW9uIHAsIHJlc3QpXG4gIHwgQXJnX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgSW50X3R5IHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgQXJnX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBfLCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgZm9ybWF0IGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbigqIElmIHR5cGluZyBzdWNjZWVkLCBnZW5lcmF0ZSBhIGNvcHkgb2YgdGhlIGZvcm1hdCB3aXRoIHRoZSBzYW1lXG4gICAgdHlwZSBwYXJhbWV0ZXJzIGFzIHRoZSBmbXR0eS4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHJlYyB0eXBlX2Zvcm1hdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSB3aXRoXG4gIHwgRm10X2ZtdHR5X0VCQiAoZm10JywgRW5kX29mX2ZtdHR5KSAtPiBmbXQnXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdF9nZW4gOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCBmbXQsIGZtdHR5IHdpdGhcbiAgfCBDaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhciBmbXQnLCBmbXR0eScpXG4gIHwgQ2FtbF9jaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9jaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBTdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQzMl90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50NjRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBGbG9hdF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQm9vbCAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgQm9vbF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQm9vbCAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsdXNoIGZtdF9yZXN0LCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZsdXNoIGZtdCcsIGZtdHR5JylcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXQnKSwgZm10dHknKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhcl9saXRlcmFsIChjaHIsIGZtdCcpLCBmbXR0eScpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWJfZm10dHkgPD4gRm10dHlfRUJCIHN1Yl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHknLCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHkxLCBfc3ViX2ZtdHR5MiwgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eTEpIHRoZW5cbiAgICAgIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPVxuICAgICAgdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IChlcmFzZV9yZWwgZm10dHlfcmVzdClcbiAgICBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5MSwgZm10JyksIGZtdHR5JylcbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEFscGhhIGZtdF9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEFscGhhIGZtdCcsIGZtdHR5JylcbiAgfCBUaGV0YSBmbXRfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChUaGV0YSBmbXQnLCBmbXR0eScpXG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmdfZ2VuLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2Zvcm1hdHRpbmdfZ2VuIGZvcm1hdHRpbmdfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3RcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgUmVhZGVyIGZtdF9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChSZWFkZXIgZm10JywgZm10dHknKVxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdF9yZXN0KSwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10JyksIGZtdHR5JylcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCksIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCcpLCBmbXR0eScpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbSBpZ24gcmVzdCBmbXR0eV9yZXN0XG5cbiAgfCBFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0IC0+IEZtdF9mbXR0eV9FQkIgKEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QpXG5cbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGExIGEzIGIxIGIzIGMxIGMzIGQxIGQzIGUxIGUyIGUzIGYxIGYyIGYzIC5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoZjEsIGIxLCBjMSwgZTEsIGUyLCBmMikgZm10IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIGZtdDAgZm10dHkwIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuXG4oKiBUeXBlIGFuIElnbm9yZWRfcGFyYW0gbm9kZSBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtIDogdHlwZSBwIHEgeCB5IHogdCB1IHYgYSBiIGMgZCBlIGYgLlxuICAgICh4LCB5LCB6LCB0LCBxLCBwKSBpZ25vcmVkIC0+XG4gICAgKHAsIHksIHosIHEsIHUsIHYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXRfZm10dHlfZWJiID1cbmZ1biBpZ24gZm10IGZtdHR5IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQgXyAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQzMiBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgXyAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQ2NCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mbG9hdCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSAoSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpKSBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHknLCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHkgZm10IGZtdHR5IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdHR5JylcbiAgfCBJZ25vcmVkX3JlYWRlciAtPiAoXG4gICAgbWF0Y2ggZm10dHkgd2l0aFxuICAgIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXQnKSwgZm10dHknKVxuICAgIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcblxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgOiB0eXBlIGExIGEyIGIxIGIyIGMxIGMyIGQxIGQyIGUxIGUyIGYxIGYyIC5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGQyLCBhMikgaWdub3JlZCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXQgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHkgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gaWduIGZtdCBmbXR0eSAtPlxuICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgaW5cbiAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoaWduLCBmbXQnKSwgZm10dHknKVxuXG4oKiBUeXBpbmcgb2YgdGhlIGNvbXBsZXggY2FzZTogXCIlXyguLi4lKVwiLiAqKVxuYW5kIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIDogdHlwZSB3IHggeSB6IHAgcyB0IHUgYSBiIGMgZCBlIGYgLlxuICAgICh3LCB4LCB5LCB6LCBzLCBwKSBmbXR0eSAtPlxuICAgIChwLCB4LCB5LCBzLCB0LCB1KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5X2ZtdF9lYmIgPVxuZnVuIHN1Yl9mbXR0eSBmbXQgZm10dHkgLT4gbWF0Y2ggc3ViX2ZtdHR5LCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSBzdWJfZm10dHlfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QsIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludF90eSBzdWJfZm10dHlfcmVzdCwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDMyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQ2NF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEZsb2F0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBCb29sX3R5IHN1Yl9mbXR0eV9yZXN0LCBCb29sX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChBbHBoYV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5LCBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1YjJfZm10dHkgPD4gRm10dHlfRUJCIHN1YjJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBzdWJfZm10dHlfcmVzdCcpLCBmbXQnKVxuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eSwgIHN1YjJfZm10dHksICBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgKCogVE9ETyBkZWZpbmUgRm10dHlfcmVsX0VCQiB0byByZW1vdmUgdGhvc2UgZXJhc2VfcmVsICopXG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgc3ViX2ZtdHR5JyA9IHRyYW5zIChzeW1tIHN1YjFfZm10dHknKSBzdWIyX2ZtdHR5JyBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHN1Yl9mbXR0eScgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiAoZXJhc2VfcmVsIHN1Yl9mbXR0eV9yZXN0KSBmbXQgZm10dHlfcmVzdFxuICAgIGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1tIHN1Yl9mbXR0eV9yZXN0JyksXG4gICAgICAgICAgICAgICAgICAgZm10JylcbiAgfCBFbmRfb2ZfZm10dHksIGZtdHR5IC0+XG4gICAgRm10dHlfZm10X0VCQiAoRW5kX29mX2ZtdHR5LCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIGByZWNhc3RgIGlzIGEgYml0IGRpc2FwcG9pbnRpbmcuIFRoZVxuICAgaW52YXJpYW50IHByb3ZpZGVkIGJ5IHRoZSB0eXBlIGFyZSB2ZXJ5IHN0cm9uZzogdGhlIGlucHV0IGZvcm1hdCdzXG4gICB0eXBlIGlzIGluIHJlbGF0aW9uIHRvIHRoZSBvdXRwdXQgdHlwZSdzIGFzIHdpdG5lc3NlZCBieSB0aGVcbiAgIGZtdHR5X3JlbCBhcmd1bWVudC4gT25lIHdvdWxkIGF0IGZpcnN0IGV4cGVjdCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICB0b3RhbCwgYW5kIGltcGxlbWVudGFibGUgYnkgZXhoYXVzdGl2ZSBwYXR0ZXJuIG1hdGNoaW5nLiBJbnN0ZWFkLFxuICAgd2UgcmV1c2UgdGhlIGhpZ2hseSBwYXJ0aWFsIGFuZCBtdWNoIGxlc3Mgd2VsbC1kZWZpbmVkIGZ1bmN0aW9uXG4gICBgdHlwZV9mb3JtYXRgIHRoYXQgaGFzIGxvc3QgYWxsIGtub3dsZWRnZSBvZiB0aGUgY29ycmVzcG9uZGVuY2VcbiAgIGJldHdlZW4gdGhlIGFyZ3VtZW50J3MgdHlwZXMuXG5cbiAgIEJlc2lkZXMgdGhlIGZhY3QgdGhhdCB0aGlzIGZ1bmN0aW9uIHJldXNlcyBhIGxvdCBvZiB0aGVcbiAgIGB0eXBlX2Zvcm1hdGAgbG9naWMgKGVnLjogc2VlaW5nIEludF90eSBpbiB0aGUgZm10dHkgcGFyYW1ldGVyIGRvZXNcbiAgIG5vdCBsZXQgeW91IG1hdGNoIG9uIEludCBvbmx5LCBhcyB5b3UgbWF5IGluIGZhY3QgaGF2ZSBGbG9hdFxuICAgKEFyZ19wYWRkaW5nLCAuLi4pIChcIiUuKmRcIikgYmVnaW5uaW5nIHdpdGggYW4gSW50X3R5KSwgaXQgaXMgYWxzb1xuICAgYSBwYXJ0aWFsIGZ1bmN0aW9uLCBiZWNhdXNlIHRoZSB0eXBpbmcgaW5mb3JtYXRpb24gaW4gYSBmb3JtYXQgaXNcbiAgIG5vdCBxdWl0ZSBlbm91Z2ggdG8gcmVjb25zdHJ1Y3QgaXQgdW5hbWJpZ3VvdXNseS4gRm9yIGV4YW1wbGUsIHRoZVxuICAgZm9ybWF0IHR5cGVzIG9mIFwiJWQlX3JcIiBhbmQgXCIlX3IlZFwiIGhhdmUgdGhlIHNhbWUgZm9ybWF0NlxuICAgcGFyYW1ldGVycywgYnV0IHRoZXkgYXJlIG5vdCBhdCBhbGwgZXhjaGFuZ2VhYmxlLCBhbmQgcHV0dGluZyBvbmVcbiAgIGluIHBsYWNlIG9mIHRoZSBvdGhlciBtdXN0IHJlc3VsdCBpbiBhIGR5bmFtaWMgZmFpbHVyZS5cblxuICAgR2l2ZW4gdGhhdDpcbiAgIC0gd2UnZCBoYXZlIHRvIGR1cGxpY2F0ZSBhIGxvdCBvZiBub24tdHJpdmlhbCB0eXBpbmcgbG9naWMgZnJvbSB0eXBlX2Zvcm1hdFxuICAgLSB0aGlzIHdvdWxkbid0IGV2ZW4gZWxpbWluYXRlIChhbGwpIHRoZSBkeW5hbWljIGZhaWx1cmVzXG4gICB3ZSBkZWNpZGVkIHRvIGp1c3QgcmV1c2UgdHlwZV9mb3JtYXQgZGlyZWN0bHkgZm9yIG5vdy5cbiopXG5sZXQgcmVjYXN0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyXG4gIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT5cbiAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQcmludGluZyB0b29scyAqKVxuXG4oKiBBZGQgcGFkZGluZyBzcGFjZXMgYXJvdW5kIGEgc3RyaW5nLiAqKVxubGV0IGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoIHN0ciA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGgsIHBhZHR5ID1cbiAgICBhYnMgd2lkdGgsXG4gICAgKCogd2hpbGUgbGl0ZXJhbCBwYWRkaW5nIHdpZHRocyBhcmUgYWx3YXlzIG5vbi1uZWdhdGl2ZSxcbiAgICAgICBkeW5hbWljYWxseS1zZXQgd2lkdGhzIChBcmdfcGFkZGluZywgZWcuICUqZCkgbWF5IGJlIG5lZ2F0aXZlO1xuICAgICAgIHdlIGludGVycHJldCB0aG9zZSBhcyBzcGVjaWZ5aW5nIGEgcGFkZGluZy10by10aGUtbGVmdDsgdGhpc1xuICAgICAgIG1lYW5zIHRoYXQgJzAnIG1heSBnZXQgZHJvcHBlZCBldmVuIGlmIGl0IHdhcyBleHBsaWNpdGx5IHNldCxcbiAgICAgICBidXQ6XG4gICAgICAgLSB0aGlzIGlzIHdoYXQgdGhlIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkb2VzLCBhbmRcbiAgICAgICAgIHdlIHByZXNlcnZlIGNvbXBhdGliaWxpdHkgaWYgcG9zc2libGVcbiAgICAgICAtIHdlIGNvdWxkIG9ubHkgc2lnbmFsIHRoaXMgaXNzdWUgYnkgZmFpbGluZyBhdCBydW50aW1lLFxuICAgICAgICAgd2hpY2ggaXMgbm90IHZlcnkgbmljZS4uLiAqKVxuICAgIGlmIHdpZHRoIDwgMCB0aGVuIExlZnQgZWxzZSBwYWR0eSBpblxuICBpZiB3aWR0aCA8PSBsZW4gdGhlbiBzdHIgZWxzZVxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHdpZHRoIChpZiBwYWR0eSA9IFplcm9zIHRoZW4gJzAnIGVsc2UgJyAnKSBpblxuICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICB8IExlZnQgIC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAwIGxlblxuICAgIHwgUmlnaHQgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDAgJiYgKHN0ci5bMF0gPSAnKycgfHwgc3RyLlswXSA9ICctJyB8fCBzdHIuWzBdID0gJyAnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAwIHN0ci5bMF07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHdpZHRoIC0gbGVuICsgMSkgKGxlbiAtIDEpXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDEgJiYgc3RyLlswXSA9ICcwJyAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHdpZHRoIC0gbGVuICsgMikgKGxlbiAtIDIpXG4gICAgfCBaZXJvcyAtPlxuICAgICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgZW5kO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEFkZCAnMCcgcGFkZGluZyB0byBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqKVxubGV0IGZpeF9pbnRfcHJlY2lzaW9uIHByZWMgc3RyID1cbiAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbWF0Y2ggc3RyLlswXSB3aXRoXG4gIHwgKCcrJyB8ICctJyB8ICcgJykgYXMgYyB3aGVuIHByZWMgKyAxID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAxKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDAgYztcbiAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHByZWMgLSBsZW4gKyAyKSAobGVuIC0gMSk7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgd2hlbiBwcmVjICsgMiA+IGxlbiAmJiBsZW4gPiAxICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAyKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHByZWMgLSBsZW4gKyA0KSAobGVuIC0gMik7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgd2hlbiBwcmVjID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgcHJlYyAnMCcgaW5cbiAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHByZWMgLSBsZW4pIGxlbjtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8IF8gLT5cbiAgICBzdHJcblxuKCogRXNjYXBlIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aW5nIGNvbnZlbnRpb24uICopXG5sZXQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nIHN0ciA9XG4gIGxldCBzdHIgPSBTdHJpbmcuZXNjYXBlZCBzdHIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXFwiJyBpblxuICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgcmVzIDEgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9pbnQvaW50MzIvbmF0aXZlaW50L2ludDY0IGZpcnN0IGFyZ3VtZW50XG4gICBmcm9tIGFuIGludF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9pY29udiA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlZFwiIHwgSW50X3BkIC0+IFwiJStkXCIgfCBJbnRfc2QgLT4gXCIlIGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJWlcIiB8IEludF9waSAtPiBcIiUraVwiIHwgSW50X3NpIC0+IFwiJSBpXCJcbiAgfCBJbnRfeCAtPiBcIiV4XCIgfCBJbnRfQ3ggLT4gXCIlI3hcIlxuICB8IEludF9YIC0+IFwiJVhcIiB8IEludF9DWCAtPiBcIiUjWFwiXG4gIHwgSW50X28gLT4gXCIlb1wiIHwgSW50X0NvIC0+IFwiJSNvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiV1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udkwgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJUxkXCIgfCBJbnRfcGQgLT4gXCIlK0xkXCIgfCBJbnRfc2QgLT4gXCIlIExkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVMaVwiIHwgSW50X3BpIC0+IFwiJStMaVwiIHwgSW50X3NpIC0+IFwiJSBMaVwiXG4gIHwgSW50X3ggLT4gXCIlTHhcIiB8IEludF9DeCAtPiBcIiUjTHhcIlxuICB8IEludF9YIC0+IFwiJUxYXCIgfCBJbnRfQ1ggLT4gXCIlI0xYXCJcbiAgfCBJbnRfbyAtPiBcIiVMb1wiIHwgSW50X0NvIC0+IFwiJSNMb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlTHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252bCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlbGRcIiB8IEludF9wZCAtPiBcIiUrbGRcIiB8IEludF9zZCAtPiBcIiUgbGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJWxpXCIgfCBJbnRfcGkgLT4gXCIlK2xpXCIgfCBJbnRfc2kgLT4gXCIlIGxpXCJcbiAgfCBJbnRfeCAtPiBcIiVseFwiIHwgSW50X0N4IC0+IFwiJSNseFwiXG4gIHwgSW50X1ggLT4gXCIlbFhcIiB8IEludF9DWCAtPiBcIiUjbFhcIlxuICB8IEludF9vIC0+IFwiJWxvXCIgfCBJbnRfQ28gLT4gXCIlI2xvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVsdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZuID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVuZFwiIHwgSW50X3BkIC0+IFwiJStuZFwiIHwgSW50X3NkIC0+IFwiJSBuZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlbmlcIiB8IEludF9waSAtPiBcIiUrbmlcIiB8IEludF9zaSAtPiBcIiUgbmlcIlxuICB8IEludF94IC0+IFwiJW54XCIgfCBJbnRfQ3ggLT4gXCIlI254XCJcbiAgfCBJbnRfWCAtPiBcIiVuWFwiIHwgSW50X0NYIC0+IFwiJSNuWFwiXG4gIHwgSW50X28gLT4gXCIlbm9cIiB8IEludF9DbyAtPiBcIiUjbm9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJW51XCJcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9mbG9hdCBmaXJzdCBhcmd1bWVudCBmcm9tIGEgZmxvYXRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYyA9XG4gICAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICAgIGxldCBzeW1iID0gY2hhcl9vZl9mY29udiB+Y0Y6J2cnIGZjb252IGluXG4gICAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIHByZWMpO1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgc3ltYjtcbiAgICBidWZmZXJfY29udGVudHMgYnVmXG5cbmxldCB0cmFuc2Zvcm1faW50X2FsdCBpY29udiBzID1cbiAgbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAtPlxuICAgIGxldCBkaWdpdHMgPVxuICAgICAgbGV0IG4gPSByZWYgMCBpblxuICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICAgfCAnMCcuLic5JyAtPiBpbmNyIG5cbiAgICAgICAgfCBfIC0+ICgpXG4gICAgICBkb25lO1xuICAgICAgIW5cbiAgICBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgKFN0cmluZy5sZW5ndGggcyArIChkaWdpdHMgLSAxKSAvIDMpIGluXG4gICAgbGV0IHBvcyA9IHJlZiAwIGluXG4gICAgbGV0IHB1dCBjID0gQnl0ZXMuc2V0IGJ1ZiAhcG9zIGM7IGluY3IgcG9zIGluXG4gICAgbGV0IGxlZnQgPSByZWYgKChkaWdpdHMgLSAxKSBtb2QgMyArIDEpIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICcwJy4uJzknIGFzIGMgLT5cbiAgICAgICAgICBpZiAhbGVmdCA9IDAgdGhlbiAocHV0ICdfJzsgbGVmdCA6PSAzKTsgZGVjciBsZWZ0OyBwdXQgY1xuICAgICAgfCBjIC0+IHB1dCBjXG4gICAgZG9uZTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ1ZlxuICB8IF8gLT4gc1xuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIGEgY29udmVyc2lvbi4gKilcbmxldCBjb252ZXJ0X2ludCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQgKGZvcm1hdF9vZl9pY29udiBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDMyIGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDMyIChmb3JtYXRfb2ZfaWNvbnZsIGljb252KSBuKVxubGV0IGNvbnZlcnRfbmF0aXZlaW50IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X25hdGl2ZWludCAoZm9ybWF0X29mX2ljb252biBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDY0IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDY0IChmb3JtYXRfb2ZfaWNvbnZMIGljb252KSBuKVxuXG4oKiBDb252ZXJ0IGEgZmxvYXQgdG8gc3RyaW5nLiAqKVxuKCogRml4IHNwZWNpYWwgY2FzZSBvZiBcIk9DYW1sIGZsb2F0IGZvcm1hdFwiLiAqKVxubGV0IGNvbnZlcnRfZmxvYXQgZmNvbnYgcHJlYyB4ID1cbiAgbGV0IGhleCAoKSA9XG4gICAgbGV0IHNpZ24gPVxuICAgICAgbWF0Y2ggZnN0IGZjb252IHdpdGhcbiAgICAgIHwgRmxvYXRfZmxhZ19wIC0+ICcrJ1xuICAgICAgfCBGbG9hdF9mbGFnX3MgLT4gJyAnXG4gICAgICB8IF8gLT4gJy0nIGluXG4gICAgaGV4c3RyaW5nX29mX2Zsb2F0IHggcHJlYyBzaWduIGluXG4gIGxldCBhZGRfZG90X2lmX25lZWRlZCBzdHIgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCByZWMgaXNfdmFsaWQgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgICAgfCAnLicgfCAnZScgfCAnRScgLT4gdHJ1ZVxuICAgICAgICB8IF8gLT4gaXNfdmFsaWQgKGkgKyAxKSBpblxuICAgIGlmIGlzX3ZhbGlkIDAgdGhlbiBzdHIgZWxzZSBzdHIgXiBcIi5cIiBpblxuICBsZXQgY2FtbF9zcGVjaWFsX3ZhbCBzdHIgPSBtYXRjaCBjbGFzc2lmeV9mbG9hdCB4IHdpdGhcbiAgICB8IEZQX25vcm1hbCB8IEZQX3N1Ym5vcm1hbCB8IEZQX3plcm8gLT4gc3RyXG4gICAgfCBGUF9pbmZpbml0ZSAtPiBpZiB4IDwgMC4wIHRoZW4gXCJuZWdfaW5maW5pdHlcIiBlbHNlIFwiaW5maW5pdHlcIlxuICAgIHwgRlBfbmFuIC0+IFwibmFuXCIgaW5cbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9oIC0+IGhleCAoKVxuICB8IEZsb2F0X0ggLT4gU3RyaW5nLnVwcGVyY2FzZV9hc2NpaSAoaGV4ICgpKVxuICB8IEZsb2F0X0NGIC0+IGNhbWxfc3BlY2lhbF92YWwgKGhleCAoKSlcbiAgfCBGbG9hdF9GIC0+XG4gICAgbGV0IHN0ciA9IGZvcm1hdF9mbG9hdCAoZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMpIHggaW5cbiAgICBjYW1sX3NwZWNpYWxfdmFsIChhZGRfZG90X2lmX25lZWRlZCBzdHIpXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cgLT5cbiAgICBmb3JtYXRfZmxvYXQgKGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjKSB4XG5cbigqIENvbnZlcnQgYSBjaGFyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGZvcm1hdF9jYW1sX2NoYXIgYyA9XG4gIGxldCBzdHIgPSBDaGFyLmVzY2FwZWQgYyBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcJycgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdHlwZSB0byBzdHJpbmcgKilcbmxldCBzdHJpbmdfb2ZfZm10dHkgZm10dHkgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10dHkgYnVmIGZtdHR5O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAoKiBHZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uICopXG5cbigqIE1ha2UgYSBnZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uLiAqKVxuKCogVXNlZCB0byBnZW5lcmF0ZSBQcmludGYgYW5kIEZvcm1hdCBwcmludGluZyBmdW5jdGlvbnMuICopXG4oKiBQYXJhbWV0ZXJzOlxuICAgICBrOiBhIGNvbnRpbnVhdGlvbiBmaW5hbGx5IGFwcGxpZWQgdG8gdGhlIG91dHB1dCBzdHJlYW0gYW5kIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgbzogdGhlIG91dHB1dCBzdHJlYW0gKHNlZSBrLCAlYSBhbmQgJXQpLlxuICAgICBhY2M6IHJldiBsaXN0IG9mIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXNoLCBmb3JtYXR0aW5nLCAuLi4pLlxuICAgICBmbXQ6IHRoZSBmb3JtYXQuICopXG5sZXQgcmVjIG1ha2VfcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfY2FtbF9jaGFyIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCAoZnVuIHN0ciAtPiBzdHIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQgaWNvbnZcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50MzIgaWNvbnZcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X25hdGl2ZWludCBpY29udlxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQ2NCBpY29udlxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBmY29udlxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgc3RyaW5nX29mX2Jvb2xcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgZnVuIGYgeCAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGVsYXkgKGFjYywgZnVuIG8gLT4gZiBvIHgpKSByZXN0XG4gIHwgVGhldGEgcmVzdCAtPlxuICAgIGZ1biBmIC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kZWxheSAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgbWFrZV9jdXN0b20gayBhY2MgcmVzdCBhcml0eSAoZiAoKSlcbiAgfCBSZWFkZXIgXyAtPlxuICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gKilcbiAgICAoKiBJbmRlZWQsIHNpbmNlIHByaW50ZiBhbmQgY28uIHRha2UgYSBmb3JtYXQ0IGFzIGFyZ3VtZW50LCB0aGUgJ2QgYW5kICdlXG4gICAgICAgdHlwZSBwYXJhbWV0ZXJzIG9mIGZtdCBhcmUgb2J2aW91c2x5IGVxdWFscy4gVGhlIFJlYWRlciBpcyB0aGVcbiAgICAgICBvbmx5IGNvbnN0cnVjdG9yIHdoaWNoIHRvdWNoICdkIGFuZCAnZSB0eXBlIHBhcmFtZXRlcnMgb2YgdGhlIGZvcm1hdFxuICAgICAgIHR5cGUsIGl0IGFkZHMgYW4gKC0+KSB0byB0aGUgJ2QgcGFyYW1ldGVycy4gQ29uc2VxdWVudGx5LCBhIGZvcm1hdDRcbiAgICAgICBjYW5ub3QgY29udGFpbiBhIFJlYWRlciBub2RlLCBleGNlcHQgaW4gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0b1xuICAgICAgIGFuICV7Li4uJX0uIEl0J3Mgbm90IGEgcHJvYmxlbSBiZWNhdXNlIG1ha2VfcHJpbnRmIGRvIG5vdCBjYWxsXG4gICAgICAgaXRzZWxmIHJlY3Vyc2l2ZWx5IG9uIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG8gJXsuLi4lfS4gKilcbiAgICBhc3NlcnQgZmFsc2VcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2ZsdXNoIGFjYykgcmVzdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2Nfc3RyaW5nX2xpdGVyYWwgKGFjYywgc3RyKSkgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19jaGFyX2xpdGVyYWwgKGFjYywgY2hyKSkgcmVzdFxuXG4gIHwgRm9ybWF0X2FyZyAoXywgc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHN0cmluZ19vZl9mbXR0eSBzdWJfZm10dHkgaW5cbiAgICAoZnVuIHN0ciAtPlxuICAgICAgaWdub3JlIHN0cjtcbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCB0eSkpIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT4gbWFrZV9wcmludGYgayBhY2NcbiAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICBsZXQgbmV3X2FjYyA9IEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJVtcIikgaW5cbiAgICBmdW4gXyAtPiBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgKCogVGhpcyBjYXNlIHNob3VsZCBiZSByZWZ1c2VkIGZvciBQcmludGYuICopXG4gICAgKCogQWNjZXB0ZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuICopXG4gICAgKCogSW50ZXJwcmV0ICVsLCAlbiBhbmQgJUwgYXMgJXUuICopXG4gICAgZnVuIG4gLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9pbnQgXCIldVwiIG4pIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9jaGFyIChhY2MsIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBtYWtlX2lnbm9yZWRfcGFyYW0gayBhY2MgaWduIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2xpdCAoYWNjLCBmbXRpbmdfbGl0KSkgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX3RhZyBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10J1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX2JveCBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10J1xuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIGsgYWNjXG5cbigqIERlbGF5IHRoZSBlcnJvciAoSW52YWxpZF9hcmd1bWVudCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikuICopXG4oKiBHZW5lcmF0ZSBmdW5jdGlvbnMgdG8gdGFrZSByZW1haW5pbmcgYXJndW1lbnRzIChhZnRlciB0aGUgXCIlX1wiKS4gKilcbmFuZCBtYWtlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuXG5cbigqIFNwZWNpYWwgY2FzZSBvZiBwcmludGYgXCIlXyhcIi4gKilcbmFuZCBtYWtlX2Zyb21fZm10dHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBmbXR0eSAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10dHkgZm10IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBCb29sX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFRoZXRhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFJlYWRlcl90eSBfICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8gICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEVuZF9vZl9mbXR0eSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyAoY29uY2F0X2ZtdHR5IHR5IHJlc3QpIGZtdFxuXG4oKiBJbnNlcnQgYW4gQWNjX2ludmFsaWRfYXJnIGluIHRoZSBhY2N1bXVsYXRvciBhbmQgY29udGludWUgdG8gZ2VuZXJhdGVcbiAgIGNsb3N1cmVzIHRvIGdldCB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cy4gKilcbmFuZCBtYWtlX2ludmFsaWRfYXJnIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10IC0+XG4gIG1ha2VfcHJpbnRmIGsgKEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikpIGZtdFxuXG4oKiBGaXggcGFkZGluZywgdGFrZSBpdCBhcyBhbiBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50IGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX3BhZGRpbmcgOiB0eXBlIHggeiBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeiAtPiBhKSBwYWRkaW5nIC0+ICh6IC0+IHN0cmluZykgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHRyYW5zIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCB0cmFucyB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuXG4oKiBGaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGZvciBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQuICopXG4oKiBUYWtlIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4gKGludF9jb252IC0+IHogLT4gc3RyaW5nKSAtPlxuICAgIGludF9jb252IC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCBwcmVjIHRyYW5zIGljb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSB0cmFucyBpY29udiB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5cbigqIENvbnZlcnQgYSBmbG9hdCwgZml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBpZiBuZWVkZWQuICopXG4oKiBUYWtlIHRoZSBmbG9hdCBhcmd1bWVudCBhbmQgb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh5LCBmbG9hdCAtPiBhKSBwcmVjaXNpb24gLT4gZmxvYXRfY29udiAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgcHJlYyBmY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuYW5kIG1ha2VfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiB4IC0+IHkgPVxuICBmdW4gayBhY2MgcmVzdCBhcml0eSBmIC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBtYWtlX2N1c3RvbSBrIGFjYyByZXN0IGFyaXR5IChmIHgpXG5cbmxldCBjb25zdCB4IF8gPSB4XG5cbmxldCByZWMgbWFrZV9pcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+IHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG4gIGZ1biBrIG8gZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IENhbWxfc3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEJvb2wgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9jdXN0b21fYXJpdHkgayBvIHJlc3QgYXJpdHlcbiAgICB8IFJlYWRlciBfIC0+XG4gICAgICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gIFNlZSB0aGVcbiAgICAgICAgICAgbm90ZSBpbiB0aGUgY29ycmVzcG9uZGluZyBjYXNlIGZvciBtYWtlX3ByaW50Zi4gKilcbiAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgICAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT5cbiAgICAgICAgICBtYWtlX2lwcmludGYgayBvXG4gICAgICAgICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcbiAgICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lnbm9yZWRfcGFyYW0gKGZ1biBfIC0+IGsgbykgKEVuZF9vZl9hY2MpIGlnbiByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICAgICAgayBvXG5hbmQgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gOlxuICB0eXBlIHggeSB6IGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT4gc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4geCA9XG4gIGZ1biBrIG8gZm10IHBhZCBwcmVjIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTm9fcGFkZGluZyAgICwgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IExpdF9wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSkpXG5hbmQgZm5fb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPlxuICBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geSA9XG4gIGZ1biBrIG8gZm10IC0+IGZ1bmN0aW9uXG4gICAgfCBDdXN0b21femVybyAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIGZtdFxuICAgIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICAgICAgY29uc3QgKGZuX29mX2N1c3RvbV9hcml0eSBrIG8gZm10IGFyaXR5KVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb250aW51YXRpb25zIGZvciBtYWtlX3ByaW50ZiAqKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIG8gYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAe1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAW1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfY2hhciBvIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGYgb1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZmx1c2ggb1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIG8gcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgYnVmcHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IGYgYlxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gYnVmcHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIGJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mICVhIGFuZCAldC4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIChmICgpKVxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXJyb3IgbWFuYWdlbWVudCAqKVxuXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIHByZXR0eS1wcmludGVkIGVycm9yIG1lc3NhZ2UuICopXG5sZXQgZmFpbHdpdGhfbWVzc2FnZSAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDI1NiBpblxuICBsZXQgayBhY2MgPSBzdHJwdXRfYWNjIGJ1ZiBhY2M7IGZhaWx3aXRoIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0dGluZyB0b29scyAqKVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGFuIG9wZW4gYmxvY2sgZGVzY3JpcHRpb24gKGluZGVudCwgYmxvY2tfdHlwZSkgKilcbmxldCBvcGVuX2JveF9vZl9zdHJpbmcgc3RyID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuICgwLCBQcF9ib3gpIGVsc2VcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgaW52YWxpZF9ib3ggKCkgPSBmYWlsd2l0aF9tZXNzYWdlIFwiaW52YWxpZCBib3ggZGVzY3JpcHRpb24gJVNcIiBzdHIgaW5cbiAgICBsZXQgcmVjIHBhcnNlX3NwYWNlcyBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBpIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgLT4gcGFyc2Vfc3BhY2VzIChpICsgMSlcbiAgICAgICAgfCBfIC0+IGlcbiAgICBhbmQgcGFyc2VfbHdvcmQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJ2EnIC4uICd6JyAtPiBwYXJzZV9sd29yZCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGpcbiAgICBhbmQgcGFyc2VfaW50IGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gcGFyc2VfaW50IGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4gaiBpblxuICAgIGxldCB3c3RhcnQgPSBwYXJzZV9zcGFjZXMgMCBpblxuICAgIGxldCB3ZW5kID0gcGFyc2VfbHdvcmQgd3N0YXJ0IHdzdGFydCBpblxuICAgIGxldCBib3hfbmFtZSA9IFN0cmluZy5zdWIgc3RyIHdzdGFydCAod2VuZCAtIHdzdGFydCkgaW5cbiAgICBsZXQgbnN0YXJ0ID0gcGFyc2Vfc3BhY2VzIHdlbmQgaW5cbiAgICBsZXQgbmVuZCA9IHBhcnNlX2ludCBuc3RhcnQgbnN0YXJ0IGluXG4gICAgbGV0IGluZGVudCA9XG4gICAgICBpZiBuc3RhcnQgPSBuZW5kIHRoZW4gMCBlbHNlXG4gICAgICAgIHRyeSBpbnRfb2Zfc3RyaW5nIChTdHJpbmcuc3ViIHN0ciBuc3RhcnQgKG5lbmQgLSBuc3RhcnQpKVxuICAgICAgICB3aXRoIEZhaWx1cmUgXyAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIGxldCBleHBfZW5kID0gcGFyc2Vfc3BhY2VzIG5lbmQgaW5cbiAgICBpZiBleHBfZW5kIDw+IGxlbiB0aGVuIGludmFsaWRfYm94ICgpO1xuICAgIGxldCBib3hfdHlwZSA9IG1hdGNoIGJveF9uYW1lIHdpdGhcbiAgICAgIHwgXCJcIiB8IFwiYlwiIC0+IFBwX2JveFxuICAgICAgfCBcImhcIiAgICAgIC0+IFBwX2hib3hcbiAgICAgIHwgXCJ2XCIgICAgICAtPiBQcF92Ym94XG4gICAgICB8IFwiaHZcIiAgICAgLT4gUHBfaHZib3hcbiAgICAgIHwgXCJob3ZcIiAgICAtPiBQcF9ob3Zib3hcbiAgICAgIHwgXyAgICAgICAgLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICAoaW5kZW50LCBib3hfdHlwZSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQYXJzaW5nIHRvb2xzICopXG5cbigqIENyZWF0ZSBhIHBhZGRpbmdfZm10X2ViYiBmcm9tIGEgcGFkZGluZyBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkZGluZ19mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwYWRkaW5nX2ZtdF9lYmIgPVxuZnVuIHBhZCBmbXQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChOb19wYWRkaW5nLCBmbXQpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZGRpbmdfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBmbXQpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgZm10KVxuXG4oKiBDcmVhdGUgYSBwcmVjaXNpb25fZm10X2ViYiBmcm9tIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwcmVjaXNpb24gLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHByZWNpc2lvbl9mbXRfZWJiID1cbmZ1biBwcmVjIGZtdCAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKE5vX3ByZWNpc2lvbiwgZm10KVxuICB8IExpdF9wcmVjaXNpb24gcCAtPiBQcmVjaXNpb25fZm10X0VCQiAoTGl0X3ByZWNpc2lvbiBwLCBmbXQpXG4gIHwgQXJnX3ByZWNpc2lvbiAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChBcmdfcHJlY2lzaW9uLCBmbXQpXG5cbigqIENyZWF0ZSBhIHBhZHByZWNfZm10X2ViYiBmcm9tIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyBhbmQgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudHNcbiAgIGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgOiB0eXBlIHggeSB6IHQgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT5cbiAgICAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgKF8sIF8sIF8sIF8sIF8pIHBhZHByZWNfZm10X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10IC0+XG4gIGxldCBQcmVjaXNpb25fZm10X0VCQiAocHJlYywgZm10JykgPSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIHByZWMgZm10IGluXG4gIG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoTm9fcGFkZGluZywgcHJlYywgZm10JylcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkcHJlY19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIHByZWMsIGZtdCcpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgcHJlYywgZm10JylcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHBhcnNpbmcgKilcblxuKCogUGFyc2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZm9ybWF0IGFuZCBjcmVhdGUgYSBmbXRfZWJiLiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIGluIGNhc2Ugb2YgaW52YWxpZCBmb3JtYXQuICopXG5sZXQgZm10X2ViYl9vZl9zdHJpbmcgP2xlZ2FjeV9iZWhhdmlvciBzdHIgPVxuICAoKiBQYXJhbWV0ZXJzIG5hbWluZyBjb252ZW50aW9uOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBsaXRfc3RhcnQ6IHN0YXJ0IG9mIHRoZSBsaXRlcmFsIHNlcXVlbmNlLiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN0cl9pbmQ6IGN1cnJlbnQgaW5kZXggaW4gdGhlIHN0cmluZy4gICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gZW5kX2luZDogZW5kIG9mIHRoZSBjdXJyZW50IChzdWItKWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwY3RfaW5kOiBpbmRleCBvZiB0aGUgJyUnIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgKilcbiAgKCogICAtIHplcm86ICBpcyB0aGUgJzAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gbWludXM6IGlzIHRoZSAnLScgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwbHVzOiAgaXMgdGhlICcrJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGhhc2g6ICBpcyB0aGUgJyMnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gc3BhY2U6IGlzIHRoZSAnICcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBpZ246ICAgaXMgdGhlICdfJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBhZDogcGFkZGluZyBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcHJlYzogcHJlY2lzaW9uIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzeW1iOiBjaGFyIHJlcHJlc2VudGluZyB0aGUgY29udmVyc2lvbiAoJ2MnLCAncycsICdkJywgLi4uKS4gKilcbiAgKCogICAtIGNoYXJfc2V0OiBzZXQgb2YgY2hhcmFjdGVycyBhcyBiaXRtYXAgKHNlZSBzY2FuZiAlWy4uLl0pLiAgICAqKVxuXG4gIGxldCBsZWdhY3lfYmVoYXZpb3IgPSBtYXRjaCBsZWdhY3lfYmVoYXZpb3Igd2l0aFxuICAgIHwgU29tZSBmbGFnIC0+IGZsYWdcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAoKiAgV2hlbiB0aGlzIGZsYWcgaXMgZW5hYmxlZCwgdGhlIGZvcm1hdCBwYXJzZXIgdHJpZXMgdG8gYmVoYXZlIGFzXG4gICAgICB0aGUgPDQuMDIgaW1wbGVtZW50YXRpb25zLCBpbiBwYXJ0aWN1bGFyIGl0IGlnbm9yZXMgbW9zdCBiZW5pbmVcbiAgICAgIG5vbnNlbnNpY2FsIGZvcm1hdC4gV2hlbiB0aGUgZmxhZyBpcyBkaXNhYmxlZCwgaXQgd2lsbCByZWplY3QgYW55XG4gICAgICBmb3JtYXQgdGhhdCBpcyBub3QgYWNjZXB0ZWQgYnkgdGhlIHNwZWNpZmljYXRpb24uXG5cbiAgICAgIEEgdHlwaWNhbCBleGFtcGxlIHdvdWxkIGJlIFwiJSsgZFwiOiBzcGVjaWZ5aW5nIGJvdGggJysnIChpZiB0aGVcbiAgICAgIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGggYSAnKycgdG8gZ2V0IHRoZSBzYW1lIHdpZHRoIGFzXG4gICAgICBuZWdhdGl2ZSBudW1iZXJzKSBhbmQgJyAnIChpZiB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aFxuICAgICAgYSBzcGFjZSkgZG9lcyBub3QgbWFrZSBzZW5zZSwgYnV0IHRoZSBsZWdhY3kgKDwgNC4wMilcbiAgICAgIGltcGxlbWVudGF0aW9uIHdhcyBoYXBweSB0byBqdXN0IGlnbm9yZSB0aGUgc3BhY2UuXG4gICopXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kIG1zZyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgbXNnXG4gIGluXG5cbiAgKCogVXNlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIGZvcm1hdCAob3IgdGhlIGN1cnJlbnQgc3ViLWZvcm1hdCkgd2FzIGVuY291bnRlcmVkXG4gICAgICB1bmV4cGVjdGVkbHkuICopXG4gIGxldCB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBlbmRfaW5kXG4gICAgICBcInVuZXhwZWN0ZWQgZW5kIG9mIGZvcm1hdFwiXG4gIGluXG5cbiAgKCogVXNlZCBmb3IgJTBjOiBubyBvdGhlciB3aWR0aHMgYXJlIGltcGxlbWVudGVkICopXG4gIGxldCBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmRcbiAgICAgIFwibm9uLXplcm8gd2lkdGhzIGFyZSB1bnN1cHBvcnRlZCBmb3IgJWMgY29udmVyc2lvbnNcIlxuICBpblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gb3B0aW9uIGRlcGVuZGVuY3lcbiAgICAgcHJvYmxlbS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X3dpdGhvdXQgc3RyX2luZCBjIHMgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICclYycgd2l0aG91dCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBjIHNcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gdW5leHBlY3RlZFxuICAgICBjaGFyYWN0ZXIuICopXG4gIGxldCBleHBlY3RlZF9jaGFyYWN0ZXIgc3RyX2luZCBleHBlY3RlZCByZWFkID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzIGV4cGVjdGVkLCByZWFkICVDXCJcbiAgICAgIHN0ciBzdHJfaW5kIGV4cGVjdGVkIHJlYWRcbiAgaW5cblxuICAoKiBQYXJzZSB0aGUgc3RyaW5nIGZyb20gYmVnX2luZCAoaW5jbHVkZWQpIHRvIGVuZF9pbmQgKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IHJlYyBwYXJzZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBiZWdfaW5kIGVuZF9pbmQgLT4gcGFyc2VfbGl0ZXJhbCBiZWdfaW5kIGJlZ19pbmQgZW5kX2luZFxuXG4gICgqIFJlYWQgbGl0ZXJhbCBjaGFyYWN0ZXJzIHVwIHRvICclJyBvciAnQCcgc3BlY2lhbCBjaGFyYWN0ZXJzLiAqKVxuICBhbmQgcGFyc2VfbGl0ZXJhbCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgRW5kX29mX2Zvcm1hdCBlbHNlXG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfZm9ybWF0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9hZnRlcl9hdCAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9saXRlcmFsIGxpdF9zdGFydCAoc3RyX2luZCArIDEpIGVuZF9pbmRcblxuICAoKiBQYXJzZSBhIGZvcm1hdCBhZnRlciAnJScgKilcbiAgYW5kIHBhcnNlX2Zvcm1hdCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIGVuZF9pbmQgLT4gcGFyc2VfaWduIHBjdF9pbmQgKHBjdF9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgYW5kIHBhcnNlX2lnbiA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXycgLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCAoc3RyX2luZCsxKSBlbmRfaW5kIHRydWVcbiAgICAgIHwgXyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBmYWxzZVxuXG4gIGFuZCBwYXJzZV9mbGFncyA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiAoXywgXywgZSwgZikgZm10X2ViYlxuICA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBpZ24gLT5cbiAgICBsZXQgemVybyA9IHJlZiBmYWxzZSBhbmQgbWludXMgPSByZWYgZmFsc2VcbiAgICBhbmQgcGx1cyA9IHJlZiBmYWxzZSBhbmQgc3BhY2UgPSByZWYgZmFsc2VcbiAgICBhbmQgaGFzaCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBzZXRfZmxhZyBzdHJfaW5kIGZsYWcgPVxuICAgICAgKCogaW4gbGVnYWN5IG1vZGUsIGR1cGxpY2F0ZSBmbGFncyBhcmUgYWNjZXB0ZWQgKilcbiAgICAgIGlmICFmbGFnICYmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgZHVwbGljYXRlIGZsYWcgJUNcIlxuICAgICAgICAgIHN0ciBzdHJfaW5kIHN0ci5bc3RyX2luZF07XG4gICAgICBmbGFnIDo9IHRydWU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHJlYWRfZmxhZ3Mgc3RyX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICcwJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHplcm87ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJy0nIC0+IHNldF9mbGFnIHN0cl9pbmQgbWludXM7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnKycgLT4gc2V0X2ZsYWcgc3RyX2luZCBwbHVzOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcjJyAtPiBzZXRfZmxhZyBzdHJfaW5kIGhhc2g7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnICcgLT4gc2V0X2ZsYWcgc3RyX2luZCBzcGFjZTsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZFxuICAgICAgICAgICF6ZXJvICFtaW51cyAhcGx1cyAhaGFzaCAhc3BhY2UgaWduXG4gICAgICBlbmRcbiAgICBpblxuICAgIHJlYWRfZmxhZ3Mgc3RyX2luZFxuXG4gICgqIFRyeSB0byByZWFkIGEgZGlnaXRhbCBvciBhICcqJyBwYWRkaW5nLiAqKVxuICBhbmQgcGFyc2VfcGFkZGluZyA6IHR5cGUgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHplcm8gbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhZHR5ID0gbWF0Y2ggemVybywgbWludXMgd2l0aFxuICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gUmlnaHRcbiAgICAgIHwgZmFsc2UsIHRydWUgIC0+IExlZnRcbiAgICAgIHwgIHRydWUsIGZhbHNlIC0+IFplcm9zXG4gICAgICB8ICB0cnVlLCB0cnVlICAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMZWZ0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICctJyBcIjBcIiBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPlxuICAgICAgbGV0IG5ld19pbmQsIHdpZHRoID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAoTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiAoQXJnX3BhZGRpbmcgcGFkdHkpXG4gICAgfCBfIC0+XG4gICAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgICB8IExlZnQgIC0+XG4gICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLScgXCJwYWRkaW5nXCI7XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIHwgWmVyb3MgLT5cbiAgICAgICAgICgqIGEgJzAnIHBhZGRpbmcgaW5kaWNhdGlvbiBub3QgZm9sbG93ZWQgYnkgYW55dGhpbmcgc2hvdWxkXG4gICAgICAgICAgIGJlIGludGVycHJldGVkIGFzIGEgUmlnaHQgcGFkZGluZyBvZiB3aWR0aCAwLiBUaGlzIGlzIHVzZWRcbiAgICAgICAgICAgYnkgc2Nhbm5pbmcgY29udmVyc2lvbnMgJTBzIGFuZCAlMGMgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgKExpdF9wYWRkaW5nIChSaWdodCwgMCkpXG4gICAgICB8IFJpZ2h0IC0+XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIGVuZFxuXG4gICgqIElzIHByZWNpc2lvbiBkZWZpbmVkPyAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcGFkZGluZyA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcuJyAtPlxuICAgICAgcGFyc2VfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkXG4gICAgfCBzeW1iIC0+XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIE5vX3ByZWNpc2lvbiBwYWQgc3ltYlxuXG4gICgqIFJlYWQgdGhlIGRpZ2l0YWwgb3IgJyonIHByZWNpc2lvbi4gKilcbiAgYW5kIHBhcnNlX3ByZWNpc2lvbiA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kID1cbiAgICAgIGxldCBuZXdfaW5kLCBwcmVjID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiBwcmVjKSBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmRcbiAgICB8ICgnKycgfCAnLScpIGFzIHN5bWIgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT5cbiAgICAgICgqIExlZ2FjeSBtb2RlIHdvdWxkIGFjY2VwdCBhbmQgaWdub3JlICcrJyBvciAnLScgYmVmb3JlIHRoZVxuICAgICAgICAgaW50ZWdlciBkZXNjcmliaW5nIHRoZSBkZXNpcmVkIHByZWNpc2lvbjsgbm90ZSB0aGF0IHRoaXNcbiAgICAgICAgIGNhbm5vdCBoYXBwZW4gZm9yIHBhZGRpbmcgd2lkdGgsIGFzICcrJyBhbmQgJy0nIGFscmVhZHkgaGF2ZVxuICAgICAgICAgYSBzZW1hbnRpY3MgdGhlcmUuXG5cbiAgICAgICAgIFRoYXQgc2FpZCwgdGhlIGlkZWEgKHN1cHBvcnRlZCBieSB0aGlzIHR3ZWFrKSB0aGF0IHdpZHRoIGFuZFxuICAgICAgICAgcHJlY2lzaW9uIGxpdGVyYWxzIGFyZSBcImludGVnZXIgbGl0ZXJhbHNcIiBpbiB0aGUgT0NhbWwgc2Vuc2UgaXNcbiAgICAgICAgIHN0aWxsIGJsYXRhbnRseSB3cm9uZywgYXMgMTIzXzQ1NiBvciAweEZGIGFyZSByZWplY3RlZC4gKilcbiAgICAgIHBhcnNlX2xpdGVyYWwgKG1pbnVzIHx8IHN5bWIgPSAnLScpIChzdHJfaW5kICsgMSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gcGFkIEFyZ19wcmVjaXNpb25cbiAgICB8IF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIG5vdGUgdGhhdCBsZWdhY3kgaW1wbGVtZW50YXRpb24gZGlkIG5vdCBpZ25vcmUgJy4nIHdpdGhvdXRcbiAgICAgICAgICAgYSBudW1iZXIgKGFzIGl0IGRvZXMgZm9yIHBhZGRpbmcgaW5kaWNhdGlvbnMpLCBidXRcbiAgICAgICAgICAgaW50ZXJwcmV0cyBpdCBhcyAnLjAnICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIDApXG4gICAgICBlbHNlXG4gICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLicgXCJwcmVjaXNpb25cIlxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiB0IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfY29udiAodHlwZSB1KSAodHlwZSB2KSAocGFkcHJlYyA6ICh1LCB2KSBwYWRkaW5nKSA9XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIHByZWMgcGFkcHJlYyBzdHIuW3N0cl9pbmRdIGluXG4gICAgKCogaW4gbGVnYWN5IG1vZGUsIHNvbWUgZm9ybWF0cyAoJXMgYW5kICVTKSBhY2NlcHQgYSB3ZWlyZCBtaXggb2ZcbiAgICAgICBwYWRkaW5nIGFuZCBwcmVjaXNpb24sIHdoaWNoIGlzIG1lcmdlZCBhcyBhIHNpbmdsZSBwYWRkaW5nXG4gICAgICAgaW5mb3JtYXRpb24uIEZvciBleGFtcGxlLCBpbiAlLjEwcyB0aGUgcHJlY2lzaW9uIGlzIGltcGxpY2l0bHlcbiAgICAgICB1bmRlcnN0b29kIGFzIHBhZGRpbmcgJTEwcywgYnV0IHRoZSBsZWZ0LXBhZGRpbmcgY29tcG9uZW50IG1heVxuICAgICAgIGJlIHNwZWNpZmllZCBlaXRoZXIgYXMgYSBsZWZ0IHBhZGRpbmcgb3IgYSBuZWdhdGl2ZSBwcmVjaXNpb246XG4gICAgICAgJS0uM3MgYW5kICUuLTNzIGFyZSBlcXVpdmFsZW50IHRvICUtM3MgKilcbiAgICBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAtPiAoXG4gICAgICBtYXRjaCBtaW51cywgcHJlYyB3aXRoXG4gICAgICAgIHwgXywgTm9fcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgTm9fcGFkZGluZ1xuICAgICAgICB8IGZhbHNlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKSlcbiAgICAgICAgfCB0cnVlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKExlZnQsIG4pKVxuICAgICAgICB8IGZhbHNlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIFJpZ2h0KVxuICAgICAgICB8IHRydWUsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgTGVmdClcbiAgICApXG4gICAgfCBwYWQgLT4gcGFyc2VfY29udiBwYWRcblxuICAoKiBDYXNlIGFuYWx5c2lzIG9uIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9jb252ZXJzaW9uIDogdHlwZSB4IHkgeiB0IHUgdiBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiAoeCwgeSkgcGFkZGluZyAtPlxuICAgICAgICAoeiwgdCkgcHJlY2lzaW9uIC0+ICh1LCB2KSBwYWRkaW5nIC0+IGNoYXIgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyBwYWRwcmVjIHN5bWIgLT5cbiAgICAoKiBGbGFncyB1c2VkIHRvIGNoZWNrIG9wdGlvbiB1c2FnZXMvY29tcGF0aWJpbGl0aWVzLiAqKVxuICAgIGxldCBwbHVzX3VzZWQgID0gcmVmIGZhbHNlIGFuZCBoYXNoX3VzZWQgPSByZWYgZmFsc2VcbiAgICBhbmQgc3BhY2VfdXNlZCA9IHJlZiBmYWxzZSBhbmQgaWduX3VzZWQgICA9IHJlZiBmYWxzZVxuICAgIGFuZCBwYWRfdXNlZCAgID0gcmVmIGZhbHNlIGFuZCBwcmVjX3VzZWQgID0gcmVmIGZhbHNlIGluXG5cbiAgICAoKiBBY2Nlc3MgdG8gb3B0aW9ucywgdXBkYXRlIGZsYWdzLiAqKVxuICAgIGxldCBnZXRfcGx1cyAgICAoKSA9IHBsdXNfdXNlZCAgOj0gdHJ1ZTsgcGx1c1xuICAgIGFuZCBnZXRfaGFzaCAgICgpID0gaGFzaF91c2VkIDo9IHRydWU7IGhhc2hcbiAgICBhbmQgZ2V0X3NwYWNlICAgKCkgPSBzcGFjZV91c2VkIDo9IHRydWU7IHNwYWNlXG4gICAgYW5kIGdldF9pZ24gICAgICgpID0gaWduX3VzZWQgICA6PSB0cnVlOyBpZ25cbiAgICBhbmQgZ2V0X3BhZCAgICAgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZFxuICAgIGFuZCBnZXRfcHJlYyAgICAoKSA9IHByZWNfdXNlZCAgOj0gdHJ1ZTsgcHJlY1xuICAgIGFuZCBnZXRfcGFkcHJlYyAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkcHJlYyBpblxuXG4gICAgbGV0IGdldF9pbnRfcGFkICgpIDogKHgseSkgcGFkZGluZyA9XG4gICAgICAoKiAlNS4zZCBpcyBhY2NlcHRlZCBhbmQgbWVhbmluZ2Z1bDogcGFkIHRvIGxlbmd0aCA1IHdpdGhcbiAgICAgICAgIHNwYWNlcywgYnV0IGZpcnN0IHBhZCB3aXRoIHplcm9zIHVwdG8gbGVuZ3RoIDMgKDAtcGFkZGluZ1xuICAgICAgICAgaXMgdGhlIGludGVycHJldGF0aW9uIG9mIFwicHJlY2lzaW9uXCIgZm9yIGludGVnZXIgZm9ybWF0cykuXG5cbiAgICAgICAgICUwNS4zZCBpcyByZWR1bmRhbnQ6IHBhZCB0byBsZW5ndGggNSAqd2l0aCB6ZXJvcyosIGJ1dFxuICAgICAgICAgZmlyc3QgcGFkIHdpdGggemVyb3MuLi4gVG8gYWRkIGluc3VsdCB0byB0aGUgaW5qdXJ5LCB0aGVcbiAgICAgICAgIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBpZ25vcmVzIHRoZSAwLXBhZGRpbmcgaW5kaWNhdGlvbiBhbmRcbiAgICAgICAgIGRvZXMgdGhlIDUgcGFkZGluZyB3aXRoIHNwYWNlcyBpbnN0ZWFkLiBXZSByZXVzZSB0aGlzXG4gICAgICAgICBpbnRlcnByZXRhdGlvbiBmb3IgY29tcGF0aWJpbGl0eSwgYnV0IHN0YXRpY2FsbHkgcmVqZWN0IHRoaXNcbiAgICAgICAgIGZvcm1hdCB3aGVuIHRoZSBsZWdhY3kgbW9kZSBpcyBkaXNhYmxlZCwgdG8gcHJvdGVjdCBzdHJpY3RcbiAgICAgICAgIHVzZXJzIGZyb20gdGhpcyBjb3JuZXIgY2FzZS4gKilcbiAgICAgICBtYXRjaCBnZXRfcGFkICgpLCBnZXRfcHJlYyAoKSB3aXRoXG4gICAgICAgICB8IHBhZCwgTm9fcHJlY2lzaW9uIC0+IHBhZFxuICAgICAgICAgfCBOb19wYWRkaW5nLCBfICAgICAtPiBOb19wYWRkaW5nXG4gICAgICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgbiksIF8gLT5cbiAgICAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKVxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcywgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBMaXRfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWRcbiAgICAgICAgIHwgQXJnX3BhZGRpbmcgXyBhcyBwYWQsIF8gLT4gcGFkIGluXG5cbiAgICAoKiBDaGVjayB0aGF0IHBhZHR5IDw+IFplcm9zLiAqKVxuICAgIGxldCBjaGVja19ub18wIHN5bWIgKHR5cGUgYSBiKSAocGFkIDogKGEsIGIpIHBhZGRpbmcpIDogKGEsYikgcGFkZGluZyA9XG4gICAgICBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoKExlZnQgfCBSaWdodCksIF8pIC0+IHBhZFxuICAgICAgfCBBcmdfcGFkZGluZyAoTGVmdCB8IFJpZ2h0KSAtPiBwYWRcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIjBcIlxuICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcyAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgaW5cblxuICAgICgqIEdldCBwYWRkaW5nIGFzIGEgcGFkX29wdGlvbiAoc2VlIFwiJV9cIiwgXCIle1wiLCBcIiUoXCIgYW5kIFwiJVtcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgb3B0X29mX3BhZCBjICh0eXBlIGEpICh0eXBlIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgPSBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IE5vbmVcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aCkgLT4gU29tZSB3aWR0aFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBTb21lIHdpZHRoXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInMCdcIlxuICAgICAgfCBMaXRfcGFkZGluZyAoTGVmdCwgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIictJ1wiXG4gICAgICB8IEFyZ19wYWRkaW5nIF8gLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInKidcIlxuICAgIGluXG4gICAgbGV0IGdldF9wYWRfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWQgKCkpIGluXG4gICAgbGV0IGdldF9wYWRwcmVjX29wdCBjID0gb3B0X29mX3BhZCBjIChnZXRfcGFkcHJlYyAoKSkgaW5cblxuICAgICgqIEdldCBwcmVjaXNpb24gYXMgYSBwcmVjX29wdGlvbiAoc2VlIFwiJV9mXCIpLlxuICAgICAgIChubyBuZWVkIGZvciBsZWdhY3kgbW9kZSB0d2Vha2luZywgdGhvc2Ugd2VyZSByZWplY3RlZCBieSB0aGVcbiAgICAgICBsZWdhY3kgcGFyc2VyIGFzIHdlbGwpICopXG4gICAgbGV0IGdldF9wcmVjX29wdCAoKSA9IG1hdGNoIGdldF9wcmVjICgpIHdpdGhcbiAgICAgIHwgTm9fcHJlY2lzaW9uICAgICAgIC0+IE5vbmVcbiAgICAgIHwgTGl0X3ByZWNpc2lvbiBuZGVjIC0+IFNvbWUgbmRlY1xuICAgICAgfCBBcmdfcHJlY2lzaW9uICAgICAgLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicqJ1wiXG4gICAgaW5cblxuICAgIGxldCBmbXRfcmVzdWx0ID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnLCcgLT5cbiAgICAgIHBhcnNlIHN0cl9pbmQgZW5kX2luZFxuICAgIHwgJ2MnIC0+XG4gICAgICBsZXQgY2hhcl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jaGFyLCBmbXRfcmVzdCkpXG4gICAgICAgIGVsc2UgRm10X0VCQiAoQ2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgc2Nhbl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlMGMgKilcbiAgICAgICAgaWYgZ2V0X2lnbiAoKVxuICAgICAgICB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChTY2FuX25leHRfY2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgYmVnaW4gbWF0Y2ggZ2V0X3BhZF9vcHQgJ2MnIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSAwIC0+IHNjYW5fZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSBfbiAtPlxuICAgICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yXG4gICAgICAgICAgIHRoZW4gaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZFxuICAgICAgICAgICBlbHNlICgqIGxlZ2FjeSBpZ25vcmVzICVjIHdpZHRocyAqKSBjaGFyX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgZW5kXG4gICAgfCAnQycgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jYW1sX2NoYXIsZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChDYW1sX2NoYXIgZm10X3Jlc3QpXG4gICAgfCAncycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc3RyaW5nIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChTdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnUycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfY2FtbF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKENhbWxfc3RyaW5nIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2QnIHwgJ2knIHwgJ3gnIHwgJ1gnIHwgJ28nIHwgJ3UnIC0+XG4gICAgICBsZXQgaWNvbnYgPSBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnTicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IFRva2VuX2NvdW50ZXIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIHwgJ24nIHwgJ0wnIHdoZW4gc3RyX2luZD1lbmRfaW5kIHx8IG5vdCAoaXNfaW50X2Jhc2Ugc3RyLltzdHJfaW5kXSkgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJfb2ZfY2hhciBzeW1iIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSlcbiAgICB8ICdsJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50MzIgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ24nIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpXG4gICAgICAgICAgKGdldF9oYXNoICgpKSAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdMJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50NjQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2YnIHwgJ2UnIHwgJ0UnIHwgJ2cnIHwgJ0cnIHwgJ0YnIHwgJ2gnIHwgJ0gnIC0+XG4gICAgICBsZXQgZmNvbnYgPVxuICAgICAgICBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kXG4gICAgICAgICAgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN5bWIgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zsb2F0IChnZXRfcGFkX29wdCAnXycsIGdldF9wcmVjX29wdCAoKSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoRmxvYXQgKGZjb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdiJyB8ICdCJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9ib29sIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChCb29sIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2EnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoQWxwaGEgZm10X3Jlc3QpXG4gICAgfCAndCcgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChUaGV0YSBmbXRfcmVzdClcbiAgICB8ICdyJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChSZWFkZXIgZm10X3Jlc3QpXG4gICAgfCAnIScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGbHVzaCBmbXRfcmVzdClcbiAgICB8ICgnJScgfCAnQCcpIGFzIGMgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKGMsIGZtdF9yZXN0KSlcbiAgICB8ICd7JyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJ30nIGluXG4gICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCBzdWJfZW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICd7Jywgc3ViX2ZtdHR5LCBmbXRfcmVzdCkpXG4gICAgfCAnKCcgLT5cbiAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kICcpJyBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3ViX2VuZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBzdWJfZm10dHkgPSBmbXR0eV9vZl9mbXQgc3ViX2ZtdCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mb3JtYXRfc3Vic3QgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJygnLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICdbJyAtPlxuICAgICAgbGV0IG5leHRfaW5kLCBjaGFyX3NldCA9IHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKGdldF9wYWRfb3B0ICdfJywgY2hhcl9zZXQpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ1snLCBjaGFyX3NldCwgZm10X3Jlc3QpKVxuICAgIHwgJy0nIHwgJysnIHwgJyMnIHwgJyAnIHwgJ18nIC0+XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICBmbGFnICVDIGlzIG9ubHkgYWxsb3dlZCBhZnRlciB0aGUgJyUlJywgYmVmb3JlIHBhZGRpbmcgYW5kIHByZWNpc2lvblwiXG4gICAgICAgIHN0ciBwY3RfaW5kIHN5bWJcbiAgICB8IF8gLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGludmFsaWQgY29udmVyc2lvbiBcXFwiJSUlY1xcXCJcIiBzdHIgKHN0cl9pbmQgLSAxKSBzeW1iXG4gICAgaW5cbiAgICAoKiBDaGVjayBmb3IgdW51c2VkIG9wdGlvbnMsIGFuZCByZWplY3QgdGhlbSBhcyBpbmNvbXBhdGlibGUuXG5cbiAgICAgICBTdWNoIGNoZWNrcyBuZWVkIHRvIGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLCBhcyB0aGUgbGVnYWN5XG4gICAgICAgcGFyc2VyIHNpbGVudGx5IGlnbm9yZWQgaW5jb21wYXRpYmxlIGZsYWdzLiAqKVxuICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlbiBiZWdpblxuICAgIGlmIG5vdCAhcGx1c191c2VkICYmIHBsdXMgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInKydcIjtcbiAgICBpZiBub3QgIWhhc2hfdXNlZCAmJiBoYXNoIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCI7XG4gICAgaWYgbm90ICFzcGFjZV91c2VkICYmIHNwYWNlIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCI7XG4gICAgaWYgbm90ICFwYWRfdXNlZCAgJiYgUGFkZGluZ19FQkIgcGFkIDw+IFBhZGRpbmdfRUJCIE5vX3BhZGRpbmcgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCJgcGFkZGluZydcIjtcbiAgICBpZiBub3QgIXByZWNfdXNlZCAmJiBQcmVjaXNpb25fRUJCIHByZWMgPD4gUHJlY2lzaW9uX0VCQiBOb19wcmVjaXNpb24gdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIChpZiBpZ24gdGhlbiAnXycgZWxzZSBzeW1iKVxuICAgICAgICBcImBwcmVjaXNpb24nXCI7XG4gICAgaWYgaWduICYmIHBsdXMgdGhlbiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJysnXCI7XG4gICAgZW5kO1xuICAgICgqIHRoaXMgbGFzdCB0ZXN0IG11c3Qgbm90IGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLFxuICAgICAgIGFzIGlnbm9yaW5nIGl0IHdvdWxkIHR5cGljYWxseSByZXN1bHQgaW4gYSBkaWZmZXJlbnQgdHlwaW5nXG4gICAgICAgdGhhbiB3aGF0IHRoZSBsZWdhY3kgcGFyc2VyIHVzZWQgKilcbiAgICBpZiBub3QgIWlnbl91c2VkICYmIGlnbiB0aGVuXG4gICAgICBiZWdpbiBtYXRjaCBzeW1iIHdpdGhcbiAgICAgICAgKCogYXJndW1lbnQtbGVzcyBmb3JtYXRzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBpbiBsZWdhY3kgbW9kZSAqKVxuICAgICAgICB8ICgnQCcgfCAnJScgfCAnIScgfCAnLCcpIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+ICgpXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJ18nXCJcbiAgICAgIGVuZDtcbiAgICBmbXRfcmVzdWx0XG5cbiAgKCogUGFyc2UgZm9ybWF0dGluZyBpbmZvcm1hdGlvbiAoYWZ0ZXIgJ0AnKS4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX2F0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIEVuZF9vZl9mb3JtYXQpKVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnWycgLT5cbiAgICAgICAgcGFyc2VfdGFnIGZhbHNlIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKENsb3NlX2JveCwgZm10X3Jlc3QpKVxuICAgICAgfCAneycgLT5cbiAgICAgICAgcGFyc2VfdGFnIHRydWUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICd9JyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfdGFnLCBmbXRfcmVzdCkpXG4gICAgICB8ICcsJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQnJlYWsgKFwiQCxcIiwgMCwgMCksIGZtdF9yZXN0KSlcbiAgICAgIHwgJyAnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJAIFwiLCAxLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnOycgLT5cbiAgICAgICAgcGFyc2VfZ29vZF9icmVhayAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJz8nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGRmx1c2gsIGZtdF9yZXN0KSlcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZvcmNlX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJy4nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGbHVzaF9uZXdsaW5lLCBmbXRfcmVzdCkpXG4gICAgICB8ICc8JyAtPlxuICAgICAgICBwYXJzZV9tYWdpY19zaXplIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfYXQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIHdoZW4gc3RyX2luZCArIDEgPCBlbmRfaW5kICYmIHN0ci5bc3RyX2luZCArIDFdID0gJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChFc2NhcGVkX3BlcmNlbnQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoJ0AnLCBmbXRfcmVzdCkpXG4gICAgICB8IGMgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKFNjYW5faW5kaWMgYywgZm10X3Jlc3QpKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8bmFtZT4gYWZ0ZXIgXCJAe1wiIG9yIFwiQFtcIi4gKilcbiAgYW5kIHBhcnNlX3RhZyA6IHR5cGUgZSBmIC4gYm9vbCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGlzX29wZW5fdGFnIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIHRyeVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIGxldCBpbmQgPSBTdHJpbmcuaW5kZXhfZnJvbSBzdHIgKHN0cl9pbmQgKyAxKSAnPicgaW5cbiAgICAgICAgaWYgaW5kID49IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgc3RyX2luZCAoaW5kIC0gc3RyX2luZCArIDEpIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKGluZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgKGluZCArIDEpIGluXG4gICAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChzdWJfZm10LCBzdWJfc3RyKSBpblxuICAgICAgICBsZXQgZm9ybWF0dGluZyA9XG4gICAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZywgZm10X3Jlc3QpKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKEVuZF9vZl9mb3JtYXQsIFwiXCIpIGluXG4gICAgICBsZXQgZm9ybWF0dGluZyA9XG4gICAgICAgIGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIE9wZW5fYm94IHN1Yl9mb3JtYXQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDx3aWR0aCBvZmZzZXQ+IGFmdGVyIFwiQDtcIi4gKilcbiAgYW5kIHBhcnNlX2dvb2RfYnJlYWsgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbGV0IG5leHRfaW5kLCBmb3JtYXR0aW5nX2xpdCA9XG4gICAgICB0cnlcbiAgICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgfHwgc3RyLltzdHJfaW5kXSA8PiAnPCcgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiAoXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMiwgd2lkdGggPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgICBsZXQgc3RyX2luZF8zID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfMiBlbmRfaW5kIGluXG4gICAgICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfM10gd2l0aFxuICAgICAgICAgICAgICB8ICc+JyAtPlxuICAgICAgICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQtMikgKHN0cl9pbmRfMy1zdHJfaW5kKzMpIGluXG4gICAgICAgICAgICAgICAgc3RyX2luZF8zICsgMSwgQnJlYWsgKHMsIHdpZHRoLCAwKVxuICAgICAgICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF80LCBvZmZzZXQgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMyBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgbGV0IHN0cl9pbmRfNSA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzQgZW5kX2luZCBpblxuICAgICAgICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF81XSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF81LXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzUgKyAxLCBCcmVhayAocywgd2lkdGgsIG9mZnNldClcbiAgICAgICAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICApXG4gICAgICAgIHwgXyAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIHN0cl9pbmQsIEJyZWFrIChcIkA7XCIsIDEsIDApXG4gICAgaW5cbiAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSB0aGUgc2l6ZSBpbiBhIDxuPi4gKilcbiAgYW5kIHBhcnNlX21hZ2ljX3NpemUgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbWF0Y2hcbiAgICAgIHRyeVxuICAgICAgICBsZXQgc3RyX2luZF8xID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfMV0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCBzaXplID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzEgZW5kX2luZCBpblxuICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICBpZiBzdHIuW3N0cl9pbmRfM10gPD4gJz4nIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQgLSAyKSAoc3RyX2luZF8zIC0gc3RyX2luZCArIDMpIGluXG4gICAgICAgICAgU29tZSAoc3RyX2luZF8zICsgMSwgTWFnaWNfc2l6ZSAocywgc2l6ZSkpXG4gICAgICAgIHwgXyAtPiBOb25lXG4gICAgICB3aXRoIE5vdF9mb3VuZCB8IEZhaWx1cmUgXyAtPlxuICAgICAgICBOb25lXG4gICAgd2l0aFxuICAgIHwgU29tZSAobmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0KSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyAnPCcsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSBhbmQgY29uc3RydWN0IGEgY2hhciBzZXQuICopXG4gIGFuZCBwYXJzZV9jaGFyX3NldCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG5cbiAgICBsZXQgY2hhcl9zZXQgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgICBsZXQgYWRkX2NoYXIgYyA9XG4gICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYztcbiAgICBpblxuICAgIGxldCBhZGRfcmFuZ2UgYyBjJyA9XG4gICAgICBmb3IgaSA9IGludF9vZl9jaGFyIGMgdG8gaW50X29mX2NoYXIgYycgZG9cbiAgICAgICAgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IChjaGFyX29mX2ludCBpKTtcbiAgICAgIGRvbmU7XG4gICAgaW5cblxuICAgIGxldCBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQgPVxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiAnJSUnIGFsb25lIGlzIG5vdCBhY2NlcHRlZCBpbiBjaGFyYWN0ZXIgc2V0cywgXFxcbiAgICAgICAgIHVzZSAlJSUlIGluc3RlYWQgYXQgcG9zaXRpb24gJWQuXCIgc3RyIHN0cl9pbmRcbiAgICBpblxuXG4gICAgKCogUGFyc2UgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGNoYXIgc2V0LiAqKVxuICAgIGxldCByZWMgcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBsZXQgYyA9IHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFBhcnNlIHRoZSBjb250ZW50IG9mIGEgY2hhciBzZXQgdW50aWwgdGhlIGZpcnN0ICddJy4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfY29udGVudCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJy0nIC0+XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgYyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgICAoKiBUZXN0IGZvciByYW5nZSBpbiBjaGFyIHNldC4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfbWludXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcbiAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgd2hlbiBjID0gJyUnIC0+XG4gICAgICAgIGFkZF9jaGFyIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBpZiBjID0gJyUnIHRoZW4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kO1xuICAgICAgICAoKiBub3RlIHRoYXQgJ0AnIGFsb25lIGlzIGFjY2VwdGVkLCBhcyBkb25lIGJ5IHRoZSBsZWdhY3lcbiAgICAgICAgICAgaW1wbGVtZW50YXRpb247IHRoZSBkb2N1bWVudGF0aW9uIHNwZWNpZmljYWxseSByZXF1aXJlcyAlQFxuICAgICAgICAgICBzbyB3ZSBjb3VsZCB3YXJuIG9uIHRoYXQgKilcbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgYydcblxuICAgICgqIE1hbmFnZSByYW5nZSBpbiBjaGFyIHNldCAoZXhjZXB0IGlmIHRoZSAnLScgdGhlIGxhc3QgY2hhciBiZWZvcmUgJ10nKSAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBhZGRfY2hhciAnLSc7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICclJyAtPlxuICAgICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgLT5cbiAgICAgICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDIpIGVuZF9pbmRcbiAgICAgICAgICB8IF8gLT4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kXG4gICAgICAgIGVuZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBhZGRfcmFuZ2UgYyBjJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICBpblxuICAgIGxldCBzdHJfaW5kLCByZXZlcnNlID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgICAgfCAnXicgLT4gc3RyX2luZCArIDEsIHRydWVcbiAgICAgICAgfCBfIC0+IHN0cl9pbmQsIGZhbHNlIGluXG4gICAgbGV0IG5leHRfaW5kID0gcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgbGV0IGNoYXJfc2V0ID0gZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0IGluXG4gICAgbmV4dF9pbmQsIChpZiByZXZlcnNlIHRoZW4gcmV2X2NoYXJfc2V0IGNoYXJfc2V0IGVsc2UgY2hhcl9zZXQpXG5cbiAgKCogQ29uc3VtZSBhbGwgbmV4dCBzcGFjZXMsIHJhaXNlIGFuIEZhaWx1cmUgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBpZiBzdHIuW3N0cl9pbmRdID0gJyAnIHRoZW4gcGFyc2Vfc3BhY2VzIChzdHJfaW5kICsgMSkgZW5kX2luZCBlbHNlIHN0cl9pbmRcblxuICAoKiBSZWFkIGEgcG9zaXRpdmUgaW50ZWdlciBmcm9tIHRoZSBzdHJpbmcsIHJhaXNlIGEgRmFpbHVyZSBpZiBlbmRfaW5kIGlzXG4gICAgIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgYWNjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IGFjYyAqIDEwICsgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCcpIGluXG4gICAgICBpZiBuZXdfYWNjID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGludGVnZXIgJWQgaXMgZ3JlYXRlciB0aGFuIHRoZSBsaW1pdCAlZFwiXG4gICAgICAgICAgc3RyIG5ld19hY2MgU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgICBlbHNlXG4gICAgICAgIHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCBuZXdfYWNjXG4gICAgfCBfIC0+IHN0cl9pbmQsIGFjY1xuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlXG4gICAgIGlmIGVuZF9pbmQgaXMgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX2ludGVnZXIgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMFxuICAgIHwgJy0nIC0+IChcbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICAgIGxldCBuZXh0X2luZCwgbiA9IHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCAwIGluXG4gICAgICAgIG5leHRfaW5kLCAtblxuICAgICAgfCBjIC0+XG4gICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiZGlnaXRcIiBjXG4gICAgKVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBBZGQgYSBsaXRlcmFsIHRvIGEgZm9ybWF0IGZyb20gYSBsaXRlcmFsIGNoYXJhY3RlciBzdWItc2VxdWVuY2UuICopXG4gIGFuZCBhZGRfbGl0ZXJhbCA6IHR5cGUgYSBkIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IChhLCBfLCBfLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGZtdCAtPiBtYXRjaCBzdHJfaW5kIC0gbGl0X3N0YXJ0IHdpdGhcbiAgICB8IDAgICAgLT4gRm10X0VCQiBmbXRcbiAgICB8IDEgICAgLT4gRm10X0VCQiAoQ2hhcl9saXRlcmFsIChzdHIuW2xpdF9zdGFydF0sIGZtdCkpXG4gICAgfCBzaXplIC0+IEZtdF9FQkIgKFN0cmluZ19saXRlcmFsIChTdHJpbmcuc3ViIHN0ciBsaXRfc3RhcnQgc2l6ZSwgZm10KSlcblxuICAoKiBTZWFyY2ggdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzdWItZm9ybWF0XG4gICAgIChpLmUuIHRoZSBjb3JyZXNwb25kaW5nIFwiJX1cIiBvciBcIiUpXCIpICopXG4gIGFuZCBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiB1bmNsb3NlZCBzdWItZm9ybWF0LCBcXFxuICAgICAgICAgZXhwZWN0ZWQgXFxcIiUlJWNcXFwiIGF0IGNoYXJhY3RlciBudW1iZXIgJWRcIiBzdHIgYyBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJyUnIC0+XG4gICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGlmIHN0ci5bc3RyX2luZCArIDFdID0gYyB0aGVuICgqIEVuZCBvZiBmb3JtYXQgZm91bmQgKikgc3RyX2luZCBlbHNlXG4gICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgICAgfCAnXycgLT5cbiAgICAgICAgICAoKiBTZWFyY2ggZm9yIFwiJV8oXCIgb3IgXCIlX3tcIi4gKilcbiAgICAgICAgICBpZiBzdHJfaW5kICsgMiA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAyXSB3aXRoXG4gICAgICAgICAgfCAneycgLT5cbiAgICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJyknIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgY1xuICAgICAgICAgIGVuZFxuICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICgqICV7Li4uJX0gc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnfScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICgqICUoLi4uJSkgc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICd9JyAtPlxuICAgICAgICAgICgqIEVycm9yOiAlKC4uLiV9LiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICcpJ1wiICd9J1xuICAgICAgICB8ICcpJyAtPlxuICAgICAgICAgICgqIEVycm9yOiAley4uLiUpLiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICd9J1wiICcpJ1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICBlbmRcbiAgICB8IF8gLT4gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAoKiBDaGVjayBpZiBzeW1iIGlzIGEgdmFsaWQgaW50IGNvbnZlcnNpb24gYWZ0ZXIgXCIlbFwiLCBcIiVuXCIgb3IgXCIlTFwiICopXG4gIGFuZCBpc19pbnRfYmFzZSBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT4gdHJ1ZVxuICAgIHwgXyAtPiBmYWxzZVxuXG4gICgqIENvbnZlcnQgYSBjaGFyIChsLCBuIG9yIEwpIHRvIGl0cyBhc3NvY2lhdGVkIGNvdW50ZXIuICopXG4gIGFuZCBjb3VudGVyX29mX2NoYXIgc3ltYiA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJ2wnIC0+IExpbmVfY291bnRlciAgfCAnbicgLT4gQ2hhcl9jb3VudGVyXG4gICAgfCAnTCcgLT4gVG9rZW5fY291bnRlciB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgaW50X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggc3BhY2Ugc3ltYiA9XG4gICAgbWF0Y2ggcGx1cywgaGFzaCwgc3BhY2UsIHN5bWIgd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9kICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfaVxuICAgIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2QnIC0+IEludF9zZCB8IGZhbHNlLCBmYWxzZSwgIHRydWUsICdpJyAtPiBJbnRfc2lcbiAgICB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdkJyAtPiBJbnRfcGQgfCAgdHJ1ZSwgZmFsc2UsIGZhbHNlLCAnaScgLT4gSW50X3BpXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAneCcgLT4gSW50X3ggIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ1gnIC0+IEludF9YXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAneCcgLT4gSW50X0N4IHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ1gnIC0+IEludF9DWFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ28nIC0+IEludF9vXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnbycgLT4gSW50X0NvXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAndScgLT4gSW50X3VcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdkJyAtPiBJbnRfQ2RcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdpJyAtPiBJbnRfQ2lcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd1JyAtPiBJbnRfQ3VcbiAgICB8IF8sIHRydWUsIF8sICd4JyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ3hcbiAgICB8IF8sIHRydWUsIF8sICdYJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ1hcbiAgICB8IF8sIHRydWUsIF8sICdvJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ29cbiAgICB8IF8sIHRydWUsIF8sICgnZCcgfCAnaScgfCAndScpIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBmYWxzZSBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCJcbiAgICB8IHRydWUsIF8sIHRydWUsIF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIlxuICAgIHwgZmFsc2UsIF8sIHRydWUsIF8gICAgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiXG4gICAgfCB0cnVlLCBfLCBmYWxzZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIGZhbHNlIGhhc2ggc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgZmFsc2UsIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3BhY2UsIHN5bWIpIHRvIGl0cyBhc3NvY2lhdGVkIGZsb2F0X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBsZXQgZmxhZyA9IG1hdGNoIHBsdXMsIHNwYWNlIHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSAtPiBGbG9hdF9mbGFnX1xuICAgIHwgZmFsc2UsICB0cnVlIC0+IEZsb2F0X2ZsYWdfc1xuICAgIHwgIHRydWUsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfcFxuICAgIHwgIHRydWUsICB0cnVlIC0+XG4gICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gRmxvYXRfZmxhZ19wXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIiBpblxuICAgIGxldCBraW5kID0gbWF0Y2ggaGFzaCwgc3ltYiB3aXRoXG4gICAgfCBfLCAnZicgLT4gRmxvYXRfZlxuICAgIHwgXywgJ2UnIC0+IEZsb2F0X2VcbiAgICB8IF8sICdFJyAtPiBGbG9hdF9FXG4gICAgfCBfLCAnZycgLT4gRmxvYXRfZ1xuICAgIHwgXywgJ0cnIC0+IEZsb2F0X0dcbiAgICB8IF8sICdoJyAtPiBGbG9hdF9oXG4gICAgfCBfLCAnSCcgLT4gRmxvYXRfSFxuICAgIHwgZmFsc2UsICdGJyAtPiBGbG9hdF9GXG4gICAgfCB0cnVlLCAnRicgLT4gRmxvYXRfQ0ZcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIGluXG4gICAgZmxhZywga2luZFxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBpbmNvbXBhdGlibGUgb3B0aW9ucy4qKVxuICBhbmQgaW5jb21wYXRpYmxlX2ZsYWcgOiB0eXBlIGEgLiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nIC0+IGEgPVxuICAgIGZ1biBwY3RfaW5kIHN0cl9pbmQgc3ltYiBvcHRpb24gLT5cbiAgICAgIGxldCBzdWJmbXQgPSBTdHJpbmcuc3ViIHN0ciBwY3RfaW5kIChzdHJfaW5kIC0gcGN0X2luZCkgaW5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgICVzIGlzIGluY29tcGF0aWJsZSB3aXRoICclYycgaW4gc3ViLWZvcm1hdCAlU1wiXG4gICAgICAgIHN0ciBwY3RfaW5kIG9wdGlvbiBzeW1iIHN1YmZtdFxuXG4gIGluIHBhcnNlIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgKCogR3VhcmRlZCBzdHJpbmcgdG8gZm9ybWF0IGNvbnZlcnNpb25zICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mbXR0eSBzdHIgZm10dHkgPVxuICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzdHIgaW5cbiAgdHJ5IEZvcm1hdCAodHlwZV9mb3JtYXQgZm10IGZtdHR5LCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiXG4gICAgICBzdHIgKHN0cmluZ19vZl9mbXR0eSBmbXR0eSlcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggYW4gb3RoZXIgZm9ybWF0LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mb3JtYXQgc3RyIChGb3JtYXQgKGZtdCcsIHN0cicpKSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgKGZtdHR5X29mX2ZtdCBmbXQnKSwgc3RyKVxuICB3aXRoIFR5cGVfbWlzbWF0Y2ggLT5cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImJhZCBpbnB1dDogZm9ybWF0IHR5cGUgbWlzbWF0Y2ggYmV0d2VlbiAlUyBhbmQgJVNcIiBzdHIgc3RyJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBYYXZpZXIgTGVyb3kgYW5kIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxubGV0IGtmcHJpbnRmIGsgbyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgbyBhY2M7IGsgbykgRW5kX29mX2FjYyBmbXRcbmxldCBrYnByaW50ZiBrIGIgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZiAoZnVuIGFjYyAtPiBidWZwdXRfYWNjIGIgYWNjOyBrIGIpIEVuZF9vZl9hY2MgZm10XG5sZXQgaWtmcHJpbnRmIGsgb2MgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBvYyBmbXRcbmxldCBpa2JwcmludGYgPSBpa2ZwcmludGZcblxubGV0IGZwcmludGYgb2MgZm10ID0ga2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGJwcmludGYgYiBmbXQgPSBrYnByaW50ZiBpZ25vcmUgYiBmbXRcbmxldCBpZnByaW50ZiBvYyBmbXQgPSBpa2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGlicHJpbnRmIGIgZm10ID0gaWticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZG91dCBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkZXJyIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBrJyBhY2MgPVxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDY0IGluXG4gICAgc3RycHV0X2FjYyBidWYgYWNjO1xuICAgIGsgKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10XG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAtPiBzKSBmbXRcblxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGtleSA9IHN0cmluZ1xudHlwZSBkb2MgPSBzdHJpbmdcbnR5cGUgdXNhZ2VfbXNnID0gc3RyaW5nXG50eXBlIGFub25fZnVuID0gKHN0cmluZyAtPiB1bml0KVxuXG50eXBlIHNwZWMgPVxuICB8IFVuaXQgb2YgKHVuaXQgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdW5pdCBhcmd1bWVudCAqKVxuICB8IEJvb2wgb2YgKGJvb2wgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBib29sIGFyZ3VtZW50ICopXG4gIHwgU2V0IG9mIGJvb2wgcmVmICAgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdHJ1ZSAqKVxuICB8IENsZWFyIG9mIGJvb2wgcmVmICAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIGZhbHNlICopXG4gIHwgU3RyaW5nIG9mIChzdHJpbmcgLT4gdW5pdCkgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IFNldF9zdHJpbmcgb2Ygc3RyaW5nIHJlZiAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBzdHJpbmcgYXJndW1lbnQgKilcbiAgfCBJbnQgb2YgKGludCAtPiB1bml0KSAgICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGFuIGludCBhcmd1bWVudCAqKVxuICB8IFNldF9pbnQgb2YgaW50IHJlZiAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBpbnQgYXJndW1lbnQgKilcbiAgfCBGbG9hdCBvZiAoZmxvYXQgLT4gdW5pdCkgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBTZXRfZmxvYXQgb2YgZmxvYXQgcmVmICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBUdXBsZSBvZiBzcGVjIGxpc3QgICAgICAgICAoKiBUYWtlIHNldmVyYWwgYXJndW1lbnRzIGFjY29yZGluZyB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjIGxpc3QgKilcbiAgfCBTeW1ib2wgb2Ygc3RyaW5nIGxpc3QgKiAoc3RyaW5nIC0+IHVuaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVGFrZSBvbmUgb2YgdGhlIHN5bWJvbHMgYXMgYXJndW1lbnQgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgc3ltYm9sLiAqKVxuICB8IFJlc3Qgb2YgKHN0cmluZyAtPiB1bml0KSAgICgqIFN0b3AgaW50ZXJwcmV0aW5nIGtleXdvcmRzIGFuZCBjYWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdpdGggZWFjaCByZW1haW5pbmcgYXJndW1lbnQgKilcbiAgfCBSZXN0X2FsbCBvZiAoc3RyaW5nIGxpc3QgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBTdG9wIGludGVycHJldGluZyBrZXl3b3JkcyBhbmQgY2FsbCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB3aXRoIGFsbCByZW1haW5pbmcgYXJndW1lbnRzLiAqKVxuICB8IEV4cGFuZCBvZiAoc3RyaW5nIC0+IHN0cmluZyBhcnJheSkgKCogSWYgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbW1wiLWZvb1wiOyBcImFyZ1wiXSBAIHJlc3RdIHdoZXJlIFwiZm9vXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHJlZ2lzdGVyZWQgYXMgW0V4cGFuZCBmXSwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyBbZiBcImFyZ1wiIEAgcmVzdF0gYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQuIE9ubHkgYWxsb3dlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXS4gKilcblxuZXhjZXB0aW9uIEJhZCBvZiBzdHJpbmdcbmV4Y2VwdGlvbiBIZWxwIG9mIHN0cmluZ1xuXG50eXBlIGVycm9yID1cbiAgfCBVbmtub3duIG9mIHN0cmluZ1xuICB8IFdyb25nIG9mIHN0cmluZyAqIHN0cmluZyAqIHN0cmluZyAgKCogb3B0aW9uLCBhY3R1YWwsIGV4cGVjdGVkICopXG4gIHwgTWlzc2luZyBvZiBzdHJpbmdcbiAgfCBNZXNzYWdlIG9mIHN0cmluZ1xuXG5leGNlcHRpb24gU3RvcCBvZiBlcnJvciAoKiB1c2VkIGludGVybmFsbHkgKilcblxub3BlbiBQcmludGZcblxubGV0IHJlYyBhc3NvYzMgeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKHkxLCB5MiwgXykgOjogXyB3aGVuIHkxID0geCAtPiB5MlxuICB8IF8gOjogdCAtPiBhc3NvYzMgeCB0XG5cblxubGV0IHNwbGl0IHMgPVxuICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc9JyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIFN0cmluZy5zdWIgcyAwIGksIFN0cmluZy5zdWIgcyAoaSsxKSAobGVuLShpKzEpKVxuXG5cbmxldCBtYWtlX3N5bWxpc3QgcHJlZml4IHNlcCBzdWZmaXggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiPG5vbmU+XCJcbiAgfCBoOjp0IC0+IChMaXN0LmZvbGRfbGVmdCAoZnVuIHggeSAtPiB4IF4gc2VwIF4geSkgKHByZWZpeCBeIGgpIHQpIF4gc3VmZml4XG5cblxubGV0IHByaW50X3NwZWMgYnVmIChrZXksIHNwZWMsIGRvYykgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGRvYyA+IDAgdGhlblxuICAgIG1hdGNoIHNwZWMgd2l0aFxuICAgIHwgU3ltYm9sIChsLCBfKSAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXMlc1xcblwiIGtleSAobWFrZV9zeW1saXN0IFwie1wiIFwifFwiIFwifVwiIGwpIGRvY1xuICAgIHwgXyAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXNcXG5cIiBrZXkgZG9jXG5cblxubGV0IGhlbHBfYWN0aW9uICgpID0gcmFpc2UgKFN0b3AgKFVua25vd24gXCItaGVscFwiKSlcblxubGV0IGFkZF9oZWxwIHNwZWNsaXN0ID1cbiAgbGV0IGFkZDEgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItaGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGFuZCBhZGQyID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi0taGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGluXG4gIHNwZWNsaXN0IEAgKGFkZDEgQCBhZGQyKVxuXG5cbmxldCB1c2FnZV9iIGJ1ZiBzcGVjbGlzdCBlcnJtc2cgPVxuICBicHJpbnRmIGJ1ZiBcIiVzXFxuXCIgZXJybXNnO1xuICBMaXN0Lml0ZXIgKHByaW50X3NwZWMgYnVmKSAoYWRkX2hlbHAgc3BlY2xpc3QpXG5cblxubGV0IHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIHVzYWdlX2IgYiBzcGVjbGlzdCBlcnJtc2c7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cblxubGV0IHVzYWdlIHNwZWNsaXN0IGVycm1zZyA9XG4gIGVwcmludGYgXCIlc1wiICh1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnKVxuXG5cbmxldCBjdXJyZW50ID0gcmVmIDBcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGJvb2xfb2Zfc3RyaW5nIHgpXG4gIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBhbGxvd19leHBhbmQgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJybXNnID1cbiAgbGV0IGluaXRwb3MgPSAhY3VycmVudCBpblxuICBsZXQgY29udmVydF9lcnJvciBlcnJvciA9XG4gICAgKCogY29udmVydCBhbiBpbnRlcm5hbCBlcnJvciB0byBhIEJhZC9IZWxwIGV4Y2VwdGlvblxuICAgICAgICpvciogYWRkIHRoZSBwcm9ncmFtIG5hbWUgYXMgYSBwcmVmaXggYW5kIHRoZSB1c2FnZSBtZXNzYWdlIGFzIGEgc3VmZml4XG4gICAgICAgdG8gYW4gdXNlci1yYWlzZWQgQmFkIGV4Y2VwdGlvbi5cbiAgICAqKVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgICBsZXQgcHJvZ25hbWUgPVxuICAgICAgaWYgaW5pdHBvcyA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKGluaXRwb3MpIGVsc2UgXCIoPylcIiBpblxuICAgIGJlZ2luIG1hdGNoIGVycm9yIHdpdGhcbiAgICAgIHwgVW5rbm93biBcIi1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBcIi0taGVscFwiIC0+ICgpXG4gICAgICB8IFVua25vd24gcyAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB1bmtub3duIG9wdGlvbiAnJXMnLlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgTWlzc2luZyBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IG9wdGlvbiAnJXMnIG5lZWRzIGFuIGFyZ3VtZW50LlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgV3JvbmcgKG9wdCwgYXJnLCBleHBlY3RlZCkgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogd3JvbmcgYXJndW1lbnQgJyVzJzsgb3B0aW9uICclcycgZXhwZWN0cyAlcy5cXG5cIlxuICAgICAgICAgICAgICAgICAgcHJvZ25hbWUgYXJnIG9wdCBleHBlY3RlZFxuICAgICAgfCBNZXNzYWdlIHMgLT4gKCogdXNlciBlcnJvciBtZXNzYWdlICopXG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6ICVzLlxcblwiIHByb2duYW1lIHNcbiAgICBlbmQ7XG4gICAgdXNhZ2VfYiBiICFzcGVjbGlzdCBlcnJtc2c7XG4gICAgaWYgZXJyb3IgPSBVbmtub3duIFwiLWhlbHBcIiB8fCBlcnJvciA9IFVua25vd24gXCItLWhlbHBcIlxuICAgIHRoZW4gSGVscCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gICAgZWxzZSBCYWQgKEJ1ZmZlci5jb250ZW50cyBiKVxuICBpblxuICBpbmNyIGN1cnJlbnQ7XG4gIHdoaWxlICFjdXJyZW50IDwgKEFycmF5Lmxlbmd0aCAhYXJndikgZG9cbiAgICBiZWdpbiB0cnlcbiAgICAgIGxldCBzID0gIWFyZ3YuKCFjdXJyZW50KSBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBzID49IDEgJiYgcy5bMF0gPSAnLScgdGhlbiBiZWdpblxuICAgICAgICBsZXQgYWN0aW9uLCBmb2xsb3cgPVxuICAgICAgICAgIHRyeSBhc3NvYzMgcyAhc3BlY2xpc3QsIE5vbmVcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IGtleXdvcmQsIGFyZyA9IHNwbGl0IHMgaW5cbiAgICAgICAgICAgIGFzc29jMyBrZXl3b3JkICFzcGVjbGlzdCwgU29tZSBhcmdcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiByYWlzZSAoU3RvcCAoVW5rbm93biBzKSlcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5vX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm5vIGFyZ3VtZW50XCIpKSkgaW5cbiAgICAgICAgbGV0IGdldF9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIGlmICFjdXJyZW50ICsgMSA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgZWxzZSByYWlzZSAoU3RvcCAoTWlzc2luZyBzKSlcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IGFyZ1xuICAgICAgICBpblxuICAgICAgICBsZXQgY29uc3VtZV9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGluY3IgY3VycmVudFxuICAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgIGluXG4gICAgICAgIGxldCByZWMgdHJlYXRfYWN0aW9uID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbml0IGYgLT4gbm9fYXJnICgpOyBmICgpO1xuICAgICAgICB8IEJvb2wgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGJvb2xfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgYm9vbGVhblwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgcyAtPiBmIHNcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldCByIC0+IG5vX2FyZyAoKTsgciA6PSB0cnVlO1xuICAgICAgICB8IENsZWFyIHIgLT4gbm9fYXJnICgpOyByIDo9IGZhbHNlO1xuICAgICAgICB8IFN0cmluZyBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTeW1ib2wgKHN5bWIsIGYpIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgaWYgTGlzdC5tZW0gYXJnIHN5bWIgdGhlbiBiZWdpblxuICAgICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgICByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJvbmUgb2Y6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIChtYWtlX3N5bWxpc3QgXCJcIiBcIiBcIiBcIlwiIHN5bWIpKSkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBTZXRfc3RyaW5nIHIgLT5cbiAgICAgICAgICAgIHIgOj0gZ2V0X2FyZyAoKTtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEludCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2ludCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgRmxvYXQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2Zsb2F0IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFR1cGxlIHNwZWNzIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICBMaXN0Lml0ZXIgdHJlYXRfYWN0aW9uIHNwZWNzO1xuICAgICAgICB8IFJlc3QgZiAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSAtIDEgZG9cbiAgICAgICAgICAgICAgZiAhYXJndi4oIWN1cnJlbnQgKyAxKTtcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICB8IFJlc3RfYWxsIGYgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIGxldCBhY2MgPSByZWYgW10gaW5cbiAgICAgICAgICAgIHdoaWxlICFjdXJyZW50IDwgQXJyYXkubGVuZ3RoICFhcmd2IC0gMSBkb1xuICAgICAgICAgICAgICBhY2MgOj0gIWFyZ3YuKCFjdXJyZW50ICsgMSkgOjogIWFjYztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICAgICAgZiAoTGlzdC5yZXYgIWFjYylcbiAgICAgICAgfCBFeHBhbmQgZiAtPlxuICAgICAgICAgICAgaWYgbm90IGFsbG93X2V4cGFuZCB0aGVuXG4gICAgICAgICAgICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiQXJnLkV4cGFuZCBpcyBpcyBvbmx5IGFsbG93ZWQgd2l0aCBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJnLnBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXCIpO1xuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGxldCBuZXdhcmcgPSBmIGFyZyBpblxuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gQXJyYXkuc3ViICFhcmd2IDAgKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgIGFuZCBhZnRlciA9XG4gICAgICAgICAgICAgIEFycmF5LnN1YiAhYXJndiAoIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgKChBcnJheS5sZW5ndGggIWFyZ3YpIC0gIWN1cnJlbnQgLSAxKSBpblxuICAgICAgICAgICAgYXJndjo9IEFycmF5LmNvbmNhdCBbYmVmb3JlO25ld2FyZzthZnRlcl07XG4gICAgICAgIGluXG4gICAgICAgIHRyZWF0X2FjdGlvbiBhY3Rpb24gZW5kXG4gICAgICBlbHNlIGFub25mdW4gc1xuICAgIHdpdGggfCBCYWQgbSAtPiByYWlzZSAoY29udmVydF9lcnJvciAoTWVzc2FnZSBtKSk7XG4gICAgICAgICB8IFN0b3AgZSAtPiByYWlzZSAoY29udmVydF9lcnJvciBlKTtcbiAgICBlbmQ7XG4gICAgaW5jciBjdXJyZW50XG4gIGRvbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCB0cnVlIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZ1xuXG5sZXQgcGFyc2VfYXJndl9keW5hbWljID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGZhbHNlIGN1cnJlbnQgKHJlZiBhcmd2KSBzcGVjbGlzdCBhbm9uZnVuXG4gICAgZXJybXNnXG5cblxubGV0IHBhcnNlX2FyZ3YgPyhjdXJyZW50PWN1cnJlbnQpIGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hcmd2X2R5bmFtaWMgfmN1cnJlbnQ6Y3VycmVudCBhcmd2IChyZWYgc3BlY2xpc3QpIGFub25mdW4gZXJybXNnXG5cblxubGV0IHBhcnNlIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2IFN5cy5hcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cblxubGV0IHBhcnNlX2R5bmFtaWMgbCBmIG1zZyA9XG4gIHRyeVxuICAgIHBhcnNlX2FyZ3ZfZHluYW1pYyBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5sZXQgcGFyc2VfZXhwYW5kIGwgZiBtc2cgPVxuICB0cnlcbiAgICBsZXQgYXJndiA9IHJlZiBTeXMuYXJndiBpblxuICAgIGxldCBzcGVjID0gcmVmIGwgaW5cbiAgICBsZXQgY3VycmVudCA9IHJlZiAoIWN1cnJlbnQpIGluXG4gICAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMgY3VycmVudCBhcmd2IHNwZWMgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cblxubGV0IHNlY29uZF93b3JkIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBuID1cbiAgICBpZiBuID49IGxlbiB0aGVuIGxlblxuICAgIGVsc2UgaWYgcy5bbl0gPSAnICcgdGhlbiBsb29wIChuKzEpXG4gICAgZWxzZSBuXG4gIGluXG4gIG1hdGNoIFN0cmluZy5pbmRleCBzICdcXHQnIHdpdGhcbiAgfCBuIC0+IGxvb3AgKG4rMSlcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+XG4gICAgICBiZWdpbiBtYXRjaCBTdHJpbmcuaW5kZXggcyAnICcgd2l0aFxuICAgICAgfCBuIC0+IGxvb3AgKG4rMSlcbiAgICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiBsZW5cbiAgICAgIGVuZFxuXG5cbmxldCBtYXhfYXJnX2xlbiBjdXIgKGt3ZCwgc3BlYywgZG9jKSA9XG4gIG1hdGNoIHNwZWMgd2l0aFxuICB8IFN5bWJvbCBfIC0+IEludC5tYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZClcbiAgfCBfIC0+IEludC5tYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZCArIHNlY29uZF93b3JkIGRvYylcblxuXG5sZXQgcmVwbGFjZV9sZWFkaW5nX3RhYiBzID1cbiAgbGV0IHNlZW4gPSByZWYgZmFsc2UgaW5cbiAgU3RyaW5nLm1hcCAoZnVuY3Rpb24gJ1xcdCcgd2hlbiBub3QgIXNlZW4gLT4gc2VlbiA6PSB0cnVlOyAnICcgfCBjIC0+IGMpIHNcblxubGV0IGFkZF9wYWRkaW5nIGxlbiBrc2QgPVxuICBtYXRjaCBrc2Qgd2l0aFxuICB8IChfLCBfLCBcIlwiKSAtPlxuICAgICAgKCogRG8gbm90IHBhZCB1bmRvY3VtZW50ZWQgb3B0aW9ucywgc28gdGhhdCB0aGV5IHN0aWxsIGRvbid0IHNob3cgdXAgd2hlblxuICAgICAgICogcnVuIHRocm91Z2ggW3VzYWdlXSBvciBbcGFyc2VdLiAqKVxuICAgICAga3NkXG4gIHwgKGt3ZCwgKFN5bWJvbCBfIGFzIHNwZWMpLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgKChJbnQubWF4IDAgKGxlbiAtIGN1dGNvbCkpICsgMykgJyAnIGluXG4gICAgICAoa3dkLCBzcGVjLCBcIlxcblwiIF4gc3BhY2VzIF4gcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gIHwgKGt3ZCwgc3BlYywgbXNnKSAtPlxuICAgICAgbGV0IGN1dGNvbCA9IHNlY29uZF93b3JkIG1zZyBpblxuICAgICAgbGV0IGt3ZF9sZW4gPSBTdHJpbmcubGVuZ3RoIGt3ZCBpblxuICAgICAgbGV0IGRpZmYgPSBsZW4gLSBrd2RfbGVuIC0gY3V0Y29sIGluXG4gICAgICBpZiBkaWZmIDw9IDAgdGhlblxuICAgICAgICAoa3dkLCBzcGVjLCByZXBsYWNlX2xlYWRpbmdfdGFiIG1zZylcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHNwYWNlcyA9IFN0cmluZy5tYWtlIGRpZmYgJyAnIGluXG4gICAgICAgIGxldCBwcmVmaXggPSBTdHJpbmcuc3ViIChyZXBsYWNlX2xlYWRpbmdfdGFiIG1zZykgMCBjdXRjb2wgaW5cbiAgICAgICAgbGV0IHN1ZmZpeCA9IFN0cmluZy5zdWIgbXNnIGN1dGNvbCAoU3RyaW5nLmxlbmd0aCBtc2cgLSBjdXRjb2wpIGluXG4gICAgICAgIChrd2QsIHNwZWMsIHByZWZpeCBeIHNwYWNlcyBeIHN1ZmZpeClcblxuXG5sZXQgYWxpZ24gPyhsaW1pdD1tYXhfaW50KSBzcGVjbGlzdCA9XG4gIGxldCBjb21wbGV0ZWQgPSBhZGRfaGVscCBzcGVjbGlzdCBpblxuICBsZXQgbGVuID0gTGlzdC5mb2xkX2xlZnQgbWF4X2FyZ19sZW4gMCBjb21wbGV0ZWQgaW5cbiAgbGV0IGxlbiA9IEludC5taW4gbGVuIGxpbWl0IGluXG4gIExpc3QubWFwIChhZGRfcGFkZGluZyBsZW4pIGNvbXBsZXRlZFxuXG5sZXQgdHJpbV9jciBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBpZiBsZW4gPiAwICYmIFN0cmluZy5nZXQgcyAobGVuIC0gMSkgPSAnXFxyJyB0aGVuXG4gICAgU3RyaW5nLnN1YiBzIDAgKGxlbiAtIDEpXG4gIGVsc2VcbiAgICBzXG5cbmxldCByZWFkX2F1eCB0cmltIHNlcCBmaWxlID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgbGV0IHdvcmRzID0gcmVmIFtdIGluXG4gIGxldCBzdGFzaCAoKSA9XG4gICAgbGV0IHdvcmQgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gICAgbGV0IHdvcmQgPSBpZiB0cmltIHRoZW4gdHJpbV9jciB3b3JkIGVsc2Ugd29yZCBpblxuICAgIHdvcmRzIDo9IHdvcmQgOjogIXdvcmRzO1xuICAgIEJ1ZmZlci5jbGVhciBidWZcbiAgaW5cbiAgYmVnaW5cbiAgICB0cnkgd2hpbGUgdHJ1ZSBkb1xuICAgICAgICBsZXQgYyA9IGlucHV0X2NoYXIgaWMgaW5cbiAgICAgICAgaWYgYyA9IHNlcCB0aGVuIHN0YXNoICgpIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjXG4gICAgICBkb25lXG4gICAgd2l0aCBFbmRfb2ZfZmlsZSAtPiAoKVxuICBlbmQ7XG4gIGlmIEJ1ZmZlci5sZW5ndGggYnVmID4gMCB0aGVuIHN0YXNoICgpO1xuICBjbG9zZV9pbiBpYztcbiAgQXJyYXkub2ZfbGlzdCAoTGlzdC5yZXYgIXdvcmRzKVxuXG5sZXQgcmVhZF9hcmcgPSByZWFkX2F1eCB0cnVlICdcXG4nXG5cbmxldCByZWFkX2FyZzAgPSByZWFkX2F1eCBmYWxzZSAnXFx4MDAnXG5cbmxldCB3cml0ZV9hdXggc2VwIGZpbGUgYXJncyA9XG4gIGxldCBvYyA9IG9wZW5fb3V0X2JpbiBmaWxlIGluXG4gIEFycmF5Lml0ZXIgKGZ1biBzIC0+IGZwcmludGYgb2MgXCIlcyVjXCIgcyBzZXApIGFyZ3M7XG4gIGNsb3NlX291dCBvY1xuXG5sZXQgd3JpdGVfYXJnID0gd3JpdGVfYXV4ICdcXG4nXG5cbmxldCB3cml0ZV9hcmcwID0gd3JpdGVfYXV4ICdcXHgwMCdcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBQcmludGZcblxudHlwZSB0ID0gZXhuID0gLi5cblxubGV0IHByaW50ZXJzID0gQXRvbWljLm1ha2UgW11cblxubGV0IGxvY2ZtdCA9IGZvcm1hdF9vZl9zdHJpbmcgXCJGaWxlIFxcXCIlc1xcXCIsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWQ6ICVzXCJcblxubGV0IGZpZWxkIHggaSA9XG4gIGxldCBmID0gT2JqLmZpZWxkIHggaSBpblxuICBpZiBub3QgKE9iai5pc19ibG9jayBmKSB0aGVuXG4gICAgc3ByaW50ZiBcIiVkXCIgKE9iai5tYWdpYyBmIDogaW50KSAgICAgICAgICAgKCogY2FuIGFsc28gYmUgYSBjaGFyICopXG4gIGVsc2UgaWYgT2JqLnRhZyBmID0gT2JqLnN0cmluZ190YWcgdGhlblxuICAgIHNwcmludGYgXCIlU1wiIChPYmoubWFnaWMgZiA6IHN0cmluZylcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouZG91YmxlX3RhZyB0aGVuXG4gICAgc3RyaW5nX29mX2Zsb2F0IChPYmoubWFnaWMgZiA6IGZsb2F0KVxuICBlbHNlXG4gICAgXCJfXCJcblxubGV0IHJlYyBvdGhlcl9maWVsZHMgeCBpID1cbiAgaWYgaSA+PSBPYmouc2l6ZSB4IHRoZW4gXCJcIlxuICBlbHNlIHNwcmludGYgXCIsICVzJXNcIiAoZmllbGQgeCBpKSAob3RoZXJfZmllbGRzIHggKGkrMSkpXG5cbmxldCBmaWVsZHMgeCA9XG4gIG1hdGNoIE9iai5zaXplIHggd2l0aFxuICB8IDAgLT4gXCJcIlxuICB8IDEgLT4gXCJcIlxuICB8IDIgLT4gc3ByaW50ZiBcIiglcylcIiAoZmllbGQgeCAxKVxuICB8IF8gLT4gc3ByaW50ZiBcIiglcyVzKVwiIChmaWVsZCB4IDEpIChvdGhlcl9maWVsZHMgeCAyKVxuXG5sZXQgdXNlX3ByaW50ZXJzIHggPVxuICBsZXQgcmVjIGNvbnYgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgKG1hdGNoIGhkIHggd2l0aFxuICAgICAgICAgfCBOb25lIHwgZXhjZXB0aW9uIF8gLT4gY29udiB0bFxuICAgICAgICAgfCBTb21lIHMgLT4gU29tZSBzKVxuICAgIHwgW10gLT4gTm9uZSBpblxuICBjb252IChBdG9taWMuZ2V0IHByaW50ZXJzKVxuXG5sZXQgdG9fc3RyaW5nX2RlZmF1bHQgPSBmdW5jdGlvblxuICB8IE91dF9vZl9tZW1vcnkgLT4gXCJPdXQgb2YgbWVtb3J5XCJcbiAgfCBTdGFja19vdmVyZmxvdyAtPiBcIlN0YWNrIG92ZXJmbG93XCJcbiAgfCBNYXRjaF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis1KSBcIlBhdHRlcm4gbWF0Y2hpbmcgZmFpbGVkXCJcbiAgfCBBc3NlcnRfZmFpbHVyZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJBc3NlcnRpb24gZmFpbGVkXCJcbiAgfCBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJVbmRlZmluZWQgcmVjdXJzaXZlIG1vZHVsZVwiXG4gIHwgeCAtPlxuICAgICAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gICAgICBpZiBPYmoudGFnIHggPD4gMCB0aGVuXG4gICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCB4IDApIDogc3RyaW5nKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgY29uc3RydWN0b3IgPVxuICAgICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCAoT2JqLmZpZWxkIHggMCkgMCkgOiBzdHJpbmcpIGluXG4gICAgICAgIGNvbnN0cnVjdG9yIF4gKGZpZWxkcyB4KVxuXG5sZXQgdG9fc3RyaW5nIGUgPVxuICBtYXRjaCB1c2VfcHJpbnRlcnMgZSB3aXRoXG4gIHwgU29tZSBzIC0+IHNcbiAgfCBOb25lIC0+IHRvX3N0cmluZ19kZWZhdWx0IGVcblxubGV0IHByaW50IGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBmbHVzaCBzdGRlcnI7XG4gICAgcmFpc2UgeFxuXG5sZXQgY2F0Y2ggZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZmx1c2ggc3Rkb3V0O1xuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBleGl0IDJcblxudHlwZSByYXdfYmFja3RyYWNlX3Nsb3RcbnR5cGUgcmF3X2JhY2t0cmFjZV9lbnRyeSA9IHByaXZhdGUgaW50XG50eXBlIHJhd19iYWNrdHJhY2UgPSByYXdfYmFja3RyYWNlX2VudHJ5IGFycmF5XG5cbmxldCByYXdfYmFja3RyYWNlX2VudHJpZXMgYnQgPSBidFxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZTpcbiAgdW5pdCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZVwiXG5cbmV4dGVybmFsIHJhaXNlX3dpdGhfYmFja3RyYWNlOiBleG4gLT4gcmF3X2JhY2t0cmFjZSAtPiAnYVxuICA9IFwiJXJhaXNlX3dpdGhfYmFja3RyYWNlXCJcblxudHlwZSBiYWNrdHJhY2Vfc2xvdCA9XG4gIHwgS25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgICAgOiBib29sO1xuICAgICAgZmlsZW5hbWUgICAgOiBzdHJpbmc7XG4gICAgICBsaW5lX251bWJlciA6IGludDtcbiAgICAgIHN0YXJ0X2NoYXIgIDogaW50O1xuICAgICAgZW5kX2NoYXIgICAgOiBpbnQ7XG4gICAgICBpc19pbmxpbmUgICA6IGJvb2w7XG4gICAgICBkZWZuYW1lICAgICA6IHN0cmluZztcbiAgICB9XG4gIHwgVW5rbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSA6IGJvb2xcbiAgICB9XG5cbigqIHRvIGF2b2lkIHdhcm5pbmcgKilcbmxldCBfID0gW0tub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZTsgZmlsZW5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lX251bWJlciA9IDA7IHN0YXJ0X2NoYXIgPSAwOyBlbmRfY2hhciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzX2lubGluZSA9IGZhbHNlOyBkZWZuYW1lID0gXCJcIiB9O1xuICAgICAgICAgVW5rbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2UgfV1cblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Q6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiBiYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZTpcbiAgcmF3X2JhY2t0cmFjZSAtPiBiYWNrdHJhY2Vfc2xvdCBhcnJheSA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2VcIlxuXG5sZXQgY29udmVydF9yYXdfYmFja3RyYWNlIGJ0ID1cbiAgdHJ5IFNvbWUgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgZm9ybWF0X2JhY2t0cmFjZV9zbG90IHBvcyBzbG90ID1cbiAgbGV0IGluZm8gaXNfcmFpc2UgPVxuICAgIGlmIGlzX3JhaXNlIHRoZW5cbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBhdFwiIGVsc2UgXCJSZS1yYWlzZWQgYXRcIlxuICAgIGVsc2VcbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBieSBwcmltaXRpdmUgb3BlcmF0aW9uIGF0XCIgZWxzZSBcIkNhbGxlZCBmcm9tXCJcbiAgaW5cbiAgbWF0Y2ggc2xvdCB3aXRoXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBpZiBsLmlzX3JhaXNlIHRoZW5cbiAgICAgICAgKCogY29tcGlsZXItaW5zZXJ0ZWQgcmUtcmFpc2UsIHNraXBwZWQgKikgTm9uZVxuICAgICAgZWxzZVxuICAgICAgICBTb21lIChzcHJpbnRmIFwiJXMgdW5rbm93biBsb2NhdGlvblwiIChpbmZvIGZhbHNlKSlcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBTb21lIChzcHJpbnRmIFwiJXMgJXMgaW4gZmlsZSBcXFwiJXNcXFwiJXMsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWRcIlxuICAgICAgICAgICAgICAoaW5mbyBsLmlzX3JhaXNlKSBsLmRlZm5hbWUgbC5maWxlbmFtZVxuICAgICAgICAgICAgICAoaWYgbC5pc19pbmxpbmUgdGhlbiBcIiAoaW5saW5lZClcIiBlbHNlIFwiXCIpXG4gICAgICAgICAgICAgIGwubGluZV9udW1iZXIgbC5zdGFydF9jaGFyIGwuZW5kX2NoYXIpXG5cbmxldCBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgICBmcHJpbnRmIG91dGNoYW5cbiAgICAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gZnByaW50ZiBvdXRjaGFuIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmVcblxubGV0IHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiByYXdfYmFja3RyYWNlID1cbiAgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6IHByaW50cyB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgcHJpbnRfYmFja3RyYWNlIG91dGNoYW4gPVxuICBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5sZXQgYmFja3RyYWNlX3RvX3N0cmluZyBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxMDI0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGJwcmludGYgYiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJcblxubGV0IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHJhd19iYWNrdHJhY2UgPVxuICBiYWNrdHJhY2VfdG9fc3RyaW5nIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfaW5saW5lXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG5cbnR5cGUgbG9jYXRpb24gPSB7XG4gIGZpbGVuYW1lIDogc3RyaW5nO1xuICBsaW5lX251bWJlciA6IGludDtcbiAgc3RhcnRfY2hhciA6IGludDtcbiAgZW5kX2NoYXIgOiBpbnQ7XG59XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgU29tZSB7XG4gICAgICBmaWxlbmFtZSAgICA9IGwuZmlsZW5hbWU7XG4gICAgICBsaW5lX251bWJlciA9IGwubGluZV9udW1iZXI7XG4gICAgICBzdGFydF9jaGFyICA9IGwuc3RhcnRfY2hhcjtcbiAgICAgIGVuZF9jaGFyICAgID0gbC5lbmRfY2hhcjtcbiAgICB9XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF9cbiAgfCBLbm93bl9sb2NhdGlvbiB7IGRlZm5hbWUgPSBcIlwiIH0gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gU29tZSBsLmRlZm5hbWVcblxubGV0IGJhY2t0cmFjZV9zbG90cyByYXdfYmFja3RyYWNlID1cbiAgKCogVGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBndWFyYW50ZWVzIHRoYXQgU29tZSBpc1xuICAgICByZXR1cm5lZCBvbmx5IGlmIGEgcGFydCBvZiB0aGUgdHJhY2UgaXMgdXNhYmxlLiBUaGlzIGdpdmVzIHVzXG4gICAgIGEgYml0IG1vcmUgd29yayB0aGFuIGp1c3QgY29udmVydF9yYXdfYmFja3RyYWNlLCBidXQgaXQgbWFrZXMgdGhlXG4gICAgIEFQSSBtb3JlIHVzZXItZnJpZW5kbHkgLS0gb3RoZXJ3aXNlIG1vc3QgdXNlcnMgd291bGQgaGF2ZSB0b1xuICAgICByZWltcGxlbWVudCB0aGUgXCJQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgc29ycnlcIiBsb2dpY1xuICAgICB0aGVtc2VsdmVzLiAqKVxuICBtYXRjaCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgYmFja3RyYWNlIC0+XG4gICAgICBsZXQgdXNhYmxlX3Nsb3QgPSBmdW5jdGlvblxuICAgICAgICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuICAgICAgICB8IEtub3duX2xvY2F0aW9uIF8gLT4gdHJ1ZSBpblxuICAgICAgbGV0IHJlYyBleGlzdHNfdXNhYmxlID0gZnVuY3Rpb25cbiAgICAgICAgfCAoLTEpIC0+IGZhbHNlXG4gICAgICAgIHwgaSAtPiB1c2FibGVfc2xvdCBiYWNrdHJhY2UuKGkpIHx8IGV4aXN0c191c2FibGUgKGkgLSAxKSBpblxuICAgICAgaWYgZXhpc3RzX3VzYWJsZSAoQXJyYXkubGVuZ3RoIGJhY2t0cmFjZSAtIDEpXG4gICAgICB0aGVuIFNvbWUgYmFja3RyYWNlXG4gICAgICBlbHNlIE5vbmVcblxubGV0IGJhY2t0cmFjZV9zbG90c19vZl9yYXdfZW50cnkgZW50cnkgPVxuICBiYWNrdHJhY2Vfc2xvdHMgW3wgZW50cnkgfF1cblxubW9kdWxlIFNsb3QgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGZvcm1hdCA9IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdFxuICBsZXQgaXNfcmFpc2UgPSBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZVxuICBsZXQgaXNfaW5saW5lID0gYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lXG4gIGxldCBsb2NhdGlvbiA9IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uXG4gIGxldCBuYW1lID0gYmFja3RyYWNlX3Nsb3RfZGVmbmFtZVxuZW5kXG5cbmxldCByYXdfYmFja3RyYWNlX2xlbmd0aCBidCA9IEFycmF5Lmxlbmd0aCBidFxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgLT4gcmF3X2JhY2t0cmFjZV9zbG90ID0gXCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiByYXdfYmFja3RyYWNlX3Nsb3Qgb3B0aW9uXG4gID0gXCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XCJcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6XG4gICByZXR1cm5zIHRoZSAqc3RyaW5nKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBnZXRfYmFja3RyYWNlICgpID0gcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5leHRlcm5hbCByZWNvcmRfYmFja3RyYWNlOiBib29sIC0+IHVuaXQgPSBcImNhbWxfcmVjb3JkX2JhY2t0cmFjZVwiXG5leHRlcm5hbCBiYWNrdHJhY2Vfc3RhdHVzOiB1bml0IC0+IGJvb2wgPSBcImNhbWxfYmFja3RyYWNlX3N0YXR1c1wiXG5cbmxldCByZWMgcmVnaXN0ZXJfcHJpbnRlciBmbiA9XG4gIGxldCBvbGRfcHJpbnRlcnMgPSBBdG9taWMuZ2V0IHByaW50ZXJzIGluXG4gIGxldCBuZXdfcHJpbnRlcnMgPSBmbiA6OiBvbGRfcHJpbnRlcnMgaW5cbiAgbGV0IHN1Y2Nlc3MgPSBBdG9taWMuY29tcGFyZV9hbmRfc2V0IHByaW50ZXJzIG9sZF9wcmludGVycyBuZXdfcHJpbnRlcnMgaW5cbiAgaWYgbm90IHN1Y2Nlc3MgdGhlbiByZWdpc3Rlcl9wcmludGVyIGZuXG5cbmV4dGVybmFsIGdldF9jYWxsc3RhY2s6IGludCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFja1wiXG5cbmxldCBleG5fc2xvdCB4ID1cbiAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gIGlmIE9iai50YWcgeCA9IDAgdGhlbiBPYmouZmllbGQgeCAwIGVsc2UgeFxuXG5sZXQgZXhuX3Nsb3RfaWQgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMSkgOiBpbnQpXG5cbmxldCBleG5fc2xvdF9uYW1lIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDApIDogc3RyaW5nKVxuXG5leHRlcm5hbCBnZXRfZGVidWdfaW5mb19zdGF0dXMgOiB1bml0IC0+IGludCA9IFwiY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1c1wiXG5cbigqIERlc2NyaXB0aW9ucyBmb3IgZXJyb3JzIGluIHN0YXJ0dXAuaC4gU2VlIGFsc28gYmFja3RyYWNlLmMgKilcbmxldCBlcnJvcnMgPSBbfCBcIlwiO1xuICAoKiBGSUxFX05PVF9GT1VORCAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgbm90IGZvdW5kKVwiO1xuICAoKiBCQURfQllURUNPREUgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGFwcGVhcnMgdG8gYmUgY29ycnVwdClcIjtcbiAgKCogV1JPTkdfTUFHSUMgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGhhcyB3cm9uZyBtYWdpYyBudW1iZXIpXCI7XG4gICgqIE5PX0ZEUyAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgY2Fubm90IGJlIG9wZW5lZDtcXG4gXFxcbiAgICAgIC0tIHRvbyBtYW55IG9wZW4gZmlsZXMuIFRyeSBydW5uaW5nIHdpdGggT0NBTUxSVU5QQVJBTT1iPTIpXCJcbnxdXG5cbmxldCBkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGV4biByYXdfYmFja3RyYWNlID1cbiAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gIGxldCBzdGF0dXMgPSBnZXRfZGVidWdfaW5mb19zdGF0dXMgKCkgaW5cbiAgaWYgc3RhdHVzIDwgMCB0aGVuXG4gICAgcHJlcnJfZW5kbGluZSBlcnJvcnMuKGFicyBzdGF0dXMpO1xuICBmbHVzaCBzdGRlcnJcblxubGV0IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyID0gcmVmIGRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXJcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBmbiA9IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIDo9IGZuXG5cbmxldCBlbXB0eV9iYWNrdHJhY2UgOiByYXdfYmFja3RyYWNlID0gW3wgfF1cblxubGV0IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSA9XG4gIHRyeVxuICAgIGdldF9yYXdfYmFja3RyYWNlICgpXG4gIHdpdGggXyAoKiBPdXRfb2ZfbWVtb3J5PyAqKSAtPlxuICAgIGVtcHR5X2JhY2t0cmFjZVxuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgICgqIEdldCB0aGUgYmFja3RyYWNlIG5vdywgaW4gY2FzZSBvbmUgb2YgdGhlIFthdF9leGl0XSBmdW5jdGlvblxuICAgICAgIGRlc3Ryb3lzIGl0LiAqKVxuICAgIGxldCByYXdfYmFja3RyYWNlID1cbiAgICAgIGlmIGRlYnVnZ2VyX2luX3VzZSAoKiBTYW1lIHRlc3QgYXMgaW4gW3J1bnRpbWUvcHJpbnRleGMuY10gKikgdGhlblxuICAgICAgICBlbXB0eV9iYWNrdHJhY2VcbiAgICAgIGVsc2VcbiAgICAgICAgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpXG4gICAgaW5cbiAgICAodHJ5IFN0ZGxpYi5kb19hdF9leGl0ICgpIHdpdGggXyAtPiAoKSk7XG4gICAgdHJ5XG4gICAgICAhdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZXhuIHJhd19iYWNrdHJhY2VcbiAgICB3aXRoIGV4bicgLT5cbiAgICAgIGxldCByYXdfYmFja3RyYWNlJyA9IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yIGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyOiBleGNlcHRpb24gJXNcXG5cIlxuICAgICAgICAodG9fc3RyaW5nIGV4bicpO1xuICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZSc7XG4gICAgICBmbHVzaCBzdGRlcnJcbiAgd2l0aFxuICAgIHwgT3V0X29mX21lbW9yeSAtPlxuICAgICAgICBwcmVycl9lbmRsaW5lXG4gICAgICAgICAgXCJGYXRhbCBlcnJvcjogb3V0IG9mIG1lbW9yeSBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlclwiXG5cbigqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IFtjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbl0gaW5cbiAgIFtydW50aW1lL3ByaW50ZXhjLmNdIHdoaWNoIGV4cGVjdHMgbm8gZXhjZXB0aW9uIGlzIHJhaXNlZC4gKilcbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlXG4gIHdpdGggXyAtPlxuICAgICgqIFRoZXJlIGlzIG5vdCBtdWNoIHdlIGNhbiBkbyBhdCB0aGlzIHBvaW50ICopXG4gICAgKClcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUHJpbnRleGMuaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblwiXG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBpZCA6ICdhIC0+ICdhID0gXCIlaWRlbnRpdHlcIlxubGV0IGNvbnN0IGMgXyA9IGNcbmxldCBmbGlwIGYgeCB5ID0gZiB5IHhcbmxldCBuZWdhdGUgcCB2ID0gbm90IChwIHYpXG5cbmV4Y2VwdGlvbiBGaW5hbGx5X3JhaXNlZCBvZiBleG5cblxubGV0ICgpID0gUHJpbnRleGMucmVnaXN0ZXJfcHJpbnRlciBAQCBmdW5jdGlvblxufCBGaW5hbGx5X3JhaXNlZCBleG4gLT4gU29tZSAoXCJGdW4uRmluYWxseV9yYWlzZWQ6IFwiIF4gUHJpbnRleGMudG9fc3RyaW5nIGV4bilcbnwgXyAtPiBOb25lXG5cbmxldCBwcm90ZWN0IH4oZmluYWxseSA6IHVuaXQgLT4gdW5pdCkgd29yayA9XG4gIGxldCBmaW5hbGx5X25vX2V4biAoKSA9XG4gICAgdHJ5IGZpbmFsbHkgKCkgd2l0aCBlIC0+XG4gICAgICBsZXQgYnQgPSBQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgKEZpbmFsbHlfcmFpc2VkIGUpIGJ0XG4gIGluXG4gIG1hdGNoIHdvcmsgKCkgd2l0aFxuICB8IHJlc3VsdCAtPiBmaW5hbGx5X25vX2V4biAoKSA7IHJlc3VsdFxuICB8IGV4Y2VwdGlvbiB3b3JrX2V4biAtPlxuICAgICAgbGV0IHdvcmtfYnQgPSBQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgZmluYWxseV9ub19leG4gKCkgO1xuICAgICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2Ugd29ya19leG4gd29ya19idFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBKYWNxdWVzLUhlbnJpIEpvdXJkYW4sIHByb2pldCBHYWxsaXVtLCBJTlJJQSBQYXJpcyAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5Ni0yMDE2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgICAqKVxuKCogICAgIGV0IGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHN0YXQgPSB7XG4gIG1pbm9yX3dvcmRzIDogZmxvYXQ7XG4gIHByb21vdGVkX3dvcmRzIDogZmxvYXQ7XG4gIG1ham9yX3dvcmRzIDogZmxvYXQ7XG4gIG1pbm9yX2NvbGxlY3Rpb25zIDogaW50O1xuICBtYWpvcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgaGVhcF93b3JkcyA6IGludDtcbiAgaGVhcF9jaHVua3MgOiBpbnQ7XG4gIGxpdmVfd29yZHMgOiBpbnQ7XG4gIGxpdmVfYmxvY2tzIDogaW50O1xuICBmcmVlX3dvcmRzIDogaW50O1xuICBmcmVlX2Jsb2NrcyA6IGludDtcbiAgbGFyZ2VzdF9mcmVlIDogaW50O1xuICBmcmFnbWVudHMgOiBpbnQ7XG4gIGNvbXBhY3Rpb25zIDogaW50O1xuICB0b3BfaGVhcF93b3JkcyA6IGludDtcbiAgc3RhY2tfc2l6ZSA6IGludDtcbiAgZm9yY2VkX21ham9yX2NvbGxlY3Rpb25zOiBpbnQ7XG59XG5cbnR5cGUgY29udHJvbCA9IHtcbiAgbXV0YWJsZSBtaW5vcl9oZWFwX3NpemUgOiBpbnQ7XG4gIG11dGFibGUgbWFqb3JfaGVhcF9pbmNyZW1lbnQgOiBpbnQ7XG4gIG11dGFibGUgc3BhY2Vfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgdmVyYm9zZSA6IGludDtcbiAgbXV0YWJsZSBtYXhfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgc3RhY2tfbGltaXQgOiBpbnQ7XG4gIG11dGFibGUgYWxsb2NhdGlvbl9wb2xpY3kgOiBpbnQ7XG4gIHdpbmRvd19zaXplIDogaW50O1xuICBjdXN0b21fbWFqb3JfcmF0aW8gOiBpbnQ7XG4gIGN1c3RvbV9taW5vcl9yYXRpbyA6IGludDtcbiAgY3VzdG9tX21pbm9yX21heF9zaXplIDogaW50O1xufVxuXG5leHRlcm5hbCBzdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3N0YXRcIlxuZXh0ZXJuYWwgcXVpY2tfc3RhdCA6IHVuaXQgLT4gc3RhdCA9IFwiY2FtbF9nY19xdWlja19zdGF0XCJcbmV4dGVybmFsIGNvdW50ZXJzIDogdW5pdCAtPiAoZmxvYXQgKiBmbG9hdCAqIGZsb2F0KSA9IFwiY2FtbF9nY19jb3VudGVyc1wiXG5leHRlcm5hbCBtaW5vcl93b3JkcyA6IHVuaXQgLT4gKGZsb2F0IFtAdW5ib3hlZF0pXG4gID0gXCJjYW1sX2djX21pbm9yX3dvcmRzXCIgXCJjYW1sX2djX21pbm9yX3dvcmRzX3VuYm94ZWRcIlxuZXh0ZXJuYWwgZ2V0IDogdW5pdCAtPiBjb250cm9sID0gXCJjYW1sX2djX2dldFwiXG5leHRlcm5hbCBzZXQgOiBjb250cm9sIC0+IHVuaXQgPSBcImNhbWxfZ2Nfc2V0XCJcbmV4dGVybmFsIG1pbm9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21pbm9yXCJcbmV4dGVybmFsIG1ham9yX3NsaWNlIDogaW50IC0+IGludCA9IFwiY2FtbF9nY19tYWpvcl9zbGljZVwiXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBmdWxsX21ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2Z1bGxfbWFqb3JcIlxuZXh0ZXJuYWwgY29tcGFjdCA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19jb21wYWN0aW9uXCJcbmV4dGVybmFsIGdldF9taW5vcl9mcmVlIDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21pbm9yX2ZyZWVcIlxuZXh0ZXJuYWwgZ2V0X2J1Y2tldCA6IGludCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2J1Y2tldFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBnZXRfY3JlZGl0IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2NyZWRpdFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBodWdlX2ZhbGxiYWNrX2NvdW50IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudFwiXG5leHRlcm5hbCBldmVudGxvZ19wYXVzZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9ldmVudGxvZ19wYXVzZVwiXG5leHRlcm5hbCBldmVudGxvZ19yZXN1bWUgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZXZlbnRsb2dfcmVzdW1lXCJcblxub3BlbiBQcmludGZcblxubGV0IHByaW50X3N0YXQgYyA9XG4gIGxldCBzdCA9IHN0YXQgKCkgaW5cbiAgZnByaW50ZiBjIFwibWlub3JfY29sbGVjdGlvbnM6ICAgICAgJWRcXG5cIiBzdC5taW5vcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwibWFqb3JfY29sbGVjdGlvbnM6ICAgICAgJWRcXG5cIiBzdC5tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiY29tcGFjdGlvbnM6ICAgICAgICAgICAgJWRcXG5cIiBzdC5jb21wYWN0aW9ucztcbiAgZnByaW50ZiBjIFwiZm9yY2VkX21ham9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0LmZvcmNlZF9tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGxldCBsMSA9IFN0cmluZy5sZW5ndGggKHNwcmludGYgXCIlLjBmXCIgc3QubWlub3Jfd29yZHMpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1pbm9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJwcm9tb3RlZF93b3JkczogJSouMGZcXG5cIiBsMSBzdC5wcm9tb3RlZF93b3JkcztcbiAgZnByaW50ZiBjIFwibWFqb3Jfd29yZHM6ICAgICUqLjBmXFxuXCIgbDEgc3QubWFqb3Jfd29yZHM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDIgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJWRcIiBzdC50b3BfaGVhcF93b3JkcykgaW5cbiAgZnByaW50ZiBjIFwidG9wX2hlYXBfd29yZHM6ICUqZFxcblwiIGwyIHN0LnRvcF9oZWFwX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJoZWFwX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwibGl2ZV93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmxpdmVfd29yZHM7XG4gIGZwcmludGYgYyBcImZyZWVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5mcmVlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJsYXJnZXN0X2ZyZWU6ICAgJSpkXFxuXCIgbDIgc3QubGFyZ2VzdF9mcmVlO1xuICBmcHJpbnRmIGMgXCJmcmFnbWVudHM6ICAgICAgJSpkXFxuXCIgbDIgc3QuZnJhZ21lbnRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgZnByaW50ZiBjIFwibGl2ZV9ibG9ja3M6ICVkXFxuXCIgc3QubGl2ZV9ibG9ja3M7XG4gIGZwcmludGYgYyBcImZyZWVfYmxvY2tzOiAlZFxcblwiIHN0LmZyZWVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJoZWFwX2NodW5rczogJWRcXG5cIiBzdC5oZWFwX2NodW5rc1xuXG5cbmxldCBhbGxvY2F0ZWRfYnl0ZXMgKCkgPVxuICBsZXQgKG1pLCBwcm8sIG1hKSA9IGNvdW50ZXJzICgpIGluXG4gIChtaSArLiBtYSAtLiBwcm8pICouIGZsb2F0X29mX2ludCAoU3lzLndvcmRfc2l6ZSAvIDgpXG5cblxuZXh0ZXJuYWwgZmluYWxpc2UgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWdpc3RlclwiXG5leHRlcm5hbCBmaW5hbGlzZV9sYXN0IDogKHVuaXQgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9XG4gIFwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZVwiXG5leHRlcm5hbCBmaW5hbGlzZV9yZWxlYXNlIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2ZpbmFsX3JlbGVhc2VcIlxuXG5cbnR5cGUgYWxhcm0gPSBib29sIHJlZlxudHlwZSBhbGFybV9yZWMgPSB7YWN0aXZlIDogYWxhcm07IGYgOiB1bml0IC0+IHVuaXR9XG5cbmxldCByZWMgY2FsbF9hbGFybSBhcmVjID1cbiAgaWYgIShhcmVjLmFjdGl2ZSkgdGhlbiBiZWdpblxuICAgIGZpbmFsaXNlIGNhbGxfYWxhcm0gYXJlYztcbiAgICBhcmVjLmYgKCk7XG4gIGVuZFxuXG5cbmxldCBjcmVhdGVfYWxhcm0gZiA9XG4gIGxldCBhcmVjID0geyBhY3RpdmUgPSByZWYgdHJ1ZTsgZiA9IGYgfSBpblxuICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gIGFyZWMuYWN0aXZlXG5cblxubGV0IGRlbGV0ZV9hbGFybSBhID0gYSA6PSBmYWxzZVxuXG5tb2R1bGUgTWVtcHJvZiA9XG4gIHN0cnVjdFxuICAgIHR5cGUgYWxsb2NhdGlvbl9zb3VyY2UgPSBOb3JtYWwgfCBNYXJzaGFsIHwgQ3VzdG9tXG4gICAgdHlwZSBhbGxvY2F0aW9uID1cbiAgICAgIHsgbl9zYW1wbGVzIDogaW50O1xuICAgICAgICBzaXplIDogaW50O1xuICAgICAgICBzb3VyY2UgOiBhbGxvY2F0aW9uX3NvdXJjZTtcbiAgICAgICAgY2FsbHN0YWNrIDogUHJpbnRleGMucmF3X2JhY2t0cmFjZSB9XG5cbiAgICB0eXBlICgnbWlub3IsICdtYWpvcikgdHJhY2tlciA9IHtcbiAgICAgIGFsbG9jX21pbm9yOiBhbGxvY2F0aW9uIC0+ICdtaW5vciBvcHRpb247XG4gICAgICBhbGxvY19tYWpvcjogYWxsb2NhdGlvbiAtPiAnbWFqb3Igb3B0aW9uO1xuICAgICAgcHJvbW90ZTogJ21pbm9yIC0+ICdtYWpvciBvcHRpb247XG4gICAgICBkZWFsbG9jX21pbm9yOiAnbWlub3IgLT4gdW5pdDtcbiAgICAgIGRlYWxsb2NfbWFqb3I6ICdtYWpvciAtPiB1bml0O1xuICAgIH1cblxuICAgIGxldCBudWxsX3RyYWNrZXIgPSB7XG4gICAgICBhbGxvY19taW5vciA9IChmdW4gXyAtPiBOb25lKTtcbiAgICAgIGFsbG9jX21ham9yID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgcHJvbW90ZSA9IChmdW4gXyAtPiBOb25lKTtcbiAgICAgIGRlYWxsb2NfbWlub3IgPSAoZnVuIF8gLT4gKCkpO1xuICAgICAgZGVhbGxvY19tYWpvciA9IChmdW4gXyAtPiAoKSk7XG4gICAgfVxuXG4gICAgZXh0ZXJuYWwgY19zdGFydCA6XG4gICAgICBmbG9hdCAtPiBpbnQgLT4gKCdtaW5vciwgJ21ham9yKSB0cmFja2VyIC0+IHVuaXRcbiAgICAgID0gXCJjYW1sX21lbXByb2Zfc3RhcnRcIlxuXG4gICAgbGV0IHN0YXJ0XG4gICAgICB+c2FtcGxpbmdfcmF0ZVxuICAgICAgPyhjYWxsc3RhY2tfc2l6ZSA9IG1heF9pbnQpXG4gICAgICB0cmFja2VyID1cbiAgICAgIGNfc3RhcnQgc2FtcGxpbmdfcmF0ZSBjYWxsc3RhY2tfc2l6ZSB0cmFja2VyXG5cbiAgICBleHRlcm5hbCBzdG9wIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX21lbXByb2Zfc3RvcFwiXG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNZXNzYWdlIGRpZ2VzdCAoTUQ1KSAqKVxuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgPSBTdHJpbmcuY29tcGFyZVxubGV0IGVxdWFsID0gU3RyaW5nLmVxdWFsXG5cbmV4dGVybmFsIHVuc2FmZV9zdHJpbmc6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X3N0cmluZ1wiXG5leHRlcm5hbCBjaGFubmVsOiBpbl9jaGFubmVsIC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9jaGFuXCJcblxubGV0IHN0cmluZyBzdHIgPVxuICB1bnNhZmVfc3RyaW5nIHN0ciAwIChTdHJpbmcubGVuZ3RoIHN0cilcblxubGV0IGJ5dGVzIGIgPSBzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYilcblxubGV0IHN1YnN0cmluZyBzdHIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBTdHJpbmcubGVuZ3RoIHN0ciAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnN1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX3N0cmluZyBzdHIgb2ZzIGxlblxuXG5sZXQgc3ViYnl0ZXMgYiBvZnMgbGVuID0gc3Vic3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpIG9mcyBsZW5cblxubGV0IGZpbGUgZmlsZW5hbWUgPVxuICBsZXQgaWMgPSBvcGVuX2luX2JpbiBmaWxlbmFtZSBpblxuICBtYXRjaCBjaGFubmVsIGljICgtMSkgd2l0aFxuICAgIHwgZCAtPiBjbG9zZV9pbiBpYzsgZFxuICAgIHwgZXhjZXB0aW9uIGUgLT4gY2xvc2VfaW4gaWM7IHJhaXNlIGVcblxubGV0IG91dHB1dCBjaGFuIGRpZ2VzdCA9XG4gIG91dHB1dF9zdHJpbmcgY2hhbiBkaWdlc3RcblxubGV0IGlucHV0IGNoYW4gPSByZWFsbHlfaW5wdXRfc3RyaW5nIGNoYW4gMTZcblxubGV0IGNoYXJfaGV4IG4gPVxuICBDaGFyLnVuc2FmZV9jaHIgKG4gKyBpZiBuIDwgMTAgdGhlbiBDaGFyLmNvZGUgJzAnIGVsc2UgKENoYXIuY29kZSAnYScgLSAxMCkpXG5cbmxldCB0b19oZXggZCA9XG4gIGlmIFN0cmluZy5sZW5ndGggZCA8PiAxNiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnRvX2hleFwiO1xuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDMyIGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIGxldCB4ID0gQ2hhci5jb2RlIGQuW2ldIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMikgKGNoYXJfaGV4ICh4IGxzciA0KSk7XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMisxKSAoY2hhcl9oZXggKHggbGFuZCAweDBmKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG5cbmxldCBmcm9tX2hleCBzID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBzIDw+IDMyIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QuZnJvbV9oZXhcIjtcbiAgbGV0IGRpZ2l0IGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJzAnLi4nOScgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnXG4gICAgfCAnQScuLidGJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnQScgKyAxMFxuICAgIHwgJ2EnLi4nZicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ2EnICsgMTBcbiAgICB8IF8gLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJEaWdlc3QuZnJvbV9oZXhcIilcbiAgaW5cbiAgbGV0IGJ5dGUgaSA9IGRpZ2l0IHMuW2ldIGxzbCA0ICsgZGlnaXQgcy5baSsxXSBpblxuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDE2IGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIEJ5dGVzLnNldCByZXN1bHQgaSAoQ2hhci5jaHIgKGJ5dGUgKDIgKiBpKSkpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbiAgIFRoaXMgaXMgYSBsYWdnZWQtRmlib25hY2NpIEYoNTUsIDI0LCArKSB3aXRoIGEgbW9kaWZpZWQgYWRkaXRpb25cbiAgIGZ1bmN0aW9uIHRvIGVuaGFuY2UgdGhlIG1peGluZyBvZiBiaXRzLlxuICAgSWYgd2UgdXNlIG5vcm1hbCBhZGRpdGlvbiwgdGhlIGxvdy1vcmRlciBiaXQgZmFpbHMgdGVzdHMgMSBhbmQgN1xuICAgb2YgdGhlIERpZWhhcmQgdGVzdCBzdWl0ZSwgYW5kIGJpdHMgMSBhbmQgMiBhbHNvIGZhaWwgdGVzdCA3LlxuICAgSWYgd2UgdXNlIG11bHRpcGxpY2F0aW9uIGFzIHN1Z2dlc3RlZCBieSBNYXJzYWdsaWEsIGl0IGRvZXNuJ3QgZmFyZVxuICAgbXVjaCBiZXR0ZXIuXG4gICBCeSBtaXhpbmcgdGhlIGJpdHMgb2Ygb25lIG9mIHRoZSBudW1iZXJzIGJlZm9yZSBhZGRpdGlvbiAoWE9SIHRoZVxuICAgNSBoaWdoLW9yZGVyIGJpdHMgaW50byB0aGUgbG93LW9yZGVyIGJpdHMpLCB3ZSBnZXQgYSBnZW5lcmF0b3IgdGhhdFxuICAgcGFzc2VzIGFsbCB0aGUgRGllaGFyZCB0ZXN0cy5cbiopXG5cbmV4dGVybmFsIHJhbmRvbV9zZWVkOiB1bml0IC0+IGludCBhcnJheSA9IFwiY2FtbF9zeXNfcmFuZG9tX3NlZWRcIlxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSB7IHN0IDogaW50IGFycmF5OyBtdXRhYmxlIGlkeCA6IGludCB9XG5cbiAgbGV0IG5ld19zdGF0ZSAoKSA9IHsgc3QgPSBBcnJheS5tYWtlIDU1IDA7IGlkeCA9IDAgfVxuICBsZXQgYXNzaWduIHN0MSBzdDIgPVxuICAgIEFycmF5LmJsaXQgc3QyLnN0IDAgc3QxLnN0IDAgNTU7XG4gICAgc3QxLmlkeCA8LSBzdDIuaWR4XG5cblxuICBsZXQgZnVsbF9pbml0IHMgc2VlZCA9XG4gICAgbGV0IGNvbWJpbmUgYWNjdSB4ID0gRGlnZXN0LnN0cmluZyAoYWNjdSBeIEludC50b19zdHJpbmcgeCkgaW5cbiAgICBsZXQgZXh0cmFjdCBkID1cbiAgICAgIENoYXIuY29kZSBkLlswXSArIChDaGFyLmNvZGUgZC5bMV0gbHNsIDgpICsgKENoYXIuY29kZSBkLlsyXSBsc2wgMTYpXG4gICAgICArIChDaGFyLmNvZGUgZC5bM10gbHNsIDI0KVxuICAgIGluXG4gICAgbGV0IHNlZWQgPSBpZiBBcnJheS5sZW5ndGggc2VlZCA9IDAgdGhlbiBbfCAwIHxdIGVsc2Ugc2VlZCBpblxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIHNlZWQgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgZG9cbiAgICAgIHMuc3QuKGkpIDwtIGk7XG4gICAgZG9uZTtcbiAgICBsZXQgYWNjdSA9IHJlZiBcInhcIiBpblxuICAgIGZvciBpID0gMCB0byA1NCArIEludC5tYXggNTUgbCBkb1xuICAgICAgbGV0IGogPSBpIG1vZCA1NSBpblxuICAgICAgbGV0IGsgPSBpIG1vZCBsIGluXG4gICAgICBhY2N1IDo9IGNvbWJpbmUgIWFjY3Ugc2VlZC4oayk7XG4gICAgICBzLnN0LihqKSA8LSAocy5zdC4oaikgbHhvciBleHRyYWN0ICFhY2N1KSBsYW5kIDB4M0ZGRkZGRkY7ICAoKiBQUiM1NTc1ICopXG4gICAgZG9uZTtcbiAgICBzLmlkeCA8LSAwXG5cblxuICBsZXQgbWFrZSBzZWVkID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgZnVsbF9pbml0IHJlc3VsdCBzZWVkO1xuICAgIHJlc3VsdFxuXG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ICgpID0gbWFrZSAocmFuZG9tX3NlZWQgKCkpXG5cbiAgbGV0IGNvcHkgcyA9XG4gICAgbGV0IHJlc3VsdCA9IG5ld19zdGF0ZSAoKSBpblxuICAgIGFzc2lnbiByZXN1bHQgcztcbiAgICByZXN1bHRcblxuXG4gICgqIFJldHVybnMgMzAgcmFuZG9tIGJpdHMgYXMgYW4gaW50ZWdlciAwIDw9IHggPCAxMDczNzQxODI0ICopXG4gIGxldCBiaXRzIHMgPVxuICAgIHMuaWR4IDwtIChzLmlkeCArIDEpIG1vZCA1NTtcbiAgICBsZXQgY3VydmFsID0gcy5zdC4ocy5pZHgpIGluXG4gICAgbGV0IG5ld3ZhbCA9IHMuc3QuKChzLmlkeCArIDI0KSBtb2QgNTUpXG4gICAgICAgICAgICAgICAgICsgKGN1cnZhbCBseG9yICgoY3VydmFsIGxzciAyNSkgbGFuZCAweDFGKSkgaW5cbiAgICBsZXQgbmV3dmFsMzAgPSBuZXd2YWwgbGFuZCAweDNGRkZGRkZGIGluICAoKiBQUiM1NTc1ICopXG4gICAgcy5zdC4ocy5pZHgpIDwtIG5ld3ZhbDMwO1xuICAgIG5ld3ZhbDMwXG5cblxuICBsZXQgcmVjIGludGF1eCBzIG4gPVxuICAgIGxldCByID0gYml0cyBzIGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiAweDNGRkZGRkZGIC0gbiArIDEgdGhlbiBpbnRhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBpbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPiAweDNGRkZGRkZGIHx8IGJvdW5kIDw9IDBcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludFwiXG4gICAgZWxzZSBpbnRhdXggcyBib3VuZFxuXG4gIGxldCByZWMgaW50NjNhdXggcyBuID1cbiAgICBsZXQgbWF4X2ludF8zMiA9ICgxIGxzbCAzMCkgKyAweDNGRkZGRkZGIGluICgqIDB4N0ZGRkZGRkYgKilcbiAgICBsZXQgYjEgPSBiaXRzIHMgaW5cbiAgICBsZXQgYjIgPSBiaXRzIHMgaW5cbiAgICBsZXQgKHIsIG1heF9pbnQpID1cbiAgICAgIGlmIG4gPD0gbWF4X2ludF8zMiB0aGVuXG4gICAgICAgICgqIDMxIHJhbmRvbSBiaXRzIG9uIGJvdGggNjQtYml0IE9DYW1sIGFuZCBKYXZhU2NyaXB0LlxuICAgICAgICAgICBVc2UgdXBwZXIgMTUgYml0cyBvZiBiMSBhbmQgMTYgYml0cyBvZiBiMi4gKilcbiAgICAgICAgbGV0IGJwb3MgPVxuICAgICAgICAgICgoKGIyIGxhbmQgMHgzRkZGQzAwMCkgbHNsIDEpIGxvciAoYjEgbHNyIDE1KSlcbiAgICAgICAgaW5cbiAgICAgICAgICAoYnBvcywgbWF4X2ludF8zMilcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IGIzID0gYml0cyBzIGluXG4gICAgICAgICgqIDYyIHJhbmRvbSBiaXRzIG9uIDY0LWJpdCBPQ2FtbDsgdW5yZWFjaGFibGUgb24gSmF2YVNjcmlwdC5cbiAgICAgICAgICAgVXNlIHVwcGVyIDIwIGJpdHMgb2YgYjEgYW5kIDIxIGJpdHMgb2YgYjIgYW5kIGIzLiAqKVxuICAgICAgICBsZXQgYnBvcyA9XG4gICAgICAgICAgKCgoKGIzIGxhbmQgMHgzRkZGRkUwMCkgbHNsIDEyKSBsb3IgKGIyIGxzciA5KSkgbHNsIDIwKVxuICAgICAgICAgICAgbG9yIChiMSBsc3IgMTApXG4gICAgICAgIGluXG4gICAgICAgICAgKGJwb3MsIG1heF9pbnQpXG4gICAgaW5cbiAgICBsZXQgdiA9IHIgbW9kIG4gaW5cbiAgICBpZiByIC0gdiA+IG1heF9pbnQgLSBuICsgMSB0aGVuIGludDYzYXV4IHMgbiBlbHNlIHZcblxuICBsZXQgZnVsbF9pbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMCB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIlJhbmRvbS5mdWxsX2ludFwiXG4gICAgZWxzZSBpZiBib3VuZCA+IDB4M0ZGRkZGRkYgdGhlblxuICAgICAgaW50NjNhdXggcyBib3VuZFxuICAgIGVsc2VcbiAgICAgIGludGF1eCBzIGJvdW5kXG5cblxuICBsZXQgcmVjIGludDMyYXV4IHMgbiA9XG4gICAgbGV0IGIxID0gSW50MzIub2ZfaW50IChiaXRzIHMpIGluXG4gICAgbGV0IGIyID0gSW50MzIuc2hpZnRfbGVmdCAoSW50MzIub2ZfaW50IChiaXRzIHMgbGFuZCAxKSkgMzAgaW5cbiAgICBsZXQgciA9IEludDMyLmxvZ29yIGIxIGIyIGluXG4gICAgbGV0IHYgPSBJbnQzMi5yZW0gciBuIGluXG4gICAgaWYgSW50MzIuc3ViIHIgdiA+IEludDMyLmFkZCAoSW50MzIuc3ViIEludDMyLm1heF9pbnQgbikgMWxcbiAgICB0aGVuIGludDMyYXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQzMiBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50MzJcIlxuICAgIGVsc2UgaW50MzJhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQ2NGF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDY0Lm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDY0LnNoaWZ0X2xlZnQgKEludDY0Lm9mX2ludCAoYml0cyBzKSkgMzAgaW5cbiAgICBsZXQgYjMgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcyBsYW5kIDcpKSA2MCBpblxuICAgIGxldCByID0gSW50NjQubG9nb3IgYjEgKEludDY0LmxvZ29yIGIyIGIzKSBpblxuICAgIGxldCB2ID0gSW50NjQucmVtIHIgbiBpblxuICAgIGlmIEludDY0LnN1YiByIHYgPiBJbnQ2NC5hZGQgKEludDY0LnN1YiBJbnQ2NC5tYXhfaW50IG4pIDFMXG4gICAgdGhlbiBpbnQ2NGF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50NjQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMExcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDY0XCJcbiAgICBlbHNlIGludDY0YXV4IHMgYm91bmRcblxuXG4gIGxldCBuYXRpdmVpbnQgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIGJvdW5kIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoaW50MzIgcyAoTmF0aXZlaW50LnRvX2ludDMyIGJvdW5kKSlcbiAgICBlbHNlIGZ1biBzIGJvdW5kIC0+IEludDY0LnRvX25hdGl2ZWludCAoaW50NjQgcyAoSW50NjQub2ZfbmF0aXZlaW50IGJvdW5kKSlcblxuXG4gICgqIFJldHVybnMgYSBmbG9hdCAwIDw9IHggPD0gMSB3aXRoIGF0IG1vc3QgNjAgYml0cyBvZiBwcmVjaXNpb24uICopXG4gIGxldCByYXdmbG9hdCBzID1cbiAgICBsZXQgc2NhbGUgPSAxMDczNzQxODI0LjAgICgqIDJeMzAgKilcbiAgICBhbmQgcjEgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBhbmQgcjIgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBpbiAocjEgLy4gc2NhbGUgKy4gcjIpIC8uIHNjYWxlXG5cblxuICBsZXQgZmxvYXQgcyBib3VuZCA9IHJhd2Zsb2F0IHMgKi4gYm91bmRcblxuICBsZXQgYm9vbCBzID0gKGJpdHMgcyBsYW5kIDEgPSAwKVxuXG4gIGxldCBiaXRzMzIgcyA9XG4gICAgbGV0IGIxID0gSW50MzIuKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKG9mX2ludCAoYml0cyBzKSkgMTQpIGluICAoKiAxNiBiaXRzICopXG4gICAgbGV0IGIyID0gSW50MzIuKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKG9mX2ludCAoYml0cyBzKSkgMTQpIGluICAoKiAxNiBiaXRzICopXG4gICAgSW50MzIuKGxvZ29yIGIxIChzaGlmdF9sZWZ0IGIyIDE2KSlcblxuICBsZXQgYml0czY0IHMgPVxuICAgIGxldCBiMSA9IEludDY0LihzaGlmdF9yaWdodF9sb2dpY2FsIChvZl9pbnQgKGJpdHMgcykpIDkpIGluICAoKiAyMSBiaXRzICopXG4gICAgbGV0IGIyID0gSW50NjQuKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKG9mX2ludCAoYml0cyBzKSkgOSkgaW4gICgqIDIxIGJpdHMgKilcbiAgICBsZXQgYjMgPSBJbnQ2NC4oc2hpZnRfcmlnaHRfbG9naWNhbCAob2ZfaW50IChiaXRzIHMpKSA4KSBpbiAgKCogMjIgYml0cyAqKVxuICAgIEludDY0Lihsb2dvciBiMSAobG9nb3IgKHNoaWZ0X2xlZnQgYjIgMjEpIChzaGlmdF9sZWZ0IGIzIDQyKSkpXG5cbiAgbGV0IG5hdGl2ZWJpdHMgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoYml0czMyIHMpXG4gICAgZWxzZSBmdW4gcyAtPiBJbnQ2NC50b19uYXRpdmVpbnQgKGJpdHM2NCBzKVxuXG5lbmRcblxuKCogVGhpcyBpcyB0aGUgc3RhdGUgeW91IGdldCB3aXRoIFtpbml0IDI3MTgyODE4XSBhbmQgdGhlbiBhcHBseWluZ1xuICAgdGhlIFwibGFuZCAweDNGRkZGRkZGXCIgZmlsdGVyIHRvIHRoZW0uICBTZWUgIzU1NzUsICM1NzkzLCAjNTk3Ny4gKilcbmxldCBkZWZhdWx0ID0ge1xuICBTdGF0ZS5zdCA9IFt8XG4gICAgICAweDNhZTI1MjJiOyAweDFkOGQ0NjM0OyAweDE1YjRmYWQwOyAweDE4YjE0YWNlOyAweDEyZjhhM2M0OyAweDNiMDg2YzQ3O1xuICAgICAgMHgxNmQ0NjdkNjsgMHgxMDFkOTFjNzsgMHgzMjFkZjE3NzsgMHgwMTc2YzE5MzsgMHgxZmY3MmJmMTsgMHgxZTg4OTEwOTtcbiAgICAgIDB4MGI0NjRiMTg7IDB4MmI4NmI5N2M7IDB4MDg5MWRhNDg7IDB4MDMxMzc0NjM7IDB4MDg1YWM1YTE7IDB4MTVkNjFmMmY7XG4gICAgICAweDNiY2VkMzU5OyAweDI5YzFjMTMyOyAweDNhODY3NjZlOyAweDM2NmQ4Yzg2OyAweDFmNWI2MjIyOyAweDNjZTFiNTlmO1xuICAgICAgMHgyZWJmNzhlMTsgMHgyN2NkMWI4NjsgMHgyNThmM2RjMzsgMHgzODlhODE5NDsgMHgwMmU0YzQ0YzsgMHgxOGM0M2Y3ZDtcbiAgICAgIDB4MGY2ZTUzNGY7IDB4MWU3ZGYzNTk7IDB4MDU1ZDBiN2U7IDB4MTBlODRlN2U7IDB4MTI2MTk4ZTQ7IDB4MGU3NzIyY2I7XG4gICAgICAweDFjYmVkZTI4OyAweDMzOTFiOTY0OyAweDNkNDBlOTJhOyAweDBjNTk5MzNkOyAweDBiOGNkMGI3OyAweDI0ZWZmZjFjO1xuICAgICAgMHgyODAzZmRhYTsgMHgwOGViYzcyZTsgMHgwZjUyMmUzMjsgMHgwNTM5OGVkYzsgMHgyMTQ0YTA0YzsgMHgwYWVmM2NiZDtcbiAgICAgIDB4MDFhZDQ3MTk7IDB4MzViOTNjZDY7IDB4MmE1NTlkNGY7IDB4MWU2ZmQ3Njg7IDB4MjZlMjdmMzY7IDB4MTg2ZjE4YzM7XG4gICAgICAweDJmYmY5NjdhO1xuICAgIHxdO1xuICBTdGF0ZS5pZHggPSAwO1xufVxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgZGVmYXVsdFxubGV0IGludCBib3VuZCA9IFN0YXRlLmludCBkZWZhdWx0IGJvdW5kXG5sZXQgZnVsbF9pbnQgYm91bmQgPSBTdGF0ZS5mdWxsX2ludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50MzIgYm91bmQgPSBTdGF0ZS5pbnQzMiBkZWZhdWx0IGJvdW5kXG5sZXQgbmF0aXZlaW50IGJvdW5kID0gU3RhdGUubmF0aXZlaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQ2NCBib3VuZCA9IFN0YXRlLmludDY0IGRlZmF1bHQgYm91bmRcbmxldCBmbG9hdCBzY2FsZSA9IFN0YXRlLmZsb2F0IGRlZmF1bHQgc2NhbGVcbmxldCBib29sICgpID0gU3RhdGUuYm9vbCBkZWZhdWx0XG5sZXQgYml0czMyICgpID0gU3RhdGUuYml0czMyIGRlZmF1bHRcbmxldCBiaXRzNjQgKCkgPSBTdGF0ZS5iaXRzNjQgZGVmYXVsdFxubGV0IG5hdGl2ZWJpdHMgKCkgPSBTdGF0ZS5uYXRpdmViaXRzIGRlZmF1bHRcblxubGV0IGZ1bGxfaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IGRlZmF1bHQgc2VlZFxubGV0IGluaXQgc2VlZCA9IFN0YXRlLmZ1bGxfaW5pdCBkZWZhdWx0IFt8IHNlZWQgfF1cbmxldCBzZWxmX2luaXQgKCkgPSBmdWxsX2luaXQgKHJhbmRvbV9zZWVkKCkpXG5cbigqIE1hbmlwdWxhdGluZyB0aGUgY3VycmVudCBzdGF0ZS4gKilcblxubGV0IGdldF9zdGF0ZSAoKSA9IFN0YXRlLmNvcHkgZGVmYXVsdFxubGV0IHNldF9zdGF0ZSBzID0gU3RhdGUuYXNzaWduIGRlZmF1bHQgc1xuXG4oKioqKioqKioqKioqKioqKioqKipcblxuKCogVGVzdCBmdW5jdGlvbnMuICBOb3QgaW5jbHVkZWQgaW4gdGhlIGxpYnJhcnkuXG4gICBUaGUgW2NoaXNxdWFyZV0gZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCB3aXRoIG4gPiAxMHIuXG4gICBJdCByZXR1cm5zIGEgdHJpcGxlIChsb3csIGFjdHVhbCwgaGlnaCkuXG4gICBJZiBsb3cgPD0gYWN0dWFsIDw9IGhpZ2gsIHRoZSBbZ10gZnVuY3Rpb24gcGFzc2VkIHRoZSB0ZXN0LFxuICAgb3RoZXJ3aXNlIGl0IGZhaWxlZC5cblxuICBTb21lIHJlc3VsdHM6XG5cbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgNTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAwIDEwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMjk5NzkyNjQzOyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDE0MTQyMTM2OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYgMTAyNDsgY2hpc3F1YXJlIGRpZmYgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZiAxMDA7IGNoaXNxdWFyZSBkaWZmIDEwMDAwMCAxMDBcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZjIgMTAyNDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbmluaXQgMTQxNDIxMzY7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuaW5pdCAyOTk3OTI2NDM7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5MzYuNzU0NDQ2Nzk2NjMyNDY1LCA5OTcuNSwgMTA2My4yNDU1NTMyMDMzNjc1NClcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg5Ljc0MDAwMDAwMDAwNTIzODcsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoNDg1OC41Nzg2NDM3NjI2OSwgNTA0NS41LCA1MTQxLjQyMTM1NjIzNzMxKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID1cbig5MzYuNzU0NDQ2Nzk2NjMyNDY1LCA5NDQuODA1OTk5OTk5OTgyMzA1LCAxMDYzLjI0NTU1MzIwMzM2NzU0KVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwMTkuMTk3NDQwMDAwMDAzNTUsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNTkuMzE3NzYwMDAwMDA1MzYsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwMzkuOTg0NjM5OTk5OTk1MTIsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNTQuMzgyMDc5OTk5OTk1NzcsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgOTAuMDk2MDAwMDAwMDA1LCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNzYuNzg3MjAwMDAwMDA2MTIsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODUuMTc2MDAwMDAwMDA2NzUyMSwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg1LjIxNjAwMDAwMDAwMDM0OTIsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4MC42MjIwMDAwMDAwMDMwMjY4LCAxMjAuKVxuXG4qKVxuXG4oKiBSZXR1cm4gdGhlIHN1bSBvZiB0aGUgc3F1YXJlcyBvZiB2W2kwLGkxWyAqKVxubGV0IHJlYyBzdW1zcSB2IGkwIGkxID1cbiAgaWYgaTAgPj0gaTEgdGhlbiAwLjBcbiAgZWxzZSBpZiBpMSA9IGkwICsgMSB0aGVuIFN0ZGxpYi5mbG9hdCB2LihpMCkgKi4gU3RkbGliLmZsb2F0IHYuKGkwKVxuICBlbHNlIHN1bXNxIHYgaTAgKChpMCtpMSkvMikgKy4gc3Vtc3EgdiAoKGkwK2kxKS8yKSBpMVxuXG5cbmxldCBjaGlzcXVhcmUgZyBuIHIgPVxuICBpZiBuIDw9IDEwICogciB0aGVuIGludmFsaWRfYXJnIFwiY2hpc3F1YXJlXCI7XG4gIGxldCBmID0gQXJyYXkubWFrZSByIDAgaW5cbiAgZm9yIGkgPSAxIHRvIG4gZG9cbiAgICBsZXQgdCA9IGcgciBpblxuICAgIGYuKHQpIDwtIGYuKHQpICsgMVxuICBkb25lO1xuICBsZXQgdCA9IHN1bXNxIGYgMCByXG4gIGFuZCByID0gU3RkbGliLmZsb2F0IHJcbiAgYW5kIG4gPSBTdGRsaWIuZmxvYXQgbiBpblxuICBsZXQgc3IgPSAyLjAgKi4gc3FydCByIGluXG4gIChyIC0uIHNyLCAgIChyICouIHQgLy4gbikgLS4gbiwgICByICsuIHNyKVxuXG5cbigqIFRoaXMgaXMgdG8gdGVzdCBmb3IgbGluZWFyIGRlcGVuZGVuY2llcyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgcmFuZG9tIG51bWJlcnMuXG4qKVxubGV0IHN0ID0gcmVmIDBcbmxldCBpbml0X2RpZmYgciA9IHN0IDo9IGludCByXG5sZXQgZGlmZiByID1cbiAgbGV0IHgxID0gIXN0XG4gIGFuZCB4MiA9IGludCByXG4gIGluXG4gIHN0IDo9IHgyO1xuICBpZiB4MSA+PSB4MiB0aGVuXG4gICAgeDEgLSB4MlxuICBlbHNlXG4gICAgciArIHgxIC0geDJcblxuXG5sZXQgc3QxID0gcmVmIDBcbmFuZCBzdDIgPSByZWYgMFxuXG5cbigqIFRoaXMgaXMgdG8gdGVzdCBmb3IgcXVhZHJhdGljIGRlcGVuZGVuY2llcyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgcmFuZG9tXG4gICBudW1iZXJzLlxuKilcbmxldCBpbml0X2RpZmYyIHIgPSBzdDEgOj0gaW50IHI7IHN0MiA6PSBpbnQgclxubGV0IGRpZmYyIHIgPVxuICBsZXQgeDEgPSAhc3QxXG4gIGFuZCB4MiA9ICFzdDJcbiAgYW5kIHgzID0gaW50IHJcbiAgaW5cbiAgc3QxIDo9IHgyO1xuICBzdDIgOj0geDM7XG4gICh4MyAtIHgyIC0geDIgKyB4MSArIDIqcikgbW9kIHJcblxuXG4qKioqKioqKioqKioqKioqKioqKilcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSGFzaCB0YWJsZXMgKilcblxuKCogV2UgZG8gZHluYW1pYyBoYXNoaW5nLCBhbmQgcmVzaXplIHRoZSB0YWJsZSBhbmQgcmVoYXNoIHRoZSBlbGVtZW50c1xuICAgd2hlbiBidWNrZXRzIGJlY29tZSB0b28gbG9uZy4gKilcblxudHlwZSAoJ2EsICdiKSB0ID1cbiAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgIG11dGFibGUgZGF0YTogKCdhLCAnYikgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgbXV0YWJsZSBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gIH1cblxuYW5kICgnYSwgJ2IpIGJ1Y2tldGxpc3QgPVxuICAgIEVtcHR5XG4gIHwgQ29ucyBvZiB7IG11dGFibGUga2V5OiAnYTtcbiAgICAgICAgICAgICAgbXV0YWJsZSBkYXRhOiAnYjtcbiAgICAgICAgICAgICAgbXV0YWJsZSBuZXh0OiAoJ2EsICdiKSBidWNrZXRsaXN0IH1cblxuKCogVGhlIHNpZ24gb2YgaW5pdGlhbF9zaXplIGVuY29kZXMgdGhlIGZhY3QgdGhhdCBhIHRyYXZlcnNhbCBpc1xuICAgb25nb2luZyBvciBub3QuXG5cbiAgIFRoaXMgZGlzYWJsZXMgdGhlIGVmZmljaWVudCBpbiBwbGFjZSBpbXBsZW1lbnRhdGlvbiBvZiByZXNpemluZy5cbiopXG5cbmxldCBvbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIHx8IGguaW5pdGlhbF9zaXplIDwgMFxuXG5sZXQgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgaC5pbml0aWFsX3NpemUgPC0gLSBoLmluaXRpYWxfc2l6ZVxuXG4oKiBUbyBwaWNrIHJhbmRvbSBzZWVkcyBpZiByZXF1ZXN0ZWQgKilcblxubGV0IHJhbmRvbWl6ZWRfZGVmYXVsdCA9XG4gIGxldCBwYXJhbXMgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJDQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPiBcIlwiIGluXG4gIFN0cmluZy5jb250YWlucyBwYXJhbXMgJ1InXG5cbmxldCByYW5kb21pemVkID0gcmVmIHJhbmRvbWl6ZWRfZGVmYXVsdFxuXG5sZXQgcmFuZG9taXplICgpID0gcmFuZG9taXplZCA6PSB0cnVlXG5sZXQgaXNfcmFuZG9taXplZCAoKSA9ICFyYW5kb21pemVkXG5cbmxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbigqIEZ1bmN0aW9ucyB3aGljaCBhcHBlYXIgYmVmb3JlIHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSBtdXN0IGVpdGhlciBiZVxuICAgaW5kZXBlbmRlbnQgb2YgdGhlIGhhc2ggZnVuY3Rpb24gb3IgdGFrZSBpdCBhcyBhIHBhcmFtZXRlciAoc2VlICMyMjAyIGFuZFxuICAgY29kZSBiZWxvdyB0aGUgZnVuY3RvciBkZWZpbml0aW9ucy4gKilcblxuKCogQ3JlYXRpbmcgYSBmcmVzaCwgZW1wdHkgdGFibGUgKilcblxubGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gIGlmIHggPj0gbiB0aGVuIHhcbiAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbmxldCBjcmVhdGUgPyhyYW5kb20gPSAhcmFuZG9taXplZCkgaW5pdGlhbF9zaXplID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbmxldCBjbGVhciBoID1cbiAgaWYgaC5zaXplID4gMCB0aGVuIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgQXJyYXkuZmlsbCBoLmRhdGEgMCAoQXJyYXkubGVuZ3RoIGguZGF0YSkgRW1wdHlcbiAgZW5kXG5cbmxldCByZXNldCBoID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gICAgfHwgbGVuID0gYWJzIGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICBjbGVhciBoXG4gIGVsc2UgYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSAoYWJzIGguaW5pdGlhbF9zaXplKSBFbXB0eVxuICBlbmRcblxubGV0IGNvcHlfYnVja2V0bGlzdCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gRW1wdHlcbiAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICBsZXQgcmVjIGxvb3AgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHwgQ29ucyBwcmVjIC0+ICBwcmVjLm5leHQgPC0gclxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgbG9vcCByIG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgIGxvb3AgciBuZXh0O1xuICAgICAgclxuXG5sZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5Lm1hcCBjb3B5X2J1Y2tldGxpc3QgaC5kYXRhIH1cblxubGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbmxldCBpbnNlcnRfYWxsX2J1Y2tldHMgaW5kZXhmdW4gaW5wbGFjZSBvZGF0YSBuZGF0YSA9XG4gIGxldCBuc2l6ZSA9IEFycmF5Lmxlbmd0aCBuZGF0YSBpblxuICBsZXQgbmRhdGFfdGFpbCA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGFzIGNlbGwgLT5cbiAgICAgICAgbGV0IGNlbGwgPVxuICAgICAgICAgIGlmIGlucGxhY2UgdGhlbiBjZWxsXG4gICAgICAgICAgZWxzZSBDb25zIHtrZXk7IGRhdGE7IG5leHQgPSBFbXB0eX1cbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5pZHggPSBpbmRleGZ1biBrZXkgaW5cbiAgICAgICAgYmVnaW4gbWF0Y2ggbmRhdGFfdGFpbC4obmlkeCkgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IG5kYXRhLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gY2VsbDtcbiAgICAgICAgZW5kO1xuICAgICAgICBuZGF0YV90YWlsLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICBpbnNlcnRfYnVja2V0IG5leHRcbiAgaW5cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBvZGF0YSAtIDEgZG9cbiAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICBkb25lO1xuICBpZiBpbnBsYWNlIHRoZW5cbiAgICBmb3IgaSA9IDAgdG8gbnNpemUgLSAxIGRvXG4gICAgICBtYXRjaCBuZGF0YV90YWlsLihpKSB3aXRoXG4gICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gRW1wdHlcbiAgICBkb25lXG5cbmxldCByZXNpemUgaW5kZXhmdW4gaCA9XG4gIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBiZWdpblxuICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICBsZXQgaW5wbGFjZSA9IG5vdCAob25nb2luZ190cmF2ZXJzYWwgaCkgaW5cbiAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICAgICgqIHNvIHRoYXQgaW5kZXhmdW4gc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgIGluc2VydF9hbGxfYnVja2V0cyAoaW5kZXhmdW4gaCkgaW5wbGFjZSBvZGF0YSBuZGF0YVxuICBlbmRcblxubGV0IGl0ZXIgZiBoID1cbiAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgKClcbiAgICB8IENvbnN7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBmIGtleSBkYXRhOyBkb19idWNrZXQgbmV4dCBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBkb19idWNrZXQgZC4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbmxldCByZWMgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBFbXB0eVxuICAgICAgZW5kXG4gIHwgKENvbnMgKHtrZXk7IGRhdGE7IG5leHR9IGFzIGMpKSBhcyBzbG90IC0+XG4gICAgICBiZWdpbiBtYXRjaCBmIGtleSBkYXRhIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyBuZXh0XG4gICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBzbG90XG4gICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIHNsb3RcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgYy5kYXRhIDwtIGRhdGE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBzbG90IG5leHRcbiAgICAgIGVuZFxuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gIGxldCBkID0gaC5kYXRhIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIEVtcHR5IGguZGF0YS4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaFxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IGZvbGQgZiBoIGluaXQgPVxuICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgIG1hdGNoIGIgd2l0aFxuICAgICAgRW1wdHkgLT5cbiAgICAgICAgYWNjdVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGRvX2J1Y2tldCBuZXh0IChmIGtleSBkYXRhIGFjY3UpIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgICFhY2N1XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG50eXBlIHN0YXRpc3RpY3MgPSB7XG4gIG51bV9iaW5kaW5nczogaW50O1xuICBudW1fYnVja2V0czogaW50O1xuICBtYXhfYnVja2V0X2xlbmd0aDogaW50O1xuICBidWNrZXRfaGlzdG9ncmFtOiBpbnQgYXJyYXlcbn1cblxubGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFjY3VcbiAgfCBDb25ze25leHR9IC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSBuZXh0XG5cbmxldCBzdGF0cyBoID1cbiAgbGV0IG1ibCA9XG4gICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IEludC5tYXggbSAoYnVja2V0X2xlbmd0aCAwIGIpKSAwIGguZGF0YSBpblxuICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gIEFycmF5Lml0ZXJcbiAgICAoZnVuIGIgLT5cbiAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgIGguZGF0YTtcbiAgeyBudW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgdGJsID1cbiAgKCogY2FwdHVyZSBjdXJyZW50IGFycmF5LCBzbyB0aGF0IGV2ZW4gaWYgdGhlIHRhYmxlIGlzIHJlc2l6ZWQgd2VcbiAgICAga2VlcCBpdGVyYXRpbmcgb24gdGhlIHNhbWUgYXJyYXkgKilcbiAgbGV0IHRibF9kYXRhID0gdGJsLmRhdGEgaW5cbiAgKCogc3RhdGU6IGluZGV4ICogbmV4dCBidWNrZXQgdG8gdHJhdmVyc2UgKilcbiAgbGV0IHJlYyBhdXggaSBidWNrICgpID0gbWF0Y2ggYnVjayB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRibF9kYXRhXG4gICAgICAgIHRoZW4gU2VxLk5pbFxuICAgICAgICBlbHNlIGF1eChpKzEpIHRibF9kYXRhLihpKSAoKVxuICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBTZXEuQ29ucyAoKGtleSwgZGF0YSksIGF1eCBpIG5leHQpXG4gIGluXG4gIGF1eCAwIEVtcHR5XG5cbmxldCB0b19zZXFfa2V5cyBtID0gU2VxLm1hcCBmc3QgKHRvX3NlcSBtKVxuXG5sZXQgdG9fc2VxX3ZhbHVlcyBtID0gU2VxLm1hcCBzbmQgKHRvX3NlcSBtKVxuXG4oKiBGdW5jdG9yaWFsIGludGVyZmFjZSAqKVxuXG5tb2R1bGUgdHlwZSBIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBoYXNoOiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICEnYSB0XG4gICAgdmFsIGNyZWF0ZTogaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weTogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmU6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhJ2EgdFxuICAgIHZhbCBjcmVhdGUgOiA/cmFuZG9tOmJvb2wgLT4gaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlciA6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkIDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZVNlZWRlZChIOiBTZWVkZWRIYXNoZWRUeXBlKTogKFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGtleSA9IEgudFxuICAgIHR5cGUgJ2EgaGFzaHRibCA9IChrZXksICdhKSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaGFzaHRibFxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVcbiAgICBsZXQgY2xlYXIgPSBjbGVhclxuICAgIGxldCByZXNldCA9IHJlc2V0XG4gICAgbGV0IGNvcHkgPSBjb3B5XG5cbiAgICBsZXQga2V5X2luZGV4IGgga2V5ID1cbiAgICAgIChILmhhc2ggaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgYWRkIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxuICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICgpXG4gICAgICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiBiZWdpblxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBuZXh0XG4gICAgICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2UgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IGMgbmV4dFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IEVtcHR5IGguZGF0YS4oaSlcblxuICAgIGxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBTb21lIGRhdGEgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHRcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbiAgICBsZXQgZmluZF9hbGwgaCBrZXkgPVxuICAgICAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgW11cbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YT1kOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGQgOjogZmluZF9pbl9idWNrZXQgbmV4dFxuICAgICAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IENvbnMgKHtrZXk9azsgbmV4dH0gYXMgc2xvdCkgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIGlmIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIGwgdGhlbiBiZWdpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuICAgICAgZW5kXG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgQ29uc3trZXk9azsgbmV4dH0gLT5cbiAgICAgICAgICBILmVxdWFsIGsga2V5IHx8IG1lbV9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgICBsZXQgaXRlciA9IGl0ZXJcbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlID0gZmlsdGVyX21hcF9pbnBsYWNlXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCBzdGF0cyA9IHN0YXRzXG4gICAgbGV0IHRvX3NlcSA9IHRvX3NlcVxuICAgIGxldCB0b19zZXFfa2V5cyA9IHRvX3NlcV9rZXlzXG4gICAgbGV0IHRvX3NlcV92YWx1ZXMgPSB0b19zZXFfdmFsdWVzXG4gIGVuZFxuXG5tb2R1bGUgTWFrZShIOiBIYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbigqIFBvbHltb3JwaGljIGhhc2ggZnVuY3Rpb24tYmFzZWQgdGFibGVzICopXG4oKiBDb2RlIGluY2x1ZGVkIGJlbG93IHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSB0byBndWFyZCBhZ2FpbnN0IGFjY2lkZW50YWxcbiAgIHVzZSAtIHNlZSAjMjIwMiAqKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cblxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbmxldCBoYXNoX3BhcmFtIG4xIG4yIHggPSBzZWVkZWRfaGFzaF9wYXJhbSBuMSBuMiAwIHhcbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5cbmxldCBrZXlfaW5kZXggaCBrZXkgPVxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNFxuICB0aGVuIChzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJIYXNodGJsOiB1bnN1cHBvcnRlZCBoYXNoIHRhYmxlIGZvcm1hdFwiXG5cbmxldCBhZGQgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxubGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgICgpXG4gIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgZW5kXG4gICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxubGV0IHJlbW92ZSBoIGtleSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbmxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbmxldCBmaW5kIGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG5sZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBOb25lXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbmxldCBmaW5kX29wdCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbmxldCBmaW5kX2FsbCBoIGtleSA9XG4gIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBbXVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiBkYXRhIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxubGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBsID0gaC5kYXRhLihpKSBpblxuICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgZW5kXG5cbmxldCBtZW0gaCBrZXkgPVxuICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBmYWxzZVxuICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICBjb21wYXJlIGsga2V5ID0gMCB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IGFkZF9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbmxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gIHRibFxuXG5sZXQgcmVidWlsZCA/KHJhbmRvbSA9ICFyYW5kb21pemVkKSBoID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IChBcnJheS5sZW5ndGggaC5kYXRhKSBpblxuICBsZXQgc2VlZCA9XG4gICAgaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZylcbiAgICBlbHNlIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSA0IHRoZW4gaC5zZWVkXG4gICAgZWxzZSAwIGluXG4gIGxldCBoJyA9IHtcbiAgICBzaXplID0gaC5zaXplO1xuICAgIGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHk7XG4gICAgc2VlZCA9IHNlZWQ7XG4gICAgaW5pdGlhbF9zaXplID0gaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDQgdGhlbiBoLmluaXRpYWxfc2l6ZSBlbHNlIHNcbiAgfSBpblxuICBpbnNlcnRfYWxsX2J1Y2tldHMgKGtleV9pbmRleCBoJykgZmFsc2UgaC5kYXRhIGgnLmRhdGE7XG4gIGgnXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiBXZWFrIGFycmF5IG9wZXJhdGlvbnMgKilcblxudHlwZSAhJ2EgdFxuXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gJ2EgdCA9IFwiY2FtbF93ZWFrX2NyZWF0ZVwiXG5cbmxldCBjcmVhdGUgbCA9XG4gIGlmIG5vdCAoMCA8PSBsICYmIGwgPD0gT2JqLkVwaGVtZXJvbi5tYXhfZXBoZV9sZW5ndGgpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhcIldlYWsuY3JlYXRlXCIpO1xuICBjcmVhdGUgbFxuXG4oKiogbnVtYmVyIG9mIGFkZGl0aW9uYWwgdmFsdWVzIGluIGEgd2VhayBwb2ludGVyICopXG5sZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG5cbmxldCBsZW5ndGggeCA9IE9iai5zaXplKE9iai5yZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxubGV0IHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBtc2cgPVxuICBpZiBub3QgKDAgPD0gbyAmJiBvIDwgbGVuZ3RoIGUpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhtc2cpXG5cbmV4dGVybmFsIHNldCcgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2tleVwiXG5leHRlcm5hbCB1bnNldCA6ICdhIHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxubGV0IHNldCBlIG8geCA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuc2V0XCI7XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4gdW5zZXQgZSBvXG4gIHwgU29tZSB4IC0+IHNldCcgZSBvIHhcblxuZXh0ZXJuYWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uID0gXCJjYW1sX3dlYWtfZ2V0XCJcbmxldCBnZXQgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5nZXRcIjtcbiAgZ2V0IGUgb1xuXG5leHRlcm5hbCBnZXRfY29weSA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldF9jb3B5XCJcbmxldCBnZXRfY29weSBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmdldF9jb3B5XCI7XG4gIGdldF9jb3B5IGUgb1xuXG5leHRlcm5hbCBjaGVjayA6ICdhIHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfd2Vha19jaGVja1wiXG5sZXQgY2hlY2sgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5jaGVja1wiO1xuICBjaGVjayBlIG9cblxuZXh0ZXJuYWwgYmxpdCA6ICdhIHQgLT4gaW50IC0+ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX3dlYWtfYmxpdFwiXG5cbigqIGJsaXQ6IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gKilcbmxldCBibGl0IGUxIG8xIGUyIG8yIGwgPVxuICBpZiBsIDwgMCB8fCBvMSA8IDAgfHwgbzEgPiBsZW5ndGggZTEgLSBsXG4gICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIldlYWsuYmxpdFwiXG4gIGVsc2UgaWYgbCA8PiAwIHRoZW4gYmxpdCBlMSBvMSBlMiBvMiBsXG5cbmxldCBmaWxsIGFyIG9mcyBsZW4geCA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYXIgLSBsZW5cbiAgdGhlbiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIldlYWsuZmlsbFwiKVxuICBlbHNlIGJlZ2luXG4gICAgZm9yIGkgPSBvZnMgdG8gKG9mcyArIGxlbiAtIDEpIGRvXG4gICAgICBzZXQgYXIgaSB4XG4gICAgZG9uZVxuICBlbmRcblxuXG4oKiogV2VhayBoYXNoIHRhYmxlcyAqKVxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgZGF0YVxuICB0eXBlIHRcbiAgdmFsIGNyZWF0ZSA6IGludCAtPiB0XG4gIHZhbCBjbGVhciA6IHQgLT4gdW5pdFxuICB2YWwgbWVyZ2UgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgYWRkIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCBmaW5kIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGZpbmRfb3B0IDogdCAtPiBkYXRhIC0+IGRhdGEgb3B0aW9uXG4gIHZhbCBmaW5kX2FsbCA6IHQgLT4gZGF0YSAtPiBkYXRhIGxpc3RcbiAgdmFsIG1lbSA6IHQgLT4gZGF0YSAtPiBib29sXG4gIHZhbCBpdGVyIDogKGRhdGEgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gIHZhbCBmb2xkIDogKGRhdGEgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgdmFsIGNvdW50IDogdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogdCAtPiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoSCA6IEhhc2h0YmwuSGFzaGVkVHlwZSkgOiAoUyB3aXRoIHR5cGUgZGF0YSA9IEgudCkgPSBzdHJ1Y3RcblxuICB0eXBlICdhIHdlYWtfdCA9ICdhIHRcbiAgbGV0IHdlYWtfY3JlYXRlID0gY3JlYXRlXG4gIGxldCBlbXB0eWJ1Y2tldCA9IHdlYWtfY3JlYXRlIDBcblxuICB0eXBlIGRhdGEgPSBILnRcblxuICB0eXBlIHQgPSB7XG4gICAgbXV0YWJsZSB0YWJsZSA6IGRhdGEgd2Vha190IGFycmF5O1xuICAgIG11dGFibGUgaGFzaGVzIDogaW50IGFycmF5IGFycmF5O1xuICAgIG11dGFibGUgbGltaXQgOiBpbnQ7ICAgICAgICAgICAgICAgKCogYnVja2V0IHNpemUgbGltaXQgKilcbiAgICBtdXRhYmxlIG92ZXJzaXplIDogaW50OyAgICAgICAgICAgICgqIG51bWJlciBvZiBvdmVyc2l6ZSBidWNrZXRzICopXG4gICAgbXV0YWJsZSByb3ZlciA6IGludDsgICAgICAgICAgICAgICAoKiBmb3IgaW50ZXJuYWwgYm9va2tlZXBpbmcgKilcbiAgfVxuXG4gIGxldCBnZXRfaW5kZXggdCBoID0gKGggbGFuZCBtYXhfaW50KSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG4gIGxldCBsaW1pdCA9IDdcbiAgbGV0IG92ZXJfbGltaXQgPSAyXG5cbiAgbGV0IGNyZWF0ZSBzeiA9XG4gICAgbGV0IHN6ID0gaWYgc3ogPCA3IHRoZW4gNyBlbHNlIHN6IGluXG4gICAgbGV0IHN6ID0gaWYgc3ogPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIFN5cy5tYXhfYXJyYXlfbGVuZ3RoIGVsc2Ugc3ogaW5cbiAgICB7XG4gICAgICB0YWJsZSA9IEFycmF5Lm1ha2Ugc3ogZW1wdHlidWNrZXQ7XG4gICAgICBoYXNoZXMgPSBBcnJheS5tYWtlIHN6IFt8IHxdO1xuICAgICAgbGltaXQgPSBsaW1pdDtcbiAgICAgIG92ZXJzaXplID0gMDtcbiAgICAgIHJvdmVyID0gMDtcbiAgICB9XG5cbiAgbGV0IGNsZWFyIHQgPVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICAgIHQudGFibGUuKGkpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgdC5oYXNoZXMuKGkpIDwtIFt8IHxdO1xuICAgIGRvbmU7XG4gICAgdC5saW1pdCA8LSBsaW1pdDtcbiAgICB0Lm92ZXJzaXplIDwtIDBcblxuXG4gIGxldCBmb2xkIGYgdCBpbml0ID1cbiAgICBsZXQgcmVjIGZvbGRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiAoZiB2IGFjY3UpXG4gICAgICB8IE5vbmUgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiBhY2N1XG4gICAgaW5cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChmb2xkX2J1Y2tldCAwKSB0LnRhYmxlIGluaXRcblxuXG4gIGxldCBpdGVyIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZiB2OyBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgICB8IE5vbmUgLT4gaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgIGluXG4gICAgQXJyYXkuaXRlciAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IGl0ZXJfd2VhayBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBqIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGNoZWNrIGIgaSB3aXRoXG4gICAgICB8IHRydWUgLT4gZiBiIHQuaGFzaGVzLihqKSBpOyBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICAgIHwgZmFsc2UgLT4gaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyaSAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IHJlYyBjb3VudF9idWNrZXQgaSBiIGFjY3UgPVxuICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICBjb3VudF9idWNrZXQgKGkrMSkgYiAoYWNjdSArIChpZiBjaGVjayBiIGkgdGhlbiAxIGVsc2UgMCkpXG5cblxuICBsZXQgY291bnQgdCA9XG4gICAgQXJyYXkuZm9sZF9yaWdodCAoY291bnRfYnVja2V0IDApIHQudGFibGUgMFxuXG5cbiAgbGV0IG5leHRfc3ogbiA9IEludC5taW4gKDMgKiBuIC8gMiArIDMpIFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG4gIGxldCBwcmV2X3N6IG4gPSAoKG4gLSAzKSAqIDIgKyAyKSAvIDNcblxuICBsZXQgdGVzdF9zaHJpbmtfYnVja2V0IHQgPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLih0LnJvdmVyKSBpblxuICAgIGxldCBoYnVja2V0ID0gdC5oYXNoZXMuKHQucm92ZXIpIGluXG4gICAgbGV0IGxlbiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcHJldl9sZW4gPSBwcmV2X3N6IGxlbiBpblxuICAgIGxldCBsaXZlID0gY291bnRfYnVja2V0IDAgYnVja2V0IDAgaW5cbiAgICBpZiBsaXZlIDw9IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCByZWMgbG9vcCBpIGogPVxuICAgICAgICBpZiBqID49IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgICBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGxvb3AgKGkgKyAxKSBqXG4gICAgICAgICAgZWxzZSBpZiBjaGVjayBidWNrZXQgaiB0aGVuIGJlZ2luXG4gICAgICAgICAgICBibGl0IGJ1Y2tldCBqIGJ1Y2tldCBpIDE7XG4gICAgICAgICAgICBoYnVja2V0LihpKSA8LSBoYnVja2V0LihqKTtcbiAgICAgICAgICAgIGxvb3AgKGkgKyAxKSAoaiAtIDEpO1xuICAgICAgICAgIGVuZCBlbHNlIGxvb3AgaSAoaiAtIDEpO1xuICAgICAgICBlbmQ7XG4gICAgICBpblxuICAgICAgbG9vcCAwIChsZW5ndGggYnVja2V0IC0gMSk7XG4gICAgICBpZiBwcmV2X2xlbiA9IDAgdGhlbiBiZWdpblxuICAgICAgICB0LnRhYmxlLih0LnJvdmVyKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIFt8IHxdO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIHByZXZfbGVuIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgcHJldl9sZW47XG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIEFycmF5LnN1YiBoYnVja2V0IDAgcHJldl9sZW5cbiAgICAgIGVuZDtcbiAgICAgIGlmIGxlbiA+IHQubGltaXQgJiYgcHJldl9sZW4gPD0gdC5saW1pdCB0aGVuIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSAtIDE7XG4gICAgZW5kO1xuICAgIHQucm92ZXIgPC0gKHQucm92ZXIgKyAxKSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG5cbiAgbGV0IHJlYyByZXNpemUgdCA9XG4gICAgbGV0IG9sZGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IG5ld2xlbiA9IG5leHRfc3ogb2xkbGVuIGluXG4gICAgaWYgbmV3bGVuID4gb2xkbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCBuZXd0ID0gY3JlYXRlIG5ld2xlbiBpblxuICAgICAgbGV0IGFkZF93ZWFrIG9iIG9oIG9pID1cbiAgICAgICAgbGV0IHNldHRlciBuYiBuaSBfID0gYmxpdCBvYiBvaSBuYiBuaSAxIGluXG4gICAgICAgIGxldCBoID0gb2guKG9pKSBpblxuICAgICAgICBhZGRfYXV4IG5ld3Qgc2V0dGVyIE5vbmUgaCAoZ2V0X2luZGV4IG5ld3QgaCk7XG4gICAgICBpblxuICAgICAgaXRlcl93ZWFrIGFkZF93ZWFrIHQ7XG4gICAgICB0LnRhYmxlIDwtIG5ld3QudGFibGU7XG4gICAgICB0Lmhhc2hlcyA8LSBuZXd0Lmhhc2hlcztcbiAgICAgIHQubGltaXQgPC0gbmV3dC5saW1pdDtcbiAgICAgIHQub3ZlcnNpemUgPC0gbmV3dC5vdmVyc2l6ZTtcbiAgICAgIHQucm92ZXIgPC0gdC5yb3ZlciBtb2QgQXJyYXkubGVuZ3RoIG5ld3QudGFibGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHQubGltaXQgPC0gbWF4X2ludDsgICAgICAgICAgICAgKCogbWF4aW11bSBzaXplIGFscmVhZHkgcmVhY2hlZCAqKVxuICAgICAgdC5vdmVyc2l6ZSA8LSAwO1xuICAgIGVuZFxuXG4gIGFuZCBhZGRfYXV4IHQgc2V0dGVyIGQgaCBpbmRleCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmV3c3ogPVxuICAgICAgICAgIEludC5taW4gKDMgKiBzeiAvIDIgKyAzKSAoU3lzLm1heF9hcnJheV9sZW5ndGggLSBhZGRpdGlvbmFsX3ZhbHVlcylcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbmV3c3ogPD0gc3ogdGhlbiBmYWlsd2l0aCBcIldlYWsuTWFrZTogaGFzaCBidWNrZXQgY2Fubm90IGdyb3cgbW9yZVwiO1xuICAgICAgICBsZXQgbmV3YnVja2V0ID0gd2Vha19jcmVhdGUgbmV3c3ogaW5cbiAgICAgICAgbGV0IG5ld2hhc2hlcyA9IEFycmF5Lm1ha2UgbmV3c3ogMCBpblxuICAgICAgICBibGl0IGJ1Y2tldCAwIG5ld2J1Y2tldCAwIHN6O1xuICAgICAgICBBcnJheS5ibGl0IGhhc2hlcyAwIG5ld2hhc2hlcyAwIHN6O1xuICAgICAgICBzZXR0ZXIgbmV3YnVja2V0IHN6IGQ7XG4gICAgICAgIG5ld2hhc2hlcy4oc3opIDwtIGg7XG4gICAgICAgIHQudGFibGUuKGluZGV4KSA8LSBuZXdidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLihpbmRleCkgPC0gbmV3aGFzaGVzO1xuICAgICAgICBpZiBzeiA8PSB0LmxpbWl0ICYmIG5ld3N6ID4gdC5saW1pdCB0aGVuIGJlZ2luXG4gICAgICAgICAgdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplICsgMTtcbiAgICAgICAgICBmb3IgX2kgPSAwIHRvIG92ZXJfbGltaXQgZG8gdGVzdF9zaHJpbmtfYnVja2V0IHQgZG9uZTtcbiAgICAgICAgZW5kO1xuICAgICAgICBpZiB0Lm92ZXJzaXplID4gQXJyYXkubGVuZ3RoIHQudGFibGUgLyBvdmVyX2xpbWl0IHRoZW4gcmVzaXplIHQ7XG4gICAgICBlbmQgZWxzZSBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGJlZ2luXG4gICAgICAgIGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0dGVyIGJ1Y2tldCBpIGQ7XG4gICAgICAgIGhhc2hlcy4oaSkgPC0gaDtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGFkZCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggKGdldF9pbmRleCB0IGgpXG5cblxuICBsZXQgZmluZF9vciB0IGQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmQgaCBpbmRleFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgbWVyZ2UgdCBkID1cbiAgICBmaW5kX29yIHQgZCAoZnVuIGggaW5kZXggLT4gYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIGluZGV4OyBkKVxuXG5cbiAgbGV0IGZpbmQgdCBkID0gZmluZF9vciB0IGQgKGZ1biBfaCBfaW5kZXggLT4gcmFpc2UgTm90X2ZvdW5kKVxuXG4gIGxldCBmaW5kX29wdCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBOb25lXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGZpbmRfc2hhZG93IHQgZCBpZmZvdW5kIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkIC0+IGlmZm91bmQgYnVja2V0IGlcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCByZW1vdmUgdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gdyBpIC0+IHNldCB3IGkgTm9uZSkgKClcblxuXG4gIGxldCBtZW0gdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gX3cgX2kgLT4gdHJ1ZSkgZmFsc2VcblxuXG4gIGxldCBmaW5kX2FsbCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpIGFjY3UgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGFjY3VcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gbG9vcCAoaSArIDEpICh2IDo6IGFjY3UpXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSkgYWNjdVxuICAgIGluXG4gICAgbG9vcCAwIFtdXG5cblxuICBsZXQgc3RhdHMgdCA9XG4gICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IGxlbnMgPSBBcnJheS5tYXAgbGVuZ3RoIHQudGFibGUgaW5cbiAgICBBcnJheS5zb3J0IGNvbXBhcmUgbGVucztcbiAgICBsZXQgdG90bGVuID0gQXJyYXkuZm9sZF9sZWZ0ICggKyApIDAgbGVucyBpblxuICAgIChsZW4sIGNvdW50IHQsIHRvdGxlbiwgbGVucy4oMCksIGxlbnMuKGxlbi8yKSwgbGVucy4obGVuLTEpKVxuXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBIHByZXR0eS1wcmludGluZyBmYWNpbGl0eSBhbmQgZGVmaW5pdGlvbiBvZiBmb3JtYXR0ZXJzIGZvciAncGFyYWxsZWwnXG4gICAoaS5lLiB1bnJlbGF0ZWQgb3IgaW5kZXBlbmRlbnQpIHByZXR0eS1wcmludGluZyBvbiBtdWx0aXBsZSBvdXQgY2hhbm5lbHMuICopXG5cbigqXG4gICBUaGUgcHJldHR5LXByaW50aW5nIGVuZ2luZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4qKVxuXG5sZXQgaWQgeCA9IHhcblxuKCogQSBkZXZvdGVkIHR5cGUgZm9yIHNpemVzIHRvIGF2b2lkIGNvbmZ1c2lvblxuICAgYmV0d2VlbiBzaXplcyBhbmQgbWVyZSBpbnRlZ2Vycy4gKilcbm1vZHVsZSBTaXplIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCB0b19pbnQgOiB0IC0+IGludFxuICB2YWwgb2ZfaW50IDogaW50IC0+IHRcbiAgdmFsIHplcm8gOiB0XG4gIHZhbCB1bmtub3duIDogdFxuICB2YWwgaXNfa25vd24gOiB0IC0+IGJvb2xcbmVuZCAgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50XG5cbiAgbGV0IHRvX2ludCA9IGlkXG4gIGxldCBvZl9pbnQgPSBpZFxuICBsZXQgemVybyA9IDBcbiAgbGV0IHVua25vd24gPSAtMVxuICBsZXQgaXNfa25vd24gbiA9IG4gPj0gMFxuZW5kXG5cblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIGJveGVzIGRlZmluaXRpb246XG4gICBhIHByZXR0eS1wcmludGluZyBib3ggaXMgZWl0aGVyXG4gICAtIGhib3g6IGhvcml6b250YWwgYm94IChubyBsaW5lIHNwbGl0dGluZylcbiAgIC0gdmJveDogdmVydGljYWwgYm94IChldmVyeSBicmVhayBoaW50IHNwbGl0cyB0aGUgbGluZSlcbiAgIC0gaHZib3g6IGhvcml6b250YWwvdmVydGljYWwgYm94XG4gICAgICh0aGUgYm94IGJlaGF2ZXMgYXMgYW4gaG9yaXpvbnRhbCBib3ggaWYgaXQgZml0cyBvblxuICAgICAgdGhlIGN1cnJlbnQgbGluZSwgb3RoZXJ3aXNlIHRoZSBib3ggYmVoYXZlcyBhcyBhIHZlcnRpY2FsIGJveClcbiAgIC0gaG92Ym94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94XG4gICAgICh0aGUgYm94IGlzIGNvbXBhY3RpbmcgbWF0ZXJpYWwsIHByaW50aW5nIGFzIG11Y2ggbWF0ZXJpYWwgYXMgcG9zc2libGVcbiAgICAgIG9uIGV2ZXJ5IGxpbmVzKVxuICAgLSBib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3ggd2l0aCBlbmhhbmNlZCBib3ggc3RydWN0dXJlXG4gICAgICh0aGUgYm94IGJlaGF2ZXMgYXMgYW4gaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBib3ggYnV0IGJyZWFrIGhpbnRzIHNwbGl0XG4gICAgICB0aGUgbGluZSBpZiBzcGxpdHRpbmcgd291bGQgbW92ZSB0byB0aGUgbGVmdClcbiopXG50eXBlIGJveF90eXBlID0gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmJsb2NrX3R5cGUgPVxuICB8IFBwX2hib3ggfCBQcF92Ym94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggfCBQcF9maXRzXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyB0b2tlbnMgZGVmaW5pdGlvbjpcbiAgIGFyZSBlaXRoZXIgdGV4dCB0byBwcmludCBvciBwcmV0dHkgcHJpbnRpbmdcbiAgIGVsZW1lbnRzIHRoYXQgZHJpdmUgaW5kZW50YXRpb24gYW5kIGxpbmUgc3BsaXR0aW5nLiAqKVxudHlwZSBwcF90b2tlbiA9XG4gIHwgUHBfdGV4dCBvZiBzdHJpbmcgICAgICAgICAgKCogbm9ybWFsIHRleHQgKilcbiAgfCBQcF9icmVhayBvZiB7ICAgICAgICAgICAgICAoKiBjb21wbGV0ZSBicmVhayAqKVxuICAgICAgZml0czogc3RyaW5nICogaW50ICogc3RyaW5nOyAgICgqIGxpbmUgaXMgbm90IHNwbGl0ICopXG4gICAgICBicmVha3M6IHN0cmluZyAqIGludCAqIHN0cmluZzsgKCogbGluZSBpcyBzcGxpdCAqKVxuICAgIH1cbiAgfCBQcF90YnJlYWsgb2YgaW50ICogaW50ICAgICAoKiBnbyB0byBuZXh0IHRhYnVsYXRpb24gKilcbiAgfCBQcF9zdGFiICAgICAgICAgICAgICAgICAgICAoKiBzZXQgYSB0YWJ1bGF0aW9uICopXG4gIHwgUHBfYmVnaW4gb2YgaW50ICogYm94X3R5cGUgKCogYmVnaW5uaW5nIG9mIGEgYm94ICopXG4gIHwgUHBfZW5kICAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgYm94ICopXG4gIHwgUHBfdGJlZ2luIG9mIHRib3ggICAgICAgICAgKCogYmVnaW5uaW5nIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF90ZW5kICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX25ld2xpbmUgICAgICAgICAgICAgICAgICgqIHRvIGZvcmNlIGEgbmV3bGluZSBpbnNpZGUgYSBib3ggKilcbiAgfCBQcF9pZl9uZXdsaW5lICAgICAgICAgICAgICAoKiB0byBkbyBzb21ldGhpbmcgb25seSBpZiB0aGlzIHZlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lIGhhcyBiZWVuIGJyb2tlbiAqKVxuICB8IFBwX29wZW5fdGFnIG9mIHN0YWcgICAgICAgICAoKiBvcGVuaW5nIGEgdGFnIG5hbWUgKilcbiAgfCBQcF9jbG9zZV90YWcgICAgICAgICAgICAgICAoKiBjbG9zaW5nIHRoZSBtb3N0IHJlY2VudGx5IG9wZW4gdGFnICopXG5cbmFuZCBzdGFnID0gLi5cblxuYW5kIHRib3ggPSBQcF90Ym94IG9mIGludCBsaXN0IHJlZiAgKCogVGFidWxhdGlvbiBib3ggKilcblxudHlwZSB0YWcgPSBzdHJpbmdcbnR5cGUgc3RhZyArPSBTdHJpbmdfdGFnIG9mIHRhZ1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZTpcbiAgIHByZXR0eS1wcmludGluZyBtYXRlcmlhbCBpcyBub3Qgd3JpdHRlbiBpbiB0aGUgb3V0cHV0IGFzIHNvb24gYXMgZW1pdHRlZDtcbiAgIGluc3RlYWQsIHRoZSBtYXRlcmlhbCBpcyBzaW1wbHkgcmVjb3JkZWQgaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLFxuICAgdW50aWwgdGhlIGVuY2xvc2luZyBib3ggaGFzIGEga25vd24gY29tcHV0ZWQgc2l6ZSBhbmQgcHJvcGVyIHNwbGl0dGluZ1xuICAgZGVjaXNpb25zIGNhbiBiZSBtYWRlLlxuXG4gICBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUgY29udGFpbnMgZm9ybWF0dGluZyBlbGVtZW50cyB0byBiZSBwcmludGVkLlxuICAgRWFjaCBmb3JtYXR0aW5nIGVsZW1lbnQgaXMgYSB0dXBsZSAoc2l6ZSwgdG9rZW4sIGxlbmd0aCksIHdoZXJlXG4gICAtIGxlbmd0aCBpcyB0aGUgZGVjbGFyZWQgbGVuZ3RoIG9mIHRoZSB0b2tlbixcbiAgIC0gc2l6ZSBpcyBlZmZlY3RpdmUgc2l6ZSBvZiB0aGUgdG9rZW4gd2hlbiBpdCBpcyBwcmludGVkXG4gICAgIChzaXplIGlzIHNldCB3aGVuIHRoZSBzaXplIG9mIHRoZSBib3ggaXMga25vd24sIHNvIHRoYXQgc2l6ZSBvZiBicmVha1xuICAgICAgaGludHMgYXJlIGRlZmluaXRpdmUpLiAqKVxudHlwZSBwcF9xdWV1ZV9lbGVtID0ge1xuICBtdXRhYmxlIHNpemUgOiBTaXplLnQ7XG4gIHRva2VuIDogcHBfdG9rZW47XG4gIGxlbmd0aCA6IGludDtcbn1cblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfcXVldWUgPSBwcF9xdWV1ZV9lbGVtIFF1ZXVlLnRcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2s6IHNjYW5uaW5nIGVsZW1lbnQgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfc2Nhbl9lbGVtID0ge1xuICBsZWZ0X3RvdGFsIDogaW50OyAoKiBWYWx1ZSBvZiBwcF9sZWZ0X3RvdGFsIHdoZW4gdGhlIGVsZW1lbnQgd2FzIGVucXVldWVkLiAqKVxuICBxdWV1ZV9lbGVtIDogcHBfcXVldWVfZWxlbVxufVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazpcbiAgIHRoZSBmb3JtYXR0aW5nIHN0YWNrIGNvbnRhaW5zIHRoZSBkZXNjcmlwdGlvbiBvZiBhbGwgdGhlIGN1cnJlbnRseSBhY3RpdmVcbiAgIGJveGVzOyB0aGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjayBpcyB1c2VkIHRvIHNwbGl0IHRoZSBsaW5lc1xuICAgd2hpbGUgcHJpbnRpbmcgdG9rZW5zLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazogZm9ybWF0dGluZyBzdGFjayBlbGVtZW50IGRlZmluaXRpb24uXG4gICBFYWNoIHN0YWNrIGVsZW1lbnQgZGVzY3JpYmVzIGEgcHJldHR5LXByaW50aW5nIGJveC4gKilcbnR5cGUgcHBfZm9ybWF0X2VsZW0gPSB7IGJveF90eXBlIDogYm94X3R5cGU7IHdpZHRoIDogaW50IH1cblxuKCogVGhlIGZvcm1hdHRlciBkZWZpbml0aW9uLlxuICAgRWFjaCBmb3JtYXR0ZXIgdmFsdWUgaXMgYSBwcmV0dHktcHJpbnRlciBpbnN0YW5jZSB3aXRoIGFsbCBpdHNcbiAgIG1hY2hpbmVyeS4gKilcbnR5cGUgZm9ybWF0dGVyID0ge1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG4gIHBwX3NjYW5fc3RhY2sgOiBwcF9zY2FuX2VsZW0gU3RhY2sudDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2suICopXG4gIHBwX2Zvcm1hdF9zdGFjayA6IHBwX2Zvcm1hdF9lbGVtIFN0YWNrLnQ7XG4gIHBwX3Rib3hfc3RhY2sgOiB0Ym94IFN0YWNrLnQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBzZW1hbnRpY3MgdGFnIHN0YWNrLiAqKVxuICBwcF90YWdfc3RhY2sgOiBzdGFnIFN0YWNrLnQ7XG4gIHBwX21hcmtfc3RhY2sgOiBzdGFnIFN0YWNrLnQ7XG4gICgqIFZhbHVlIG9mIHJpZ2h0IG1hcmdpbi4gKilcbiAgbXV0YWJsZSBwcF9tYXJnaW4gOiBpbnQ7XG4gICgqIE1pbmltYWwgc3BhY2UgbGVmdCBiZWZvcmUgbWFyZ2luLCB3aGVuIG9wZW5pbmcgYSBib3guICopXG4gIG11dGFibGUgcHBfbWluX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIE1heGltdW0gdmFsdWUgb2YgaW5kZW50YXRpb246XG4gICAgIG5vIGJveCBjYW4gYmUgb3BlbmVkIGZ1cnRoZXIuICopXG4gIG11dGFibGUgcHBfbWF4X2luZGVudCA6IGludDtcbiAgKCogU3BhY2UgcmVtYWluaW5nIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG4gIG11dGFibGUgcHBfc3BhY2VfbGVmdCA6IGludDtcbiAgKCogQ3VycmVudCB2YWx1ZSBvZiBpbmRlbnRhdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9jdXJyZW50X2luZGVudCA6IGludDtcbiAgKCogVHJ1ZSB3aGVuIHRoZSBsaW5lIGhhcyBiZWVuIGJyb2tlbiBieSB0aGUgcHJldHR5LXByaW50ZXIuICopXG4gIG11dGFibGUgcHBfaXNfbmV3X2xpbmUgOiBib29sO1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgYWxyZWFkeSBwcmludGVkLiAqKVxuICBtdXRhYmxlIHBwX2xlZnRfdG90YWwgOiBpbnQ7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBldmVyIHB1dCBpbiBxdWV1ZS4gKilcbiAgbXV0YWJsZSBwcF9yaWdodF90b3RhbCA6IGludDtcbiAgKCogQ3VycmVudCBudW1iZXIgb2Ygb3BlbiBib3hlcy4gKilcbiAgbXV0YWJsZSBwcF9jdXJyX2RlcHRoIDogaW50O1xuICAoKiBNYXhpbXVtIG51bWJlciBvZiBib3hlcyB3aGljaCBjYW4gYmUgc2ltdWx0YW5lb3VzbHkgb3Blbi4gKilcbiAgbXV0YWJsZSBwcF9tYXhfYm94ZXMgOiBpbnQ7XG4gICgqIEVsbGlwc2lzIHN0cmluZy4gKilcbiAgbXV0YWJsZSBwcF9lbGxpcHNpcyA6IHN0cmluZztcbiAgKCogT3V0cHV0IGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICAoKiBGbHVzaGluZyBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X25ld2xpbmUgOiB1bml0IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBicmVhayBoaW50cyBzcGFjZXMuICopXG4gIG11dGFibGUgcHBfb3V0X3NwYWNlcyA6IGludCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgaW5kZW50YXRpb24gb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbiAgKCogQXJlIHRhZ3MgcHJpbnRlZCA/ICopXG4gIG11dGFibGUgcHBfcHJpbnRfdGFncyA6IGJvb2w7XG4gICgqIEFyZSB0YWdzIG1hcmtlZCA/ICopXG4gIG11dGFibGUgcHBfbWFya190YWdzIDogYm9vbDtcbiAgKCogRmluZCBvcGVuaW5nIGFuZCBjbG9zaW5nIG1hcmtlcnMgb2YgdGFncy4gKilcbiAgbXV0YWJsZSBwcF9tYXJrX29wZW5fdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfbWFya19jbG9zZV90YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9wcmludF9vcGVuX3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgbXV0YWJsZSBwcF9wcmludF9jbG9zZV90YWcgOiBzdGFnIC0+IHVuaXQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbiAgcHBfcXVldWUgOiBwcF9xdWV1ZTtcbn1cblxuXG4oKiBUaGUgZm9ybWF0dGVyIHNwZWNpZmljIHRhZyBoYW5kbGluZyBmdW5jdGlvbnMuICopXG50eXBlIGZvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9IHtcbiAgbWFya19vcGVuX3N0YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbWFya19jbG9zZV9zdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIHByaW50X29wZW5fc3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgcHJpbnRfY2xvc2Vfc3RhZyA6IHN0YWcgLT4gdW5pdDtcbn1cblxuXG4oKiBUaGUgZm9ybWF0dGVyIGZ1bmN0aW9ucyB0byBvdXRwdXQgbWF0ZXJpYWwuICopXG50eXBlIGZvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID0ge1xuICBvdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICBvdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgb3V0X3NwYWNlcyA6IGludCAtPiB1bml0O1xuICBvdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG59XG5cblxuKCpcblxuICBBdXhpbGlhcmllcyBhbmQgYmFzaWMgZnVuY3Rpb25zLlxuXG4qKVxuXG4oKiBFbnRlciBhIHRva2VuIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9lbnF1ZXVlIHN0YXRlIHRva2VuID1cbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gc3RhdGUucHBfcmlnaHRfdG90YWwgKyB0b2tlbi5sZW5ndGg7XG4gIFF1ZXVlLmFkZCB0b2tlbiBzdGF0ZS5wcF9xdWV1ZVxuXG5cbmxldCBwcF9jbGVhcl9xdWV1ZSBzdGF0ZSA9XG4gIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gMTsgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gMTtcbiAgUXVldWUuY2xlYXIgc3RhdGUucHBfcXVldWVcblxuXG4oKiBQcF9pbmZpbml0eTogbGFyZ2UgdmFsdWUgZm9yIGRlZmF1bHQgdG9rZW5zIHNpemUuXG5cbiAgIFBwX2luZmluaXR5IGlzIGRvY3VtZW50ZWQgYXMgYmVpbmcgZ3JlYXRlciB0aGFuIDFlMTA7IHRvIGF2b2lkXG4gICBjb25mdXNpb24gYWJvdXQgdGhlIHdvcmQgJ2dyZWF0ZXInLCB3ZSBjaG9vc2UgcHBfaW5maW5pdHkgZ3JlYXRlclxuICAgdGhhbiAxZTEwICsgMTsgZm9yIGNvcnJlY3QgaGFuZGxpbmcgb2YgdGVzdHMgaW4gdGhlIGFsZ29yaXRobSxcbiAgIHBwX2luZmluaXR5IG11c3QgYmUgZXZlbiBvbmUgbW9yZSB0aGFuIDFlMTAgKyAxOyBsZXQncyBzdGFuZCBvbiB0aGVcbiAgIHNhZmUgc2lkZSBieSBjaG9vc2luZyAxLmUxMCsxMC5cblxuICAgUHBfaW5maW5pdHkgY291bGQgcHJvYmFibHkgYmUgMTA3Mzc0MTgyMyB0aGF0IGlzIDJeMzAgLSAxLCB0aGF0IGlzXG4gICB0aGUgbWluaW1hbCB1cHBlciBib3VuZCBmb3IgaW50ZWdlcnM7IG5vdyB0aGF0IG1heF9pbnQgaXMgZGVmaW5lZCxcbiAgIHRoaXMgbGltaXQgY291bGQgYWxzbyBiZSBkZWZpbmVkIGFzIG1heF9pbnQgLSAxLlxuXG4gICBIb3dldmVyLCBiZWZvcmUgc2V0dGluZyBwcF9pbmZpbml0eSB0byBzb21ldGhpbmcgYXJvdW5kIG1heF9pbnQsIHdlXG4gICBtdXN0IGNhcmVmdWxseSBkb3VibGUtY2hlY2sgYWxsIHRoZSBpbnRlZ2VyIGFyaXRobWV0aWMgb3BlcmF0aW9uc1xuICAgdGhhdCBpbnZvbHZlIHBwX2luZmluaXR5LCBzaW5jZSBhbnkgb3ZlcmZsb3cgd291bGQgd3JlY2sgaGF2b2MgdGhlXG4gICBwcmV0dHktcHJpbnRpbmcgYWxnb3JpdGhtJ3MgaW52YXJpYW50cy4gR2l2ZW4gdGhhdCB0aGlzIGFyaXRobWV0aWNcbiAgIGNvcnJlY3RuZXNzIGNoZWNrIGlzIGRpZmZpY3VsdCBhbmQgZXJyb3IgcHJvbmUgYW5kIGdpdmVuIHRoYXQgMWUxMFxuICAgKyAxIGlzIGluIHByYWN0aWNlIGxhcmdlIGVub3VnaCwgdGhlcmUgaXMgbm8gbmVlZCB0byBhdHRlbXB0IHRvIHNldFxuICAgcHBfaW5maW5pdHkgdG8gdGhlIHRoZW9yZXRpY2FsbHkgbWF4aW11bSBsaW1pdC4gSXQgaXMgbm90IHdvcnRoIHRoZVxuICAgYnVyZGVuICEgKilcbmxldCBwcF9pbmZpbml0eSA9IDEwMDAwMDAwMTBcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBmb3IgdGhlIGZvcm1hdHRlci4gKilcbmxldCBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHMgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIHMgMCAoU3RyaW5nLmxlbmd0aCBzKVxuYW5kIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlID0gc3RhdGUucHBfb3V0X25ld2xpbmUgKClcbmFuZCBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfc3BhY2VzIG5cbmFuZCBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfaW5kZW50IG5cblxuKCogRm9ybWF0IGEgdGV4dHVhbCB0b2tlbiAqKVxubGV0IGZvcm1hdF9wcF90ZXh0IHN0YXRlIHNpemUgdGV4dCA9XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIHNpemU7XG4gIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgdGV4dDtcbiAgc3RhdGUucHBfaXNfbmV3X2xpbmUgPC0gZmFsc2VcblxuKCogRm9ybWF0IGEgc3RyaW5nIGJ5IGl0cyBsZW5ndGgsIGlmIG5vdCBlbXB0eSAqKVxubGV0IGZvcm1hdF9zdHJpbmcgc3RhdGUgcyA9XG4gIGlmIHMgPD4gXCJcIiB0aGVuIGZvcm1hdF9wcF90ZXh0IHN0YXRlIChTdHJpbmcubGVuZ3RoIHMpIHNcblxuKCogVG8gZm9ybWF0IGEgYnJlYWssIGluZGVudGluZyBhIG5ldyBsaW5lLiAqKVxubGV0IGJyZWFrX25ld19saW5lIHN0YXRlIChiZWZvcmUsIG9mZnNldCwgYWZ0ZXIpIHdpZHRoID1cbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBiZWZvcmU7XG4gIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSB0cnVlO1xuICBsZXQgaW5kZW50ID0gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZzZXQgaW5cbiAgKCogRG9uJ3QgaW5kZW50IG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LiAqKVxuICBsZXQgcmVhbF9pbmRlbnQgPSBJbnQubWluIHN0YXRlLnBwX21heF9pbmRlbnQgaW5kZW50IGluXG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIHJlYWxfaW5kZW50O1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGFmdGVyXG5cblxuKCogVG8gZm9yY2UgYSBsaW5lIGJyZWFrIGluc2lkZSBhIGJveDogbm8gb2Zmc2V0IGlzIGFkZGVkLiAqKVxubGV0IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGggPSBicmVha19uZXdfbGluZSBzdGF0ZSAoXCJcIiwgMCwgXCJcIikgd2lkdGhcblxuKCogVG8gZm9ybWF0IGEgYnJlYWsgdGhhdCBmaXRzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgYnJlYWtfc2FtZV9saW5lIHN0YXRlIChiZWZvcmUsIHdpZHRoLCBhZnRlcikgPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gd2lkdGg7XG4gIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgd2lkdGg7XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYWZ0ZXJcblxuXG4oKiBUbyBpbmRlbnQgbm8gbW9yZSB0aGFuIHBwX21heF9pbmRlbnQsIGlmIG9uZSB0cmllcyB0byBvcGVuIGEgYm94XG4gICBiZXlvbmQgcHBfbWF4X2luZGVudCwgdGhlbiB0aGUgYm94IGlzIHJlamVjdGVkIG9uIHRoZSBsZWZ0XG4gICBieSBzaW11bGF0aW5nIGEgYnJlYWsuICopXG5sZXQgcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSA9XG4gIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlXG4gIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgaWYgd2lkdGggPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW5cbiAgICAgIG1hdGNoIGJveF90eXBlIHdpdGhcbiAgICAgIHwgUHBfZml0cyB8IFBwX2hib3ggLT4gKClcbiAgICAgIHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcblxuXG4oKiBUbyBza2lwIGEgdG9rZW4sIGlmIHRoZSBwcmV2aW91cyBsaW5lIGhhcyBiZWVuIGJyb2tlbi4gKilcbmxldCBwcF9za2lwX3Rva2VuIHN0YXRlID1cbiAgbWF0Y2ggUXVldWUudGFrZV9vcHQgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogcHJpbnRfaWZfbmV3bGluZSBtdXN0IGhhdmUgYmVlbiB0aGUgbGFzdCBwcmludGluZyBjb21tYW5kICopXG4gIHwgU29tZSB7IHNpemU7IGxlbmd0aDsgXyB9IC0+XG4gICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIC0gbGVuZ3RoO1xuICAgIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCArIFNpemUudG9faW50IHNpemVcblxuXG4oKlxuXG4gIFRoZSBtYWluIHByZXR0eSBwcmludGluZyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEZvcm1hdHRpbmcgYSB0b2tlbiB3aXRoIGEgZ2l2ZW4gc2l6ZS4gKilcbmxldCBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSA9IGZ1bmN0aW9uXG5cbiAgfCBQcF90ZXh0IHMgLT5cbiAgICBmb3JtYXRfcHBfdGV4dCBzdGF0ZSBzaXplIHNcblxuICB8IFBwX2JlZ2luIChvZmYsIHR5KSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgaWYgaW5zZXJ0aW9uX3BvaW50ID4gc3RhdGUucHBfbWF4X2luZGVudCB0aGVuXG4gICAgICAoKiBjYW4gbm90IG9wZW4gYSBib3ggcmlnaHQgdGhlcmUuICopXG4gICAgICBiZWdpbiBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlIGVuZDtcbiAgICBsZXQgd2lkdGggPSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gb2ZmIGluXG4gICAgbGV0IGJveF90eXBlID1cbiAgICAgIG1hdGNoIHR5IHdpdGhcbiAgICAgIHwgUHBfdmJveCAtPiBQcF92Ym94XG4gICAgICB8IFBwX2hib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHMgLT5cbiAgICAgICAgaWYgc2l6ZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlbiB0eSBlbHNlIFBwX2ZpdHMgaW5cbiAgICBTdGFjay5wdXNoIHsgYm94X3R5cGU7IHdpZHRoIH0gc3RhdGUucHBfZm9ybWF0X3N0YWNrXG5cbiAgfCBQcF9lbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB8PiBpZ25vcmVcblxuICB8IFBwX3RiZWdpbiAoUHBfdGJveCBfIGFzIHRib3gpIC0+XG4gICAgU3RhY2sucHVzaCB0Ym94IHN0YXRlLnBwX3Rib3hfc3RhY2tcblxuICB8IFBwX3RlbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgfD4gaWdub3JlXG5cbiAgfCBQcF9zdGFiIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICB8IFNvbWUgKFBwX3Rib3ggdGFicykgLT5cbiAgICAgIGxldCByZWMgYWRkX3RhYiBuID0gZnVuY3Rpb25cbiAgICAgICAgfCBbXSAtPiBbbl1cbiAgICAgICAgfCB4IDo6IGwgYXMgbHMgLT4gaWYgbiA8IHggdGhlbiBuIDo6IGxzIGVsc2UgeCA6OiBhZGRfdGFiIG4gbCBpblxuICAgICAgdGFicyA6PSBhZGRfdGFiIChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0KSAhdGFic1xuICAgIGVuZFxuXG4gIHwgUHBfdGJyZWFrIChuLCBvZmYpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIHwgU29tZSAoUHBfdGJveCB0YWJzKSAtPlxuICAgICAgbGV0IHRhYiA9XG4gICAgICAgIG1hdGNoICF0YWJzIHdpdGhcbiAgICAgICAgfCBbXSAtPiBpbnNlcnRpb25fcG9pbnRcbiAgICAgICAgfCBmaXJzdCA6OiBfIC0+XG4gICAgICAgICAgbGV0IHJlYyBmaW5kID0gZnVuY3Rpb25cbiAgICAgICAgICAgIHwgaGVhZCA6OiB0YWlsIC0+XG4gICAgICAgICAgICAgIGlmIGhlYWQgPj0gaW5zZXJ0aW9uX3BvaW50IHRoZW4gaGVhZCBlbHNlIGZpbmQgdGFpbFxuICAgICAgICAgICAgfCBbXSAtPiBmaXJzdCBpblxuICAgICAgICAgIGZpbmQgIXRhYnMgaW5cbiAgICAgIGxldCBvZmZzZXQgPSB0YWIgLSBpbnNlcnRpb25fcG9pbnQgaW5cbiAgICAgIGlmIG9mZnNldCA+PSAwXG4gICAgICB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAoXCJcIiwgb2Zmc2V0ICsgbiwgXCJcIilcbiAgICAgIGVsc2UgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKFwiXCIsIHRhYiArIG9mZiwgXCJcIikgc3RhdGUucHBfbWFyZ2luXG4gICAgZW5kXG5cbiAgfCBQcF9uZXdsaW5lIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSAoKiBObyBvcGVuIGJveC4gKilcbiAgICB8IFNvbWUgeyB3aWR0aDsgX30gLT4gYnJlYWtfbGluZSBzdGF0ZSB3aWR0aFxuICAgIGVuZFxuXG4gIHwgUHBfaWZfbmV3bGluZSAtPlxuICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ICE9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICB0aGVuIHBwX3NraXBfdG9rZW4gc3RhdGVcblxuICB8IFBwX2JyZWFrIHsgZml0czsgYnJlYWtzIH0gLT5cbiAgICBsZXQgYmVmb3JlLCBvZmYsIF8gPSBicmVha3MgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgICBiZWdpbiBtYXRjaCBib3hfdHlwZSB3aXRoXG4gICAgICB8IFBwX2hvdmJveCAtPlxuICAgICAgICBpZiBzaXplICsgU3RyaW5nLmxlbmd0aCBiZWZvcmUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfYm94IC0+XG4gICAgICAgICgqIEhhdmUgdGhlIGxpbmUganVzdCBiZWVuIGJyb2tlbiBoZXJlID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfaXNfbmV3X2xpbmUgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0cyBlbHNlXG4gICAgICAgIGlmIHNpemUgKyBTdHJpbmcubGVuZ3RoIGJlZm9yZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aCBlbHNlXG4gICAgICAgICgqIGJyZWFrIHRoZSBsaW5lIGhlcmUgbGVhZHMgdG8gbmV3IGluZGVudGF0aW9uID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPiBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZlxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX2h2Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgfCBQcF9maXRzIC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX3Zib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICB8IFBwX2hib3ggLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICB8IFBwX29wZW5fdGFnIHRhZ19uYW1lIC0+XG4gICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyO1xuICAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX21hcmtfc3RhY2tcblxuICAgfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9tYXJrX3N0YWNrIHdpdGhcbiAgICAgfCBOb25lIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19jbG9zZV90YWcgdGFnX25hbWUgaW5cbiAgICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlclxuICAgICBlbmRcblxuXG4oKiBQcmludCBpZiB0b2tlbiBzaXplIGlzIGtub3duIGVsc2UgcHJpbnRpbmcgaXMgZGVsYXllZC5cbiAgIFByaW50aW5nIGlzIGRlbGF5ZWQgd2hlbiB0aGUgdGV4dCB3YWl0aW5nIGluIHRoZSBxdWV1ZSByZXF1aXJlc1xuICAgbW9yZSByb29tIHRvIGZvcm1hdCB0aGFuIGV4aXN0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IHJlYyBhZHZhbmNlX2xlZnQgc3RhdGUgPVxuICBtYXRjaCBRdWV1ZS5wZWVrX29wdCBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBObyB0b2tlbnMgdG8gcHJpbnQgKilcbiAgfCBTb21lIHsgc2l6ZTsgdG9rZW47IGxlbmd0aCB9IC0+XG4gICAgbGV0IHBlbmRpbmdfY291bnQgPSBzdGF0ZS5wcF9yaWdodF90b3RhbCAtIHN0YXRlLnBwX2xlZnRfdG90YWwgaW5cbiAgICBpZiBTaXplLmlzX2tub3duIHNpemUgfHwgcGVuZGluZ19jb3VudCA+PSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gYmVnaW5cbiAgICAgIFF1ZXVlLnRha2Ugc3RhdGUucHBfcXVldWUgfD4gaWdub3JlOyAoKiBOb3QgZW1wdHk6IHdlIHBlZWsgaW50byBpdCAqKVxuICAgICAgbGV0IHNpemUgPSBpZiBTaXplLmlzX2tub3duIHNpemUgdGhlbiBTaXplLnRvX2ludCBzaXplIGVsc2UgcHBfaW5maW5pdHkgaW5cbiAgICAgIGZvcm1hdF9wcF90b2tlbiBzdGF0ZSBzaXplIHRva2VuO1xuICAgICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBsZW5ndGggKyBzdGF0ZS5wcF9sZWZ0X3RvdGFsO1xuICAgICAgKGFkdmFuY2VfbGVmdCBbQHRhaWxjYWxsXSkgc3RhdGVcbiAgICBlbmRcblxuXG4oKiBUbyBlbnF1ZXVlIGEgdG9rZW4gOiB0cnkgdG8gYWR2YW5jZS4gKilcbmxldCBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgdG9rID0gcHBfZW5xdWV1ZSBzdGF0ZSB0b2s7IGFkdmFuY2VfbGVmdCBzdGF0ZVxuXG5cbigqIFRvIGVucXVldWUgc3RyaW5ncy4gKilcbmxldCBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHMgPVxuICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgeyBzaXplOyB0b2tlbiA9IFBwX3RleHQgczsgbGVuZ3RoID0gU2l6ZS50b19pbnQgc2l6ZSB9XG5cblxubGV0IGVucXVldWVfc3RyaW5nIHN0YXRlIHMgPVxuICBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSAoU2l6ZS5vZl9pbnQgKFN0cmluZy5sZW5ndGggcykpIHNcblxuXG4oKiBSb3V0aW5lcyBmb3Igc2NhbiBzdGFja1xuICAgZGV0ZXJtaW5lIHNpemUgb2YgYm94ZXMuICopXG5cbigqIFRoZSBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxubGV0IGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGFjayA9XG4gIFN0YWNrLmNsZWFyIHN0YWNrO1xuICBsZXQgcXVldWVfZWxlbSA9IHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF90ZXh0IFwiXCI7IGxlbmd0aCA9IDAgfSBpblxuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IC0xOyBxdWV1ZV9lbGVtIH0gc3RhY2tcblxuKCogU2V0dGluZyB0aGUgc2l6ZSBvZiBib3hlcyBvbiBzY2FuIHN0YWNrOlxuICAgaWYgdHkgPSB0cnVlIHRoZW4gc2l6ZSBvZiBicmVhayBpcyBzZXQgZWxzZSBzaXplIG9mIGJveCBpcyBzZXQ7XG4gICBpbiBlYWNoIGNhc2UgcHBfc2Nhbl9zdGFjayBpcyBwb3BwZWQuXG5cbiAgIE5vdGU6XG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHNjYW4gc3RhY2sgaXMgZXhoYXVzdGl2ZSwgc2luY2Ugc2Nhbl9zdGFjayBpcyBuZXZlclxuICAgZW1wdHkuXG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHRva2VuIGluIHNjYW4gc3RhY2sgaXMgYWxzbyBleGhhdXN0aXZlLFxuICAgc2luY2Ugc2Nhbl9wdXNoIGlzIHVzZWQgb24gYnJlYWtzIGFuZCBvcGVuaW5nIG9mIGJveGVzLiAqKVxubGV0IHNldF9zaXplIHN0YXRlIHR5ID1cbiAgbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG4gIHwgU29tZSB7IGxlZnRfdG90YWw7IHF1ZXVlX2VsZW0gfSAtPlxuICAgIGxldCBzaXplID0gU2l6ZS50b19pbnQgcXVldWVfZWxlbS5zaXplIGluXG4gICAgKCogdGVzdCBpZiBzY2FuIHN0YWNrIGNvbnRhaW5zIGFueSBkYXRhIHRoYXQgaXMgbm90IG9ic29sZXRlLiAqKVxuICAgIGlmIGxlZnRfdG90YWwgPCBzdGF0ZS5wcF9sZWZ0X3RvdGFsIHRoZW5cbiAgICAgIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggcXVldWVfZWxlbS50b2tlbiB3aXRoXG4gICAgICB8IFBwX2JyZWFrIF8gfCBQcF90YnJlYWsgKF8sIF8pIC0+XG4gICAgICAgIGlmIHR5IHRoZW4gYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLnNpemUgPC0gU2l6ZS5vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHw+IGlnbm9yZVxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfYmVnaW4gKF8sIF8pIC0+XG4gICAgICAgIGlmIG5vdCB0eSB0aGVuIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5zaXplIDwtIFNpemUub2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB8PiBpZ25vcmVcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX3RleHQgXyB8IFBwX3N0YWIgfCBQcF90YmVnaW4gXyB8IFBwX3RlbmQgfCBQcF9lbmRcbiAgICAgIHwgUHBfbmV3bGluZSB8IFBwX2lmX25ld2xpbmUgfCBQcF9vcGVuX3RhZyBfIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgICAgICgpICgqIHNjYW5fcHVzaCBpcyBvbmx5IHVzZWQgZm9yIGJyZWFrcyBhbmQgYm94ZXMuICopXG5cblxuKCogUHVzaCBhIHRva2VuIG9uIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLlxuICAgSWYgYiBpcyB0cnVlIHNldF9zaXplIGlzIGNhbGxlZC4gKilcbmxldCBzY2FuX3B1c2ggc3RhdGUgYiB0b2tlbiA9XG4gIHBwX2VucXVldWUgc3RhdGUgdG9rZW47XG4gIGlmIGIgdGhlbiBzZXRfc2l6ZSBzdGF0ZSB0cnVlO1xuICBsZXQgZWxlbSA9IHsgbGVmdF90b3RhbCA9IHN0YXRlLnBwX3JpZ2h0X3RvdGFsOyBxdWV1ZV9lbGVtID0gdG9rZW4gfSBpblxuICBTdGFjay5wdXNoIGVsZW0gc3RhdGUucHBfc2Nhbl9zdGFja1xuXG5cbigqIFRvIG9wZW4gYSBuZXcgYm94IDpcbiAgIHRoZSB1c2VyIG1heSBzZXQgdGhlIGRlcHRoIGJvdW5kIHBwX21heF9ib3hlc1xuICAgYW55IHRleHQgbmVzdGVkIGRlZXBlciBpcyBwcmludGVkIGFzIHRoZSBlbGxpcHNpcyBzdHJpbmcuICopXG5sZXQgcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBicl90eSA9XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCArIDE7XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfYmVnaW4gKGluZGVudCwgYnJfdHkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgZmFsc2UgZWxlbSBlbHNlXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRoZSBib3ggd2hpY2ggaXMgYWx3YXlzIG9wZW4uICopXG5sZXQgcHBfb3Blbl9zeXNfYm94IHN0YXRlID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIDAgUHBfaG92Ym94XG5cbigqIENsb3NlIGEgYm94LCBzZXR0aW5nIHNpemVzIG9mIGl0cyBzdWIgYm94ZXMuICopXG5sZXQgcHBfY2xvc2VfYm94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGJlZ2luXG4gICAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9lbmQ7IGxlbmd0aCA9IDAgfTtcbiAgICAgIHNldF9zaXplIHN0YXRlIHRydWU7IHNldF9zaXplIHN0YXRlIGZhbHNlXG4gICAgZW5kO1xuICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDE7XG4gIGVuZFxuXG5cbigqIE9wZW4gYSB0YWcsIHB1c2hpbmcgaXQgb24gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9vcGVuX3N0YWcgc3RhdGUgdGFnX25hbWUgPVxuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgYmVnaW5cbiAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyB0YWdfbmFtZVxuICBlbmQ7XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgbGV0IHRva2VuID0gUHBfb3Blbl90YWcgdGFnX25hbWUgaW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW47IGxlbmd0aCA9IDAgfVxuXG5cbigqIENsb3NlIGEgdGFnLCBwb3BwaW5nIGl0IGZyb20gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9jbG9zZV9zdGFnIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9jbG9zZV90YWc7IGxlbmd0aCA9IDAgfTtcbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gICAgbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF90YWdfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyB0YWdfbmFtZVxuXG5sZXQgcHBfb3Blbl90YWcgc3RhdGUgcyA9IHBwX29wZW5fc3RhZyBzdGF0ZSAoU3RyaW5nX3RhZyBzKVxubGV0IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSA9IHBwX2Nsb3NlX3N0YWcgc3RhdGUgKClcblxubGV0IHBwX3NldF9wcmludF90YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9wcmludF90YWdzIDwtIGJcbmxldCBwcF9zZXRfbWFya190YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9tYXJrX3RhZ3MgPC0gYlxubGV0IHBwX2dldF9wcmludF90YWdzIHN0YXRlICgpID0gc3RhdGUucHBfcHJpbnRfdGFnc1xubGV0IHBwX2dldF9tYXJrX3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJrX3RhZ3NcbmxldCBwcF9zZXRfdGFncyBzdGF0ZSBiID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYjsgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiXG5cblxuKCogSGFuZGxpbmcgdGFnIGhhbmRsaW5nIGZ1bmN0aW9uczogZ2V0L3NldCBmdW5jdGlvbnMuICopXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgbWFya19vcGVuX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnO1xuICBtYXJrX2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZztcbiAgcHJpbnRfb3Blbl9zdGFnID0gc3RhdGUucHBfcHJpbnRfb3Blbl90YWc7XG4gIHByaW50X2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWc7XG59XG5cblxubGV0IHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fc3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV9zdGFnID0gbWN0O1xuICAgICBwcmludF9vcGVuX3N0YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3N0YWcgPSBwY3Q7XG4gIH0gPVxuICBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIDwtIG1vdDtcbiAgc3RhdGUucHBfbWFya19jbG9zZV90YWcgPC0gbWN0O1xuICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyA8LSBwb3Q7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBwY3RcblxuXG4oKiBJbml0aWFsaXplIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX3Jpbml0IHN0YXRlID1cbiAgcHBfY2xlYXJfcXVldWUgc3RhdGU7XG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF9mb3JtYXRfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3Rib3hfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfbWFya19zdGFjaztcbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gMDtcbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSAwO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbjtcbiAgcHBfb3Blbl9zeXNfYm94IHN0YXRlXG5cbmxldCBjbGVhcl90YWdfc3RhY2sgc3RhdGUgPVxuICBTdGFjay5pdGVyIChmdW4gXyAtPiBwcF9jbG9zZV90YWcgc3RhdGUgKCkpIHN0YXRlLnBwX3RhZ19zdGFja1xuXG5cbigqIEZsdXNoaW5nIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIGIgPVxuICBjbGVhcl90YWdfc3RhY2sgc3RhdGU7XG4gIHdoaWxlIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIGRvXG4gICAgcHBfY2xvc2VfYm94IHN0YXRlICgpXG4gIGRvbmU7XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHBwX2luZmluaXR5O1xuICBhZHZhbmNlX2xlZnQgc3RhdGU7XG4gIGlmIGIgdGhlbiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgcHBfcmluaXQgc3RhdGVcblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGZvcm1hdCB2YWx1ZXMgYW5kIHVzZSBib3hlcy5cblxuKilcblxuKCogVG8gZm9ybWF0IGEgc3RyaW5nLiAqKVxubGV0IHBwX3ByaW50X2FzX3NpemUgc3RhdGUgc2l6ZSBzID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgc1xuXG5cbmxldCBwcF9wcmludF9hcyBzdGF0ZSBpc2l6ZSBzID1cbiAgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSAoU2l6ZS5vZl9pbnQgaXNpemUpIHNcblxuXG5sZXQgcHBfcHJpbnRfc3RyaW5nIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cbmxldCBwcF9wcmludF9ieXRlcyBzdGF0ZSBzID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgKEJ5dGVzLmxlbmd0aCBzKSAoQnl0ZXMudG9fc3RyaW5nIHMpXG5cbigqIFRvIGZvcm1hdCBhbiBpbnRlZ2VyLiAqKVxubGV0IHBwX3ByaW50X2ludCBzdGF0ZSBpID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChJbnQudG9fc3RyaW5nIGkpXG5cbigqIFRvIGZvcm1hdCBhIGZsb2F0LiAqKVxubGV0IHBwX3ByaW50X2Zsb2F0IHN0YXRlIGYgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9mbG9hdCBmKVxuXG4oKiBUbyBmb3JtYXQgYSBib29sZWFuLiAqKVxubGV0IHBwX3ByaW50X2Jvb2wgc3RhdGUgYiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Jvb2wgYilcblxuKCogVG8gZm9ybWF0IGEgY2hhci4gKilcbmxldCBwcF9wcmludF9jaGFyIHN0YXRlIGMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAxIChTdHJpbmcubWFrZSAxIGMpXG5cblxuKCogT3BlbmluZyBib3hlcy4gKilcbmxldCBwcF9vcGVuX2hib3ggc3RhdGUgKCkgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9oYm94XG5hbmQgcHBfb3Blbl92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfdmJveFxuXG5hbmQgcHBfb3Blbl9odmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2h2Ym94XG5hbmQgcHBfb3Blbl9ob3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ob3Zib3hcbmFuZCBwcF9vcGVuX2JveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2JveFxuXG5cbigqIFByaW50aW5nIHF1ZXVlZCB0ZXh0LlxuXG4gICBbcHBfcHJpbnRfZmx1c2hdIHByaW50cyBhbGwgcGVuZGluZyBpdGVtcyBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYW5kXG4gICB0aGVuIGZsdXNoZXMgdGhlIGxvdyBsZXZlbCBvdXRwdXQgZGV2aWNlIG9mIHRoZSBmb3JtYXR0ZXIgdG8gYWN0dWFsbHlcbiAgIGRpc3BsYXkgcHJpbnRpbmcgbWF0ZXJpYWwuXG5cbiAgIFtwcF9wcmludF9uZXdsaW5lXSBiZWhhdmVzIGFzIFtwcF9wcmludF9mbHVzaF0gYWZ0ZXIgcHJpbnRpbmcgYW4gYWRkaXRpb25hbFxuICAgbmV3IGxpbmUuICopXG5sZXQgcHBfcHJpbnRfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIHRydWU7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuYW5kIHBwX3ByaW50X2ZsdXNoIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgZmFsc2U7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuXG5cbigqIFRvIGdldCBhIG5ld2xpbmUgd2hlbiBvbmUgZG9lcyBub3Qgd2FudCB0byBjbG9zZSB0aGUgY3VycmVudCBib3guICopXG5sZXQgcHBfZm9yY2VfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfbmV3bGluZTsgbGVuZ3RoID0gMCB9XG5cblxuKCogVG8gZm9ybWF0IHNvbWV0aGluZywgb25seSBpbiBjYXNlIHRoZSBsaW5lIGhhcyBqdXN0IGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3ByaW50X2lmX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGVcbiAgICAgIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9pZl9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBHZW5lcmFsaXplZCBicmVhayBoaW50IHRoYXQgYWxsb3dzIHByaW50aW5nIHN0cmluZ3MgYmVmb3JlL2FmdGVyXG4gICBzYW1lLWxpbmUgb2Zmc2V0ICh3aWR0aCkgb3IgbmV3LWxpbmUgb2Zmc2V0ICopXG5sZXQgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlIH5maXRzIH5icmVha3MgPVxuICBsZXQgYmVmb3JlLCB3aWR0aCwgYWZ0ZXIgPSBmaXRzIGluXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IHRva2VuID0gUHBfYnJlYWsgeyBmaXRzOyBicmVha3MgfSBpblxuICAgIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoIGJlZm9yZSArIHdpZHRoICsgU3RyaW5nLmxlbmd0aCBhZnRlciBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbjsgbGVuZ3RoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cbigqIFByaW50aW5nIGJyZWFrIGhpbnRzOlxuICAgQSBicmVhayBoaW50IGluZGljYXRlcyB3aGVyZSBhIGJveCBtYXkgYmUgYnJva2VuLlxuICAgSWYgbGluZSBpcyBicm9rZW4gdGhlbiBvZmZzZXQgaXMgYWRkZWQgdG8gdGhlIGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50XG4gICBib3ggZWxzZSAodGhlIHZhbHVlIG9mKSB3aWR0aCBibGFua3MgYXJlIHByaW50ZWQuICopXG5sZXQgcHBfcHJpbnRfYnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlXG4gICAgfmZpdHM6KFwiXCIsIHdpZHRoLCBcIlwiKSB+YnJlYWtzOihcIlwiLCBvZmZzZXQsIFwiXCIpXG5cblxuKCogUHJpbnQgYSBzcGFjZSA6XG4gICBhIHNwYWNlIGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBhIHNpbmdsZSBzcGFjZSBpZiB0aGUgYnJlYWsgZG9lcyBub3RcbiAgIHNwbGl0IHRoZSBsaW5lO1xuICAgYSBjdXQgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIG5vdGhpbmcgaWYgdGhlIGJyZWFrIGRvZXMgbm90IHNwbGl0IHRoZVxuICAgbGluZS4gKilcbmxldCBwcF9wcmludF9zcGFjZSBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDEgMFxuYW5kIHBwX3ByaW50X2N1dCBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDAgMFxuXG5cbigqIFRhYnVsYXRpb24gYm94ZXMuICopXG5sZXQgcHBfb3Blbl90Ym94IHN0YXRlICgpID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLnplcm8gaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF90YmVnaW4gKFBwX3Rib3ggKHJlZiBbXSkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqIENsb3NlIGEgdGFidWxhdGlvbiBib3guICopXG5sZXQgcHBfY2xvc2VfdGJveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF90ZW5kOyBsZW5ndGggPSAwIH0gaW5cbiAgICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW07XG4gICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDFcbiAgZW5kXG5cblxuKCogUHJpbnQgYSB0YWJ1bGF0aW9uIGJyZWFrLiAqKVxubGV0IHBwX3ByaW50X3RicmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RicmVhayAod2lkdGgsIG9mZnNldCk7IGxlbmd0aCA9IHdpZHRoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cblxubGV0IHBwX3ByaW50X3RhYiBzdGF0ZSAoKSA9IHBwX3ByaW50X3RicmVhayBzdGF0ZSAwIDBcblxubGV0IHBwX3NldF90YWIgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9zdGFiOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBjb250cm9sIHRoZSBwcmV0dHktcHJpbnRlcnNcblxuKilcblxuKCogU2V0X21heF9ib3hlcy4gKilcbmxldCBwcF9zZXRfbWF4X2JveGVzIHN0YXRlIG4gPSBpZiBuID4gMSB0aGVuIHN0YXRlLnBwX21heF9ib3hlcyA8LSBuXG5cbigqIFRvIGtub3cgdGhlIGN1cnJlbnQgbWF4aW11bSBudW1iZXIgb2YgYm94ZXMgYWxsb3dlZC4gKilcbmxldCBwcF9nZXRfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbmxldCBwcF9vdmVyX21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxuKCogRWxsaXBzaXMuICopXG5sZXQgcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgcyA9IHN0YXRlLnBwX2VsbGlwc2lzIDwtIHNcbmFuZCBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSAoKSA9IHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVG8gc2V0IHRoZSBtYXJnaW4gb2YgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfbGltaXQgbiA9XG4gIGlmIG4gPCBwcF9pbmZpbml0eSB0aGVuIG4gZWxzZSBwcmVkIHBwX2luZmluaXR5XG5cblxuKCogSW50ZXJuYWwgcHJldHR5LXByaW50ZXIgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdCA8LSBuO1xuICAgIHN0YXRlLnBwX21heF9pbmRlbnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfcmluaXQgc3RhdGVcblxuXG4oKiBJbml0aWFsbHksIHdlIGhhdmUgOlxuICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0LCBhbmRcbiAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW4uICopXG5sZXQgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbiA9XG4gIGlmIG4gPiAxIHRoZW5cbiAgICBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgKHN0YXRlLnBwX21hcmdpbiAtIG4pXG5cblxubGV0IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2luZGVudFxuXG5sZXQgcHBfc2V0X21hcmdpbiBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9tYXJnaW4gPC0gbjtcbiAgICBsZXQgbmV3X21heF9pbmRlbnQgPVxuICAgICAgKCogVHJ5IHRvIG1haW50YWluIG1heF9pbmRlbnQgdG8gaXRzIGFjdHVhbCB2YWx1ZS4gKilcbiAgICAgIGlmIHN0YXRlLnBwX21heF9pbmRlbnQgPD0gc3RhdGUucHBfbWFyZ2luXG4gICAgICB0aGVuIHN0YXRlLnBwX21heF9pbmRlbnQgZWxzZVxuICAgICAgKCogSWYgcG9zc2libGUgbWFpbnRhaW4gcHBfbWluX3NwYWNlX2xlZnQgdG8gaXRzIGFjdHVhbCB2YWx1ZSxcbiAgICAgICAgIGlmIHRoaXMgbGVhZHMgdG8gYSB0b28gc21hbGwgbWF4X2luZGVudCwgdGFrZSBoYWxmIG9mIHRoZVxuICAgICAgICAgbmV3IG1hcmdpbiwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDEuICopXG4gICAgICAgSW50Lm1heCAoSW50Lm1heCAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQpXG4gICAgICAgICAgICAgICAgKHN0YXRlLnBwX21hcmdpbiAvIDIpKSAxIGluXG4gICAgKCogUmVidWlsZCBpbnZhcmlhbnRzLiAqKVxuICAgIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG5ld19tYXhfaW5kZW50XG5cblxuKCoqIEdlb21ldHJ5IGZ1bmN0aW9ucyBhbmQgdHlwZXMgKilcbnR5cGUgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ6aW50OyBtYXJnaW46IGludH1cblxubGV0IHZhbGlkYXRlX2dlb21ldHJ5IHttYXJnaW47IG1heF9pbmRlbnR9ID1cbiAgaWYgbWF4X2luZGVudCA8IDIgdGhlblxuICAgIEVycm9yIFwibWF4X2luZGVudCA8IDJcIlxuICBlbHNlIGlmIG1hcmdpbiA8PSBtYXhfaW5kZW50IHRoZW5cbiAgICBFcnJvciBcIm1hcmdpbiA8PSBtYXhfaW5kZW50XCJcbiAgZWxzZSBPayAoKVxuXG5sZXQgY2hlY2tfZ2VvbWV0cnkgZ2VvbWV0cnkgPVxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgT2sgKCkgLT4gdHJ1ZVxuICB8IEVycm9yIF8gLT4gZmFsc2VcblxubGV0IHBwX2dldF9tYXJnaW4gc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJnaW5cblxubGV0IHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIHttYXJnaW47IG1heF9pbmRlbnR9ID1cbiAgcHBfc2V0X21hcmdpbiBzdGF0ZSBtYXJnaW47XG4gIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG1heF9pbmRlbnQ7XG4gICgpXG5cbmxldCBwcF9zZXRfZ2VvbWV0cnkgc3RhdGUgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIGxldCBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDsgbWFyZ2luIH0gaW5cbiAgbWF0Y2ggdmFsaWRhdGVfZ2VvbWV0cnkgZ2VvbWV0cnkgd2l0aFxuICB8IEVycm9yIG1zZyAtPlxuICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IChcIkZvcm1hdC5wcF9zZXRfZ2VvbWV0cnk6IFwiIF4gbXNnKSlcbiAgfCBPayAoKSAtPlxuICAgIHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIGdlb21ldHJ5XG5cbmxldCBwcF9zYWZlX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgbGV0IGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OyBtYXJnaW4gfSBpblxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgRXJyb3IgX21zZyAtPlxuICAgICAoKVxuICB8IE9rICgpIC0+XG4gICAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgZ2VvbWV0cnlcblxubGV0IHBwX2dldF9nZW9tZXRyeSBzdGF0ZSAoKSA9XG4gIHsgbWFyZ2luID0gcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKTsgbWF4X2luZGVudCA9IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpIH1cblxubGV0IHBwX3VwZGF0ZV9nZW9tZXRyeSBzdGF0ZSB1cGRhdGUgPVxuICBsZXQgZ2VvbWV0cnkgPSBwcF9nZXRfZ2VvbWV0cnkgc3RhdGUgKCkgaW5cbiAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgKHVwZGF0ZSBnZW9tZXRyeSlcblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgICBvdXRfc3RyaW5nID0gZjtcbiAgICAgIG91dF9mbHVzaCA9IGc7XG4gICAgICBvdXRfbmV3bGluZSA9IGg7XG4gICAgICBvdXRfc3BhY2VzID0gaTtcbiAgICAgIG91dF9pbmRlbnQgPSBqO1xuICAgIH0gPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGk7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0galxuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBvdXRfc3RyaW5nID0gc3RhdGUucHBfb3V0X3N0cmluZztcbiAgb3V0X2ZsdXNoID0gc3RhdGUucHBfb3V0X2ZsdXNoO1xuICBvdXRfbmV3bGluZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lO1xuICBvdXRfc3BhY2VzID0gc3RhdGUucHBfb3V0X3NwYWNlcztcbiAgb3V0X2luZGVudCA9IHN0YXRlLnBwX291dF9pbmRlbnQ7XG59XG5cblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBzdHJpbmcgb3V0cHV0IGFuZCBmbHVzaCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjsgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGdcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9XG4gIChzdGF0ZS5wcF9vdXRfc3RyaW5nLCBzdGF0ZS5wcF9vdXRfZmx1c2gpXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X25ld2xpbmUgc3RhdGUgKCkgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIFwiXFxuXCIgMCAgMVxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgc3BhY2VzLiAqKVxubGV0IGJsYW5rX2xpbmUgPSBTdHJpbmcubWFrZSA4MCAnICdcbmxldCByZWMgZGlzcGxheV9ibGFua3Mgc3RhdGUgbiA9XG4gIGlmIG4gPiAwIHRoZW5cbiAgaWYgbiA8PSA4MCB0aGVuIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIG4gZWxzZVxuICBiZWdpblxuICAgIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIDgwO1xuICAgIGRpc3BsYXlfYmxhbmtzIHN0YXRlIChuIC0gODApXG4gIGVuZFxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9pbmRlbnQgPSBkaXNwbGF5X2JsYW5rc1xuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMgYXMgcHJpbnRpbmcgdG8gYSBnaXZlblxuICAgW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGF0ZSBvYyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gb3V0cHV0X3N1YnN0cmluZyBvYztcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIChmdW4gKCkgLT4gZmx1c2ggb2MpO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3Mgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0gZGlzcGxheV9pbmRlbnQgc3RhdGVcblxuKCpcblxuICBEZWZpbmluZyBzcGVjaWZpYyBmb3JtYXR0ZXJzXG5cbiopXG5cbmxldCBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjxcIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxubGV0IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjwvXCIgXiBzIF4gXCI+XCJcbiAgfCBfIC0+IFwiXCJcblxubGV0IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWcgPSBpZ25vcmVcbmxldCBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyA9IGlnbm9yZVxuXG4oKiBCdWlsZGluZyBhIGZvcm1hdHRlciBnaXZlbiBpdHMgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy5cbiAgIE90aGVyIGZpZWxkcyBnZXQgcmVhc29uYWJsZSBkZWZhdWx0IHZhbHVlcy4gKilcbmxldCBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGogPVxuICAoKiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgZm9ybWF0dGVyIGNvbnRhaW5zIGEgZHVtbXkgYm94LiAqKVxuICBsZXQgcHBfcXVldWUgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgbGV0IHN5c190b2sgPVxuICAgIHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF9iZWdpbiAoMCwgUHBfaG92Ym94KTsgbGVuZ3RoID0gMCB9IGluXG4gIFF1ZXVlLmFkZCBzeXNfdG9rIHBwX3F1ZXVlO1xuICBsZXQgc2Nhbl9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKSBpblxuICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc2Nhbl9zdGFjaztcbiAgU3RhY2sucHVzaCB7IGxlZnRfdG90YWwgPSAxOyBxdWV1ZV9lbGVtID0gc3lzX3RvayB9IHNjYW5fc3RhY2s7XG4gIGxldCBwcF9tYXJnaW4gPSA3OFxuICBhbmQgcHBfbWluX3NwYWNlX2xlZnQgPSAxMCBpblxuICB7XG4gICAgcHBfc2Nhbl9zdGFjayA9IHNjYW5fc3RhY2s7XG4gICAgcHBfZm9ybWF0X3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX3Rib3hfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGFnX3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX21hcmtfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFyZ2luID0gcHBfbWFyZ2luO1xuICAgIHBwX21pbl9zcGFjZV9sZWZ0ID0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW47XG4gICAgcHBfY3VycmVudF9pbmRlbnQgPSAwO1xuICAgIHBwX2lzX25ld19saW5lID0gdHJ1ZTtcbiAgICBwcF9sZWZ0X3RvdGFsID0gMTtcbiAgICBwcF9yaWdodF90b3RhbCA9IDE7XG4gICAgcHBfY3Vycl9kZXB0aCA9IDE7XG4gICAgcHBfbWF4X2JveGVzID0gbWF4X2ludDtcbiAgICBwcF9lbGxpcHNpcyA9IFwiLlwiO1xuICAgIHBwX291dF9zdHJpbmcgPSBmO1xuICAgIHBwX291dF9mbHVzaCA9IGc7XG4gICAgcHBfb3V0X25ld2xpbmUgPSBoO1xuICAgIHBwX291dF9zcGFjZXMgPSBpO1xuICAgIHBwX291dF9pbmRlbnQgPSBqO1xuICAgIHBwX3ByaW50X3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX29wZW5fdGFnID0gZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnO1xuICAgIHBwX21hcmtfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZztcbiAgICBwcF9wcmludF9vcGVuX3RhZyA9IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWc7XG4gICAgcHBfcHJpbnRfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWc7XG4gICAgcHBfcXVldWUgPSBwcF9xdWV1ZTtcbiAgfVxuXG5cbigqIEJ1aWxkIGEgZm9ybWF0dGVyIG91dCBvZiBpdHMgb3V0IGZ1bmN0aW9ucy4gKilcbmxldCBmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyBvdXRfZnVucyA9XG4gIHBwX21ha2VfZm9ybWF0dGVyXG4gICAgb3V0X2Z1bnMub3V0X3N0cmluZ1xuICAgIG91dF9mdW5zLm91dF9mbHVzaFxuICAgIG91dF9mdW5zLm91dF9uZXdsaW5lXG4gICAgb3V0X2Z1bnMub3V0X3NwYWNlc1xuICAgIG91dF9mdW5zLm91dF9pbmRlbnRcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdpdGggZGVmYXVsdCBmdW5jdGlvbnMgdG8gb3V0cHV0IHNwYWNlcyxcbiAgaW5kZW50YXRpb24sIGFuZCBuZXcgbGluZXMuICopXG5sZXQgbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoID1cbiAgbGV0IHBwZiA9IHBwX21ha2VfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCBpZ25vcmUgaWdub3JlIGlnbm9yZSBpblxuICBwcGYucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHBwZjtcbiAgcHBmLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3MgcHBmO1xuICBwcGYucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBwcGY7XG4gIHBwZlxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtQZXJ2YXNpdmUub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBvYyA9XG4gIG1ha2VfZm9ybWF0dGVyIChvdXRwdXRfc3Vic3RyaW5nIG9jKSAoZnVuICgpIC0+IGZsdXNoIG9jKVxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtCdWZmZXIudF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX2J1ZmZlciBiID1cbiAgbWFrZV9mb3JtYXR0ZXIgKEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGIpIGlnbm9yZVxuXG5cbigqIEFsbG9jYXRpbmcgYnVmZmVyIGZvciBwcmV0dHktcHJpbnRpbmcgcHVycG9zZXMuXG4gICBEZWZhdWx0IGJ1ZmZlciBzaXplIGlzIHBwX2J1ZmZlcl9zaXplIG9yIDUxMi5cbiopXG5sZXQgcHBfYnVmZmVyX3NpemUgPSA1MTJcbmxldCBwcF9tYWtlX2J1ZmZlciAoKSA9IEJ1ZmZlci5jcmVhdGUgcHBfYnVmZmVyX3NpemVcblxuKCogVGhlIHN0YW5kYXJkIChzaGFyZWQpIGJ1ZmZlci4gKilcbmxldCBzdGRidWYgPSBwcF9tYWtlX2J1ZmZlciAoKVxuXG4oKiBQcmVkZWZpbmVkIGZvcm1hdHRlcnMgc3RhbmRhcmQgZm9ybWF0dGVyIHRvIHByaW50XG4gICB0byBbU3RkbGliLnN0ZG91dF0sIFtTdGRsaWIuc3RkZXJyXSwgYW5kIHshc3RkYnVmfS4gKilcbmxldCBzdGRfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRvdXRcbmFuZCBlcnJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRlcnJcbmFuZCBzdHJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX2J1ZmZlciBzdGRidWZcblxuXG4oKiBbZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmXSBmbHVzaGVzIGZvcm1hdHRlciBbcHBmXSxcbiAgIHRoZW4gcmV0dXJucyB0aGUgY29udGVudHMgb2YgYnVmZmVyIFtidWZdIHRoYXQgaXMgcmVzZXQuXG4gICBGb3JtYXR0ZXIgW3BwZl0gaXMgc3VwcG9zZWQgdG8gcHJpbnQgdG8gYnVmZmVyIFtidWZdLCBvdGhlcndpc2UgdGhpc1xuICAgZnVuY3Rpb24gaXMgbm90IHJlYWxseSB1c2VmdWwuICopXG5sZXQgZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmID1cbiAgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlO1xuICBsZXQgcyA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgQnVmZmVyLnJlc2V0IGJ1ZjtcbiAgc1xuXG5cbigqIEZsdXNoIFtzdHJfZm9ybWF0dGVyXSBhbmQgZ2V0IHRoZSBjb250ZW50cyBvZiBbc3RkYnVmXS4gKilcbmxldCBmbHVzaF9zdHJfZm9ybWF0dGVyICgpID0gZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBzdGRidWYgc3RyX2Zvcm1hdHRlclxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmdcbiopXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZyBpcyBwcmV0dHktcHJpbnRpbmcgd2l0aCBubyBsb3cgbGV2ZWwgb3V0cHV0LlxuXG4gIFdoZW4gdXNpbmcgYSBzeW1ib2xpYyBmb3JtYXR0ZXIsIGFsbCByZWd1bGFyIHByZXR0eS1wcmludGluZyBhY3Rpdml0aWVzXG4gIG9jY3VyIGJ1dCBvdXRwdXQgbWF0ZXJpYWwgaXMgc3ltYm9saWMgYW5kIHN0b3JlZCBpbiBhIGJ1ZmZlciBvZiBvdXRwdXRcbiAgaXRlbXMuIEF0IHRoZSBlbmQgb2YgcHJldHR5LXByaW50aW5nLCBmbHVzaGluZyB0aGUgb3V0cHV0IGJ1ZmZlciBhbGxvd3NcbiAgcG9zdC1wcm9jZXNzaW5nIG9mIHN5bWJvbGljIG91dHB1dCBiZWZvcmUgbG93IGxldmVsIG91dHB1dCBvcGVyYXRpb25zLlxuKilcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfaXRlbSA9XG4gIHwgT3V0cHV0X2ZsdXNoXG4gIHwgT3V0cHV0X25ld2xpbmVcbiAgfCBPdXRwdXRfc3RyaW5nIG9mIHN0cmluZ1xuICB8IE91dHB1dF9zcGFjZXMgb2YgaW50XG4gIHwgT3V0cHV0X2luZGVudCBvZiBpbnRcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfYnVmZmVyID0ge1xuICBtdXRhYmxlIHN5bWJvbGljX291dHB1dF9jb250ZW50cyA6IHN5bWJvbGljX291dHB1dF9pdGVtIGxpc3Q7XG59XG5cbmxldCBtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIgKCkgPVxuICB7IHN5bWJvbGljX291dHB1dF9jb250ZW50cyA9IFtdIH1cblxubGV0IGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBbXVxuXG5sZXQgZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgTGlzdC5yZXYgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgaXRlbXMgPSBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgaW5cbiAgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2I7XG4gIGl0ZW1zXG5cbmxldCBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIGl0ZW0gPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIGl0ZW0gOjogc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IHN5bWJvbGljX2ZsdXNoIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfZmx1c2hcbiAgYW5kIHN5bWJvbGljX25ld2xpbmUgc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9uZXdsaW5lXG4gIGFuZCBzeW1ib2xpY19zdHJpbmcgc29iIHMgaSBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3RyaW5nIChTdHJpbmcuc3ViIHMgaSBuKSlcbiAgYW5kIHN5bWJvbGljX3NwYWNlcyBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3NwYWNlcyBuKVxuICBhbmQgc3ltYm9saWNfaW5kZW50IHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfaW5kZW50IG4pIGluXG5cbiAgbGV0IGYgPSBzeW1ib2xpY19zdHJpbmcgc29iXG4gIGFuZCBnID0gc3ltYm9saWNfZmx1c2ggc29iXG4gIGFuZCBoID0gc3ltYm9saWNfbmV3bGluZSBzb2JcbiAgYW5kIGkgPSBzeW1ib2xpY19zcGFjZXMgc29iXG4gIGFuZCBqID0gc3ltYm9saWNfaW5kZW50IHNvYiBpblxuICBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGpcblxuKCpcblxuICBCYXNpYyBmdW5jdGlvbnMgb24gdGhlICdzdGFuZGFyZCcgZm9ybWF0dGVyXG4gICh0aGUgZm9ybWF0dGVyIHRoYXQgcHJpbnRzIHRvIFtTdGRsaWIuc3Rkb3V0XSkuXG5cbiopXG5cbmxldCBvcGVuX2hib3ggPSBwcF9vcGVuX2hib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fdmJveCA9IHBwX29wZW5fdmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9odmJveCA9IHBwX29wZW5faHZib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5faG92Ym94ID0gcHBfb3Blbl9ob3Zib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fYm94ID0gcHBfb3Blbl9ib3ggc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX2JveCA9IHBwX2Nsb3NlX2JveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl90YWcgPSBwcF9vcGVuX3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfdGFnID0gcHBfY2xvc2VfdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3N0YWcgPSBwcF9vcGVuX3N0YWcgc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3N0YWcgPSBwcF9jbG9zZV9zdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9hcyA9IHBwX3ByaW50X2FzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9zdHJpbmcgPSBwcF9wcmludF9zdHJpbmcgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2J5dGVzID0gcHBfcHJpbnRfYnl0ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2ludCA9IHBwX3ByaW50X2ludCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfZmxvYXQgPSBwcF9wcmludF9mbG9hdCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfY2hhciA9IHBwX3ByaW50X2NoYXIgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2Jvb2wgPSBwcF9wcmludF9ib29sIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9icmVhayA9IHBwX3ByaW50X2JyZWFrIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9jdXQgPSBwcF9wcmludF9jdXQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3NwYWNlID0gcHBfcHJpbnRfc3BhY2Ugc3RkX2Zvcm1hdHRlclxuYW5kIGZvcmNlX25ld2xpbmUgPSBwcF9mb3JjZV9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9mbHVzaCA9IHBwX3ByaW50X2ZsdXNoIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9uZXdsaW5lID0gcHBfcHJpbnRfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfaWZfbmV3bGluZSA9IHBwX3ByaW50X2lmX25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuXG5hbmQgb3Blbl90Ym94ID0gcHBfb3Blbl90Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV90Ym94ID0gcHBfY2xvc2VfdGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfdGJyZWFrID0gcHBfcHJpbnRfdGJyZWFrIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF90YWIgPSBwcF9zZXRfdGFiIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF90YWIgPSBwcF9wcmludF90YWIgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21hcmdpbiA9IHBwX3NldF9tYXJnaW4gc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXhfaW5kZW50ID0gcHBfc2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2dlb21ldHJ5ID0gcHBfc2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCBzYWZlX3NldF9nZW9tZXRyeSA9IHBwX3NhZmVfc2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZ2VvbWV0cnkgPSBwcF9nZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIHVwZGF0ZV9nZW9tZXRyeSA9IHBwX3VwZGF0ZV9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2JveGVzID0gcHBfc2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9ib3hlcyA9IHBwX2dldF9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIG92ZXJfbWF4X2JveGVzID0gcHBfb3Zlcl9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2VsbGlwc2lzX3RleHQgPSBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2VsbGlwc2lzX3RleHQgPSBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9wcmludF90YWdzID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9wcmludF90YWdzID1cbiAgcHBfZ2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9tYXJrX3RhZ3MgPVxuICBwcF9zZXRfbWFya190YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFya190YWdzID1cbiAgcHBfZ2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X3RhZ3MgPVxuICBwcF9zZXRfdGFncyBzdGRfZm9ybWF0dGVyXG5cblxuKCogQ29udmVuaWVuY2UgZnVuY3Rpb25zICopXG5cbigqIFRvIGZvcm1hdCBhIGxpc3QgKilcbmxldCByZWMgcHBfcHJpbnRfbGlzdCA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgPSBmdW5jdGlvblxuICB8IFtdIC0+ICgpXG4gIHwgW3ZdIC0+IHBwX3YgcHBmIHZcbiAgfCB2IDo6IHZzIC0+XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9zZXAgcHBmICgpO1xuICAgIHBwX3ByaW50X2xpc3QgfnBwX3NlcCBwcF92IHBwZiB2c1xuXG4oKiBUbyBmb3JtYXQgYSBzZXF1ZW5jZSAqKVxubGV0IHJlYyBwcF9wcmludF9zZXFfaW4gfnBwX3NlcCBwcF92IHBwZiBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IFNlcS5OaWwgLT4gKClcbiAgfCBTZXEuQ29ucyAodiwgc2VxKSAtPlxuICAgIHBwX3NlcCBwcGYgKCk7XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9wcmludF9zZXFfaW4gfnBwX3NlcCBwcF92IHBwZiBzZXFcblxubGV0IHBwX3ByaW50X3NlcSA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBTZXEuTmlsIC0+ICgpXG4gIHwgU2VxLkNvbnMgKHYsIHNlcSkgLT5cbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3ByaW50X3NlcV9pbiB+cHBfc2VwIHBwX3YgcHBmIHNlcVxuXG4oKiBUbyBmb3JtYXQgZnJlZS1mbG93aW5nIHRleHQgKilcbmxldCBwcF9wcmludF90ZXh0IHBwZiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbGVmdCA9IHJlZiAwIGluXG4gIGxldCByaWdodCA9IHJlZiAwIGluXG4gIGxldCBmbHVzaCAoKSA9XG4gICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoU3RyaW5nLnN1YiBzICFsZWZ0ICghcmlnaHQgLSAhbGVmdCkpO1xuICAgIGluY3IgcmlnaHQ7IGxlZnQgOj0gIXJpZ2h0O1xuICBpblxuICB3aGlsZSAoIXJpZ2h0IDw+IGxlbikgZG9cbiAgICBtYXRjaCBzLlshcmlnaHRdIHdpdGhcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgZmx1c2ggKCk7XG4gICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBmbHVzaCAoKTsgcHBfcHJpbnRfc3BhY2UgcHBmICgpXG4gICAgICAoKiB0aGVyZSBpcyBubyBzcGVjaWZpYyBzdXBwb3J0IGZvciAnXFx0J1xuICAgICAgICAgYXMgaXQgaXMgdW5jbGVhciB3aGF0IGEgcmlnaHQgc2VtYW50aWNzIHdvdWxkIGJlICopXG4gICAgICB8IF8gLT4gaW5jciByaWdodFxuICBkb25lO1xuICBpZiAhbGVmdCA8PiBsZW4gdGhlbiBmbHVzaCAoKVxuXG5sZXQgcHBfcHJpbnRfb3B0aW9uID8obm9uZSA9IGZ1biBfICgpIC0+ICgpKSBwcF92IHBwZiA9IGZ1bmN0aW9uXG58IE5vbmUgLT4gbm9uZSBwcGYgKClcbnwgU29tZSB2IC0+IHBwX3YgcHBmIHZcblxubGV0IHBwX3ByaW50X3Jlc3VsdCB+b2sgfmVycm9yIHBwZiA9IGZ1bmN0aW9uXG58IE9rIHYgLT4gb2sgcHBmIHZcbnwgRXJyb3IgZSAtPiBlcnJvciBwcGYgZVxuXG5sZXQgcHBfcHJpbnRfZWl0aGVyIH5sZWZ0IH5yaWdodCBwcGYgPSBmdW5jdGlvblxufCBFaXRoZXIuTGVmdCBsIC0+IGxlZnQgcHBmIGxcbnwgRWl0aGVyLlJpZ2h0IHIgLT4gcmlnaHQgcHBmIHJcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGNvbXB1dGVfdGFnIG91dHB1dCB0YWdfYWNjID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gIG91dHB1dCBwcGYgdGFnX2FjYztcbiAgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgZWxzZSBCdWZmZXIuc3ViIGJ1ZiAxIChsZW4gLSAyKVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgRGVmaW5pbmcgY29udGludWF0aW9ucyB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIG9mXG4gIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIEludGVycHJldCBhIGZvcm1hdHRpbmcgZW50aXR5IG9uIGEgZm9ybWF0dGVyLiAqKVxubGV0IG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZm10aW5nX2xpdCA9IG1hdGNoIGZtdGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfYm94IHBwZiAoKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfdGFnIHBwZiAoKVxuICB8IEJyZWFrIChfLCB3aWR0aCwgb2Zmc2V0KSAgLT4gcHBfcHJpbnRfYnJlYWsgcHBmIHdpZHRoIG9mZnNldFxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfZmx1c2ggcHBmICgpXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfcHJpbnRfbmV3bGluZSBwcGYgKClcbiAgfCBNYWdpY19zaXplIChfLCBfKSAgICAgICAgIC0+ICgpXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCdcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICclJ1xuICB8IFNjYW5faW5kaWMgYyAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnOyBwcF9wcmludF9jaGFyIHBwZiBjXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5vdXRwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IGYgcHBmO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5idWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2RlbGF5IChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoZiAoKSk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgKGYgKCkpO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCpcblxuICBEZWZpbmluZyBbZnByaW50Zl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbZnByaW50Zl0uXG5cbiopXG5cbmxldCBrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBwcGYgYWNjOyBrIHBwZilcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5hbmQgaWtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgcHBmIGZtdFxuXG5sZXQgaWZwcmludGYgX3BwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBpZ25vcmUgKCkgZm10XG5cbmxldCBmcHJpbnRmIHBwZiA9IGtmcHJpbnRmIGlnbm9yZSBwcGZcbmxldCBwcmludGYgZm10ID0gZnByaW50ZiBzdGRfZm9ybWF0dGVyIGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBlcnJfZm9ybWF0dGVyIGZtdFxuXG5sZXQga2RwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gayAoZnVuIHBwZiAtPiBvdXRwdXRfYWNjIHBwZiBhY2MpKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmxldCBkcHJpbnRmIGZtdCA9IGtkcHJpbnRmIChmdW4gaSAtPiBpKSBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBzdHJwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIGlkIGZtdFxuXG5sZXQga2FzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBvdXRwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBhc3ByaW50ZiBmbXQgPSBrYXNwcmludGYgaWQgZm10XG5cbigqIEZsdXNoaW5nIHN0YW5kYXJkIGZvcm1hdHRlcnMgYXQgZW5kIG9mIGV4ZWN1dGlvbi4gKilcblxubGV0IGZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnMgKCkgPVxuICBwcF9wcmludF9mbHVzaCBzdGRfZm9ybWF0dGVyICgpO1xuICBwcF9wcmludF9mbHVzaCBlcnJfZm9ybWF0dGVyICgpXG5cbmxldCAoKSA9IGF0X2V4aXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVyc1xuXG4oKlxuXG4gIERlcHJlY2F0ZWQgc3R1ZmYuXG5cbiopXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlXG4gICAgfm91dDpmIH5mbHVzaDpnIH5uZXdsaW5lOmggfnNwYWNlczppID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaCxcbiAgIHN0YXRlLnBwX291dF9uZXdsaW5lLCBzdGF0ZS5wcF9vdXRfc3BhY2VzKVxuXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBzZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IGdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogZXJyb3IgcHJvbmUgZnVuY3Rpb24sIGRvIG5vdCB1c2UgaXQuXG4gICBUaGlzIGZ1bmN0aW9uIGlzIG5laXRoZXIgY29tcG9zaXRpb25hbCBub3IgaW5jcmVtZW50YWwsIHNpbmNlIGl0IGZsdXNoZXNcbiAgIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhdCBlYWNoIGNhbGwuXG4gICBUbyBnZXQgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSwgZGVmaW5lIGEgZm9ybWF0dGVyIG9mIHlvdXIgb3duIHdyaXRpbmcgdG9cbiAgIHRoZSBidWZmZXIgYXJndW1lbnQsIGFzIGluXG4gICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiXG4gICB0aGVuIHVzZSB7IWZwcmludGYgcHBmfSBhcyB1c3VhbC4gKilcbmxldCBicHJpbnRmIGIgKEZvcm1hdCAoZm10LCBfKSA6ICgnYSwgZm9ybWF0dGVyLCB1bml0KSBmb3JtYXQpID1cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPSBvdXRwdXRfYWNjIHBwZiBhY2M7IHBwX2ZsdXNoX3F1ZXVlIHBwZiBmYWxzZSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxuKCogRGVwcmVjYXRlZCA6IGFsaWFzIGZvciBrc3ByaW50Zi4gKilcbmxldCBrcHJpbnRmID0ga3NwcmludGZcblxuXG5cbigqIERlcHJlY2F0ZWQgdGFnIGZ1bmN0aW9ucyAqKVxuXG50eXBlIGZvcm1hdHRlcl90YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fdGFnIDogdGFnIC0+IHN0cmluZztcbiAgbWFya19jbG9zZV90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3RhZyA6IHRhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV90YWcgOiB0YWcgLT4gdW5pdDtcbn1cblxuXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV90YWcgPSBtY3Q7XG4gICAgIHByaW50X29wZW5fdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV90YWcgPSBwY3Q7XG4gICB9ID1cbiAgbGV0IHN0cmluZ2lmeSBmIGUgPSBmdW5jdGlvbiBTdHJpbmdfdGFnIHMgLT4gZiBzIHwgXyAtPiBlIGluXG4gIHN0YXRlLnBwX21hcmtfb3Blbl90YWcgPC0gc3RyaW5naWZ5IG1vdCBcIlwiO1xuICBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgbWN0IFwiXCI7XG4gIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIDwtIHN0cmluZ2lmeSBwb3QgKCk7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgcGN0ICgpXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgZm10ICgpID1cbiAgbGV0IGZ1bnMgPSBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIGZtdCAoKSBpblxuICBsZXQgbWFya19vcGVuX3RhZyBzID0gZnVucy5tYXJrX29wZW5fc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgbWFya19jbG9zZV90YWcgcyA9IGZ1bnMubWFya19jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBwcmludF9vcGVuX3RhZyBzID0gZnVucy5wcmludF9vcGVuX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IHByaW50X2Nsb3NlX3RhZyBzID0gZnVucy5wcmludF9jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIHttYXJrX29wZW5fdGFnOyBtYXJrX2Nsb3NlX3RhZzsgcHJpbnRfb3Blbl90YWc7IHByaW50X2Nsb3NlX3RhZ31cblxubGV0IHNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIGFsaWFzIHRvIGF2b2lkIHdhcm5pbmcgZm9yIGFtYmlndWl0eSBiZXR3ZWVuXG4gICBTdGRsaWIuZm9ybWF0NlxuICAgYW5kIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG5cbiAgICh0aGUgZm9ybWVyIGlzIGluIGZhY3QgYW4gYWxpYXMgZm9yIHRoZSBsYXR0ZXIsXG4gICAgYnV0IHRoZSBhbWJpZ3VpdHkgd2FybmluZyBkb2Vzbid0IGNhcmUpXG4qKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBTdGRsaWIuZm9ybWF0NlxuXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FubmVycy4gKilcblxuKCogU2Nhbm5pbmcgYnVmZmVycy4gKilcbm1vZHVsZSB0eXBlIFNDQU5OSU5HID0gc2lnXG5cbiAgdHlwZSBpbl9jaGFubmVsXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdmFsIHN0ZGluIDogaW5fY2hhbm5lbFxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXS5cbiAgICAgW3N0ZGliXSBpcyBlcXVpdmFsZW50IHRvIFtTY2FubmluZy5mcm9tX2NoYW5uZWwgU3RkbGliLnN0ZGluXS4gKilcblxuICB2YWwgc3RkaWIgOiBpbl9jaGFubmVsXG4gICgqIEFuIGFsaWFzIGZvciBbU2NhbmYuc3RkaW5dLCB0aGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbVxuICAgICBbU3RkbGliLnN0ZGluXS4gKilcblxuICB2YWwgbmV4dF9jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5uZXh0X2NoYXIgaWJdIGFkdmFuY2UgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3Rlci5cbiAgICAgSWYgbm8gbW9yZSBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYSBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXSBtYXJrIHRoZSBjdXJyZW50X2NoYXIgYXMgYWxyZWFkeVxuICAgICBzY2FubmVkLiAqKVxuXG4gIHZhbCBwZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLnBlZWtfY2hhciBpYl0gcmV0dXJucyB0aGUgY3VycmVudCBjaGFyIGF2YWlsYWJsZSBpblxuICAgICB0aGUgYnVmZmVyIG9yIHJlYWRzIG9uZSBpZiBuZWNlc3NhcnkgKHdoZW4gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzXG4gICAgIGFscmVhZHkgc2Nhbm5lZCkuXG4gICAgIElmIG5vIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhbiBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgY2hlY2tlZF9wZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogU2FtZSBhcyBbU2Nhbm5pbmcucGVla19jaGFyXSBhYm92ZSBidXQgYWx3YXlzIHJldHVybnMgYSB2YWxpZCBjaGFyIG9yXG4gICAgIGZhaWxzOiBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG51bGwgY2hhciB3aGVuIHRoZSByZWFkaW5nIG1ldGhvZCBvZiB0aGVcbiAgICAgaW5wdXQgYnVmZmVyIGhhcyByZWFjaGVkIGFuIGVuZCBvZiBmaWxlLCB0aGUgZnVuY3Rpb24gcmFpc2VzIGV4Y2VwdGlvblxuICAgICBbRW5kX29mX2ZpbGVdLiAqKVxuXG4gIHZhbCBzdG9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gY2hhciAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnN0b3JlX2NoYXIgbGltIGliIGNdIGFkZHMgW2NdIHRvIHRoZSB0b2tlbiBidWZmZXJcbiAgICAgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlciBbaWJdLiBJdCBhbHNvIGFkdmFuY2VzIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIgYW5kIHJldHVybnMgW2xpbSAtIDFdLCBpbmRpY2F0aW5nIHRoZSBuZXcgbGltaXQgZm9yIHRoZVxuICAgICBsZW5ndGggb2YgdGhlIGN1cnJlbnQgdG9rZW4uICopXG5cbiAgdmFsIHNraXBfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc2tpcF9jaGFyIGxpbSBpYl0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuICopXG5cbiAgdmFsIGlnbm9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5pZ25vcmVfY2hhciBpYiBsaW1dIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGFuZFxuICAgICBkZWNyZW1lbnRzIHRoZSBsaW1pdC4gKilcblxuICB2YWwgdG9rZW4gOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcudG9rZW4gaWJdIHJldHVybnMgdGhlIHN0cmluZyBzdG9yZWQgaW50byB0aGUgdG9rZW5cbiAgICAgYnVmZmVyIG9mIHRoZSBzY2FubmluZyBidWZmZXI6IGl0IHJldHVybnMgdGhlIHRva2VuIG1hdGNoZWQgYnkgdGhlXG4gICAgIGZvcm1hdC4gKilcblxuICB2YWwgcmVzZXRfdG9rZW4gOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLnJlc2V0X3Rva2VuIGliXSByZXNldHMgdGhlIHRva2VuIGJ1ZmZlciBvZlxuICAgICB0aGUgZ2l2ZW4gc2Nhbm5pbmcgYnVmZmVyLiAqKVxuXG4gIHZhbCBjaGFyX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmNoYXJfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbGluZV9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5saW5lX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbmV3IGxpbmVcbiAgICAgY2hhcmFjdGVycyByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIHRva2VuX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnRva2VuX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgdG9rZW5zIHJlYWRcbiAgICAgc28gZmFyIGZyb20gW2liXS4gKilcblxuICB2YWwgZW9mIDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lb2YgaWJdIHJldHVybnMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgZW5kX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIgKGlmIG5vIGNoYXIgaGFzIGV2ZXIgYmVlbiByZWFkLCBhbiBhdHRlbXB0IHRvXG4gICAgIHJlYWQgb25lIGlzIHBlcmZvcm1lZCkuICopXG5cbiAgdmFsIGJlZ2lubmluZ19vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuYmVnaW5uaW5nX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgYmVnaW5uaW5nIG9mIGlucHV0XG4gICAgIGNvbmRpdGlvbiBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBuYW1lX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLm5hbWVfb2ZfaW5wdXQgaWJdIHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNoYXJhY3RlclxuICAgICBzb3VyY2UgZm9yIGlucHV0IGJ1ZmZlciBbaWJdLiAqKVxuXG4gIHZhbCBvcGVuX2luIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIG9wZW5faW5fYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZSA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGVfYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fc3RyaW5nIDogc3RyaW5nIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZnVuY3Rpb24gOiAodW5pdCAtPiBjaGFyKSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2NoYW5uZWwgOiBTdGRsaWIuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG5cbiAgdmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0XG5cbiAgdmFsIG1lbW9fZnJvbV9jaGFubmVsIDogU3RkbGliLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuICAoKiBPYnNvbGV0ZS4gKilcblxuZW5kXG5cblxubW9kdWxlIFNjYW5uaW5nIDogU0NBTk5JTkcgPSBzdHJ1Y3RcblxuICAoKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2NhbmYuICopXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB0eXBlIGluX2NoYW5uZWxfbmFtZSA9XG4gICAgfCBGcm9tX2NoYW5uZWwgb2YgU3RkbGliLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZmlsZSBvZiBmaWxlX25hbWUgKiBTdGRsaWIuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9mdW5jdGlvblxuICAgIHwgRnJvbV9zdHJpbmdcblxuXG4gIHR5cGUgaW5fY2hhbm5lbCA9IHtcbiAgICBtdXRhYmxlIGljX2VvZiA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXIgOiBjaGFyO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2NoYXJfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY19saW5lX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfdG9rZW5fY291bnQgOiBpbnQ7XG4gICAgaWNfZ2V0X25leHRfY2hhciA6IHVuaXQgLT4gY2hhcjtcbiAgICBpY190b2tlbl9idWZmZXIgOiBCdWZmZXIudDtcbiAgICBpY19pbnB1dF9uYW1lIDogaW5fY2hhbm5lbF9uYW1lO1xuICB9XG5cblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgbGV0IG51bGxfY2hhciA9ICdcXDAwMCdcblxuICAoKiBSZWFkcyBhIG5ldyBjaGFyYWN0ZXIgZnJvbSBpbnB1dCBidWZmZXIuXG4gICAgIE5leHRfY2hhciBuZXZlciBmYWlscywgZXZlbiBpbiBjYXNlIG9mIGVuZCBvZiBpbnB1dDpcbiAgICAgaXQgdGhlbiBzaW1wbHkgc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uLiAqKVxuICBsZXQgbmV4dF9jaGFyIGliID1cbiAgICB0cnlcbiAgICAgIGxldCBjID0gaWIuaWNfZ2V0X25leHRfY2hhciAoKSBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gdHJ1ZTtcbiAgICAgIGliLmljX2NoYXJfY291bnQgPC0gc3VjYyBpYi5pY19jaGFyX2NvdW50O1xuICAgICAgaWYgYyA9ICdcXG4nIHRoZW4gaWIuaWNfbGluZV9jb3VudCA8LSBzdWNjIGliLmljX2xpbmVfY291bnQ7XG4gICAgICBjIHdpdGhcbiAgICB8IEVuZF9vZl9maWxlIC0+XG4gICAgICBsZXQgYyA9IG51bGxfY2hhciBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2U7XG4gICAgICBpYi5pY19lb2YgPC0gdHJ1ZTtcbiAgICAgIGNcblxuXG4gIGxldCBwZWVrX2NoYXIgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY3VycmVudF9jaGFyXG4gICAgZWxzZSBuZXh0X2NoYXIgaWJcblxuXG4gICgqIFJldHVybnMgYSB2YWxpZCBjdXJyZW50IGNoYXIgZm9yIHRoZSBpbnB1dCBidWZmZXIuIEluIHBhcnRpY3VsYXJcbiAgICAgbm8gaXJyZWxldmFudCBudWxsIGNoYXJhY3RlciAoYXMgc2V0IGJ5IFtuZXh0X2NoYXJdIGluIGNhc2Ugb2YgZW5kXG4gICAgIG9mIGlucHV0KSBpcyByZXR1cm5lZCwgc2luY2UgW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlblxuICAgICBbbmV4dF9jaGFyXSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24gd2hpbGUgdHJ5aW5nIHRvIHJlYWQgYVxuICAgICBuZXcgY2hhcmFjdGVyLiAqKVxuICBsZXQgY2hlY2tlZF9wZWVrX2NoYXIgaWIgPVxuICAgIGxldCBjID0gcGVla19jaGFyIGliIGluXG4gICAgaWYgaWIuaWNfZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGU7XG4gICAgY1xuXG5cbiAgbGV0IGVuZF9vZl9pbnB1dCBpYiA9XG4gICAgaWdub3JlIChwZWVrX2NoYXIgaWIpO1xuICAgIGliLmljX2VvZlxuXG5cbiAgbGV0IGVvZiBpYiA9IGliLmljX2VvZlxuXG4gIGxldCBiZWdpbm5pbmdfb2ZfaW5wdXQgaWIgPSBpYi5pY19jaGFyX2NvdW50ID0gMFxuXG4gIGxldCBuYW1lX29mX2lucHV0IGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBfaWMgLT4gXCJ1bm5hbWVkIFN0ZGxpYiBpbnB1dCBjaGFubmVsXCJcbiAgICB8IEZyb21fZmlsZSAoZm5hbWUsIF9pYykgLT4gZm5hbWVcbiAgICB8IEZyb21fZnVuY3Rpb24gLT4gXCJ1bm5hbWVkIGZ1bmN0aW9uXCJcbiAgICB8IEZyb21fc3RyaW5nIC0+IFwidW5uYW1lZCBjaGFyYWN0ZXIgc3RyaW5nXCJcblxuXG4gIGxldCBjaGFyX2NvdW50IGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2NoYXJfY291bnQgLSAxXG4gICAgZWxzZSBpYi5pY19jaGFyX2NvdW50XG5cblxuICBsZXQgbGluZV9jb3VudCBpYiA9IGliLmljX2xpbmVfY291bnRcblxuICBsZXQgcmVzZXRfdG9rZW4gaWIgPSBCdWZmZXIucmVzZXQgaWIuaWNfdG9rZW5fYnVmZmVyXG5cbiAgbGV0IGludmFsaWRhdGVfY3VycmVudF9jaGFyIGliID0gaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlXG5cbiAgbGV0IHRva2VuIGliID1cbiAgICBsZXQgdG9rZW5fYnVmZmVyID0gaWIuaWNfdG9rZW5fYnVmZmVyIGluXG4gICAgbGV0IHRvayA9IEJ1ZmZlci5jb250ZW50cyB0b2tlbl9idWZmZXIgaW5cbiAgICBCdWZmZXIuY2xlYXIgdG9rZW5fYnVmZmVyO1xuICAgIGliLmljX3Rva2VuX2NvdW50IDwtIHN1Y2MgaWIuaWNfdG9rZW5fY291bnQ7XG4gICAgdG9rXG5cblxuICBsZXQgdG9rZW5fY291bnQgaWIgPSBpYi5pY190b2tlbl9jb3VudFxuXG4gIGxldCBza2lwX2NoYXIgd2lkdGggaWIgPVxuICAgIGludmFsaWRhdGVfY3VycmVudF9jaGFyIGliO1xuICAgIHdpZHRoXG5cblxuICBsZXQgaWdub3JlX2NoYXIgd2lkdGggaWIgPSBza2lwX2NoYXIgKHdpZHRoIC0gMSkgaWJcblxuICBsZXQgc3RvcmVfY2hhciB3aWR0aCBpYiBjID1cbiAgICBCdWZmZXIuYWRkX2NoYXIgaWIuaWNfdG9rZW5fYnVmZmVyIGM7XG4gICAgaWdub3JlX2NoYXIgd2lkdGggaWJcblxuXG4gIGxldCBkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplID0gMTAyNFxuXG4gIGxldCBjcmVhdGUgaW5hbWUgbmV4dCA9IHtcbiAgICBpY19lb2YgPSBmYWxzZTtcbiAgICBpY19jdXJyZW50X2NoYXIgPSBudWxsX2NoYXI7XG4gICAgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkID0gZmFsc2U7XG4gICAgaWNfY2hhcl9jb3VudCA9IDA7XG4gICAgaWNfbGluZV9jb3VudCA9IDA7XG4gICAgaWNfdG9rZW5fY291bnQgPSAwO1xuICAgIGljX2dldF9uZXh0X2NoYXIgPSBuZXh0O1xuICAgIGljX3Rva2VuX2J1ZmZlciA9IEJ1ZmZlci5jcmVhdGUgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZTtcbiAgICBpY19pbnB1dF9uYW1lID0gaW5hbWU7XG4gIH1cblxuXG4gIGxldCBmcm9tX3N0cmluZyBzID1cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpID49IGxlbiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlIGVsc2VcbiAgICAgIGxldCBjID0gcy5bIWldIGluXG4gICAgICBpbmNyIGk7XG4gICAgICBjIGluXG4gICAgY3JlYXRlIEZyb21fc3RyaW5nIG5leHRcblxuXG4gIGxldCBmcm9tX2Z1bmN0aW9uID0gY3JlYXRlIEZyb21fZnVuY3Rpb25cblxuICAoKiBTY2FubmluZyBmcm9tIGFuIGlucHV0IGNoYW5uZWwuICopXG5cbiAgKCogUG9zaXRpb24gb2YgdGhlIHByb2JsZW06XG5cbiAgICAgV2UgY2Fubm90IHByZXZlbnQgdGhlIHNjYW5uaW5nIG1lY2hhbmlzbSB0byB1c2Ugb25lIGxvb2thaGVhZCBjaGFyYWN0ZXIsXG4gICAgIGlmIG5lZWRlZCBieSB0aGUgc2VtYW50aWNzIG9mIHRoZSBmb3JtYXQgc3RyaW5nIHNwZWNpZmljYXRpb25zIChlLmcuIGFcbiAgICAgdHJhaWxpbmcgJ3NraXAgc3BhY2UnIHNwZWNpZmljYXRpb24gaW4gdGhlIGZvcm1hdCBzdHJpbmcpOyBpbiB0aGlzIGNhc2UsXG4gICAgIHRoZSBtYW5kYXRvcnkgbG9va2FoZWFkIGNoYXJhY3RlciBpcyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBpbnB1dCBhbmQgbm90XG4gICAgIHVzZWQgdG8gcmV0dXJuIHRoZSB0b2tlbiByZWFkLiBJdCBpcyB0aHVzIG1hbmRhdG9yeSB0byBiZSBhYmxlIHRvIHN0b3JlXG4gICAgIGFuIHVudXNlZCBsb29rYWhlYWQgY2hhcmFjdGVyIHNvbWV3aGVyZSB0byBnZXQgaXQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgICBvZiB0aGUgbmV4dCBzY2FuLlxuXG4gICAgIFRvIGNpcmN1bXZlbnQgdGhpcyBwcm9ibGVtLCBhbGwgdGhlIHNjYW5uaW5nIGZ1bmN0aW9ucyBnZXQgYSBsb3cgbGV2ZWxcbiAgICAgaW5wdXQgYnVmZmVyIGFyZ3VtZW50IHdoZXJlIHRoZXkgc3RvcmUgdGhlIGxvb2thaGVhZCBjaGFyYWN0ZXIgd2hlblxuICAgICBuZWVkZWQ7IGFkZGl0aW9uYWxseSwgdGhlIGlucHV0IGJ1ZmZlciBpcyB0aGUgb25seSBzb3VyY2Ugb2YgY2hhcmFjdGVyIG9mXG4gICAgIGEgc2Nhbm5lci4gVGhlIFtzY2FuYnVmXSBpbnB1dCBidWZmZXJzIGFyZSBkZWZpbmVkIGluIG1vZHVsZSB7IVNjYW5uaW5nfS5cblxuICAgICBOb3cgd2UgdW5kZXJzdGFuZCB0aGF0IGl0IGlzIGV4dHJlbWVseSBpbXBvcnRhbnQgdGhhdCByZWxhdGVkIGFuZFxuICAgICBzdWNjZXNzaXZlIGNhbGxzIHRvIHNjYW5uZXJzIGluZGVlZCByZWFkIGZyb20gdGhlIHNhbWUgaW5wdXQgYnVmZmVyLlxuICAgICBJbiBlZmZlY3QsIGlmIGEgc2Nhbm5lciBbc2NhbjFdIGlzIHJlYWRpbmcgZnJvbSBbaWIxXSBhbmQgc3RvcmVzIGFuXG4gICAgIHVudXNlZCBsb29rYWhlYWQgY2hhcmFjdGVyIFtjMV0gaW50byBpdHMgaW5wdXQgYnVmZmVyIFtpYjFdLCB0aGVuXG4gICAgIGFub3RoZXIgc2Nhbm5lciBbc2NhbjJdIG5vdCByZWFkaW5nIGZyb20gdGhlIHNhbWUgYnVmZmVyIFtpYjFdIHdpbGwgbWlzc1xuICAgICB0aGUgY2hhcmFjdGVyIFtjMV0sIHNlZW1pbmdseSB2YW5pc2hlZCBpbiB0aGUgYWlyIGZyb20gdGhlIHBvaW50IG9mIHZpZXdcbiAgICAgb2YgW3NjYW4yXS5cblxuICAgICBUaGlzIG1lY2hhbmlzbSB3b3JrcyBwZXJmZWN0bHkgdG8gcmVhZCBmcm9tIHN0cmluZ3MsIGZyb20gZmlsZXMsIGFuZCBmcm9tXG4gICAgIGZ1bmN0aW9ucywgc2luY2UgaW4gdGhvc2UgY2FzZXMsIGFsbG9jYXRpbmcgdHdvIGJ1ZmZlcnMgcmVhZGluZyBmcm9tIHRoZVxuICAgICBzYW1lIHNvdXJjZSBpcyB1bm5hdHVyYWwuXG5cbiAgICAgU3RpbGwsIHRoZXJlIGlzIGEgZGlmZmljdWx0eSBpbiB0aGUgY2FzZSBvZiBzY2FubmluZyBmcm9tIGFuIGlucHV0XG4gICAgIGNoYW5uZWwuIEluIGVmZmVjdCwgd2hlbiBzY2FubmluZyBmcm9tIGFuIGlucHV0IGNoYW5uZWwgW2ljXSwgdGhpcyBjaGFubmVsXG4gICAgIG1heSBub3QgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHdpdGhpbiB0aGlzIGxpYnJhcnkuIEhlbmNlLCBpdCBtYXkgYmVcbiAgICAgc2hhcmVkICh0d28gZnVuY3Rpb25zIG9mIHRoZSB1c2VyJ3MgcHJvZ3JhbSBtYXkgc3VjY2Vzc2l2ZWx5IHJlYWQgZnJvbVxuICAgICBbaWNdKS4gVGhpcyBpcyBoaWdobHkgZXJyb3IgcHJvbmUgc2luY2UsIG9uZSBvZiB0aGUgZnVuY3Rpb24gbWF5IHNlZWsgdGhlXG4gICAgIGlucHV0IGNoYW5uZWwsIHdoaWxlIHRoZSBvdGhlciBmdW5jdGlvbiBoYXMgc3RpbGwgYW4gdW51c2VkIGxvb2thaGVhZFxuICAgICBjaGFyYWN0ZXIgaW4gaXRzIGlucHV0IGJ1ZmZlci4gSW4gY29uY2x1c2lvbiwgeW91IHNob3VsZCBuZXZlciBtaXggZGlyZWN0XG4gICAgIGxvdyBsZXZlbCByZWFkaW5nIGFuZCBoaWdoIGxldmVsIHNjYW5uaW5nIGZyb20gdGhlIHNhbWUgaW5wdXQgY2hhbm5lbC5cblxuICAqKVxuXG4gICgqIFBlcmZvcm0gYnVmZmVyaXplZCBpbnB1dCB0byBpbXByb3ZlIGVmZmljaWVuY3kuICopXG4gIGxldCBmaWxlX2J1ZmZlcl9zaXplID0gcmVmIDEwMjRcblxuICAoKiBUaGUgc2Nhbm5lciBjbG9zZXMgdGhlIGlucHV0IGNoYW5uZWwgYXQgZW5kIG9mIGlucHV0LiAqKVxuICBsZXQgc2Nhbl9jbG9zZV9hdF9lbmQgaWMgPSBTdGRsaWIuY2xvc2VfaW4gaWM7IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgKCogVGhlIHNjYW5uZXIgZG9lcyBub3QgY2xvc2UgdGhlIGlucHV0IGNoYW5uZWwgYXQgZW5kIG9mIGlucHV0OlxuICAgICBpdCBqdXN0IHJhaXNlcyBbRW5kX29mX2ZpbGVdLiAqKVxuICBsZXQgc2Nhbl9yYWlzZV9hdF9lbmQgX2ljID0gcmFpc2UgRW5kX29mX2ZpbGVcblxuICBsZXQgZnJvbV9pYyBzY2FuX2Nsb3NlX2ljIGluYW1lIGljID1cbiAgICBsZXQgbGVuID0gIWZpbGVfYnVmZmVyX3NpemUgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgbGltID0gcmVmIDAgaW5cbiAgICBsZXQgZW9mID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IG5leHQgKCkgPVxuICAgICAgaWYgIWkgPCAhbGltIHRoZW4gYmVnaW4gbGV0IGMgPSBCeXRlcy5nZXQgYnVmICFpIGluIGluY3IgaTsgYyBlbmQgZWxzZVxuICAgICAgaWYgIWVvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlIGVsc2UgYmVnaW5cbiAgICAgICAgbGltIDo9IGlucHV0IGljIGJ1ZiAwIGxlbjtcbiAgICAgICAgaWYgIWxpbSA9IDAgdGhlbiBiZWdpbiBlb2YgOj0gdHJ1ZTsgc2Nhbl9jbG9zZV9pYyBpYyBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgIGkgOj0gMTtcbiAgICAgICAgICBCeXRlcy5nZXQgYnVmIDBcbiAgICAgICAgZW5kXG4gICAgICBlbmQgaW5cbiAgICBjcmVhdGUgaW5hbWUgbmV4dFxuXG5cbiAgbGV0IGZyb21faWNfY2xvc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX2Nsb3NlX2F0X2VuZFxuICBsZXQgZnJvbV9pY19yYWlzZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG5cbiAgKCogVGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0uXG4gICAgIE9uZSBjb3VsZCB0cnkgdG8gZGVmaW5lIFtzdGRpYl0gYXMgYSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBhIGNoYXJhY3RlclxuICAgICBhdCBhIHRpbWUgKG5vIGJ1ZmZlcml6YXRpb24gYXQgYWxsKSwgYnV0IHVuZm9ydHVuYXRlbHkgdGhlIHRvcC1sZXZlbFxuICAgICBpbnRlcmFjdGlvbiB3b3VsZCBiZSB3cm9uZy4gVGhpcyBpcyBkdWUgdG8gc29tZSBraW5kIG9mXG4gICAgICdyYWNlIGNvbmRpdGlvbicgd2hlbiByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0sXG4gICAgIHNpbmNlIHRoZSBpbnRlcmFjdGl2ZSBjb21waWxlciBhbmQgW1NjYW5mLnNjYW5mXSB3aWxsIHNpbXVsdGFuZW91c2x5XG4gICAgIHJlYWQgdGhlIG1hdGVyaWFsIHRoZXkgbmVlZCBmcm9tIFtTdGRsaWIuc3RkaW5dOyB0aGVuLCBjb25mdXNpb25cbiAgICAgd2lsbCByZXN1bHQgZnJvbSB3aGF0IHNob3VsZCBiZSByZWFkIGJ5IHRoZSB0b3AtbGV2ZWwgYW5kIHdoYXQgc2hvdWxkIGJlXG4gICAgIHJlYWQgYnkgW1NjYW5mLnNjYW5mXS5cbiAgICAgVGhpcyBpcyBldmVuIG1vcmUgY29tcGxpY2F0ZWQgYnkgdGhlIG9uZSBjaGFyYWN0ZXIgbG9va2FoZWFkIHRoYXRcbiAgICAgW1NjYW5mLnNjYW5mXSBpcyBzb21ldGltZXMgb2JsaWdlZCB0byBtYWludGFpbjogdGhlIGxvb2thaGVhZCBjaGFyYWN0ZXJcbiAgICAgd2lsbCBiZSBhdmFpbGFibGUgZm9yIHRoZSBuZXh0IFtTY2FuZi5zY2FuZl0gZW50cnksIHNlZW1pbmdseSBjb21pbmcgZnJvbVxuICAgICBub3doZXJlLlxuICAgICBBbHNvIG5vIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW4gcmVhZGluZyBmcm9tIHN0ZGluOiBpZiBub3QgZW5vdWdoXG4gICAgIGNoYXJhY3RlcnMgaGF2ZSBiZWVuIHJlYWQsIHdlIHNpbXBseSBhc2sgdG8gcmVhZCBtb3JlLiAqKVxuICBsZXQgc3RkaW4gPVxuICAgIGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcbiAgICAgIChGcm9tX2ZpbGUgKFwiLVwiLCBTdGRsaWIuc3RkaW4pKSBTdGRsaWIuc3RkaW5cblxuXG4gIGxldCBzdGRpYiA9IHN0ZGluXG5cbiAgbGV0IG9wZW5faW5fZmlsZSBvcGVuX2luIGZuYW1lID1cbiAgICBtYXRjaCBmbmFtZSB3aXRoXG4gICAgfCBcIi1cIiAtPiBzdGRpblxuICAgIHwgZm5hbWUgLT5cbiAgICAgIGxldCBpYyA9IG9wZW5faW4gZm5hbWUgaW5cbiAgICAgIGZyb21faWNfY2xvc2VfYXRfZW5kIChGcm9tX2ZpbGUgKGZuYW1lLCBpYykpIGljXG5cblxuICBsZXQgb3Blbl9pbiA9IG9wZW5faW5fZmlsZSBTdGRsaWIub3Blbl9pblxuICBsZXQgb3Blbl9pbl9iaW4gPSBvcGVuX2luX2ZpbGUgU3RkbGliLm9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fZmlsZSA9IG9wZW5faW5cbiAgbGV0IGZyb21fZmlsZV9iaW4gPSBvcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2NoYW5uZWwgaWMgPVxuICAgIGZyb21faWNfcmFpc2VfYXRfZW5kIChGcm9tX2NoYW5uZWwgaWMpIGljXG5cblxuICBsZXQgY2xvc2VfaW4gaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIGljIC0+XG4gICAgICBTdGRsaWIuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZmlsZSAoX2ZuYW1lLCBpYykgLT4gU3RkbGliLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2Z1bmN0aW9uIHwgRnJvbV9zdHJpbmcgLT4gKClcblxuXG4gICgqXG4gICAgIE9ic29sZXRlOiBhIG1lbW8gW2Zyb21fY2hhbm5lbF0gdmVyc2lvbiB0byBidWlsZCBhIFtTY2FubmluZy5pbl9jaGFubmVsXVxuICAgICBzY2FubmluZyBidWZmZXIgb3V0IG9mIGEgW1N0ZGxpYi5pbl9jaGFubmVsXS5cbiAgICAgVGhpcyBmdW5jdGlvbiB3YXMgdXNlZCB0byB0cnkgdG8gcHJlc2VydmUgdGhlIHNjYW5uaW5nXG4gICAgIHNlbWFudGljcyBmb3IgdGhlIChub3cgb2Jzb2xldGUpIGZ1bmN0aW9uIFtmc2NhbmZdLlxuICAgICBHaXZlbiB0aGF0IGFsbCBzY2FubmVyIG11c3QgcmVhZCBmcm9tIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdIHNjYW5uaW5nXG4gICAgIGJ1ZmZlciwgW2ZzY2FuZl0gbXVzdCByZWFkIGZyb20gb25lIVxuICAgICBNb3JlIHByZWNpc2VseSwgZ2l2ZW4gW2ljXSwgYWxsIHN1Y2Nlc3NpdmUgY2FsbHMgW2ZzY2FuZiBpY10gbXVzdCByZWFkXG4gICAgIGZyb20gdGhlIHNhbWUgc2Nhbm5pbmcgYnVmZmVyLlxuICAgICBUaGlzIG9ibGlnZWQgdGhpcyBsaWJyYXJ5IHRvIGFsbG9jYXRlZCBzY2FubmluZyBidWZmZXJzIHRoYXQgd2VyZVxuICAgICBub3QgcHJvcGVybHkgZ2FyYmFnZSBjb2xsZWN0YWJsZSwgaGVuY2UgbGVhZGluZyB0byBtZW1vcnkgbGVha3MuXG4gICAgIElmIHlvdSBuZWVkIHRvIHJlYWQgZnJvbSBhIFtTdGRsaWIuaW5fY2hhbm5lbF0gaW5wdXQgY2hhbm5lbFxuICAgICBbaWNdLCBzaW1wbHkgZGVmaW5lIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdIGZvcm1hdHRlZCBpbnB1dCBjaGFubmVsIGFzIGluXG4gICAgIFtsZXQgaWIgPSBTY2FubmluZy5mcm9tX2NoYW5uZWwgaWNdLCB0aGVuIHVzZSBbU2NhbmYuYnNjYW5mIGliXSBhcyB1c3VhbC5cbiAgKilcbiAgbGV0IG1lbW9fZnJvbV9pYyA9XG4gICAgbGV0IG1lbW8gPSByZWYgW10gaW5cbiAgICAoZnVuIHNjYW5fY2xvc2VfaWMgaWMgLT5cbiAgICAgdHJ5IExpc3QuYXNzcSBpYyAhbWVtbyB3aXRoXG4gICAgIHwgTm90X2ZvdW5kIC0+XG4gICAgICAgbGV0IGliID1cbiAgICAgICAgIGZyb21faWMgc2Nhbl9jbG9zZV9pYyAoRnJvbV9jaGFubmVsIGljKSBpYyBpblxuICAgICAgIG1lbW8gOj0gKGljLCBpYikgOjogIW1lbW87XG4gICAgICAgaWIpXG5cblxuICAoKiBPYnNvbGV0ZTogc2VlIHshbWVtb19mcm9tX2ljfSBhYm92ZS4gKilcbiAgbGV0IG1lbW9fZnJvbV9jaGFubmVsID0gbWVtb19mcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG5cbmVuZFxuXG5cbigqIEZvcm1hdHRlZCBpbnB1dCBmdW5jdGlvbnMuICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBzY2FubmVyID1cbiAgICAgKCdhLCBTY2FubmluZy5pbl9jaGFubmVsLCAnYiwgJ2MsICdhIC0+ICdkLCAnZCkgZm9ybWF0NiAtPiAnY1xuXG5cbigqIFJlcG9ydGluZyBlcnJvcnMuICopXG5leGNlcHRpb24gU2Nhbl9mYWlsdXJlIG9mIHN0cmluZ1xuXG5sZXQgYmFkX2lucHV0IHMgPSByYWlzZSAoU2Nhbl9mYWlsdXJlIHMpXG5cbmxldCBiYWRfaW5wdXRfZXNjYXBlIGMgPVxuICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiaWxsZWdhbCBlc2NhcGUgY2hhcmFjdGVyICVDXCIgYylcblxuXG5sZXQgYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHRoZSBzcGVjaWZpZWQgbGVuZ3RoIHdhcyB0b28gc2hvcnQgZm9yIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgPVxuICBiYWRfaW5wdXRcbiAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICBcInNjYW5uaW5nIG9mICVzIGZhaWxlZDogXFxcbiAgICAgICAgcHJlbWF0dXJlIGVuZCBvZiBmaWxlIG9jY3VycmVkIGJlZm9yZSBlbmQgb2YgdG9rZW5cIlxuICAgICAgIG1lc3NhZ2UpXG5cblxubGV0IGJhZF9mbG9hdCAoKSA9XG4gIGJhZF9pbnB1dCBcIm5vIGRvdCBvciBleHBvbmVudCBwYXJ0IGZvdW5kIGluIGZsb2F0IHRva2VuXCJcblxuXG5sZXQgYmFkX2hleF9mbG9hdCAoKSA9XG4gIGJhZF9pbnB1dCBcIm5vdCBhIHZhbGlkIGZsb2F0IGluIGhleGFkZWNpbWFsIG5vdGF0aW9uXCJcblxuXG5sZXQgY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpID1cbiAgUHJpbnRmLnNwcmludGYgXCJsb29raW5nIGZvciAlQywgZm91bmQgJUNcIiBjIGNpXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpID1cbiAgYmFkX2lucHV0IChjaGFyYWN0ZXJfbWlzbWF0Y2hfZXJyIGMgY2kpXG5cblxubGV0IHJlYyBza2lwX3doaXRlcyBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSB0aGVuIGJlZ2luXG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnICcgfCAnXFx0JyB8ICdcXG4nIHwgJ1xccicgLT5cbiAgICAgIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliOyBza2lwX3doaXRlcyBpYlxuICAgIHwgXyAtPiAoKVxuICBlbmRcblxuXG4oKiBDaGVja2luZyB0aGF0IFtjXSBpcyBpbmRlZWQgaW4gdGhlIGlucHV0LCB0aGVuIHNraXBzIGl0LlxuICAgSW4gdGhpcyBjYXNlLCB0aGUgY2hhcmFjdGVyIFtjXSBoYXMgYmVlbiBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGVcbiAgIGZvcm1hdCBhcyBiZWluZyBtYW5kYXRvcnkgaW4gdGhlIGlucHV0OyBoZW5jZSB3ZSBzaG91bGQgZmFpbCB3aXRoXG4gICBbRW5kX29mX2ZpbGVdIGluIGNhc2Ugb2YgZW5kX29mX2lucHV0LlxuICAgKFJlbWVtYmVyIHRoYXQgW1NjYW5fZmFpbHVyZV0gaXMgcmFpc2VkIG9ubHkgd2hlbiAod2UgY2FuIHByb3ZlIGJ5XG4gICBldmlkZW5jZSkgdGhhdCB0aGUgaW5wdXQgZG9lcyBub3QgbWF0Y2ggdGhlIGZvcm1hdCBzdHJpbmcgZ2l2ZW4uIFdlIG11c3RcbiAgIHRodXMgZGlmZmVyZW50aWF0ZSBbRW5kX29mX2ZpbGVdIGFzIGFuIGVycm9yIGR1ZSB0byBsYWNrIG9mIGlucHV0LCBhbmRcbiAgIFtTY2FuX2ZhaWx1cmVdIHdoaWNoIGlzIGR1ZSB0byBwcm92YWJseSB3cm9uZyBpbnB1dC4gSSBhbSBub3Qgc3VyZSB0aGlzIGlzXG4gICB3b3J0aCB0aGUgYnVyZGVuOiBpdCBpcyBjb21wbGV4IGFuZCBzb21laG93IHN1YmxpbWluYWw7IHNob3VsZCBiZSBjbGVhcmVyXG4gICB0byBmYWlsIHdpdGggU2Nhbl9mYWlsdXJlIFwiTm90IGVub3VnaCBpbnB1dCB0byBjb21wbGV0ZSBzY2FubmluZ1wiISlcblxuICAgVGhhdCdzIHdoeSwgd2FpdGluZyBmb3IgYSBiZXR0ZXIgc29sdXRpb24sIHdlIHVzZSBjaGVja2VkX3BlZWtfY2hhciBoZXJlLlxuICAgV2UgYXJlIGFsc28gY2FyZWZ1bCB0byB0cmVhdCBcIlxcclxcblwiIGluIHRoZSBpbnB1dCBhcyBhbiBlbmQgb2YgbGluZSBtYXJrZXI6XG4gICBpdCBhbHdheXMgbWF0Y2hlcyBhICdcXG4nIHNwZWNpZmljYXRpb24gaW4gdGhlIGlucHV0IGZvcm1hdCBzdHJpbmcuICopXG5sZXQgcmVjIGNoZWNrX2NoYXIgaWIgYyA9XG4gIG1hdGNoIGMgd2l0aFxuICB8ICcgJyAtPiBza2lwX3doaXRlcyBpYlxuICB8ICdcXG4nIC0+IGNoZWNrX25ld2xpbmUgaWJcbiAgfCBjIC0+IGNoZWNrX3RoaXNfY2hhciBpYiBjXG5cbmFuZCBjaGVja190aGlzX2NoYXIgaWIgYyA9XG4gIGxldCBjaSA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGNpID0gYyB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliIGVsc2VcbiAgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuYW5kIGNoZWNrX25ld2xpbmUgaWIgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjaSB3aXRoXG4gIHwgJ1xcbicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgfCAnXFxyJyAtPiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgY2hlY2tfdGhpc19jaGFyIGliICdcXG4nXG4gIHwgXyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcbicgY2lcblxuXG4oKiBFeHRyYWN0aW5nIHRva2VucyBmcm9tIHRoZSBvdXRwdXQgdG9rZW4gYnVmZmVyLiAqKVxuXG5sZXQgdG9rZW5fY2hhciBpYiA9IChTY2FubmluZy50b2tlbiBpYikuWzBdXG5cbmxldCB0b2tlbl9zdHJpbmcgPSBTY2FubmluZy50b2tlblxuXG5sZXQgdG9rZW5fYm9vbCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLnRva2VuIGliIHdpdGhcbiAgfCBcInRydWVcIiAtPiB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gIHwgcyAtPiBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiaW52YWxpZCBib29sZWFuICclcydcIiBzKVxuXG5cbigqIFRoZSB0eXBlIG9mIGludGVnZXIgY29udmVyc2lvbnMuICopXG50eXBlIGludGVnZXJfY29udmVyc2lvbiA9XG4gIHwgQl9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGJpbmFyeSBjb252ZXJzaW9uICopXG4gIHwgRF9jb252ZXJzaW9uICgqIFNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBJX2NvbnZlcnNpb24gKCogU2lnbmVkIGludGVnZXIgY29udmVyc2lvbiAqKVxuICB8IE9fY29udmVyc2lvbiAoKiBVbnNpZ25lZCBvY3RhbCBjb252ZXJzaW9uICopXG4gIHwgVV9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGRlY2ltYWwgY29udmVyc2lvbiAqKVxuICB8IFhfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBoZXhhZGVjaW1hbCBjb252ZXJzaW9uICopXG5cblxubGV0IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyID0gZnVuY3Rpb25cbiAgfCAnYicgLT4gQl9jb252ZXJzaW9uXG4gIHwgJ2QnIC0+IERfY29udmVyc2lvblxuICB8ICdpJyAtPiBJX2NvbnZlcnNpb25cbiAgfCAnbycgLT4gT19jb252ZXJzaW9uXG4gIHwgJ3UnIC0+IFVfY29udmVyc2lvblxuICB8ICd4JyB8ICdYJyAtPiBYX2NvbnZlcnNpb25cbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5cbigqIEV4dHJhY3QgYW4gaW50ZWdlciBsaXRlcmFsIHRva2VuLlxuICAgU2luY2UgdGhlIGZ1bmN0aW9ucyBTdGRsaWIuKmludCpfb2Zfc3RyaW5nIGRvIG5vdCBhY2NlcHQgYSBsZWFkaW5nICssXG4gICB3ZSBza2lwIGl0IGlmIG5lY2Vzc2FyeS4gKilcbmxldCB0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliID1cbiAgbGV0IHRvayA9XG4gICAgbWF0Y2ggY29udiB3aXRoXG4gICAgfCBEX2NvbnZlcnNpb24gfCBJX2NvbnZlcnNpb24gLT4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFVfY29udmVyc2lvbiAtPiBcIjB1XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgT19jb252ZXJzaW9uIC0+IFwiMG9cIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBYX2NvbnZlcnNpb24gLT4gXCIweFwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IEJfY29udmVyc2lvbiAtPiBcIjBiXCIgXiBTY2FubmluZy50b2tlbiBpYiBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggdG9rIGluXG4gIGlmIGwgPSAwIHx8IHRvay5bMF0gPD4gJysnIHRoZW4gdG9rIGVsc2UgU3RyaW5nLnN1YiB0b2sgMSAobCAtIDEpXG5cblxuKCogQWxsIHRoZSBmdW5jdGlvbnMgdGhhdCBjb252ZXJ0IGEgc3RyaW5nIHRvIGEgbnVtYmVyIHJhaXNlIHRoZSBleGNlcHRpb25cbiAgIEZhaWx1cmUgd2hlbiB0aGUgY29udmVyc2lvbiBpcyBub3QgcG9zc2libGUuXG4gICBUaGlzIGV4Y2VwdGlvbiBpcyB0aGVuIHRyYXBwZWQgaW4gW2tzY2FuZl0uICopXG5sZXQgdG9rZW5faW50IGNvbnYgaWIgPSBpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG5sZXQgdG9rZW5fZmxvYXQgaWIgPSBmbG9hdF9vZl9zdHJpbmcgKFNjYW5uaW5nLnRva2VuIGliKVxuXG4oKiBUbyBzY2FuIG5hdGl2ZSBpbnRzLCBpbnQzMiBhbmQgaW50NjQgaW50ZWdlcnMuXG4gICBXZSBjYW5ub3QgYWNjZXNzIHRvIGNvbnZlcnNpb25zIHRvL2Zyb20gc3RyaW5ncyBmb3IgdGhvc2UgdHlwZXMsXG4gICBOYXRpdmVpbnQub2Zfc3RyaW5nLCBJbnQzMi5vZl9zdHJpbmcsIGFuZCBJbnQ2NC5vZl9zdHJpbmcsXG4gICBzaW5jZSB0aG9zZSBtb2R1bGVzIGFyZSBub3QgYXZhaWxhYmxlIHRvIFtTY2FuZl0uXG4gICBIb3dldmVyLCB3ZSBjYW4gYmluZCBhbmQgdXNlIHRoZSBjb3JyZXNwb25kaW5nIHByaW1pdGl2ZXMgdGhhdCBhcmVcbiAgIGF2YWlsYWJsZSBpbiB0aGUgcnVudGltZS4gKilcbmV4dGVybmFsIG5hdGl2ZWludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gbmF0aXZlaW50XG4gID0gXCJjYW1sX25hdGl2ZWludF9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQzMl9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50NjRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG5cblxubGV0IHRva2VuX25hdGl2ZWludCBjb252IGliID0gbmF0aXZlaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQzMiBjb252IGliID0gaW50MzJfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDY0IGNvbnYgaWIgPSBpbnQ2NF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbigqIFNjYW5uaW5nIG51bWJlcnMuICopXG5cbigqIERpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc3VwcG9zZSB0aGF0IG9uZSBjaGFyYWN0ZXIgaGFzIGJlZW4gY2hlY2tlZCBhbmRcbiAgIGlzIGF2YWlsYWJsZSwgc2luY2UgdGhleSByZXR1cm4gYXQgZW5kIG9mIGZpbGUgd2l0aCB0aGUgY3VycmVudGx5IGZvdW5kXG4gICB0b2tlbiBzZWxlY3RlZC5cblxuICAgUHV0IGl0IGluIGFub3RoZXIgd2F5LCB0aGUgZGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzY2FuIGZvciBhIHBvc3NpYmx5XG4gICBlbXB0eSBzZXF1ZW5jZSBvZiBkaWdpdHMsIChoZW5jZSwgYSBzdWNjZXNzZnVsIHNjYW5uaW5nIGZyb20gb25lIG9mIHRob3NlXG4gICBmdW5jdGlvbnMgZG9lcyBub3QgaW1wbHkgdGhhdCB0aGUgdG9rZW4gaXMgYSB3ZWxsLWZvcm1lZCBudW1iZXI6IHRvIGdldCBhXG4gICB0cnVlIG51bWJlciwgaXQgaXMgbWFuZGF0b3J5IHRvIGNoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIHZhbGlkIGRpZ2l0IGlzXG4gICBhdmFpbGFibGUgYmVmb3JlIGNhbGxpbmcgb25lIG9mIHRoZSBkaWdpdCBzY2FubmluZyBmdW5jdGlvbnMpLiAqKVxuXG4oKiBUaGUgZGVjaW1hbCBjYXNlIGlzIHRyZWF0ZWQgZXNwZWNpYWxseSBmb3Igb3B0aW1pemF0aW9uIHB1cnBvc2VzLiAqKVxubGV0IHJlYyBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8ICdfJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fZGVjaW1hbF9kaWdpdF9wbHVzIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImRlY2ltYWwgZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIGRlY2ltYWwgZGlnaXRcIiBjKVxuXG5cbigqIFRvIHNjYW4gbnVtYmVycyBmcm9tIG90aGVyIGJhc2VzLCB3ZSB1c2UgYSBwcmVkaWNhdGUgYXJndW1lbnQgdG9cbiAgIHNjYW4gZGlnaXRzLiAqKVxubGV0IHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fZGlnaXRzIHdpZHRoIGliID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCBjIHdoZW4gZGlnaXRwIGMgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8ICdfJyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCBfIC0+IHdpZHRoIGluXG4gIHNjYW5fZGlnaXRzIHdpZHRoIGliXG5cblxubGV0IHNjYW5fZGlnaXRfcGx1cyBiYXNpcyBkaWdpdHAgd2lkdGggaWIgPVxuICAoKiBFbnN1cmUgd2UgaGF2ZSBnb3QgZW5vdWdoIHdpZHRoIGxlZnQsXG4gICAgIGFuZCByZWFkIGF0IGxlYXN0IG9uZSBkaWdpdC4gKilcbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBkaWdpdHAgYyB0aGVuXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYlxuICBlbHNlXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSB2YWxpZCAlcyBkaWdpdFwiIGMgYmFzaXMpXG5cblxubGV0IGlzX2JpbmFyeV9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICcxJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2JpbmFyeV9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJiaW5hcnlcIiBpc19iaW5hcnlfZGlnaXRcblxubGV0IGlzX29jdGFsX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzcnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fb2N0YWxfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwib2N0YWxcIiBpc19vY3RhbF9kaWdpdFxuXG5sZXQgaXNfaGV4YV9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5faGV4YWRlY2ltYWxfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiaGV4YWRlY2ltYWxcIiBpc19oZXhhX2RpZ2l0XG5cbigqIFNjYW4gYSBkZWNpbWFsIGludGVnZXIuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCA9IHNjYW5fZGVjaW1hbF9kaWdpdF9wbHVzXG5cbmxldCBzY2FuX3NpZ24gd2lkdGggaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcrJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCAnLScgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FuIGFuIHVuc2lnbmVkIGludGVnZXIgdGhhdCBjb3VsZCBiZSBnaXZlbiBpbiBhbnkgKGNvbW1vbikgYmFzaXMuXG4gICBJZiBkaWdpdHMgYXJlIHByZWZpeGVkIGJ5IG9uZSBvZiAweCwgMFgsIDBvLCBvciAwYiwgdGhlIG51bWJlciBpc1xuICAgYXNzdW1lZCB0byBiZSB3cml0dGVuIHJlc3BlY3RpdmVseSBpbiBoZXhhZGVjaW1hbCwgaGV4YWRlY2ltYWwsXG4gICBvY3RhbCwgb3IgYmluYXJ5LiAqKVxubGV0IHNjYW5fdW5zaWduZWRfaW50IHdpZHRoIGliID1cbiAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIGJlZ2luIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnbycgLT4gc2Nhbl9vY3RhbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdiJyAtPiBzY2FuX2JpbmFyeV9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8IF8gLT4gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgZW5kXG4gIHwgXyAtPiBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fdW5zaWduZWRfaW50IHdpZHRoIGliXG5cblxubGV0IHNjYW5faW50X2NvbnZlcnNpb24gY29udiB3aWR0aCBpYiA9XG4gIG1hdGNoIGNvbnYgd2l0aFxuICB8IEJfY29udmVyc2lvbiAtPiBzY2FuX2JpbmFyeV9pbnQgd2lkdGggaWJcbiAgfCBEX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IElfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYlxuICB8IE9fY29udmVyc2lvbiAtPiBzY2FuX29jdGFsX2ludCB3aWR0aCBpYlxuICB8IFVfY29udmVyc2lvbiAtPiBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgWF9jb252ZXJzaW9uIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2Nhbm5pbmcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycy4gKilcblxuKCogRnJhY3Rpb25hbCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2ZyYWN0aW9uYWxfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG4oKiBFeHAgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICdlJyB8ICdFJyBhcyBjIC0+XG4gICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG4oKiBTY2FuIHRoZSBpbnRlZ2VyIHBhcnQgb2YgYSBmbG9hdGluZyBwb2ludCBudW1iZXIsIChub3QgdXNpbmcgdGhlXG4gICBPQ2FtbCBsZXhpY2FsIGNvbnZlbnRpb24gc2luY2UgdGhlIGludGVnZXIgcGFydCBjYW4gYmUgZW1wdHkpOlxuICAgYW4gb3B0aW9uYWwgc2lnbiwgZm9sbG93ZWQgYnkgYSBwb3NzaWJseSBlbXB0eSBzZXF1ZW5jZSBvZiBkZWNpbWFsXG4gICBkaWdpdHMgKGUuZy4gLS4xKS4gKilcbmxldCBzY2FuX2ludGVnZXJfcGFydCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuXG5cbigqXG4gICBGb3IgdGhlIHRpbWUgYmVpbmcgd2UgaGF2ZSAoYXMgZm91bmQgaW4gc2NhbmYubWxpKTpcbiAgIHRoZSBmaWVsZCB3aWR0aCBpcyBjb21wb3NlZCBvZiBhbiBvcHRpb25hbCBpbnRlZ2VyIGxpdGVyYWxcbiAgIGluZGljYXRpbmcgdGhlIG1heGltYWwgd2lkdGggb2YgdGhlIHRva2VuIHRvIHJlYWQuXG4gICBVbmZvcnR1bmF0ZWx5LCB0aGUgdHlwZS1jaGVja2VyIGxldCB0aGUgdXNlciB3cml0ZSBhbiBvcHRpb25hbCBwcmVjaXNpb24sXG4gICBzaW5jZSB0aGlzIGlzIHZhbGlkIGZvciBwcmludGYgZm9ybWF0IHN0cmluZ3MuXG5cbiAgIFRodXMsIHRoZSBuZXh0IHN0ZXAgZm9yIFNjYW5mIGlzIHRvIHN1cHBvcnQgYSBmdWxsIHdpZHRoIGFuZCBwcmVjaXNpb25cbiAgIGluZGljYXRpb24sIG1vcmUgb3IgbGVzcyBzaW1pbGFyIHRvIHRoZSBvbmUgZm9yIHByaW50ZiwgcG9zc2libHkgZXh0ZW5kZWRcbiAgIHRvIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGEgW21heCwgbWluXSByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkXG4gICBmb3Igc3RyaW5ncy4gU29tZXRoaW5nIGxpa2UgdGhlIGZvbGxvd2luZyBzcGVjIGZvciBzY2FuZi5tbGk6XG5cbiAgIFRoZSBvcHRpb25hbCBbd2lkdGhdIGlzIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbWF4aW1hbFxuICAgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuIEZvciBpbnN0YW5jZSwgWyU2ZF0gcmVhZHMgYW4gaW50ZWdlcixcbiAgIGhhdmluZyBhdCBtb3N0IDYgY2hhcmFjdGVycy5cblxuICAgVGhlIG9wdGlvbmFsIFtwcmVjaXNpb25dIGlzIGEgZG90IFsuXSBmb2xsb3dlZCBieSBhbiBpbnRlZ2VyOlxuXG4gICAtIGluIHRoZSBmbG9hdGluZyBwb2ludCBudW1iZXIgY29udmVyc2lvbnMgKFslZl0sIFslZV0sIFslZ10sIFslRl0sIFslRV0sXG4gICBhbmQgWyVGXSBjb252ZXJzaW9ucywgdGhlIFtwcmVjaXNpb25dIGluZGljYXRlcyB0aGUgbWF4aW11bSBudW1iZXIgb2ZcbiAgIGRpZ2l0cyB0aGF0IG1heSBmb2xsb3cgdGhlIGRlY2ltYWwgcG9pbnQuIEZvciBpbnN0YW5jZSwgWyUuNGZdIHJlYWRzIGFcbiAgIFtmbG9hdF0gd2l0aCBhdCBtb3N0IDQgZnJhY3Rpb25hbCBkaWdpdHMsXG5cbiAgIC0gaW4gdGhlIHN0cmluZyBjb252ZXJzaW9ucyAoWyVzXSwgWyVTXSwgWyVcXFsgcmFuZ2UgXFxdXSksIGFuZCBpbiB0aGVcbiAgIGludGVnZXIgbnVtYmVyIGNvbnZlcnNpb25zIChbJWldLCBbJWRdLCBbJXVdLCBbJXhdLCBbJW9dLCBhbmQgdGhlaXJcbiAgIFtpbnQzMl0sIFtpbnQ2NF0sIGFuZCBbbmF0aXZlX2ludF0gY29ycmVzcG9uZGVudCksIHRoZSBbcHJlY2lzaW9uXVxuICAgaW5kaWNhdGVzIHRoZSByZXF1aXJlZCBtaW5pbXVtIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLFxuXG4gICAtIG9uIGFsbCBvdGhlciBjb252ZXJzaW9ucywgdGhlIHdpZHRoIGFuZCBwcmVjaXNpb24gc3BlY2lmeSB0aGUgW21heCwgbWluXVxuICAgcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC5cbiopXG5sZXQgc2Nhbl9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX2ludGVnZXJfcGFydCB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcuJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGxldCBwcmVjaXNpb24gPSBJbnQubWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYikgaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuICB8IF8gLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuXG5cbmxldCBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBlcnJvciBzdHIgPVxuICBsZXQgbG93ZXJjYXNlIGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ0EnIC4uICdaJyAtPlxuICAgICAgY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKyBpbnRfb2ZfY2hhciAnYScpXG4gICAgfCBfIC0+IGMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCA9IHJlZiB3aWR0aCBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgbG93ZXJjYXNlIGMgPD4gbG93ZXJjYXNlIHN0ci5baV0gdGhlbiBlcnJvciAoKTtcbiAgICBpZiAhd2lkdGggPSAwIHRoZW4gZXJyb3IgKCk7XG4gICAgd2lkdGggOj0gU2Nhbm5pbmcuc3RvcmVfY2hhciAhd2lkdGggaWIgYztcbiAgZG9uZTtcbiAgIXdpZHRoXG5cblxubGV0IHNjYW5faGV4X2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGxldCB3aWR0aCA9IGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJ4XCIgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgICAgKVxuICAgICAgICAgIHwgXyAtPiB3aWR0aCBpblxuICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgICB8IF8gLT4gd2lkdGhcbiAgKVxuICB8ICduJyB8ICdOJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcImFuXCJcbiAgfCAnaScgfCAnSScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJuZmluaXR5XCJcbiAgfCBfIC0+IGJhZF9oZXhfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgKCogVGhlIGVmZmVjdGl2ZSB3aWR0aCBhdmFpbGFibGUgZm9yIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgaXNcbiAgICAgICB0aGUgbWluaW11bSBvZiBkZWNsYXJlZCBwcmVjaXNpb24gYW5kIHdpZHRoIGxlZnQuICopXG4gICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgKCogQWZ0ZXIgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB3aXRoIFtwcmVjaXNpb25dIHByb3Zpc2lvbmFsIHdpZHRoLFxuICAgICAgIFt3aWR0aF9wcmVjaXNpb25dIGlzIGxlZnQuICopXG4gICAgbGV0IHdpZHRoX3ByZWNpc2lvbiA9IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYiBpblxuICAgICgqIEhlbmNlLCBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHRvb2sgZXhhY3RseVxuICAgICAgIFtwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb25dIGNoYXJzLiAqKVxuICAgIGxldCBmcmFjX3dpZHRoID0gcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uIGluXG4gICAgKCogQW5kIG5ldyBwcm92aXNpb25hbCB3aWR0aCBpcyBbd2lkdGggLSB3aWR0aF9wcmVjaXNpb24uICopXG4gICAgbGV0IHdpZHRoID0gd2lkdGggLSBmcmFjX3dpZHRoIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliXG4gIHwgJ2UnIHwgJ0UnIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAneCcgfCAnWCcgYXMgYyAtPiAoXG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICApXG4gICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBiYWRfZmxvYXQgKCkgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgIHwgXyAtPiB3aWR0aFxuICAgIClcbiAgICB8IF8gLT5cbiAgICAgIHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYlxuICApXG4gIHwgJzEnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbigqIFNwZWNpYWwgY2FzZSBvZiBuYW4gYW5kIGluZmluaXR5OlxuICB8ICdpJyAtPlxuICB8ICduJyAtPlxuKilcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbigqIFNjYW4gYSByZWd1bGFyIHN0cmluZzpcbiAgIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIGEgc3BhY2UsIGlmIG5vIHNjYW5uaW5nIGluZGljYXRpb24gaGFzIGJlZW4gZ2l2ZW47XG4gICBvdGhlcndpc2UsIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzY2FubmluZ1xuICAgaW5kaWNhdGlvbiBbc3RwXS5cbiAgIEl0IGFsc28gc3RvcHMgYXQgZW5kIG9mIGZpbGUgb3Igd2hlbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBoYXNcbiAgIGJlZW4gcmVhZC4gKilcbmxldCBzY2FuX3N0cmluZyBzdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIGxvb3Agd2lkdGggPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIG1hdGNoIHN0cCB3aXRoXG4gICAgICB8IFNvbWUgYycgd2hlbiBjID0gYycgLT4gU2Nhbm5pbmcuc2tpcF9jaGFyIHdpZHRoIGliXG4gICAgICB8IFNvbWUgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGluXG4gIGxvb3Agd2lkdGhcblxuXG4oKiBTY2FuIGEgY2hhcjogcGVlayBzdHJpY3RseSBvbmUgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCwgd2hhdHNvZXZlci4gKilcbmxldCBzY2FuX2NoYXIgd2lkdGggaWIgPVxuICAoKiBUaGUgY2FzZSB3aWR0aCA9IDAgY291bGQgbm90IGhhcHBlbiBoZXJlLCBzaW5jZSBpdCBpcyB0ZXN0ZWQgYmVmb3JlXG4gICAgIGNhbGxpbmcgc2Nhbl9jaGFyLCBpbiB0aGUgbWFpbiBzY2FubmluZyBmdW5jdGlvbi5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiYSBjaGFyYWN0ZXJcIiBlbHNlICopXG4gIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliKVxuXG5cbmxldCBjaGFyX2Zvcl9iYWNrc2xhc2ggPSBmdW5jdGlvblxuICB8ICduJyAtPiAnXFwwMTAnXG4gIHwgJ3InIC0+ICdcXDAxMydcbiAgfCAnYicgLT4gJ1xcMDA4J1xuICB8ICd0JyAtPiAnXFwwMDknXG4gIHwgYyAtPiBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGRlY2ltYWwgZGlnaXQgY2hhcmFjdGVyLiAqKVxubGV0IGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID0gaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJ1xuXG5sZXQgY2hhcl9mb3JfZGVjaW1hbF9jb2RlIGMwIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDEwMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMCArXG4gICAgIDEwICogZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMxICtcbiAgICAgICAgICBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzIgaW5cbiAgaWYgYyA8IDAgfHwgYyA+IDI1NSB0aGVuXG4gICAgYmFkX2lucHV0XG4gICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgIFwiYmFkIGNoYXJhY3RlciBkZWNpbWFsIGVuY29kaW5nIFxcXFwlYyVjJWNcIiBjMCBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGhleGFkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMgPVxuICBsZXQgZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgKCogQ291bGQgYWxzbyBiZTpcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICc5JyB0aGVuIGQgLSBpbnRfb2ZfY2hhciAnMCcgZWxzZVxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJ0YnIHRoZW4gMTAgKyBkIC0gaW50X29mX2NoYXIgJ0EnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdmJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdhJyBlbHNlIGFzc2VydCBmYWxzZVxuICAqKVxuICBpZiBkID49IGludF9vZl9jaGFyICdhJyB0aGVuXG4gICAgZCAtIDg3ICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdhJyAqKSBlbHNlXG4gIGlmIGQgPj0gaW50X29mX2NoYXIgJ0EnIHRoZW5cbiAgICBkIC0gNTUgICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdBJyAqKSBlbHNlXG4gICAgZCAtIGludF9vZl9jaGFyICcwJ1xuXG5cbmxldCBjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDE2ICogaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmIFwiYmFkIGNoYXJhY3RlciBoZXhhZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlY1wiIGMxIGMyKSBlbHNlXG4gIGNoYXJfb2ZfaW50IGNcblxuXG4oKiBDYWxsZWQgaW4gcGFydGljdWxhciB3aGVuIGVuY291bnRlcmluZyAnXFxcXCcgYXMgc3RhcnRlciBvZiBhIGNoYXIuXG4gICBTdG9wcyBiZWZvcmUgdGhlIGNvcnJlc3BvbmRpbmcgJ1xcJycuICopXG5sZXQgY2hlY2tfbmV4dF9jaGFyIG1lc3NhZ2Ugd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgZWxzZVxuICBjXG5cblxubGV0IGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciA9IGNoZWNrX25leHRfY2hhciBcImEgQ2hhclwiXG5sZXQgY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgPSBjaGVja19uZXh0X2NoYXIgXCJhIFN0cmluZ1wiXG5cbmxldCBzY2FuX2JhY2tzbGFzaF9jaGFyIHdpZHRoIGliID1cbiAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgfCAnXFxcXCcgfCAnXFwnJyB8ICdcXFwiJyB8ICduJyB8ICd0JyB8ICdiJyB8ICdyJyBhcyBjIC0+XG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAoY2hhcl9mb3JfYmFja3NsYXNoIGMpXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgYXMgYyAtPiBjXG4gICAgICB8IGMgLT4gYmFkX2lucHV0X2VzY2FwZSBjIGluXG4gICAgbGV0IGMwID0gYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMilcbiAgfCAneCcgLT5cbiAgICBsZXQgZ2V0X2RpZ2l0ICgpID1cbiAgICAgIGxldCBjID0gU2Nhbm5pbmcubmV4dF9jaGFyIGliIGluXG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgfCAnYScgLi4gJ2YnIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2hleGFkZWNpbWFsX2NvZGUgYzEgYzIpXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dF9lc2NhcGUgY1xuXG5cbigqIFNjYW4gYSBjaGFyYWN0ZXIgKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2NhbWxfY2hhciB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBmaW5kX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgY1xuXG4gIGFuZCBmaW5kX2NoYXIgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxcXCcgLT5cbiAgICAgIGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpIGliKVxuICAgIHwgYyAtPlxuICAgICAgZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXCcnIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFwnJyBjIGluXG5cbiAgZmluZF9zdGFydCB3aWR0aFxuXG5cbigqIFNjYW4gYSBkZWxpbWl0ZWQgc3RyaW5nIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFxcIicgLT4gZmluZF9zdG9wIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXFwiJyBjXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCAnXFxcXCcgLT4gc2Nhbl9iYWNrc2xhc2ggKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcblxuICBhbmQgc2Nhbl9iYWNrc2xhc2ggd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXHInIC0+IHNraXBfbmV3bGluZSAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYilcblxuICBhbmQgc2tpcF9uZXdsaW5lIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAnXFxyJylcblxuICBhbmQgc2tpcF9zcGFjZXMgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICcgJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCB3aWR0aCBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgYm9vbGVhbiAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fYm9vbCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbGV0IG0gPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3QnIC0+IDRcbiAgICB8ICdmJyAtPiA1XG4gICAgfCBjIC0+XG4gICAgICBiYWRfaW5wdXRcbiAgICAgICAgKFByaW50Zi5zcHJpbnRmIFwidGhlIGNoYXJhY3RlciAlQyBjYW5ub3Qgc3RhcnQgYSBib29sZWFuXCIgYykgaW5cbiAgc2Nhbl9zdHJpbmcgTm9uZSBtIGliXG5cblxuKCogU2NhbiBhIHN0cmluZyBjb250YWluaW5nIGVsZW1lbnRzIGluIGNoYXJfc2V0IGFuZCB0ZXJtaW5hdGVkIGJ5IHNjYW5faW5kaWNcbiAgIGlmIHByb3ZpZGVkLiAqKVxubGV0IHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgc2Nhbl9pbmRpYyB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9jaGFycyBpIHN0cCA9XG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpID4gMCAmJiBub3QgKFNjYW5uaW5nLmVvZiBpYikgJiZcbiAgICAgICBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjICYmXG4gICAgICAgaW50X29mX2NoYXIgYyA8PiBzdHAgdGhlblxuICAgICAgbGV0IF8gPSBTY2FubmluZy5zdG9yZV9jaGFyIG1heF9pbnQgaWIgYyBpblxuICAgICAgc2Nhbl9jaGFycyAoaSAtIDEpIHN0cCBpblxuICBtYXRjaCBzY2FuX2luZGljIHdpdGhcbiAgfCBOb25lIC0+IHNjYW5fY2hhcnMgd2lkdGggKC0xKTtcbiAgfCBTb21lIGMgLT5cbiAgICBzY2FuX2NoYXJzIHdpZHRoIChpbnRfb2ZfY2hhciBjKTtcbiAgICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlblxuICAgICAgbGV0IGNpID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgICBpZiBjID0gY2lcbiAgICAgIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgICAgIGVsc2UgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuXG4oKiBUaGUgZ2xvYmFsIGVycm9yIHJlcG9ydCBmdW5jdGlvbiBmb3IgW1NjYW5mXS4gKilcbmxldCBzY2FuZl9iYWRfaW5wdXQgaWIgPSBmdW5jdGlvblxuICB8IFNjYW5fZmFpbHVyZSBzIHwgRmFpbHVyZSBzIC0+XG4gICAgbGV0IGkgPSBTY2FubmluZy5jaGFyX2NvdW50IGliIGluXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcInNjYW5mOiBiYWQgaW5wdXQgYXQgY2hhciBudW1iZXIgJWk6ICVzXCIgaSBzKVxuICB8IHggLT4gcmFpc2UgeFxuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiBhIGNvdW50ZXIgZnJvbSBhbiBpbnB1dCBidWZmZXIuICopXG5sZXQgZ2V0X2NvdW50ZXIgaWIgY291bnRlciA9XG4gIG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAtPiBTY2FubmluZy5saW5lX2NvdW50IGliXG4gIHwgQ2hhcl9jb3VudGVyIC0+IFNjYW5uaW5nLmNoYXJfY291bnQgaWJcbiAgfCBUb2tlbl9jb3VudGVyIC0+IFNjYW5uaW5nLnRva2VuX2NvdW50IGliXG5cblxuKCogQ29tcHV0ZSB0aGUgd2lkdGggb2YgYSBwYWRkaW5nIG9wdGlvbiAoc2VlIFwiJTQye1wiIGFuZCBcIiUxMjMoXCIpLiAqKVxubGV0IHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gbWF4X2ludFxuICB8IFNvbWUgd2lkdGggLT4gd2lkdGhcblxuXG5sZXQgc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmcgPVxuICBpZiBmbXRpbmcgPSBFc2NhcGVkX3BlcmNlbnQgdGhlbiAnJScsIFwiXCIgZWxzZVxuICAgIGxldCBzdHIgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nIGluXG4gICAgbGV0IHN0cCA9IHN0ci5bMV0gaW5cbiAgICBsZXQgc3ViX3N0ciA9IFN0cmluZy5zdWIgc3RyIDIgKFN0cmluZy5sZW5ndGggc3RyIC0gMikgaW5cbiAgICBzdHAsIHN1Yl9zdHJcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUmVhZGVyIG1hbmFnZW1lbnQgKilcblxuKCogQSBjYWxsIHRvIHRha2VfZm9ybWF0X3JlYWRlcnMgb24gYSBmb3JtYXQgaXMgZXZhbHVhdGVkIGludG8gZnVuY3Rpb25zXG4gICB0YWtpbmcgcmVhZGVycyBhcyBhcmd1bWVudHMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYW4gaGV0ZXJvZ2VuZW91cyBsaXN0ICopXG4oKiBXaGVuIGFsbCByZWFkZXJzIGFyZSB0YWtlbiwgZmluYWxseSBwYXNzIHRoZSBsaXN0IG9mIHRoZSByZWFkZXJzIHRvIHRoZVxuICAgY29udGludWF0aW9uIGsuICopXG5sZXQgcmVjIHRha2VfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICBkID1cbmZ1biBrIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IFJlYWRlciBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0XG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFN0cmluZyAoXywgcmVzdCkgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9zdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludDMyIChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgTmF0aXZlaW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQ2NCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsb2F0IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQm9vbCAoXywgcmVzdCkgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ3VzdG9tIChfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSksIHJlc3QpIC0+XG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXQgZm10IHJlc3QpXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAgICAtPlxuICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAgICAgICAtPiB0YWtlX2lnbm9yZWRfZm9ybWF0X3JlYWRlcnMgayBpZ24gcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgICAgICAgLT4gayBOaWxcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gZm10dHkgY29taW5nIGZyb20gYSBGb3JtYXRfc3Vic3QgXCIlKC4uLiUpXCIuICopXG5hbmQgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBmbXR0eSAtPlxuICAgICAgKHksIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIHgsIGUsIGYpIGZtdCAtPiBkID1cbmZ1biBrIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgUmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdCBmbXRcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gaWdub3JlZCBwYXJhbWV0ZXIuICopXG5hbmQgdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSB4IHkgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIHgsIHkpIGlnbm9yZWQgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBzY2FubmluZyAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBzY2FubmluZyBmdW5jdGlvbi4gKilcbigqIFNjYW4gYSBzdHJlYW0gYWNjb3JkaW5nIHRvIGEgZm9ybWF0IGFuZCByZWFkZXJzIG9idGFpbmVkIGJ5XG4gICB0YWtlX2Zvcm1hdF9yZWFkZXJzLCBhbmQgYWdncmVnYXRlIHNjYW5uZWQgdmFsdWVzIGludG8gYW5cbiAgIGhldGVyb2dlbmVvdXMgbGlzdC4gKilcbigqIFJldHVybiB0aGUgaGV0ZXJvZ2VuZW91cyBsaXN0IG9mIHNjYW5uZWQgdmFsdWVzLiAqKVxubGV0IHJlYyBtYWtlX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoYSwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9jaGFyIDAgaWIgaW5cbiAgICBsZXQgYyA9IHRva2VuX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcblxuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lIHN0cCkgd2lkdGggaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgJ3snKSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW5cbiAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICdbJykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIE5vbmUgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQgYylcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50MzIgYylcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX25hdGl2ZWludCBjKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQ2NCBjKVxuICB8IEZsb2F0ICgoXywgKEZsb2F0X0YgfCBGbG9hdF9DRikpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fY2FtbF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HKSksXG4gICAgICAgICAgIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2ggfCBGbG9hdF9IKSksIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9oZXhfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gXyBfIGliID0gc2Nhbl9ib29sIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9ib29sXG4gIHwgQWxwaGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlYVxcXCJcIlxuICB8IFRoZXRhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJXRcXFwiXCJcbiAgfCBDdXN0b20gXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlP1xcXCIgKGN1c3RvbSBjb252ZXJ0ZXIpXCJcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBiZWdpbiBtYXRjaCByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSAtPlxuICAgICAgICBsZXQgeCA9IHJlYWRlciBpYiBpblxuICAgICAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdF9yZXN0IHJlYWRlcnNfcmVzdClcbiAgICB8IE5pbCAtPlxuICAgICAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBtaXNzaW5nIHJlYWRlclwiXG4gICAgZW5kXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIGlmIFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gICAgZWxzZSBiYWRfaW5wdXQgXCJlbmQgb2YgaW5wdXQgbm90IGZvdW5kXCJcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIHN0cjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgY2hyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgcyBmbXR0eVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChmbXQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10LCBmbXQnID1cbiAgICAgIHRyeVxuICAgICAgICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCcgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgICgqIFRPRE86IGZpbmQgYSB3YXkgdG8gYXZvaWQgcmVwYXJzaW5nIHR3aWNlICopXG5cbiAgICAgICAgKCogVE9ETzogdGhlc2UgdHlwZS1jaGVja3MgYmVsb3cgKmNhbiogZmFpbCBiZWNhdXNlIG9mIHR5cGVcbiAgICAgICAgICAgYW1iaWd1aXR5IGluIHByZXNlbmNlIG9mIGlnbm9yZWQtcmVhZGVyczogXCIlX3IlZFwiIGFuZCBcIiVkJV9yXCJcbiAgICAgICAgICAgYXJlIHR5cGVkIGluIHRoZSBzYW1lIHdheS5cblxuICAgICAgICAgICAjIFNjYW5mLnNzY2FuZiBcIlxcXCIlX3IlZFxcXCIzXCIgXCIlKCVkJV9yJSlcIiBpZ25vcmVcbiAgICAgICAgICAgICAoZnVuIGZtdCBuIC0+IHN0cmluZ19vZl9mb3JtYXQgZm10LCBuKVxuICAgICAgICAgICBFeGNlcHRpb246IENhbWxpbnRlcm5hbEZvcm1hdC5UeXBlX21pc21hdGNoLlxuXG4gICAgICAgICAgIFdlIHNob3VsZCBwcm9wZXJseSBjYXRjaCB0aGlzIGV4Y2VwdGlvbi5cbiAgICAgICAgKilcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgZm10dHkpLFxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQnIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChGb3JtYXQgKGZtdCwgcyksXG4gICAgICAgICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IChTb21lIHN0cCkgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBOb25lIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBsZXQgY291bnQgPSBnZXRfY291bnRlciBpYiBjb3VudGVyIGluXG4gICAgQ29ucyAoY291bnQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQpO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAneyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICdbJztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICBiZWdpbiBtYXRjaCBtYWtlX3NjYW5mIGliIGZtdCcgcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChfLCBhcmdfcmVzdCkgLT4gYXJnX3Jlc3RcbiAgICB8IE5pbCAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBOaWxcblxuKCogQ2FzZSBhbmFseXNpcyBvbiBwYWRkaW5nIGFuZCBwcmVjaXNpb24uICopXG4oKiBSZWplY3QgZm9ybWF0cyBjb250YWluaW5nIFwiJSpcIiBvciBcIiUuKlwiLiAqKVxuKCogUGFzcyBwYWRkaW5nIGFuZCBwcmVjaXNpb24gdG8gdGhlIGdlbmVyaWMgc2Nhbm5lciBgc2NhbicuICopXG5hbmQgcGFkX3ByZWNfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZiB4IHkgeiB0IC5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+ICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPlxuICAgICAgKGludCAtPiBpbnQgLT4gU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB0KSAtPlxuICAgICAgKFNjYW5uaW5nLmluX2NoYW5uZWwgLT4geikgLT5cbiAgICAgICh4LCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyBwYWQgcHJlYyBzY2FuIHRva2VuIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKExlZnQsIF8pLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUtXFxcIlwiXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgXyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBBcmdfcGFkZGluZyBfLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgKCogRGVmaW5pbmcgW3NjYW5mXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtzY2FuZl0gKilcblxudHlwZSAnYSBrc2NhbmZfcmVzdWx0ID0gQXJncyBvZiAnYSB8IEV4YyBvZiBleG5cblxubGV0IGtzY2FuZiBpYiBlZiAoRm9ybWF0IChmbXQsIHN0cikpID1cbiAgbGV0IHJlYyBhcHBseSA6IHR5cGUgYSBiIC4gYSAtPiAoYSwgYikgaGV0ZXJfbGlzdCAtPiBiID1cbiAgICBmdW4gZiBhcmdzIC0+IG1hdGNoIGFyZ3Mgd2l0aFxuICAgIHwgQ29ucyAoeCwgcikgLT4gYXBwbHkgKGYgeCkgclxuICAgIHwgTmlsIC0+IGZcbiAgaW5cbiAgbGV0IGsgcmVhZGVycyBmID1cbiAgICBTY2FubmluZy5yZXNldF90b2tlbiBpYjtcbiAgICBtYXRjaCB0cnkgQXJncyAobWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycykgd2l0aFxuICAgICAgfCAoU2Nhbl9mYWlsdXJlIF8gfCBGYWlsdXJlIF8gfCBFbmRfb2ZfZmlsZSkgYXMgZXhjIC0+IEV4YyBleGNcbiAgICAgIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgKG1zZyBeIFwiIGluIGZvcm1hdCBcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzdHIgXiBcIlxcXCJcIilcbiAgICB3aXRoXG4gICAgICB8IEFyZ3MgYXJncyAtPiBhcHBseSBmIGFyZ3NcbiAgICAgIHwgRXhjIGV4YyAtPiBlZiBpYiBleGNcbiAgaW5cbiAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG4oKioqKVxuXG5sZXQga2JzY2FuZiA9IGtzY2FuZlxubGV0IGJzY2FuZiBpYiBmbXQgPSBrYnNjYW5mIGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxubGV0IGtzc2NhbmYgcyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBlZiBmbXRcbmxldCBzc2NhbmYgcyBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBzY2FuZiBmbXQgPSBrc2NhbmYgU2Nhbm5pbmcuc3RkaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG4oKioqKVxuXG4oKiBTY2FubmluZyBmb3JtYXQgc3RyaW5ncy4gKilcbmxldCBic2NhbmZfZm9ybWF0IDpcbiAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIGliIGZvcm1hdCBmIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nIG1heF9pbnQgaWIgaW5cbiAgICBsZXQgc3RyID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCcgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciBmb3JtYXRcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZyBpblxuICAgIGYgZm10J1xuXG5cbmxldCBzc2NhbmZfZm9ybWF0IDpcbiAgc3RyaW5nIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gcyBmb3JtYXQgZiAtPiBic2NhbmZfZm9ybWF0IChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBmb3JtYXQgZlxuXG5cbmxldCBmb3JtYXRfZnJvbV9zdHJpbmcgcyBmbXQgPVxuICBzc2NhbmZfZm9ybWF0IChcIlxcXCJcIiBeIFN0cmluZy5lc2NhcGVkIHMgXiBcIlxcXCJcIikgZm10IChmdW4geCAtPiB4KVxuXG5cbmxldCB1bmVzY2FwZWQgcyA9XG4gIHNzY2FuZiAoXCJcXFwiXCIgXiBzIF4gXCJcXFwiXCIpIFwiJVMlIVwiIChmdW4geCAtPiB4KVxuXG5cbigqIERlcHJlY2F0ZWQgKilcbmxldCBrZnNjYW5mIGljIGVmIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLm1lbW9fZnJvbV9jaGFubmVsIGljKSBlZiBmbXRcbmxldCBmc2NhbmYgaWMgZm10ID0ga3NjYW5mIChTY2FubmluZy5tZW1vX2Zyb21fY2hhbm5lbCBpYykgc2NhbmZfYmFkX2lucHV0IGZtdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBSZWdpc3RlcmluZyBPQ2FtbCB2YWx1ZXMgd2l0aCB0aGUgQyBydW50aW1lIGZvciBsYXRlciBjYWxsYmFja3MgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gT2JqLnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgcmVnaXN0ZXIgbmFtZSB2ID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSAoT2JqLnJlcHIgdilcblxubGV0IHJlZ2lzdGVyX2V4Y2VwdGlvbiBuYW1lIChleG4gOiBleG4pID1cbiAgbGV0IGV4biA9IE9iai5yZXByIGV4biBpblxuICBsZXQgc2xvdCA9IGlmIE9iai50YWcgZXhuID0gT2JqLm9iamVjdF90YWcgdGhlbiBleG4gZWxzZSBPYmouZmllbGQgZXhuIDAgaW5cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSBzbG90XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICBKZXJvbWUgVm91aWxsb24sIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gT2JqXG5cbigqKioqIE9iamVjdCByZXByZXNlbnRhdGlvbiAqKioqKVxuXG5leHRlcm5hbCBzZXRfaWQ6ICdhIC0+ICdhID0gXCJjYW1sX3NldF9vb19pZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIE9iamVjdCBjb3B5ICoqKiopXG5cbmxldCBjb3B5IG8gPVxuICBsZXQgbyA9IChPYmoub2JqIChPYmouZHVwIChPYmoucmVwciBvKSkpIGluXG4gIHNldF9pZCBvXG5cbigqKioqIENvbXByZXNzaW9uIG9wdGlvbnMgKioqKilcbigqIFBhcmFtZXRlcnMgKilcbnR5cGUgcGFyYW1zID0ge1xuICAgIG11dGFibGUgY29tcGFjdF90YWJsZSA6IGJvb2w7XG4gICAgbXV0YWJsZSBjb3B5X3BhcmVudCA6IGJvb2w7XG4gICAgbXV0YWJsZSBjbGVhbl93aGVuX2NvcHlpbmcgOiBib29sO1xuICAgIG11dGFibGUgcmV0cnlfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBidWNrZXRfc21hbGxfc2l6ZSA6IGludFxuICB9XG5cbmxldCBwYXJhbXMgPSB7XG4gIGNvbXBhY3RfdGFibGUgPSB0cnVlO1xuICBjb3B5X3BhcmVudCA9IHRydWU7XG4gIGNsZWFuX3doZW5fY29weWluZyA9IHRydWU7XG4gIHJldHJ5X2NvdW50ID0gMztcbiAgYnVja2V0X3NtYWxsX3NpemUgPSAxNlxufVxuXG4oKioqKiBQYXJhbWV0ZXJzICoqKiopXG5cbmxldCBpbml0aWFsX29iamVjdF9zaXplID0gMlxuXG4oKioqKiBJdGVtcyAqKioqKVxuXG50eXBlIGl0ZW0gPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbmxldCBkdW1teV9pdGVtID0gKG1hZ2ljICgpIDogaXRlbSlcblxuKCoqKiogVHlwZXMgKioqKilcblxudHlwZSB0YWdcbnR5cGUgbGFiZWwgPSBpbnRcbnR5cGUgY2xvc3VyZSA9IGl0ZW1cbnR5cGUgdCA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxudHlwZSBvYmogPSB0IGFycmF5XG5leHRlcm5hbCByZXQgOiAob2JqIC0+ICdhKSAtPiBjbG9zdXJlID0gXCIlaWRlbnRpdHlcIlxuXG4oKioqKiBMYWJlbHMgKioqKilcblxubGV0IHB1YmxpY19tZXRob2RfbGFiZWwgcyA6IHRhZyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9IDIyMyAqICFhY2N1ICsgQ2hhci5jb2RlIHMuW2ldXG4gIGRvbmU7XG4gICgqIHJlZHVjZSB0byAzMSBiaXRzICopXG4gIGFjY3UgOj0gIWFjY3UgbGFuZCAoMSBsc2wgMzEgLSAxKTtcbiAgKCogbWFrZSBpdCBzaWduZWQgZm9yIDY0IGJpdHMgYXJjaGl0ZWN0dXJlcyAqKVxuICBsZXQgdGFnID0gaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3UgaW5cbiAgKCogUHJpbnRmLmVwcmludGYgXCIlcyA9ICVkXFxuXCIgcyB0YWc7IGZsdXNoIHN0ZGVycjsgKilcbiAgbWFnaWMgdGFnXG5cbigqKioqIFNwYXJzZSBhcnJheSAqKioqKVxuXG5tb2R1bGUgVmFycyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgdmFycyA9IGludCBWYXJzLnRcblxubW9kdWxlIE1ldGhzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBtZXRocyA9IGxhYmVsIE1ldGhzLnRcbm1vZHVsZSBMYWJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IGxhYmVsIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIGxhYnMgPSBib29sIExhYnMudFxuXG4oKiBUaGUgY29tcGlsZXIgYXNzdW1lcyB0aGF0IHRoZSBmaXJzdCBmaWVsZCBvZiB0aGlzIHN0cnVjdHVyZSBpcyBbc2l6ZV0uICopXG50eXBlIHRhYmxlID1cbiB7IG11dGFibGUgc2l6ZTogaW50O1xuICAgbXV0YWJsZSBtZXRob2RzOiBjbG9zdXJlIGFycmF5O1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X25hbWU6IG1ldGhzO1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X2xhYmVsOiBsYWJzO1xuICAgbXV0YWJsZSBwcmV2aW91c19zdGF0ZXM6XG4gICAgIChtZXRocyAqIGxhYnMgKiAobGFiZWwgKiBpdGVtKSBsaXN0ICogdmFycyAqXG4gICAgICBsYWJlbCBsaXN0ICogc3RyaW5nIGxpc3QpIGxpc3Q7XG4gICBtdXRhYmxlIGhpZGRlbl9tZXRoczogKGxhYmVsICogaXRlbSkgbGlzdDtcbiAgIG11dGFibGUgdmFyczogdmFycztcbiAgIG11dGFibGUgaW5pdGlhbGl6ZXJzOiAob2JqIC0+IHVuaXQpIGxpc3QgfVxuXG5sZXQgZHVtbXlfdGFibGUgPVxuICB7IG1ldGhvZHMgPSBbfCBkdW1teV9pdGVtIHxdO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSAwIH1cblxubGV0IHRhYmxlX2NvdW50ID0gcmVmIDBcblxuKCogZHVtbXlfbWV0IHNob3VsZCBiZSBhIHBvaW50ZXIsIHNvIHVzZSBhbiBhdG9tICopXG5sZXQgZHVtbXlfbWV0IDogaXRlbSA9IG9iaiAoT2JqLm5ld19ibG9jayAwIDApXG4oKiBpZiBkZWJ1Z2dpbmcgaXMgbmVlZGVkLCB0aGlzIGNvdWxkIGJlIGEgZ29vZCBpZGVhOiAqKVxuKCogbGV0IGR1bW15X21ldCAoKSA9IGZhaWx3aXRoIFwiVW5kZWZpbmVkIG1ldGhvZFwiICopXG5cbmxldCByZWMgZml0X3NpemUgbiA9XG4gIGlmIG4gPD0gMiB0aGVuIG4gZWxzZVxuICBmaXRfc2l6ZSAoKG4rMSkvMikgKiAyXG5cbmxldCBuZXdfdGFibGUgcHViX2xhYmVscyA9XG4gIGluY3IgdGFibGVfY291bnQ7XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggcHViX2xhYmVscyBpblxuICBsZXQgbWV0aG9kcyA9IEFycmF5Lm1ha2UgKGxlbioyKzIpIGR1bW15X21ldCBpblxuICBtZXRob2RzLigwKSA8LSBtYWdpYyBsZW47XG4gIG1ldGhvZHMuKDEpIDwtIG1hZ2ljIChmaXRfc2l6ZSBsZW4gKiBTeXMud29yZF9zaXplIC8gOCAtIDEpO1xuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkbyBtZXRob2RzLihpKjIrMykgPC0gbWFnaWMgcHViX2xhYmVscy4oaSkgZG9uZTtcbiAgeyBtZXRob2RzID0gbWV0aG9kcztcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gaW5pdGlhbF9vYmplY3Rfc2l6ZSB9XG5cbmxldCByZXNpemUgYXJyYXkgbmV3X3NpemUgPVxuICBsZXQgb2xkX3NpemUgPSBBcnJheS5sZW5ndGggYXJyYXkubWV0aG9kcyBpblxuICBpZiBuZXdfc2l6ZSA+IG9sZF9zaXplIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3X2J1Y2sgPSBBcnJheS5tYWtlIG5ld19zaXplIGR1bW15X21ldCBpblxuICAgIEFycmF5LmJsaXQgYXJyYXkubWV0aG9kcyAwIG5ld19idWNrIDAgb2xkX3NpemU7XG4gICAgYXJyYXkubWV0aG9kcyA8LSBuZXdfYnVja1xuIGVuZFxuXG5sZXQgcHV0IGFycmF5IGxhYmVsIGVsZW1lbnQgPVxuICByZXNpemUgYXJyYXkgKGxhYmVsICsgMSk7XG4gIGFycmF5Lm1ldGhvZHMuKGxhYmVsKSA8LSBlbGVtZW50XG5cbigqKioqIENsYXNzZXMgKioqKilcblxubGV0IG1ldGhvZF9jb3VudCA9IHJlZiAwXG5sZXQgaW5zdF92YXJfY291bnQgPSByZWYgMFxuXG4oKiB0eXBlIHQgKilcbnR5cGUgbWV0aCA9IGl0ZW1cblxubGV0IG5ld19tZXRob2QgdGFibGUgPVxuICBsZXQgaW5kZXggPSBBcnJheS5sZW5ndGggdGFibGUubWV0aG9kcyBpblxuICByZXNpemUgdGFibGUgKGluZGV4ICsgMSk7XG4gIGluZGV4XG5cbmxldCBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG5hbWUgPVxuICB0cnlcbiAgICBNZXRocy5maW5kIG5hbWUgdGFibGUubWV0aG9kc19ieV9uYW1lXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGxhYmVsID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBNZXRocy5hZGQgbmFtZSBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWJlbCB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWw7XG4gICAgbGFiZWxcblxubGV0IGdldF9tZXRob2RfbGFiZWxzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBuYW1lc1xuXG5sZXQgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBlbGVtZW50ID1cbiAgaW5jciBtZXRob2RfY291bnQ7XG4gIGlmIExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHRoZW5cbiAgICBwdXQgdGFibGUgbGFiZWwgZWxlbWVudFxuICBlbHNlXG4gICAgdGFibGUuaGlkZGVuX21ldGhzIDwtIChsYWJlbCwgZWxlbWVudCkgOjogdGFibGUuaGlkZGVuX21ldGhzXG5cbmxldCBnZXRfbWV0aG9kIHRhYmxlIGxhYmVsID1cbiAgdHJ5IExpc3QuYXNzb2MgbGFiZWwgdGFibGUuaGlkZGVuX21ldGhzXG4gIHdpdGggTm90X2ZvdW5kIC0+IHRhYmxlLm1ldGhvZHMuKGxhYmVsKVxuXG5sZXQgdG9fbGlzdCBhcnIgPVxuICBpZiBhcnIgPT0gbWFnaWMgMCB0aGVuIFtdIGVsc2UgQXJyYXkudG9fbGlzdCBhcnJcblxubGV0IG5hcnJvdyB0YWJsZSB2YXJzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgPVxuICBsZXQgdmFycyA9IHRvX2xpc3QgdmFyc1xuICBhbmQgdmlydF9tZXRocyA9IHRvX2xpc3QgdmlydF9tZXRoc1xuICBhbmQgY29uY3JfbWV0aHMgPSB0b19saXN0IGNvbmNyX21ldGhzIGluXG4gIGxldCB2aXJ0X21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSB2aXJ0X21ldGhzIGluXG4gIGxldCBjb25jcl9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgY29uY3JfbWV0aHMgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtXG4gICAgICh0YWJsZS5tZXRob2RzX2J5X25hbWUsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwsIHRhYmxlLmhpZGRlbl9tZXRocyxcbiAgICAgIHRhYmxlLnZhcnMsIHZpcnRfbWV0aF9sYWJzLCB2YXJzKVxuICAgICA6OiB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICBWYXJzLmZvbGRcbiAgICAgIChmdW4gbGFiIGluZm8gdHZhcnMgLT5cbiAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZhcnMgdGhlbiBWYXJzLmFkZCBsYWIgaW5mbyB0dmFycyBlbHNlIHR2YXJzKVxuICAgICAgdGFibGUudmFycyBWYXJzLmVtcHR5O1xuICBsZXQgYnlfbmFtZSA9IHJlZiBNZXRocy5lbXB0eSBpblxuICBsZXQgYnlfbGFiZWwgPSByZWYgTGFicy5lbXB0eSBpblxuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj1cbiAgICAgICAgICBMYWJzLmFkZCBsYWJlbFxuICAgICAgICAgICAgKHRyeSBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB3aXRoIE5vdF9mb3VuZCAtPiB0cnVlKVxuICAgICAgICAgICAgIWJ5X2xhYmVsKVxuICAgIGNvbmNyX21ldGhzIGNvbmNyX21ldGhfbGFicztcbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9IExhYnMuYWRkIGxhYmVsIGZhbHNlICFieV9sYWJlbClcbiAgICB2aXJ0X21ldGhzIHZpcnRfbWV0aF9sYWJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gIWJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gIWJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhfbGFicyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBbXVxuXG5sZXQgd2lkZW4gdGFibGUgPVxuICBsZXQgKGJ5X25hbWUsIGJ5X2xhYmVsLCBzYXZlZF9oaWRkZW5fbWV0aHMsIHNhdmVkX3ZhcnMsIHZpcnRfbWV0aHMsIHZhcnMpID1cbiAgICBMaXN0LmhkIHRhYmxlLnByZXZpb3VzX3N0YXRlc1xuICBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC0gTGlzdC50bCB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAoZnVuIHMgdiAtPiBWYXJzLmFkZCB2IChWYXJzLmZpbmQgdiB0YWJsZS52YXJzKSBzKVxuICAgICAgIHNhdmVkX3ZhcnMgdmFycztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIGJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aHMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgc2F2ZWRfaGlkZGVuX21ldGhzXG5cbmxldCBuZXdfc2xvdCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IHRhYmxlLnNpemUgaW5cbiAgdGFibGUuc2l6ZSA8LSBpbmRleCArIDE7XG4gIGluZGV4XG5cbmxldCBuZXdfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGluZGV4ID0gbmV3X3Nsb3QgdGFibGUgaW5cbiAgICBpZiBuYW1lIDw+IFwiXCIgdGhlbiB0YWJsZS52YXJzIDwtIFZhcnMuYWRkIG5hbWUgaW5kZXggdGFibGUudmFycztcbiAgICBpbmRleFxuXG5sZXQgdG9fYXJyYXkgYXJyID1cbiAgaWYgYXJyID0gT2JqLm1hZ2ljIDAgdGhlbiBbfHxdIGVsc2UgYXJyXG5cbmxldCBuZXdfbWV0aG9kc192YXJpYWJsZXMgdGFibGUgbWV0aHMgdmFscyA9XG4gIGxldCBtZXRocyA9IHRvX2FycmF5IG1ldGhzIGluXG4gIGxldCBubWV0aHMgPSBBcnJheS5sZW5ndGggbWV0aHMgYW5kIG52YWxzID0gQXJyYXkubGVuZ3RoIHZhbHMgaW5cbiAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgKG5tZXRocyArIG52YWxzKSAwIGluXG4gIGZvciBpID0gMCB0byBubWV0aHMgLSAxIGRvXG4gICAgcmVzLihpKSA8LSBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG1ldGhzLihpKVxuICBkb25lO1xuICBmb3IgaSA9IDAgdG8gbnZhbHMgLSAxIGRvXG4gICAgcmVzLihpK25tZXRocykgPC0gbmV3X3ZhcmlhYmxlIHRhYmxlIHZhbHMuKGkpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgZ2V0X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFycyB3aXRoIE5vdF9mb3VuZCAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGdldF92YXJpYWJsZXMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF92YXJpYWJsZSB0YWJsZSkgbmFtZXNcblxubGV0IGFkZF9pbml0aWFsaXplciB0YWJsZSBmID1cbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIGY6OnRhYmxlLmluaXRpYWxpemVyc1xuXG4oKlxubW9kdWxlIEtleXMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gdGFnIGFycmF5IGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG5sZXQga2V5X21hcCA9IHJlZiBLZXlzLmVtcHR5XG5sZXQgZ2V0X2tleSB0YWdzIDogaXRlbSA9XG4gIHRyeSBtYWdpYyAoS2V5cy5maW5kIHRhZ3MgIWtleV9tYXAgOiB0YWcgYXJyYXkpXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAga2V5X21hcCA6PSBLZXlzLmFkZCB0YWdzIHRhZ3MgIWtleV9tYXA7XG4gICAgbWFnaWMgdGFnc1xuKilcblxubGV0IGNyZWF0ZV90YWJsZSBwdWJsaWNfbWV0aG9kcyA9XG4gIGlmIHB1YmxpY19tZXRob2RzID09IG1hZ2ljIDAgdGhlbiBuZXdfdGFibGUgW3x8XSBlbHNlXG4gICgqIFtwdWJsaWNfbWV0aG9kc10gbXVzdCBiZSBpbiBhc2NlbmRpbmcgb3JkZXIgZm9yIGJ5dGVjb2RlICopXG4gIGxldCB0YWdzID0gQXJyYXkubWFwIHB1YmxpY19tZXRob2RfbGFiZWwgcHVibGljX21ldGhvZHMgaW5cbiAgbGV0IHRhYmxlID0gbmV3X3RhYmxlIHRhZ3MgaW5cbiAgQXJyYXkuaXRlcmlcbiAgICAoZnVuIGkgbWV0IC0+XG4gICAgICBsZXQgbGFiID0gaSoyKzIgaW5cbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSAgPC0gTWV0aHMuYWRkIG1ldCBsYWIgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWIgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsKVxuICAgIHB1YmxpY19tZXRob2RzO1xuICB0YWJsZVxuXG5sZXQgaW5pdF9jbGFzcyB0YWJsZSA9XG4gIGluc3RfdmFyX2NvdW50IDo9ICFpbnN0X3Zhcl9jb3VudCArIHRhYmxlLnNpemUgLSAxO1xuICB0YWJsZS5pbml0aWFsaXplcnMgPC0gTGlzdC5yZXYgdGFibGUuaW5pdGlhbGl6ZXJzO1xuICByZXNpemUgdGFibGUgKDMgKyBtYWdpYyB0YWJsZS5tZXRob2RzLigxKSAqIDE2IC8gU3lzLndvcmRfc2l6ZSlcblxubGV0IGluaGVyaXRzIGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgKF8sIHN1cGVyLCBfLCBlbnYpIHRvcCA9XG4gIG5hcnJvdyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzO1xuICBsZXQgaW5pdCA9XG4gICAgaWYgdG9wIHRoZW4gc3VwZXIgY2xhIGVudiBlbHNlIE9iai5yZXByIChzdXBlciBjbGEpIGluXG4gIHdpZGVuIGNsYTtcbiAgQXJyYXkuY29uY2F0XG4gICAgW1t8IHJlcHIgaW5pdCB8XTtcbiAgICAgbWFnaWMgKEFycmF5Lm1hcCAoZ2V0X3ZhcmlhYmxlIGNsYSkgKHRvX2FycmF5IHZhbHMpIDogaW50IGFycmF5KTtcbiAgICAgQXJyYXkubWFwXG4gICAgICAgKGZ1biBubSAtPiByZXByIChnZXRfbWV0aG9kIGNsYSAoZ2V0X21ldGhvZF9sYWJlbCBjbGEgbm0pIDogY2xvc3VyZSkpXG4gICAgICAgKHRvX2FycmF5IGNvbmNyX21ldGhzKSBdXG5cbmxldCBtYWtlX2NsYXNzIHB1Yl9tZXRocyBjbGFzc19pbml0ID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIChlbnZfaW5pdCAoT2JqLnJlcHIgMCksIGNsYXNzX2luaXQsIGVudl9pbml0LCBPYmoucmVwciAwKVxuXG50eXBlIGluaXRfdGFibGUgPSB7IG11dGFibGUgZW52X2luaXQ6IHQ7IG11dGFibGUgY2xhc3NfaW5pdDogdGFibGUgLT4gdCB9XG5bQEB3YXJuaW5nIFwiLXVudXNlZC1maWVsZFwiXVxuXG5sZXQgbWFrZV9jbGFzc19zdG9yZSBwdWJfbWV0aHMgY2xhc3NfaW5pdCBpbml0X3RhYmxlID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIGluaXRfdGFibGUuY2xhc3NfaW5pdCA8LSBjbGFzc19pbml0O1xuICBpbml0X3RhYmxlLmVudl9pbml0IDwtIGVudl9pbml0XG5cbmxldCBkdW1teV9jbGFzcyBsb2MgPVxuICBsZXQgdW5kZWYgPSBmdW4gXyAtPiByYWlzZSAoVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgbG9jKSBpblxuICAoT2JqLm1hZ2ljIHVuZGVmLCB1bmRlZiwgdW5kZWYsIE9iai5yZXByIDApXG5cbigqKioqIE9iamVjdHMgKioqKilcblxubGV0IGNyZWF0ZV9vYmplY3QgdGFibGUgPVxuICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICBPYmoub2JqIChzZXRfaWQgb2JqKVxuXG5sZXQgY3JlYXRlX29iamVjdF9vcHQgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgICBPYmoub2JqIChzZXRfaWQgb2JqKVxuICBlbmRcblxubGV0IHJlYyBpdGVyX2Ygb2JqID1cbiAgZnVuY3Rpb25cbiAgICBbXSAgIC0+ICgpXG4gIHwgZjo6bCAtPiBmIG9iajsgaXRlcl9mIG9iaiBsXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZSA9XG4gIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICBpZiBpbml0cyA8PiBbXSB0aGVuXG4gICAgaXRlcl9mIG9iaiBpbml0c1xuXG5sZXQgcnVuX2luaXRpYWxpemVyc19vcHQgb2JqXzAgb2JqIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqIGVsc2UgYmVnaW5cbiAgICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgICBpZiBpbml0cyA8PiBbXSB0aGVuIGl0ZXJfZiBvYmogaW5pdHM7XG4gICAgb2JqXG4gIGVuZFxuXG5sZXQgY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpemVycyBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICBsZXQgb2JqID0gY3JlYXRlX29iamVjdCB0YWJsZSBpblxuICAgIHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlO1xuICAgIG9ialxuICBlbmRcblxuKCogRXF1aXZhbGVudCBwcmltaXRpdmUgYmVsb3dcbmxldCBzZW5kc2VsZiBvYmogbGFiID1cbiAgKG1hZ2ljIG9iaiA6IChvYmogLT4gdCkgYXJyYXkgYXJyYXkpLigwKS4obGFiKSBvYmpcbiopXG5leHRlcm5hbCBzZW5kIDogb2JqIC0+IHRhZyAtPiAnYSA9IFwiJXNlbmRcIlxuZXh0ZXJuYWwgc2VuZGNhY2hlIDogb2JqIC0+IHRhZyAtPiB0IC0+IGludCAtPiAnYSA9IFwiJXNlbmRjYWNoZVwiXG5leHRlcm5hbCBzZW5kc2VsZiA6IG9iaiAtPiBsYWJlbCAtPiAnYSA9IFwiJXNlbmRzZWxmXCJcbmV4dGVybmFsIGdldF9wdWJsaWNfbWV0aG9kIDogb2JqIC0+IHRhZyAtPiBjbG9zdXJlXG4gICAgPSBcImNhbWxfZ2V0X3B1YmxpY19tZXRob2RcIiBbQEBub2FsbG9jXVxuXG4oKioqKiB0YWJsZSBjb2xsZWN0aW9uIGFjY2VzcyAqKioqKVxuXG50eXBlIHRhYmxlcyA9XG4gIHwgRW1wdHlcbiAgfCBDb25zIG9mIHtrZXkgOiBjbG9zdXJlOyBtdXRhYmxlIGRhdGE6IHRhYmxlczsgbXV0YWJsZSBuZXh0OiB0YWJsZXN9XG5cbmxldCBzZXRfZGF0YSB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGEgPC0gdlxubGV0IHNldF9uZXh0IHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dCA8LSB2XG5sZXQgZ2V0X2tleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmtleVxubGV0IGdldF9kYXRhID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YVxubGV0IGdldF9uZXh0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dFxuXG5sZXQgYnVpbGRfcGF0aCBuIGtleXMgdGFibGVzID1cbiAgbGV0IHJlcyA9IENvbnMge2tleSA9IE9iai5tYWdpYyAwOyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgbGV0IHIgPSByZWYgcmVzIGluXG4gIGZvciBpID0gMCB0byBuIGRvXG4gICAgciA6PSBDb25zIHtrZXkgPSBrZXlzLihpKTsgZGF0YSA9ICFyOyBuZXh0ID0gRW1wdHl9XG4gIGRvbmU7XG4gIHNldF9kYXRhIHRhYmxlcyAhcjtcbiAgcmVzXG5cbmxldCByZWMgbG9va3VwX2tleXMgaSBrZXlzIHRhYmxlcyA9XG4gIGlmIGkgPCAwIHRoZW4gdGFibGVzIGVsc2VcbiAgbGV0IGtleSA9IGtleXMuKGkpIGluXG4gIGxldCByZWMgbG9va3VwX2tleSAodGFibGVzOnRhYmxlcykgPVxuICAgIGlmIGdldF9rZXkgdGFibGVzID09IGtleSB0aGVuXG4gICAgICBtYXRjaCBnZXRfZGF0YSB0YWJsZXMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgQ29ucyBfIGFzIHRhYmxlc19kYXRhIC0+XG4gICAgICAgICAgbG9va3VwX2tleXMgKGktMSkga2V5cyB0YWJsZXNfZGF0YVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGdldF9uZXh0IHRhYmxlcyB3aXRoXG4gICAgICB8IENvbnMgXyBhcyBuZXh0IC0+IGxvb2t1cF9rZXkgbmV4dFxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGxldCBuZXh0IDogdGFibGVzID0gQ29ucyB7a2V5OyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgICAgICAgICBzZXRfbmV4dCB0YWJsZXMgbmV4dDtcbiAgICAgICAgICBidWlsZF9wYXRoIChpLTEpIGtleXMgbmV4dFxuICBpblxuICBsb29rdXBfa2V5IHRhYmxlc1xuXG5sZXQgbG9va3VwX3RhYmxlcyByb290IGtleXMgPVxuICBtYXRjaCBnZXRfZGF0YSByb290IHdpdGhcbiAgfCBDb25zIF8gYXMgcm9vdF9kYXRhIC0+XG4gICAgbG9va3VwX2tleXMgKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290X2RhdGFcbiAgfCBFbXB0eSAtPlxuICAgIGJ1aWxkX3BhdGggKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290XG5cbigqKioqIGJ1aWx0aW4gbWV0aG9kcyAqKioqKVxuXG5sZXQgZ2V0X2NvbnN0IHggPSByZXQgKGZ1biBfb2JqIC0+IHgpXG5sZXQgZ2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogLT4gQXJyYXkudW5zYWZlX2dldCBvYmogbilcbmxldCBnZXRfZW52IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pXG5sZXQgZ2V0X21ldGggbiAgPSByZXQgKGZ1biBvYmogLT4gc2VuZHNlbGYgb2JqIG4pXG5sZXQgc2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogeCAtPiBBcnJheS51bnNhZmVfc2V0IG9iaiBuIHgpXG5sZXQgYXBwX2NvbnN0IGYgeCA9IHJldCAoZnVuIF9vYmogLT4gZiB4KVxubGV0IGFwcF92YXIgZiBuICAgPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2VudiBmIGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9tZXRoIGYgbiAgPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9jb25zdCBmIHggeSA9IHJldCAoZnVuIF9vYmogLT4gZiB4IHkpXG5sZXQgYXBwX2NvbnN0X3ZhciBmIHggbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2NvbnN0X21ldGggZiB4IG4gPSByZXQgKGZ1biBvYmogLT4gZiB4IChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX3Zhcl9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSB4KVxubGV0IGFwcF9tZXRoX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSB4KVxubGV0IGFwcF9jb25zdF9lbnYgZiB4IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgeCAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX2Vudl9jb25zdCBmIGUgbiB4ID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgeClcbmxldCBtZXRoX2FwcF9jb25zdCBuIHggPSByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSB4KVxubGV0IG1ldGhfYXBwX3ZhciBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoQXJyYXkudW5zYWZlX2dldCBvYmogbSkpXG5sZXQgbWV0aF9hcHBfZW52IG4gZSBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXylcbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBtKSlcbmxldCBtZXRoX2FwcF9tZXRoIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChzZW5kc2VsZiBvYmogbSkpXG5sZXQgc2VuZF9jb25zdCBtIHggYyA9XG4gIHJldCAoZnVuIG9iaiAtPiBzZW5kY2FjaGUgeCBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfdmFyIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIDogb2JqKSBtXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX2VudiBtIGUgbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlXG4gICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0XG4gICAgICAgICAgICAgICAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSA6IG9iailcbiAgICAgIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9tZXRoIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChzZW5kc2VsZiBvYmogbikgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBuZXdfY2FjaGUgdGFibGUgPVxuICBsZXQgbiA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgbGV0IG4gPVxuICAgIGlmIG4gbW9kIDIgPSAwIHx8IG4gPiAyICsgbWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemVcbiAgICB0aGVuIG4gZWxzZSBuZXdfbWV0aG9kIHRhYmxlXG4gIGluXG4gIHRhYmxlLm1ldGhvZHMuKG4pIDwtIE9iai5tYWdpYyAwO1xuICBuXG5cbnR5cGUgaW1wbCA9XG4gICAgR2V0Q29uc3RcbiAgfCBHZXRWYXJcbiAgfCBHZXRFbnZcbiAgfCBHZXRNZXRoXG4gIHwgU2V0VmFyXG4gIHwgQXBwQ29uc3RcbiAgfCBBcHBWYXJcbiAgfCBBcHBFbnZcbiAgfCBBcHBNZXRoXG4gIHwgQXBwQ29uc3RDb25zdFxuICB8IEFwcENvbnN0VmFyXG4gIHwgQXBwQ29uc3RFbnZcbiAgfCBBcHBDb25zdE1ldGhcbiAgfCBBcHBWYXJDb25zdFxuICB8IEFwcEVudkNvbnN0XG4gIHwgQXBwTWV0aENvbnN0XG4gIHwgTWV0aEFwcENvbnN0XG4gIHwgTWV0aEFwcFZhclxuICB8IE1ldGhBcHBFbnZcbiAgfCBNZXRoQXBwTWV0aFxuICB8IFNlbmRDb25zdFxuICB8IFNlbmRWYXJcbiAgfCBTZW5kRW52XG4gIHwgU2VuZE1ldGhcbiAgfCBDbG9zdXJlIG9mIGNsb3N1cmVcblxubGV0IG1ldGhvZF9pbXBsIHRhYmxlIGkgYXJyID1cbiAgbGV0IG5leHQgKCkgPSBpbmNyIGk7IG1hZ2ljIGFyci4oIWkpIGluXG4gIG1hdGNoIG5leHQoKSB3aXRoXG4gICAgR2V0Q29uc3QgLT4gbGV0IHggOiB0ID0gbmV4dCgpIGluIGdldF9jb25zdCB4XG4gIHwgR2V0VmFyICAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X3ZhciBuXG4gIHwgR2V0RW52ICAgLT4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X2VudiBlIG5cbiAgfCBHZXRNZXRoICAtPiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfbWV0aCBuXG4gIHwgU2V0VmFyICAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gc2V0X3ZhciBuXG4gIHwgQXBwQ29uc3QgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gYXBwX2NvbnN0IGYgeFxuICB8IEFwcFZhciAgIC0+IGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBhcHBfdmFyIGYgblxuICB8IEFwcEVudiAgIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiAgbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnYgZiBlIG5cbiAgfCBBcHBNZXRoICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX21ldGggZiBuXG4gIHwgQXBwQ29uc3RDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IHkgPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9jb25zdCBmIHggeVxuICB8IEFwcENvbnN0VmFyIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X3ZhciBmIHggblxuICB8IEFwcENvbnN0RW52IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9lbnYgZiB4IGUgblxuICB8IEFwcENvbnN0TWV0aCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9tZXRoIGYgeCBuXG4gIHwgQXBwVmFyQ29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfdmFyX2NvbnN0IGYgbiB4XG4gIHwgQXBwRW52Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCAoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX2Vudl9jb25zdCBmIGUgbiB4XG4gIHwgQXBwTWV0aENvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX21ldGhfY29uc3QgZiBuIHhcbiAgfCBNZXRoQXBwQ29uc3QgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIG1ldGhfYXBwX2NvbnN0IG4geFxuICB8IE1ldGhBcHBWYXIgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluIG1ldGhfYXBwX3ZhciBuIG1cbiAgfCBNZXRoQXBwRW52IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpblxuICAgICAgbWV0aF9hcHBfZW52IG4gZSBtXG4gIHwgTWV0aEFwcE1ldGggLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluIG1ldGhfYXBwX21ldGggbiBtXG4gIHwgU2VuZENvbnN0IC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBzZW5kX2NvbnN0IG0geCAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRWYXIgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX3ZhciBtIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kRW52IC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgc2VuZF9lbnYgbSBlIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kTWV0aCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIHNlbmRfbWV0aCBtIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBDbG9zdXJlIF8gYXMgY2xvIC0+IG1hZ2ljIGNsb1xuXG5sZXQgc2V0X21ldGhvZHMgdGFibGUgbWV0aG9kcyA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggbWV0aG9kcyBpbiBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuIGRvXG4gICAgbGV0IGxhYmVsID0gbWV0aG9kcy4oIWkpIGluIGxldCBjbG8gPSBtZXRob2RfaW1wbCB0YWJsZSBpIG1ldGhvZHMgaW5cbiAgICBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGNsbztcbiAgICBpbmNyIGlcbiAgZG9uZVxuXG4oKioqKiBTdGF0aXN0aWNzICoqKiopXG5cbnR5cGUgc3RhdHMgPVxuICB7IGNsYXNzZXM6IGludDsgbWV0aG9kczogaW50OyBpbnN0X3ZhcnM6IGludDsgfVxuXG5sZXQgc3RhdHMgKCkgPVxuICB7IGNsYXNzZXMgPSAhdGFibGVfY291bnQ7XG4gICAgbWV0aG9kcyA9ICFtZXRob2RfY291bnQ7IGluc3RfdmFycyA9ICFpbnN0X3Zhcl9jb3VudDsgfVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHNoYXBlID1cbiAgfCBGdW5jdGlvblxuICB8IExhenlcbiAgfCBDbGFzc1xuICB8IE1vZHVsZSBvZiBzaGFwZSBhcnJheVxuICB8IFZhbHVlIG9mIE9iai50XG5cbmxldCByZWMgaW5pdF9tb2RfZmllbGQgbW9kdSBpIGxvYyBzaGFwZSA9XG4gIGxldCBpbml0ID1cbiAgICBtYXRjaCBzaGFwZSB3aXRoXG4gICAgfCBGdW5jdGlvbiAtPlxuICAgICAgIGxldCByZWMgZm4gKHggOiAnYSkgPVxuICAgICAgICAgbGV0IGZuJyA6ICdhIC0+ICdiID0gT2JqLm9iaiAoT2JqLmZpZWxkIG1vZHUgaSkgaW5cbiAgICAgICAgIGlmIGZuID09IGZuJyB0aGVuXG4gICAgICAgICAgIHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpXG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIGZuJyB4IGluXG4gICAgICAgT2JqLnJlcHIgZm5cbiAgICB8IExhenkgLT5cbiAgICAgICBsZXQgcmVjIGwgPVxuICAgICAgICAgbGF6eSAoXG4gICAgICAgICAgIGxldCBsJyA9IE9iai5vYmogKE9iai5maWVsZCBtb2R1IGkpIGluXG4gICAgICAgICAgIGlmIGwgPT0gbCcgdGhlblxuICAgICAgICAgICAgIHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpXG4gICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICBMYXp5LmZvcmNlIGwnKSBpblxuICAgICAgIE9iai5yZXByIGxcbiAgICB8IENsYXNzIC0+XG4gICAgICAgT2JqLnJlcHIgKENhbWxpbnRlcm5hbE9PLmR1bW15X2NsYXNzIGxvYylcbiAgICB8IE1vZHVsZSBjb21wcyAtPlxuICAgICAgIE9iai5yZXByIChpbml0X21vZF9ibG9jayBsb2MgY29tcHMpXG4gICAgfCBWYWx1ZSB2IC0+IHZcbiAgaW5cbiAgT2JqLnNldF9maWVsZCBtb2R1IGkgaW5pdFxuXG5hbmQgaW5pdF9tb2RfYmxvY2sgbG9jIGNvbXBzID1cbiAgbGV0IGxlbmd0aCA9IEFycmF5Lmxlbmd0aCBjb21wcyBpblxuICBsZXQgbW9kdSA9IE9iai5uZXdfYmxvY2sgMCBsZW5ndGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCAtIDEgZG9cbiAgICBpbml0X21vZF9maWVsZCBtb2R1IGkgbG9jIGNvbXBzLihpKVxuICBkb25lO1xuICBtb2R1XG5cbmxldCBpbml0X21vZCBsb2Mgc2hhcGUgPVxuICBtYXRjaCBzaGFwZSB3aXRoXG4gIHwgTW9kdWxlIGNvbXBzIC0+XG4gICAgIE9iai5yZXByIChpbml0X21vZF9ibG9jayBsb2MgY29tcHMpXG4gIHwgXyAtPiBmYWlsd2l0aCBcIkNhbWxpbnRlcm5hbE1vZC5pbml0X21vZDogbm90IGEgbW9kdWxlXCJcblxubGV0IHJlYyB1cGRhdGVfbW9kX2ZpZWxkIG1vZHUgaSBzaGFwZSBuID1cbiAgbWF0Y2ggc2hhcGUgd2l0aFxuICB8IEZ1bmN0aW9uIHwgTGF6eSAtPlxuICAgICBPYmouc2V0X2ZpZWxkIG1vZHUgaSBuXG4gIHwgVmFsdWUgXyAtPlxuICAgICAoKSAoKiB0aGUgdmFsdWUgaXMgYWxyZWFkeSB0aGVyZSAqKVxuICB8IENsYXNzIC0+XG4gICAgIGFzc2VydCAoT2JqLnRhZyBuID0gMCAmJiBPYmouc2l6ZSBuID0gNCk7XG4gICAgIGxldCBjbCA9IE9iai5maWVsZCBtb2R1IGkgaW5cbiAgICAgZm9yIGogPSAwIHRvIDMgZG9cbiAgICAgICBPYmouc2V0X2ZpZWxkIGNsIGogKE9iai5maWVsZCBuIGopXG4gICAgIGRvbmVcbiAgfCBNb2R1bGUgY29tcHMgLT5cbiAgICAgdXBkYXRlX21vZF9ibG9jayBjb21wcyAoT2JqLmZpZWxkIG1vZHUgaSkgblxuXG5hbmQgdXBkYXRlX21vZF9ibG9jayBjb21wcyBvIG4gPVxuICBhc3NlcnQgKE9iai50YWcgbiA9IDAgJiYgT2JqLnNpemUgbiA+PSBBcnJheS5sZW5ndGggY29tcHMpO1xuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGNvbXBzIC0gMSBkb1xuICAgIHVwZGF0ZV9tb2RfZmllbGQgbyBpIGNvbXBzLihpKSAoT2JqLmZpZWxkIG4gaSlcbiAgZG9uZVxuXG5sZXQgdXBkYXRlX21vZCBzaGFwZSBvIG4gPVxuICBtYXRjaCBzaGFwZSB3aXRoXG4gIHwgTW9kdWxlIGNvbXBzIC0+XG4gICAgIHVwZGF0ZV9tb2RfYmxvY2sgY29tcHMgbyBuXG4gIHwgXyAtPiBmYWlsd2l0aCBcIkNhbWxpbnRlcm5hbE1vZC51cGRhdGVfbW9kOiBub3QgYSBtb2R1bGVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdICgqIGlnbm9yZSBkZXByZWNhdGlvbiB3YXJuaW5nIGFib3V0IG1vZHVsZSBTdHJlYW0gKilcblxudHlwZSB0b2tlbiA9XG4gICAgS3dkIG9mIHN0cmluZ1xuICB8IElkZW50IG9mIHN0cmluZ1xuICB8IEludCBvZiBpbnRcbiAgfCBGbG9hdCBvZiBmbG9hdFxuICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgfCBDaGFyIG9mIGNoYXJcblxuKCogVGhlIHN0cmluZyBidWZmZXJpbmcgbWFjaGluZXJ5ICopXG5cbmxldCBpbml0aWFsX2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAzMlxuXG5sZXQgYnVmZmVyID0gcmVmIGluaXRpYWxfYnVmZmVyXG5sZXQgYnVmcG9zID0gcmVmIDBcblxubGV0IHJlc2V0X2J1ZmZlciAoKSA9IGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgYnVmcG9zIDo9IDBcblxubGV0IHN0b3JlIGMgPVxuICBpZiAhYnVmcG9zID49IEJ5dGVzLmxlbmd0aCAhYnVmZmVyIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3YnVmZmVyID0gQnl0ZXMuY3JlYXRlICgyICogIWJ1ZnBvcykgaW5cbiAgICBCeXRlcy5ibGl0ICFidWZmZXIgMCBuZXdidWZmZXIgMCAhYnVmcG9zO1xuICAgIGJ1ZmZlciA6PSBuZXdidWZmZXJcbiAgZW5kO1xuICBCeXRlcy5zZXQgIWJ1ZmZlciAhYnVmcG9zIGM7XG4gIGluY3IgYnVmcG9zXG5cbmxldCBnZXRfc3RyaW5nICgpID1cbiAgbGV0IHMgPSBCeXRlcy5zdWJfc3RyaW5nICFidWZmZXIgMCAhYnVmcG9zIGluIGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgc1xuXG4oKiBUaGUgbGV4ZXIgKilcblxubGV0IG1ha2VfbGV4ZXIga2V5d29yZHMgPVxuICBsZXQga3dkX3RhYmxlID0gSGFzaHRibC5jcmVhdGUgMTcgaW5cbiAgTGlzdC5pdGVyIChmdW4gcyAtPiBIYXNodGJsLmFkZCBrd2RfdGFibGUgcyAoS3dkIHMpKSBrZXl3b3JkcztcbiAgbGV0IGlkZW50X29yX2tleXdvcmQgaWQgPVxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIGlkIHdpdGhcbiAgICAgIE5vdF9mb3VuZCAtPiBJZGVudCBpZFxuICBhbmQga2V5d29yZF9vcl9lcnJvciBjID1cbiAgICBsZXQgcyA9IFN0cmluZy5tYWtlIDEgYyBpblxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIHMgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgKFwiSWxsZWdhbCBjaGFyYWN0ZXIgXCIgXiBzKSlcbiAgaW5cbiAgbGV0IHJlYyBuZXh0X3Rva2VuIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcgJyB8ICdcXDAxMCcgfCAnXFwwMTMnIHwgJ1xcMDA5JyB8ICdcXDAyNicgfCAnXFwwMTInKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IG5leHRfdG9rZW4gc3RybV9fXG4gICAgfCBTb21lICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ18nIHwgJ1xcMTkyJy4uJ1xcMjU1JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQgc1xuICAgIHwgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHwgJz4nIHxcbiAgICAgICAgICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQyIHNcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnXFwnJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgY2hhciBzdHJtX18gd2l0aFxuICAgICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBpblxuICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgIFNvbWUgJ1xcJycgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChDaGFyIGMpXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSAnXFxcIicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IFNvbWUgKFN0cmluZyAoc3RyaW5nIHMpKVxuICAgIHwgU29tZSAnLScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBuZWdfbnVtYmVyIHN0cm1fX1xuICAgIHwgU29tZSAnKCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgU29tZSAoa2V5d29yZF9vcl9lcnJvciBjKVxuICAgIHwgXyAtPiBOb25lXG4gIGFuZCBpZGVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lXG4gICAgICAgICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ1xcMTkyJy4uJ1xcMjU1JyB8ICcwJy4uJzknIHwgJ18nIHwgJ1xcJycgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgaWRlbnQyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCchJyB8ICclJyB8ICcmJyB8ICckJyB8ICcjJyB8ICcrJyB8ICctJyB8ICcvJyB8ICc6JyB8ICc8JyB8ICc9JyB8XG4gICAgICAgICAnPicgfCAnPycgfCAnQCcgfCAnXFxcXCcgfCAnficgfCAnXicgfCAnfCcgfCAnKicgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgXyAtPiBTb21lIChpZGVudF9vcl9rZXl3b3JkIChnZXRfc3RyaW5nICgpKSlcbiAgYW5kIG5lZ19udW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IF8gLT4gbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSAnLSc7IGlkZW50MiBzXG4gIGFuZCBudW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnLicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnLic7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoSW50IChpbnRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBkZWNpbWFsX3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBkZWNpbWFsX3BhcnQgc1xuICAgIHwgU29tZSAoJ2UnIHwgJ0UnKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICdFJzsgZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGV4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJysnIHwgJy0nIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBlbmRfZXhwb25lbnRfcGFydCBzdHJtX19cbiAgYW5kIGVuZF9leHBvbmVudF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChGbG9hdCAoZmxvYXRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBzdHJpbmcgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnXFxcIicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBnZXRfc3RyaW5nICgpXG4gICAgfCBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgZXNjYXBlIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBzdHJpbmcgc1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgY2hhciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgZXNjYXBlIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ24nIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcbidcbiAgICB8IFNvbWUgJ3InIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xccidcbiAgICB8IFNvbWUgJ3QnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcdCdcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMxKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAoJzAnLi4nOScgYXMgYzIpIC0+XG4gICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMykgLT5cbiAgICAgICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICAgICAgQ2hhci5jaHJcbiAgICAgICAgICAgICAgICAgICgoQ2hhci5jb2RlIGMxIC0gNDgpICogMTAwICsgKENoYXIuY29kZSBjMiAtIDQ4KSAqIDEwICtcbiAgICAgICAgICAgICAgICAgICAgIChDaGFyLmNvZGUgYzMgLSA0OCkpXG4gICAgICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgbmV4dF90b2tlbiBzXG4gICAgfCBfIC0+IFNvbWUgKGtleXdvcmRfb3JfZXJyb3IgJygnKVxuICBhbmQgY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX25lc3RlZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9uZXN0ZWRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgY29tbWVudCBzXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfZW5kX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAoKVxuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGluXG4gIGZ1biBpbnB1dCAtPiBTdHJlYW0uZnJvbSAoZnVuIF9jb3VudCAtPiBuZXh0X3Rva2VuIGlucHV0KVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5bQEBAb2NhbWwud2FybmluZyBcIi0zMlwiXVxuXG5tb2R1bGUgdHlwZSBTZWVkZWRTID0gc2lnXG5cbiAgdHlwZSBrZXlcbiAgdHlwZSAhJ2EgdFxuICB2YWwgY3JlYXRlIDogP3JhbmRvbSAoKnRod2FydCB0b29scy9zeW5jX3N0ZGxpYl9kb2NzKikgOiBib29sIC0+IGludCAtPiAnYSB0XG4gIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgdmFsIGZpbmQgOiAnYSB0IC0+IGtleSAtPiAnYVxuICB2YWwgZmluZF9vcHQgOiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgdmFsIGZpbmRfYWxsIDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2UgOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIGZvbGQgOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gIHZhbCBzdGF0cyA6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG5cbiAgdHlwZSBrZXlcbiAgdHlwZSAhJ2EgdFxuICB2YWwgY3JlYXRlIDogaW50IC0+ICdhIHRcbiAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICB2YWwgYWRkIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gIHZhbCBmaW5kX29wdCA6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICB2YWwgaXRlciA6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgW0BAYWxlcnQgb2xkX2VwaGVtZXJvbl9hcGkgXCJUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGF2YWlsYWJsZSBpbiA1LjBcIl1cbiAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZSA6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgZm9sZCA6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIFtAQGFsZXJ0IG9sZF9lcGhlbWVyb25fYXBpIFwiVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBhdmFpbGFibGUgaW4gNS4wXCJdXG4gIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICBbQEBhbGVydCBvbGRfZXBoZW1lcm9uX2FwaSBcIlRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgYXZhaWxhYmxlIGluIDUuMFwiXVxuICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgdmFsIGNsZWFuOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHN0YXRzX2FsaXZlOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICAgICgqKiBzYW1lIGFzIHshc3RhdHN9IGJ1dCBvbmx5IGNvdW50IHRoZSBhbGl2ZSBiaW5kaW5ncyAqKVxuZW5kXG5cbm1vZHVsZSBHZW5IYXNoVGFibGUgPSBzdHJ1Y3RcblxuICB0eXBlIGVxdWFsID1cbiAgfCBFVHJ1ZSB8IEVGYWxzZVxuICB8IEVEZWFkICgqKiB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IgcmVjbGFpbWVkIHRoZSBkYXRhICopXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQoSDogc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSAnYSBjb250YWluZXJcbiAgICB2YWwgY3JlYXRlOiB0IC0+ICdhIC0+ICdhIGNvbnRhaW5lclxuICAgIHZhbCBoYXNoOiBpbnQgLT4gdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6ICdhIGNvbnRhaW5lciAtPiB0IC0+IGVxdWFsXG4gICAgdmFsIGdldF9kYXRhOiAnYSBjb250YWluZXIgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGdldF9rZXk6ICdhIGNvbnRhaW5lciAtPiB0IG9wdGlvblxuICAgIHZhbCBzZXRfa2V5X2RhdGE6ICdhIGNvbnRhaW5lciAtPiB0IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgY2hlY2tfa2V5OiAnYSBjb250YWluZXIgLT4gYm9vbFxuICBlbmQpIDogU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50XG4gID0gc3RydWN0XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgICAgICBtdXRhYmxlIGRhdGE6ICdhIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgICAgICBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBmb3IgcmFuZG9taXphdGlvbiAqKVxuICAgICAgICBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgICAgIH1cblxuICAgIGFuZCAnYSBidWNrZXRsaXN0ID1cbiAgICB8IEVtcHR5XG4gICAgfCBDb25zIG9mIGludCAoKiBoYXNoIG9mIHRoZSBrZXkgKikgKiAnYSBILmNvbnRhaW5lciAqICdhIGJ1Y2tldGxpc3RcblxuICAgICgqKiB0aGUgaGFzaCBvZiB0aGUga2V5IGlzIGtlcHQgaW4gb3JkZXIgdG8gdGVzdCB0aGUgZXF1YWxpdHkgb2YgdGhlIGhhc2hcbiAgICAgIGJlZm9yZSB0aGUga2V5LiBTYW1lIHJlYXNvbiBhcyBmb3IgV2Vhay5NYWtlICopXG5cbiAgICB0eXBlIGtleSA9IEgudFxuXG4gICAgbGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gICAgICBpZiB4ID49IG4gdGhlbiB4XG4gICAgICBlbHNlIGlmIHggKiAyID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiB4XG4gICAgICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbiAgICBsZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCgpKVxuXG4gICAgbGV0IGNyZWF0ZSA/KHJhbmRvbSA9IChIYXNodGJsLmlzX3JhbmRvbWl6ZWQgKCkpKSBpbml0aWFsX3NpemUgPVxuICAgICAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICAgICAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgICAgIHsgaW5pdGlhbF9zaXplID0gczsgc2l6ZSA9IDA7IHNlZWQgPSBzZWVkOyBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5IH1cblxuICAgIGxldCBjbGVhciBoID1cbiAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIGRvbmVcblxuICAgIGxldCByZXNldCBoID1cbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBpZiBsZW4gPSBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgICAgIGNsZWFyIGhcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIDA7XG4gICAgICAgIGguZGF0YSA8LSBBcnJheS5tYWtlIGguaW5pdGlhbF9zaXplIEVtcHR5XG4gICAgICBlbmRcblxuICAgIGxldCBjb3B5IGggPSB7IGggd2l0aCBkYXRhID0gQXJyYXkuY29weSBoLmRhdGEgfVxuXG4gICAgbGV0IGtleV9pbmRleCBoIGhrZXkgPVxuICAgICAgaGtleSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBjbGVhbiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgRW1wdHlcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIHdoZW4gbm90IChILmNoZWNrX2tleSBjKSAtPlxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICB8IENvbnMoaGtleSwgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIENvbnMoaGtleSwgYywgZG9fYnVja2V0IHJlc3QpXG4gICAgICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZC4oaSkgPC0gZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICAoKiogcmVzaXplIGlzIHRoZSBvbmx5IGZ1bmN0aW9uIHRvIGRvIHRoZSBhY3R1YWwgY2xlYW5pbmcgb2YgZGVhZCBrZXlzXG4gICAgICAgIChyZW1vdmUgZG9lcyBpdCBqdXN0IGJlY2F1c2UgaXQgY291bGQpLlxuXG4gICAgICAgIFRoZSBnb2FsIGlzIHRvOlxuXG4gICAgICAgIC0gbm90IHJlc2l6ZSBpbmZpbml0ZWx5IHdoZW4gdGhlIGFjdHVhbCBudW1iZXIgb2YgYWxpdmUga2V5cyBpc1xuICAgICAgICBib3VuZGVkIGJ1dCBrZXlzIGFyZSBjb250aW51b3VzbHkgYWRkZWQuIFRoYXQgd291bGQgaGFwcGVuIGlmXG4gICAgICAgIHRoaXMgZnVuY3Rpb24gYWx3YXlzIHJlc2l6ZS5cbiAgICAgICAgLSBub3QgY2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIGVhY2ggYWRkaXRpb24sIHRoYXQgd291bGQgaGFwcGVuIGlmIHRoaXNcbiAgICAgICAgZnVuY3Rpb24gZG9uJ3QgcmVzaXplIGV2ZW4gd2hlbiBvbmx5IG9uZSBrZXkgaXMgZGVhZC5cblxuICAgICAgICBTbyB0aGUgYWxnb3JpdGhtOlxuICAgICAgICAtIGNsZWFuIHRoZSBrZXlzIGJlZm9yZSByZXNpemluZ1xuICAgICAgICAtIGlmIHRoZSBudW1iZXIgb2YgcmVtYWluaW5nIGtleXMgaXMgbGVzcyB0aGFuIGhhbGYgdGhlIHNpemUgb2YgdGhlXG4gICAgICAgIGFycmF5LCBkb24ndCByZXNpemUuXG4gICAgICAgIC0gaWYgaXQgaXMgbW9yZSwgcmVzaXplLlxuXG4gICAgICAgIFRoZSBzZWNvbmQgcHJvYmxlbSByZW1haW5zIGlmIHRoZSB0YWJsZSByZWFjaGVzIHshU3lzLm1heF9hcnJheV9sZW5ndGh9LlxuXG4gICAgKilcbiAgICBsZXQgcmVzaXplIGggPVxuICAgICAgbGV0IG9kYXRhID0gaC5kYXRhIGluXG4gICAgICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgICAgIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICAgICAgY2xlYW4gaDtcbiAgICAgIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggJiYgaC5zaXplID49IG9zaXplIGxzciAxIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5kYXRhID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgICAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICgqIHNvIHRoYXQga2V5X2luZGV4IHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICAgICAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICAgICAgfCBDb25zKGhrZXksIGRhdGEsIHJlc3QpIC0+XG4gICAgICAgICAgICAgIGluc2VydF9idWNrZXQgcmVzdDsgKCogcHJlc2VydmUgb3JpZ2luYWwgb3JkZXIgb2YgZWxlbWVudHMgKilcbiAgICAgICAgICAgICAgbGV0IG5pZHggPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICAgICAgICAgIG5kYXRhLihuaWR4KSA8LSBDb25zKGhrZXksIGRhdGEsIG5kYXRhLihuaWR4KSkgaW5cbiAgICAgICAgZm9yIGkgPSAwIHRvIG9zaXplIC0gMSBkb1xuICAgICAgICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gICAgICAgIGRvbmVcbiAgICAgIGVuZFxuXG4gICAgbGV0IGFkZCBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgbGV0IGNvbnRhaW5lciA9IEguY3JlYXRlIGtleSBpbmZvIGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29ucyhoa2V5LCBjb250YWluZXIsIGguZGF0YS4oaSkpIGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBoXG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgICAgfCBDb25zKGhrLCBjLCBuZXh0KSB3aGVuIGhrZXkgPSBoayAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgICB8IEVUcnVlIC0+IGguc2l6ZSA8LSBoLnNpemUgLSAxOyBuZXh0XG4gICAgICAgICAgICB8IEVGYWxzZSAtPiBDb25zKGhrLCBjLCByZW1vdmVfYnVja2V0IG5leHQpXG4gICAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgICAgKCogVGhlIGRlYWQga2V5IGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC4gSXQgaXMgYWNjZXB0YWJsZVxuICAgICAgICAgICAgICAgICAgICBmb3IgdGhpcyBmdW5jdGlvbiBzaW5jZSBpdCBhbHJlYWR5IHJlbW92ZXMgYSBiaW5kaW5nICopXG4gICAgICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgcmVtb3ZlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKGhrLGMsbmV4dCkgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KSBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIHJlbW92ZV9idWNrZXQgaC5kYXRhLihpKVxuXG4gICAgKCoqIHshZmluZH0gZG9uJ3QgcmVtb3ZlIGRlYWQga2V5cyBiZWNhdXNlIGl0IHdvdWxkIGJlIHN1cnByaXNpbmcgZm9yXG4gICAgICAgIHRoZSB1c2VyIHRoYXQgYSByZWFkLW9ubHkgZnVuY3Rpb24gbXV0YXRlcyB0aGUgc3RhdGUgKGVnLiBjb25jdXJyZW50XG4gICAgICAgIGFjY2VzcykuIFNhbWUgZm9yIHshaXRlcn0sIHshZm9sZH0sIHshbWVtfS5cbiAgICAqKVxuICAgIGxldCByZWMgZmluZF9yZWMga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+XG4gICAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgKCogVGhpcyBjYXNlIGlzIG5vdCBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdjIGNhbiBydW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgIEguZXF1YWwgYW5kIEguZ2V0X2RhdGEgKilcbiAgICAgICAgICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjIGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgXyBhcyBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgICgqIFRPRE8gaW5saW5lIDMgaXRlcmF0aW9ucyAqKVxuICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBbXVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+IGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgZCAtPiBkOjpmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpXG5cblxuICAgIGxldCByZXBsYWNlIGgga2V5IGluZm8gPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyByZXBsYWNlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBILnNldF9rZXlfZGF0YSBjIGtleSBpbmZvXG4gICAgICAgICAgICB8IEVGYWxzZSB8IEVEZWFkIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IENvbnMoXyxfLG5leHQpIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgdHJ5XG4gICAgICAgIHJlcGxhY2VfYnVja2V0IGxcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnMoaGtleSwgY29udGFpbmVyLCBsKTtcbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGsgPSBoa2V5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiB0cnVlXG4gICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiBtZW1faW5fYnVja2V0IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfaGssIF9jLCByZXN0KSAtPiBtZW1faW5fYnVja2V0IHJlc3QgaW5cbiAgICAgIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG4gICAgbGV0IGl0ZXIgZiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgKClcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gKClcbiAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT4gZiBrIGRcbiAgICAgICAgICAgIGVuZDsgZG9fYnVja2V0IHJlc3QgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgbGV0IGZvbGQgZiBoIGluaXQgPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgYiBhY2N1ID1cbiAgICAgICAgbWF0Y2ggYiB3aXRoXG4gICAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAgIGFjY3VcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBsZXQgYWNjdSA9IGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IGFjY3VcbiAgICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPiBmIGsgZCBhY2N1XG4gICAgICAgICAgICBlbmQgaW5cbiAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0IGFjY3UgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgICAgZG9uZTtcbiAgICAgICFhY2N1XG5cbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPlxuICAgICAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+XG4gICAgICAgICAgICAgICAgbWF0Y2ggZiBrIGQgd2l0aFxuICAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICAgICAgICAgIHwgU29tZSBuZXdfZCAtPlxuICAgICAgICAgICAgICAgICAgICBILnNldF9rZXlfZGF0YSBjIGsgbmV3X2Q7XG4gICAgICAgICAgICAgICAgICAgIENvbnMoaGssIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgbGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoIChhY2N1ICsgMSkgcmVzdFxuXG4gICAgbGV0IHN0YXRzIGggPVxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBJbnQubWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIEguY2hlY2tfa2V5IGMgLT5cbiAgICAgICAgICBidWNrZXRfbGVuZ3RoX2FsaXZlIChhY2N1ICsgMSkgcmVzdFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSByZXN0XG5cbiAgICBsZXQgc3RhdHNfYWxpdmUgaCA9XG4gICAgICBsZXQgc2l6ZSA9IHJlZiAwIGluXG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0XG4gICAgICAgICAgKGZ1biBtIGIgLT4gSW50Lm1heCBtIChidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYikpIDAgaC5kYXRhXG4gICAgICBpblxuICAgICAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICAgICAgQXJyYXkuaXRlclxuICAgICAgICAoZnVuIGIgLT5cbiAgICAgICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYiBpblxuICAgICAgICAgICBzaXplIDo9ICFzaXplICsgbDtcbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSAhc2l6ZTtcbiAgICAgICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgICAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICAgICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuICAgIGxldCB0b19zZXEgdGJsID1cbiAgICAgICgqIGNhcHR1cmUgY3VycmVudCBhcnJheSwgc28gdGhhdCBldmVuIGlmIHRoZSB0YWJsZSBpcyByZXNpemVkIHdlXG4gICAgICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICAgICAgbGV0IHRibF9kYXRhID0gdGJsLmRhdGEgaW5cbiAgICAgICgqIHN0YXRlOiBpbmRleCAqIG5leHQgYnVja2V0IHRvIHRyYXZlcnNlICopXG4gICAgICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0YmxfZGF0YVxuICAgICAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgICAgICBlbHNlIGF1eChpKzEpIHRibF9kYXRhLihpKSAoKVxuICAgICAgICB8IENvbnMgKF8sIGMsIG5leHQpIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBhdXggaSBuZXh0ICgpXG4gICAgICAgICAgICAgIHwgU29tZSBrZXksIFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgICAgU2VxLkNvbnMgKChrZXksIGRhdGEpLCBhdXggaSBuZXh0KVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgYXV4IDAgRW1wdHlcblxuICAgIGxldCB0b19zZXFfa2V5cyBtID0gU2VxLm1hcCBmc3QgKHRvX3NlcSBtKVxuXG4gICAgbGV0IHRvX3NlcV92YWx1ZXMgbSA9IFNlcS5tYXAgc25kICh0b19zZXEgbSlcblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgZW5kXG5lbmRcblxubW9kdWxlIE9iakVwaCA9IE9iai5FcGhlbWVyb25cblxubGV0IF9vYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4geFxuICB8IFNvbWUgdiAtPiBTb21lIChPYmoub2JqIHYpXG5cbigqKiBUaGUgcHJldmlvdXMgZnVuY3Rpb24gaXMgdHlwZWQgc28gdGhpcyBvbmUgaXMgYWxzbyBjb3JyZWN0ICopXG5sZXQgb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPiBPYmoubWFnaWMgeFxuXG5cbm1vZHVsZSBLMSA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgMVxuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBnZXRfa2V5X2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAwKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChrOidrKSA6IHVuaXQgPSBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMFxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgYmxpdF9rZXkgKHQxOignaywnZCkgdCkgKHQyOignaywnZCkgdCk6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMVxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIGxldCBtYWtlIGtleSBkYXRhID1cbiAgICBsZXQgZXBoID0gY3JlYXRlICgpIGluXG4gICAgc2V0X2RhdGEgZXBoIGRhdGE7XG4gICAgc2V0X2tleSBlcGgga2V5O1xuICAgIGVwaFxuXG4gIGxldCBxdWVyeSBlcGgga2V5ID1cbiAgICBtYXRjaCBnZXRfa2V5IGVwaCB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgayB3aGVuIGsgPT0ga2V5IC0+IGdldF9kYXRhIGVwaFxuICAgIHwgU29tZSBfIC0+IE5vbmVcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoID0gSC5oYXNoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgKCogeyFnZXRfa2V5X2NvcHl9IGlzIG5vdCB1c2VkIGJlY2F1c2UgdGhlIGVxdWFsaXR5IG9mIHRoZSB1c2VyIGNhbiBiZVxuICAgICAgICAgICAgdGhlIHBoeXNpY2FsIGVxdWFsaXR5ICopXG4gICAgICAgIG1hdGNoIGdldF9rZXkgYyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsnIC0+XG4gICAgICAgICAgICBpZiBILmVxdWFsIGsgaycgdGhlbiBHZW5IYXNoVGFibGUuRVRydWUgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgPSBnZXRfa2V5XG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5ID0gY2hlY2tfa2V5XG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG4gIG1vZHVsZSBCdWNrZXQgPSBzdHJ1Y3RcblxuICAgIHR5cGUgbm9ucmVjICgnaywgJ2QpIHQgPSAoJ2ssICdkKSB0IGxpc3QgcmVmXG4gICAgbGV0IGsxX21ha2UgPSBtYWtlXG4gICAgbGV0IG1ha2UgKCkgPSByZWYgW11cbiAgICBsZXQgYWRkIGIgayBkID0gYiA6PSBrMV9tYWtlIGsgZCA6OiAhYlxuXG4gICAgbGV0IHRlc3Rfa2V5IGsgZSA9XG4gICAgICBtYXRjaCBnZXRfa2V5IGUgd2l0aFxuICAgICAgfCBTb21lIHggd2hlbiB4ID09IGsgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVtb3ZlIGIgayA9XG4gICAgICBsZXQgcmVjIGxvb3AgbCBhY2MgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGggOjogdCB3aGVuIHRlc3Rfa2V5IGsgaCAtPiBiIDo9IExpc3QucmV2X2FwcGVuZCBhY2MgdFxuICAgICAgICB8IGggOjogdCAtPiBsb29wIHQgKGggOjogYWNjKVxuICAgICAgaW5cbiAgICAgIGxvb3AgIWIgW11cblxuICAgIGxldCBmaW5kIGIgayA9XG4gICAgICBtYXRjaCBMaXN0LmZpbmRfb3B0ICh0ZXN0X2tleSBrKSAhYiB3aXRoXG4gICAgICB8IFNvbWUgZSAtPiBnZXRfZGF0YSBlXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuXG4gICAgbGV0IGxlbmd0aCBiID0gTGlzdC5sZW5ndGggIWJcbiAgICBsZXQgY2xlYXIgYiA9IGIgOj0gW11cblxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLMiA9IHN0cnVjdFxuICB0eXBlICgnazEsICdrMiwgJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2sxLCdrMiwnZCkgdCA9IE9iakVwaC5jcmVhdGUgMlxuXG4gIGxldCBnZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgZ2V0X2tleTFfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMClcbiAgbGV0IHNldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSAoazonazEpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDBcbiAgbGV0IGNoZWNrX2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGdldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDEpXG4gIGxldCBnZXRfa2V5Ml9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAxKVxuICBsZXQgc2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMikgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDEgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMVxuICBsZXQgY2hlY2tfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDFcblxuXG4gIGxldCBibGl0X2tleTEgKHQxOignazEsXyxfKSB0KSAodDI6KCdrMSxfLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAxXG4gIGxldCBibGl0X2tleTIgKHQxOihfLCdrMixfKSB0KSAodDI6KF8sJ2syLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDEgdDIgMSAxXG4gIGxldCBibGl0X2tleTEyICh0MTooJ2sxLCdrMixfKSB0KSAodDI6KCdrMSwnazIsXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDJcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSAoZDonZCkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sXywnZCkgdCkgKHQyOihfLF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBsZXQgbWFrZSBrZXkxIGtleTIgZGF0YSA9XG4gICAgbGV0IGVwaCA9IGNyZWF0ZSAoKSBpblxuICAgIHNldF9kYXRhIGVwaCBkYXRhO1xuICAgIHNldF9rZXkxIGVwaCBrZXkxO1xuICAgIHNldF9rZXkyIGVwaCBrZXkyO1xuICAgIGlnbm9yZSAoU3lzLm9wYXF1ZV9pZGVudGl0eSBrZXkxKTtcbiAgICBlcGhcblxuICBsZXQgcXVlcnkgZXBoIGtleTEga2V5MiA9XG4gICAgbWF0Y2ggZ2V0X2tleTEgZXBoIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBrIHdoZW4gayA9PSBrZXkxIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIGdldF9rZXkyIGVwaCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSBrIHdoZW4gayA9PSBrZXkyIC0+IGdldF9kYXRhIGVwaFxuICAgICAgICB8IFNvbWUgXyAtPiBOb25lXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBfIC0+IE5vbmVcblxuICBtb2R1bGUgTWFrZVNlZWRlZFxuICAgICAgKEgxOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSlcbiAgICAgIChIMjpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgxLnQsSDIudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSDEudCAqIEgyLnRcbiAgICAgIGxldCBjcmVhdGUgKGsxLGsyKSBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCBzZWVkIChrMSxrMikgPVxuICAgICAgICBIMS5oYXNoIHNlZWQgazEgKyBIMi5oYXNoIHNlZWQgazIgKiA2NTU5OVxuICAgICAgbGV0IGVxdWFsIGMgKGsxLGsyKSA9XG4gICAgICAgIG1hdGNoIGdldF9rZXkxIGMsIGdldF9rZXkyIGMgd2l0aFxuICAgICAgICB8IE5vbmUsIF8gfCBfICwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT5cbiAgICAgICAgICAgIGlmIEgxLmVxdWFsIGsxIGsxJyAmJiBIMi5lcXVhbCBrMiBrMidcbiAgICAgICAgICAgIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5IGMgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgazEnLCBTb21lIGsyJyAtPiBTb21lIChrMScsIGsyJylcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyAoazEsazIpIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID0gY2hlY2tfa2V5MSBjICYmIGNoZWNrX2tleTIgY1xuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIMTogSGFzaHRibC5IYXNoZWRUeXBlKShIMjogSGFzaHRibC5IYXNoZWRUeXBlKTpcbiAgICAoUyB3aXRoIHR5cGUga2V5ID0gSDEudCAqIEgyLnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMS50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDEuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgxLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMi50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDIuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgyLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG4gIG1vZHVsZSBCdWNrZXQgPSBzdHJ1Y3RcblxuICAgIHR5cGUgbm9ucmVjICgnazEsICdrMiwgJ2QpIHQgPSAoJ2sxLCAnazIsICdkKSB0IGxpc3QgcmVmXG4gICAgbGV0IGsyX21ha2UgPSBtYWtlXG4gICAgbGV0IG1ha2UgKCkgPSByZWYgW11cbiAgICBsZXQgYWRkIGIgazEgazIgZCA9IGIgOj0gazJfbWFrZSBrMSBrMiBkIDo6ICFiXG5cbiAgICBsZXQgdGVzdF9rZXlzIGsxIGsyIGUgPVxuICAgICAgbWF0Y2ggZ2V0X2tleTEgZSwgZ2V0X2tleTIgZSB3aXRoXG4gICAgICB8IFNvbWUgeDEsIFNvbWUgeDIgd2hlbiB4MSA9PSBrMSAmJiB4MiA9PSBrMiAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZW1vdmUgYiBrMSBrMiA9XG4gICAgICBsZXQgcmVjIGxvb3AgbCBhY2MgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGggOjogdCB3aGVuIHRlc3Rfa2V5cyBrMSBrMiBoIC0+IGIgOj0gTGlzdC5yZXZfYXBwZW5kIGFjYyB0XG4gICAgICAgIHwgaCA6OiB0IC0+IGxvb3AgdCAoaCA6OiBhY2MpXG4gICAgICBpblxuICAgICAgbG9vcCAhYiBbXVxuXG4gICAgbGV0IGZpbmQgYiBrMSBrMiA9XG4gICAgICBtYXRjaCBMaXN0LmZpbmRfb3B0ICh0ZXN0X2tleXMgazEgazIpICFiIHdpdGhcbiAgICAgIHwgU29tZSBlIC0+IGdldF9kYXRhIGVcbiAgICAgIHwgTm9uZSAtPiBOb25lXG5cbiAgICBsZXQgbGVuZ3RoIGIgPSBMaXN0Lmxlbmd0aCAhYlxuICAgIGxldCBjbGVhciBiID0gYiA6PSBbXVxuXG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEtuID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlIG4gOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIG5cbiAgbGV0IGxlbmd0aCAoazooJ2ssJ2QpIHQpIDogaW50ID0gT2JqRXBoLmxlbmd0aCBrXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCBuKVxuICBsZXQgZ2V0X2tleV9jb3B5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IG4pXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSAoazonaykgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IG4gKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCBuXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCBuXG5cbiAgbGV0IGJsaXRfa2V5ICh0MTooJ2ssJ2QpIHQpIChvMTppbnQpICh0MjooJ2ssJ2QpIHQpIChvMjppbnQpIChsOmludCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgbzEgdDIgbzIgbFxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIGxldCBtYWtlIGtleXMgZGF0YSA9XG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGgga2V5cyBpblxuICAgIGxldCBlcGggPSBjcmVhdGUgbCBpblxuICAgIHNldF9kYXRhIGVwaCBkYXRhO1xuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyBzZXRfa2V5IGVwaCBpIGtleXMuKGkpIGRvbmU7XG4gICAgZXBoXG5cbiAgbGV0IHF1ZXJ5IGVwaCBrZXlzID1cbiAgICBsZXQgbCA9IGxlbmd0aCBlcGggaW5cbiAgICB0cnlcbiAgICAgIGlmIGwgPD4gQXJyYXkubGVuZ3RoIGtleXMgdGhlbiByYWlzZSBFeGl0O1xuICAgICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICAgIG1hdGNoIGdldF9rZXkgZXBoIGkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gcmFpc2UgRXhpdFxuICAgICAgICB8IFNvbWUgayB3aGVuIGsgPT0ga2V5cy4oaSkgLT4gKClcbiAgICAgICAgfCBTb21lIF8gLT4gcmFpc2UgRXhpdFxuICAgICAgZG9uZTtcbiAgICAgIGdldF9kYXRhIGVwaFxuICAgIHdpdGggRXhpdCAtPiBOb25lXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudCBhcnJheVxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoQXJyYXkubGVuZ3RoIGspIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCBzZWVkIGsgPVxuICAgICAgICBsZXQgaCA9IHJlZiAwIGluXG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBoIDo9IEguaGFzaCBzZWVkIGsuKGkpICogNjU1OTkgKyAhaDtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgIWhcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICBsZXQgbGVuICA9IEFycmF5Lmxlbmd0aCBrIGluXG4gICAgICAgIGxldCBsZW4nID0gbGVuZ3RoIGMgaW5cbiAgICAgICAgaWYgbGVuICE9IGxlbicgdGhlbiBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgcmVjIGVxdWFsX2FycmF5IGsgYyBpID1cbiAgICAgICAgICAgIGlmIGkgPCAwIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyBpIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICAgICAgICB8IFNvbWUga2kgLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwgay4oaSkga2lcbiAgICAgICAgICAgICAgICAgIHRoZW4gZXF1YWxfYXJyYXkgayBjIChpLTEpXG4gICAgICAgICAgICAgICAgICBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgICBpblxuICAgICAgICAgIGVxdWFsX2FycmF5IGsgYyAobGVuLTEpXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgYyA9XG4gICAgICAgIGxldCBsZW4gPSBsZW5ndGggYyBpblxuICAgICAgICBpZiBsZW4gPSAwIHRoZW4gU29tZSBbfHxdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgMCB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICB8IFNvbWUgazAgLT5cbiAgICAgICAgICAgICAgbGV0IHJlYyBmaWxsIGEgaSA9XG4gICAgICAgICAgICAgICAgaWYgaSA8IDEgdGhlbiBTb21lIGFcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgaSB3aXRoXG4gICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgICAgICAgICAgfCBTb21lIGtpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgYS4oaSkgPC0ga2k7XG4gICAgICAgICAgICAgICAgICAgICAgZmlsbCBhIChpLTEpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIGxldCBhID0gQXJyYXkubWFrZSBsZW4gazAgaW5cbiAgICAgICAgICAgICAgZmlsbCBhIChsZW4tMSlcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5IGMgPVxuICAgICAgICBsZXQgcmVjIGNoZWNrIGMgaSA9XG4gICAgICAgICAgaSA8IDAgfHwgKGNoZWNrX2tleSBjIGkgJiYgY2hlY2sgYyAoaS0xKSkgaW5cbiAgICAgICAgY2hlY2sgYyAobGVuZ3RoIGMgLSAxKVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50IGFycmF5KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuICBtb2R1bGUgQnVja2V0ID0gc3RydWN0XG5cbiAgICB0eXBlIG5vbnJlYyAoJ2ssICdkKSB0ID0gKCdrLCAnZCkgdCBsaXN0IHJlZlxuICAgIGxldCBrbl9tYWtlID0gbWFrZVxuICAgIGxldCBtYWtlICgpID0gcmVmIFtdXG4gICAgbGV0IGFkZCBiIGsgZCA9IGIgOj0ga25fbWFrZSBrIGQgOjogIWJcblxuICAgIGxldCB0ZXN0X2tleXMgayBlID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBsZW5ndGggZSA8PiBBcnJheS5sZW5ndGggayB0aGVuIHJhaXNlIEV4aXQ7XG4gICAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggayAtIDEgZG9cbiAgICAgICAgICBtYXRjaCBnZXRfa2V5IGUgaSB3aXRoXG4gICAgICAgICAgfCBTb21lIHggd2hlbiB4ID09IGsuKGkpIC0+ICgpXG4gICAgICAgICAgfCBfIC0+IHJhaXNlIEV4aXRcbiAgICAgICAgZG9uZTtcbiAgICAgICAgdHJ1ZVxuICAgICAgd2l0aCBFeGl0IC0+IGZhbHNlXG5cbiAgICBsZXQgcmVtb3ZlIGIgayA9XG4gICAgICBsZXQgcmVjIGxvb3AgbCBhY2MgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGggOjogdCB3aGVuIHRlc3Rfa2V5cyBrIGggLT4gYiA6PSBMaXN0LnJldl9hcHBlbmQgYWNjIHRcbiAgICAgICAgfCBoIDo6IHQgLT4gbG9vcCB0IChoIDo6IGFjYylcbiAgICAgIGluXG4gICAgICBsb29wICFiIFtdXG5cbiAgICBsZXQgZmluZCBiIGsgPVxuICAgICAgbWF0Y2ggTGlzdC5maW5kX29wdCAodGVzdF9rZXlzIGspICFiIHdpdGhcbiAgICAgIHwgU29tZSBlIC0+IGdldF9kYXRhIGVcbiAgICAgIHwgTm9uZSAtPiBOb25lXG5cbiAgICBsZXQgbGVuZ3RoIGIgPSBMaXN0Lmxlbmd0aCAhYlxuICAgIGxldCBjbGVhciBiID0gYiA6PSBbXVxuXG4gIGVuZFxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBYYXZpZXIgTGVyb3kgYW5kIERhbWllbiBEb2xpZ2V6LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGdlbmVyaWNfcXVvdGUgcXVvdGVxdW90ZSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBpZiBzLltpXSA9ICdcXCcnXG4gICAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBiIHF1b3RlcXVvdGVcbiAgICBlbHNlIEJ1ZmZlci5hZGRfY2hhciBiICBzLltpXVxuICBkb25lO1xuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1sxXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Jhc2VuYW1lLmh0bWxcbiAgSW4gc3RlcCAxIG9mIFtbMV1dLCB3ZSBjaG9vc2UgdG8gcmV0dXJuIFwiLlwiIGZvciBlbXB0eSBpbnB1dC5cbiAgICAoZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPQ2FtbClcbiAgSW4gc3RlcCAyLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4gIFN0ZXAgNiBpcyBub3QgaW1wbGVtZW50ZWQ6IHdlIGNvbnNpZGVyIHRoYXQgdGhlIFtzdWZmaXhdIG9wZXJhbmQgaXNcbiAgICBhbHdheXMgYWJzZW50LiAgU3VmZml4ZXMgYXJlIGhhbmRsZWQgYnkgW2Nob3Bfc3VmZml4XSBhbmQgW2Nob3BfZXh0ZW5zaW9uXS5cbiopXG5sZXQgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgZmluZF9lbmQgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGZpbmRfZW5kIChuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIG4gKG4gKyAxKVxuICBhbmQgZmluZF9iZWcgbiBwID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIHBcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gU3RyaW5nLnN1YiBuYW1lIChuICsgMSkgKHAgLSBuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIChuIC0gMSkgcFxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSBmaW5kX2VuZCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1syXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Rpcm5hbWUuaHRtbFxuICBJbiBzdGVwIDYgb2YgW1syXV0sIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiopXG5sZXQgZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyB0cmFpbGluZ19zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIHRyYWlsaW5nX3NlcCAobiAtIDEpXG4gICAgZWxzZSBiYXNlIG5cbiAgYW5kIGJhc2UgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgblxuICAgIGVsc2UgYmFzZSAobiAtIDEpXG4gIGFuZCBpbnRlcm1lZGlhdGVfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIChuIC0gMSlcbiAgICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChuICsgMSlcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgdHJhaWxpbmdfc2VwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5tb2R1bGUgdHlwZSBTWVNERVBTID0gc2lnXG4gIHZhbCBudWxsIDogc3RyaW5nXG4gIHZhbCBjdXJyZW50X2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBwYXJlbnRfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIGRpcl9zZXAgOiBzdHJpbmdcbiAgdmFsIGlzX2Rpcl9zZXAgOiBzdHJpbmcgLT4gaW50IC0+IGJvb2xcbiAgdmFsIGlzX3JlbGF0aXZlIDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGlzX2ltcGxpY2l0IDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGNoZWNrX3N1ZmZpeCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgY2hvcF9zdWZmaXhfb3B0IDogc3VmZml4OnN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nIG9wdGlvblxuICB2YWwgdGVtcF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgcXVvdGUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBxdW90ZV9jb21tYW5kIDpcbiAgICBzdHJpbmcgLT4gP3N0ZGluOiBzdHJpbmcgLT4gP3N0ZG91dDogc3RyaW5nIC0+ID9zdGRlcnI6IHN0cmluZ1xuICAgICAgICAgICAtPiBzdHJpbmcgbGlzdCAtPiBzdHJpbmdcbiAgdmFsIGJhc2VuYW1lIDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgZGlybmFtZSA6IHN0cmluZyAtPiBzdHJpbmdcbmVuZFxuXG5tb2R1bGUgVW5peCA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IHMuW2ldID0gJy8nXG4gIGxldCBpc19yZWxhdGl2ZSBuID0gU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLydcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgICBTdHJpbmcuZW5kc193aXRoIH5zdWZmaXg6c3VmZiBuYW1lXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgciA9IHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVE1QRElSXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIvdG1wXCJcbiAgbGV0IHF1b3RlID0gZ2VuZXJpY19xdW90ZSBcIidcXFxcJydcIlxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiIFwiIChMaXN0Lm1hcCBxdW90ZSAoY21kIDo6IGFyZ3MpKVxuICAgIF4gKG1hdGNoIHN0ZGluICB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA8XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZGVyciB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBpZiBzdGRlcnIgPSBzdGRvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gXCIgMj4mMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZSBmKVxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgV2luMzIgOiBTWVNERVBTID0gc3RydWN0XG4gIGxldCBudWxsID0gXCJOVUxcIlxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIlxcXFxcIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBsZXQgYyA9IHMuW2ldIGluIGMgPSAnLycgfHwgYyA9ICdcXFxcJyB8fCBjID0gJzonXG4gIGxldCBpc19yZWxhdGl2ZSBuID1cbiAgICAoU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLycpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJ1xcXFwnKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IG4uWzFdIDw+ICc6JylcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLlxcXFxcIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uXFxcXFwiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICBTdHJpbmcubGVuZ3RoIG5hbWUgPj0gU3RyaW5nLmxlbmd0aCBzdWZmICYmXG4gICAobGV0IHMgPSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBzdWZmKSBpblxuICAgIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgcyA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgc3VmZilcblxuICBsZXQgY2hvcF9zdWZmaXhfb3B0IH5zdWZmaXggZmlsZW5hbWUgPVxuICAgIGxldCBsZW5fcyA9IFN0cmluZy5sZW5ndGggc3VmZml4IGFuZCBsZW5fZiA9IFN0cmluZy5sZW5ndGggZmlsZW5hbWUgaW5cbiAgICBpZiBsZW5fZiA+PSBsZW5fcyB0aGVuXG4gICAgICBsZXQgciA9IFN0cmluZy5zdWIgZmlsZW5hbWUgKGxlbl9mIC0gbGVuX3MpIGxlbl9zIGluXG4gICAgICBpZiBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHIgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cblxuICBsZXQgdGVtcF9kaXJfbmFtZSA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJURU1QXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIuXCJcbiAgbGV0IHF1b3RlIHMgPVxuICAgIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInIGVsc2VcbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJ1xcXCInIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8IGMgICAgLT4gQnVmZmVyLmFkZF9jaGFyIGIgYzsgbG9vcCAoaSsxKTtcbiAgICBhbmQgbG9vcF9icyBuIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgICAgIGFkZF9icyBuO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgICB8ICdcXFwiJyAtPiBhZGRfYnMgKDIqbisxKTsgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInOyBsb29wIChpKzEpO1xuICAgICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIChuKzEpIChpKzEpO1xuICAgICAgICB8IF8gICAgLT4gYWRkX2JzIG47IGxvb3AgaVxuICAgICAgZW5kXG4gICAgYW5kIGFkZF9icyBuID0gZm9yIF9qID0gMSB0byBuIGRvIEJ1ZmZlci5hZGRfY2hhciBiICdcXFxcJzsgZG9uZVxuICAgIGluXG4gICAgbG9vcCAwO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG4oKlxuUXVvdGluZyBjb21tYW5kcyBmb3IgZXhlY3V0aW9uIGJ5IGNtZC5leGUgaXMgZGlmZmljdWx0LlxuMS0gRWFjaCBhcmd1bWVudCBpcyBmaXJzdCBxdW90ZWQgdXNpbmcgdGhlIFwicXVvdGVcIiBmdW5jdGlvbiBhYm92ZSwgdG9cbiAgIHByb3RlY3QgaXQgYWdhaW5zdCB0aGUgcHJvY2Vzc2luZyBwZXJmb3JtZWQgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sXG4gICB0aGVuIGNtZC5leGUncyBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQgd2l0aCAnXicsIHVzaW5nXG4gICB0aGUgXCJxdW90ZV9jbWRcIiBmdW5jdGlvbiBiZWxvdy4gIEZvciBtb3JlIGRldGFpbHMsIHNlZVxuICAgaHR0cHM6Ly9ibG9ncy5tc2RuLm1pY3Jvc29mdC5jb20vdHdpc3R5bGl0dGxlcGFzc2FnZXNhbGxhbGlrZS8yMDExLzA0LzIzXG4yLSBUaGUgY29tbWFuZCBhbmQgdGhlIHJlZGlyZWN0aW9uIGZpbGVzLCBpZiBhbnksIG11c3QgYmUgZG91YmxlLXF1b3RlZFxuICAgaW4gY2FzZSB0aGV5IGNvbnRhaW4gc3BhY2VzLiAgVGhpcyBxdW90aW5nIGlzIGludGVycHJldGVkIGJ5IGNtZC5leGUsXG4gICBub3QgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sIGhlbmNlIHRoZSBcInF1b3RlXCIgZnVuY3Rpb24gYWJvdmVcbiAgIGNhbm5vdCBiZSB1c2VkLiAgVGhlIHR3byBjaGFyYWN0ZXJzIHdlIGRvbid0IGtub3cgaG93IHRvIHF1b3RlXG4gICBpbnNpZGUgYSBkb3VibGUtcXVvdGVkIGNtZC5leGUgc3RyaW5nIGFyZSBkb3VibGUtcXVvdGUgYW5kIHBlcmNlbnQuXG4gICBXZSBqdXN0IGZhaWwgaWYgdGhlIGNvbW1hbmQgbmFtZSBvciB0aGUgcmVkaXJlY3Rpb24gZmlsZSBuYW1lc1xuICAgY29udGFpbiBhIGRvdWJsZSBxdW90ZSAobm90IGFsbG93ZWQgaW4gV2luZG93cyBmaWxlIG5hbWVzLCBhbnl3YXkpXG4gICBvciBhIHBlcmNlbnQuICBTZWUgZnVuY3Rpb24gXCJxdW90ZV9jbWRfZmlsZW5hbWVcIiBiZWxvdy5cbjMtIFRoZSB3aG9sZSBzdHJpbmcgcGFzc2VkIHRvIFN5cy5jb21tYW5kIGlzIHRoZW4gZW5jbG9zZWQgaW4gZG91YmxlXG4gICBxdW90ZXMsIHdoaWNoIGFyZSBpbW1lZGlhdGVseSBzdHJpcHBlZCBieSBjbWQuZXhlLiAgT3RoZXJ3aXNlLFxuICAgc29tZSBvZiB0aGUgZG91YmxlIHF1b3RlcyBmcm9tIHN0ZXAgMiBhYm92ZSBjYW4gYmUgbWlzcGFyc2VkLlxuICAgU2VlIGUuZy4gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk5NjUxNDFcbiopXG4gIGxldCBxdW90ZV9jbWQgcyA9XG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMgKyAyMCkgaW5cbiAgICBTdHJpbmcuaXRlclxuICAgICAgKGZ1biBjIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcoJyB8ICcpJyB8ICchJyB8ICdeJyB8ICclJyB8ICdcXFwiJyB8ICc8JyB8ICc+JyB8ICcmJyB8ICd8JyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ14nOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgYylcbiAgICAgIHM7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgbGV0IHF1b3RlX2NtZF9maWxlbmFtZSBmID1cbiAgICBpZiBTdHJpbmcuY29udGFpbnMgZiAnXFxcIicgfHwgU3RyaW5nLmNvbnRhaW5zIGYgJyUnIHRoZW5cbiAgICAgIGZhaWx3aXRoIChcIkZpbGVuYW1lLnF1b3RlX2NvbW1hbmQ6IGJhZCBmaWxlIG5hbWUgXCIgXiBmKVxuICAgIGVsc2UgaWYgU3RyaW5nLmNvbnRhaW5zIGYgJyAnIHRoZW5cbiAgICAgIFwiXFxcIlwiIF4gZiBeIFwiXFxcIlwiXG4gICAgZWxzZVxuICAgICAgZlxuICAoKiBSZWRpcmVjdGlvbnMgaW4gY21kLmV4ZTogc2VlIGh0dHBzOi8vc3M2NC5jb20vbnQvc3ludGF4LXJlZGlyZWN0aW9uLmh0bWxcbiAgICAgYW5kIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3ByZXZpb3VzLXZlcnNpb25zL3dpbmRvd3MvaXQtcHJvL3dpbmRvd3MteHAvYmI0OTA5ODIodj10ZWNobmV0LjEwKVxuICAqKVxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiXCIgW1xuICAgICAgXCJcXFwiXCI7XG4gICAgICBxdW90ZV9jbWRfZmlsZW5hbWUgY21kO1xuICAgICAgXCIgXCI7XG4gICAgICBxdW90ZV9jbWQgKFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QubWFwIHF1b3RlIGFyZ3MpKTtcbiAgICAgIChtYXRjaCBzdGRpbiAgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPFwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICAobWF0Y2ggc3RkZXJyIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgc3RkZXJyID0gc3Rkb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBcIiAyPiYxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICBcIlxcXCJcIlxuICAgIF1cbiAgbGV0IGhhc19kcml2ZSBzID1cbiAgICBsZXQgaXNfbGV0dGVyID0gZnVuY3Rpb25cbiAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBTdHJpbmcubGVuZ3RoIHMgPj0gMiAmJiBpc19sZXR0ZXIgcy5bMF0gJiYgcy5bMV0gPSAnOidcbiAgbGV0IGRyaXZlX2FuZF9wYXRoIHMgPVxuICAgIGlmIGhhc19kcml2ZSBzXG4gICAgdGhlbiAoU3RyaW5nLnN1YiBzIDAgMiwgU3RyaW5nLnN1YiBzIDIgKFN0cmluZy5sZW5ndGggcyAtIDIpKVxuICAgIGVsc2UgKFwiXCIsIHMpXG4gIGxldCBkaXJuYW1lIHMgPVxuICAgIGxldCAoZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGxldCBkaXIgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGggaW5cbiAgICBkcml2ZSBeIGRpclxuICBsZXQgYmFzZW5hbWUgcyA9XG4gICAgbGV0IChfZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGhcbmVuZFxuXG5tb2R1bGUgQ3lnd2luIDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiL2Rldi9udWxsXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgPSBXaW4zMi5pc19kaXJfc2VwXG4gIGxldCBpc19yZWxhdGl2ZSA9IFdpbjMyLmlzX3JlbGF0aXZlXG4gIGxldCBpc19pbXBsaWNpdCA9IFdpbjMyLmlzX2ltcGxpY2l0XG4gIGxldCBjaGVja19zdWZmaXggPSBXaW4zMi5jaGVja19zdWZmaXhcbiAgbGV0IGNob3Bfc3VmZml4X29wdCA9IFdpbjMyLmNob3Bfc3VmZml4X29wdFxuICBsZXQgdGVtcF9kaXJfbmFtZSA9IFVuaXgudGVtcF9kaXJfbmFtZVxuICBsZXQgcXVvdGUgPSBVbml4LnF1b3RlXG4gIGxldCBxdW90ZV9jb21tYW5kID0gVW5peC5xdW90ZV9jb21tYW5kXG4gIGxldCBiYXNlbmFtZSA9IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG4gIGxldCBkaXJuYW1lID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuZW5kXG5cbm1vZHVsZSBTeXNkZXBzID1cbiAgKHZhbCAobWF0Y2ggU3lzLm9zX3R5cGUgd2l0aFxuICAgICAgIHwgXCJXaW4zMlwiIC0+IChtb2R1bGUgV2luMzI6IFNZU0RFUFMpXG4gICAgICAgfCBcIkN5Z3dpblwiIC0+IChtb2R1bGUgQ3lnd2luOiBTWVNERVBTKVxuICAgICAgIHwgXyAtPiAobW9kdWxlIFVuaXg6IFNZU0RFUFMpKSlcblxuaW5jbHVkZSBTeXNkZXBzXG5cbmxldCBjb25jYXQgZGlybmFtZSBmaWxlbmFtZSA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBkaXJuYW1lIGluXG4gIGlmIGwgPSAwIHx8IGlzX2Rpcl9zZXAgZGlybmFtZSAobC0xKVxuICB0aGVuIGRpcm5hbWUgXiBmaWxlbmFtZVxuICBlbHNlIGRpcm5hbWUgXiBkaXJfc2VwIF4gZmlsZW5hbWVcblxubGV0IGNob3Bfc3VmZml4IG5hbWUgc3VmZiA9XG4gIGlmIGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmZcbiAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICBlbHNlIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9zdWZmaXhcIlxuXG5sZXQgZXh0ZW5zaW9uX2xlbiBuYW1lID1cbiAgbGV0IHJlYyBjaGVjayBpMCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaTAgKGkgLSAxKVxuICAgIGVsc2UgU3RyaW5nLmxlbmd0aCBuYW1lIC0gaTBcbiAgaW5cbiAgbGV0IHJlYyBzZWFyY2hfZG90IGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpIChpIC0gMSlcbiAgICBlbHNlIHNlYXJjaF9kb3QgKGkgLSAxKVxuICBpblxuICBzZWFyY2hfZG90IChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5sZXQgZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIFwiXCIgZWxzZSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpIGxcblxubGV0IGNob3BfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9leHRlbnNpb25cIlxuICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5sZXQgcmVtb3ZlX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBuYW1lIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmV4dGVybmFsIG9wZW5fZGVzYzogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuZXh0ZXJuYWwgY2xvc2VfZGVzYzogaW50IC0+IHVuaXQgPSBcImNhbWxfc3lzX2Nsb3NlXCJcblxubGV0IHBybmcgPSBsYXp5KFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcm5kID0gKFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpKSBsYW5kIDB4RkZGRkZGIGluXG4gIGNvbmNhdCB0ZW1wX2RpciAoUHJpbnRmLnNwcmludGYgXCIlcyUwNnglc1wiIHByZWZpeCBybmQgc3VmZml4KVxuXG5cbmxldCBjdXJyZW50X3RlbXBfZGlyX25hbWUgPSByZWYgdGVtcF9kaXJfbmFtZVxuXG5sZXQgc2V0X3RlbXBfZGlyX25hbWUgcyA9IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA6PSBzXG5sZXQgZ2V0X3RlbXBfZGlyX25hbWUgKCkgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lXG5cbmxldCB0ZW1wX2ZpbGUgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgY2xvc2VfZGVzYyhvcGVuX2Rlc2MgbmFtZSBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fZXhjbF0gMG82MDApO1xuICAgICAgbmFtZVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuXG5sZXQgb3Blbl90ZW1wX2ZpbGUgPyhtb2RlID0gW09wZW5fdGV4dF0pID8ocGVybXMgPSAwbzYwMClcbiAgICAgICAgICAgICAgICAgICA/KHRlbXBfZGlyID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICAobmFtZSxcbiAgICAgICBvcGVuX291dF9nZW4gKE9wZW5fd3Jvbmx5OjpPcGVuX2NyZWF0OjpPcGVuX2V4Y2w6Om1vZGUpIHBlcm1zIG5hbWUpXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENvbXBsZXggbnVtYmVycyAqKVxuXG50eXBlIHQgPSB7IHJlOiBmbG9hdDsgaW06IGZsb2F0IH1cblxubGV0IHplcm8gPSB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG5sZXQgb25lID0geyByZSA9IDEuMDsgaW0gPSAwLjAgfVxubGV0IGkgPSB7IHJlID0gMC4wOyBpbSA9IDEuMCB9XG5cbmxldCBhZGQgeCB5ID0geyByZSA9IHgucmUgKy4geS5yZTsgaW0gPSB4LmltICsuIHkuaW0gfVxuXG5sZXQgc3ViIHggeSA9IHsgcmUgPSB4LnJlIC0uIHkucmU7IGltID0geC5pbSAtLiB5LmltIH1cblxubGV0IG5lZyB4ID0geyByZSA9IC0uIHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBjb25qIHggPSB7IHJlID0geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IG11bCB4IHkgPSB7IHJlID0geC5yZSAqLiB5LnJlIC0uIHguaW0gKi4geS5pbTtcbiAgICAgICAgICAgICAgICBpbSA9IHgucmUgKi4geS5pbSArLiB4LmltICouIHkucmUgfVxuXG5sZXQgZGl2IHggeSA9XG4gIGlmIGFic19mbG9hdCB5LnJlID49IGFic19mbG9hdCB5LmltIHRoZW5cbiAgICBsZXQgciA9IHkuaW0gLy4geS5yZSBpblxuICAgIGxldCBkID0geS5yZSArLiByICouIHkuaW0gaW5cbiAgICB7IHJlID0gKHgucmUgKy4gciAqLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAoeC5pbSAtLiByICouIHgucmUpIC8uIGQgfVxuICBlbHNlXG4gICAgbGV0IHIgPSB5LnJlIC8uIHkuaW0gaW5cbiAgICBsZXQgZCA9IHkuaW0gKy4gciAqLiB5LnJlIGluXG4gICAgeyByZSA9IChyICouIHgucmUgKy4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHIgKi4geC5pbSAtLiB4LnJlKSAvLiBkIH1cblxubGV0IGludiB4ID0gZGl2IG9uZSB4XG5cbmxldCBub3JtMiB4ID0geC5yZSAqLiB4LnJlICsuIHguaW0gKi4geC5pbVxuXG5sZXQgbm9ybSB4ID1cbiAgKCogV2F0Y2ggb3V0IGZvciBvdmVyZmxvdyBpbiBjb21wdXRpbmcgcmVeMiArIGltXjIgKilcbiAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gIGlmIHIgPSAwLjAgdGhlbiBpXG4gIGVsc2UgaWYgaSA9IDAuMCB0aGVuIHJcbiAgZWxzZSBpZiByID49IGkgdGhlblxuICAgIGxldCBxID0gaSAvLiByIGluIHIgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuICBlbHNlXG4gICAgbGV0IHEgPSByIC8uIGkgaW4gaSAqLiBzcXJ0KDEuMCArLiBxICouIHEpXG5cbmxldCBhcmcgeCA9IGF0YW4yIHguaW0geC5yZVxuXG5sZXQgcG9sYXIgbiBhID0geyByZSA9IGNvcyBhICouIG47IGltID0gc2luIGEgKi4gbiB9XG5cbmxldCBzcXJ0IHggPVxuICBpZiB4LnJlID0gMC4wICYmIHguaW0gPSAwLjAgdGhlbiB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgICBsZXQgdyA9XG4gICAgICBpZiByID49IGkgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcSA9IGkgLy4gciBpblxuICAgICAgICBzcXJ0KHIpICouIHNxcnQoMC41ICouICgxLjAgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgcSA9IHIgLy4gaSBpblxuICAgICAgICBzcXJ0KGkpICouIHNxcnQoMC41ICouIChxICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGluXG4gICAgaWYgeC5yZSA+PSAwLjBcbiAgICB0aGVuIHsgcmUgPSB3OyAgaW0gPSAwLjUgKi4geC5pbSAvLiB3IH1cbiAgICBlbHNlIHsgcmUgPSAwLjUgKi4gaSAvLiB3OyAgaW0gPSBpZiB4LmltID49IDAuMCB0aGVuIHcgZWxzZSAtLiB3IH1cbiAgZW5kXG5cbmxldCBleHAgeCA9XG4gIGxldCBlID0gZXhwIHgucmUgaW4geyByZSA9IGUgKi4gY29zIHguaW07IGltID0gZSAqLiBzaW4geC5pbSB9XG5cbmxldCBsb2cgeCA9IHsgcmUgPSBsb2cgKG5vcm0geCk7IGltID0gYXRhbjIgeC5pbSB4LnJlIH1cblxubGV0IHBvdyB4IHkgPSBleHAgKG11bCB5IChsb2cgeCkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgTWFudWVsIFNlcnJhbm8gZXQgWGF2aWVyIExlcm95LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbQmlnYXJyYXldOiBsYXJnZSwgbXVsdGktZGltZW5zaW9uYWwsIG51bWVyaWNhbCBhcnJheXMgKilcblxuKCogVGhlc2UgdHlwZXMgaW4gbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgdGFibGVzIGluXG4gICAuLi90eXBpbmcvdHlwZW9wdC5tbCAqKVxuXG50eXBlIGZsb2F0MzJfZWx0ID0gRmxvYXQzMl9lbHRcbnR5cGUgZmxvYXQ2NF9lbHQgPSBGbG9hdDY0X2VsdFxudHlwZSBpbnQ4X3NpZ25lZF9lbHQgPSBJbnQ4X3NpZ25lZF9lbHRcbnR5cGUgaW50OF91bnNpZ25lZF9lbHQgPSBJbnQ4X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQxNl9zaWduZWRfZWx0ID0gSW50MTZfc2lnbmVkX2VsdFxudHlwZSBpbnQxNl91bnNpZ25lZF9lbHQgPSBJbnQxNl91bnNpZ25lZF9lbHRcbnR5cGUgaW50MzJfZWx0ID0gSW50MzJfZWx0XG50eXBlIGludDY0X2VsdCA9IEludDY0X2VsdFxudHlwZSBpbnRfZWx0ID0gSW50X2VsdFxudHlwZSBuYXRpdmVpbnRfZWx0ID0gTmF0aXZlaW50X2VsdFxudHlwZSBjb21wbGV4MzJfZWx0ID0gQ29tcGxleDMyX2VsdFxudHlwZSBjb21wbGV4NjRfZWx0ID0gQ29tcGxleDY0X2VsdFxuXG50eXBlICgnYSwgJ2IpIGtpbmQgPVxuICAgIEZsb2F0MzIgOiAoZmxvYXQsIGZsb2F0MzJfZWx0KSBraW5kXG4gIHwgRmxvYXQ2NCA6IChmbG9hdCwgZmxvYXQ2NF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3NpZ25lZCA6IChpbnQsIGludDhfc2lnbmVkX2VsdCkga2luZFxuICB8IEludDhfdW5zaWduZWQgOiAoaW50LCBpbnQ4X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDE2X3NpZ25lZCA6IChpbnQsIGludDE2X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl91bnNpZ25lZCA6IChpbnQsIGludDE2X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDMyIDogKGludDMyLCBpbnQzMl9lbHQpIGtpbmRcbiAgfCBJbnQ2NCA6IChpbnQ2NCwgaW50NjRfZWx0KSBraW5kXG4gIHwgSW50IDogKGludCwgaW50X2VsdCkga2luZFxuICB8IE5hdGl2ZWludCA6IChuYXRpdmVpbnQsIG5hdGl2ZWludF9lbHQpIGtpbmRcbiAgfCBDb21wbGV4MzIgOiAoQ29tcGxleC50LCBjb21wbGV4MzJfZWx0KSBraW5kXG4gIHwgQ29tcGxleDY0IDogKENvbXBsZXgudCwgY29tcGxleDY0X2VsdCkga2luZFxuICB8IENoYXIgOiAoY2hhciwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcblxudHlwZSBjX2xheW91dCA9IENfbGF5b3V0X3R5cFxudHlwZSBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0X3R5cCAoKiopXG5cbnR5cGUgJ2EgbGF5b3V0ID1cbiAgICBDX2xheW91dDogY19sYXlvdXQgbGF5b3V0XG4gIHwgRm9ydHJhbl9sYXlvdXQ6IGZvcnRyYW5fbGF5b3V0IGxheW91dFxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfa2luZCBlbnVtZXJhdGlvblxuICAgaW4gYmlnYXJyYXkuaCAqKVxuXG5sZXQgZmxvYXQzMiA9IEZsb2F0MzJcbmxldCBmbG9hdDY0ID0gRmxvYXQ2NFxubGV0IGludDhfc2lnbmVkID0gSW50OF9zaWduZWRcbmxldCBpbnQ4X3Vuc2lnbmVkID0gSW50OF91bnNpZ25lZFxubGV0IGludDE2X3NpZ25lZCA9IEludDE2X3NpZ25lZFxubGV0IGludDE2X3Vuc2lnbmVkID0gSW50MTZfdW5zaWduZWRcbmxldCBpbnQzMiA9IEludDMyXG5sZXQgaW50NjQgPSBJbnQ2NFxubGV0IGludCA9IEludFxubGV0IG5hdGl2ZWludCA9IE5hdGl2ZWludFxubGV0IGNvbXBsZXgzMiA9IENvbXBsZXgzMlxubGV0IGNvbXBsZXg2NCA9IENvbXBsZXg2NFxubGV0IGNoYXIgPSBDaGFyXG5cbmxldCBraW5kX3NpemVfaW5fYnl0ZXMgOiB0eXBlIGEgYi4gKGEsIGIpIGtpbmQgLT4gaW50ID0gZnVuY3Rpb25cbiAgfCBGbG9hdDMyIC0+IDRcbiAgfCBGbG9hdDY0IC0+IDhcbiAgfCBJbnQ4X3NpZ25lZCAtPiAxXG4gIHwgSW50OF91bnNpZ25lZCAtPiAxXG4gIHwgSW50MTZfc2lnbmVkIC0+IDJcbiAgfCBJbnQxNl91bnNpZ25lZCAtPiAyXG4gIHwgSW50MzIgLT4gNFxuICB8IEludDY0IC0+IDhcbiAgfCBJbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBOYXRpdmVpbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBDb21wbGV4MzIgLT4gOFxuICB8IENvbXBsZXg2NCAtPiAxNlxuICB8IENoYXIgLT4gMVxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfbGF5b3V0IGVudW1lcmF0aW9uXG4gICBpbiBiaWdhcnJheS5oICopXG5cbmxldCBjX2xheW91dCA9IENfbGF5b3V0XG5sZXQgZm9ydHJhbl9sYXlvdXQgPSBGb3J0cmFuX2xheW91dFxuXG5tb2R1bGUgR2VuYXJyYXkgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdFxuICBleHRlcm5hbCBjcmVhdGU6ICgnYSwgJ2IpIGtpbmQgLT4gJ2MgbGF5b3V0IC0+IGludCBhcnJheSAtPiAoJ2EsICdiLCAnYykgdFxuICAgICA9IFwiY2FtbF9iYV9jcmVhdGVcIlxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCBhcnJheSAtPiAnYVxuICAgICA9IFwiY2FtbF9iYV9nZXRfZ2VuZXJpY1wiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfc2V0X2dlbmVyaWNcIlxuXG4gIGxldCByZWMgY2xvb3AgYXJyIGlkeCBmIGNvbCBtYXggPVxuICAgIGlmIGNvbCA9IEFycmF5Lmxlbmd0aCBpZHggdGhlbiBzZXQgYXJyIGlkeCAoZiBpZHgpXG4gICAgZWxzZSBmb3IgaiA9IDAgdG8gcHJlZCBtYXguKGNvbCkgZG9cbiAgICAgICAgICAgaWR4Lihjb2wpIDwtIGo7XG4gICAgICAgICAgIGNsb29wIGFyciBpZHggZiAoc3VjYyBjb2wpIG1heFxuICAgICAgICAgZG9uZVxuICBsZXQgcmVjIGZsb29wIGFyciBpZHggZiBjb2wgbWF4ID1cbiAgICBpZiBjb2wgPCAwIHRoZW4gc2V0IGFyciBpZHggKGYgaWR4KVxuICAgIGVsc2UgZm9yIGogPSAxIHRvIG1heC4oY29sKSBkb1xuICAgICAgICAgICBpZHguKGNvbCkgPC0gajtcbiAgICAgICAgICAgZmxvb3AgYXJyIGlkeCBmIChwcmVkIGNvbCkgbWF4XG4gICAgICAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW1zIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltcyBpblxuICAgIG1hdGNoIEFycmF5Lmxlbmd0aCBkaW1zLCBsYXlvdXQgd2l0aFxuICAgIHwgMCwgXyAtPiBhcnJcbiAgICB8IGRsZW4sIENfbGF5b3V0IC0+IGNsb29wIGFyciAoQXJyYXkubWFrZSBkbGVuIDApIGYgMCBkaW1zOyBhcnJcbiAgICB8IGRsZW4sIEZvcnRyYW5fbGF5b3V0IC0+IGZsb29wIGFyciAoQXJyYXkubWFrZSBkbGVuIDEpIGYgKHByZWQgZGxlbikgZGltcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyclxuXG4gIGV4dGVybmFsIG51bV9kaW1zOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcImNhbWxfYmFfbnVtX2RpbXNcIlxuICBleHRlcm5hbCBudGhfZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX2JhX2RpbVwiXG4gIGxldCBkaW1zIGEgPVxuICAgIGxldCBuID0gbnVtX2RpbXMgYSBpblxuICAgIGxldCBkID0gQXJyYXkubWFrZSBuIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gbi0xIGRvIGQuKGkpIDwtIG50aF9kaW0gYSBpIGRvbmU7XG4gICAgZFxuXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoQXJyYXkuZm9sZF9sZWZ0ICggKiApIDEgKGRpbXMgYXJyKSlcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc2xpY2VfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IGFycmF5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3NsaWNlXCJcbiAgZXh0ZXJuYWwgc2xpY2VfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCBhcnJheSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zbGljZVwiXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5lbmRcblxubW9kdWxlIEFycmF5MCA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8fF1cbiAgbGV0IGdldCBhcnIgPSBHZW5hcnJheS5nZXQgYXJyIFt8fF1cbiAgbGV0IHNldCBhcnIgPSBHZW5hcnJheS5zZXQgYXJyIFt8fF1cbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPSBraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKVxuXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5cbiAgbGV0IG9mX3ZhbHVlIGtpbmQgbGF5b3V0IHYgPVxuICAgIGxldCBhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGluXG4gICAgc2V0IGEgdjtcbiAgICBhXG4gIGxldCBpbml0ID0gb2ZfdmFsdWVcbmVuZFxuXG5tb2R1bGUgQXJyYXkxID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8xXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWNhbWxfYmFfc2V0XzFcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMVwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzFcIlxuICBleHRlcm5hbCBkaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0gYXJyKVxuXG4gIGV4dGVybmFsIHN1YjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCAnYykgdCA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2UgKHR5cGUgdCkgKGEgOiAoXywgXywgdCkgR2VuYXJyYXkudCkgbiA9XG4gICAgbWF0Y2ggbGF5b3V0IGEgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XSA6IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF06IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgY19pbml0IGFyciBkaW0gZiA9XG4gICAgZm9yIGkgPSAwIHRvIHByZWQgZGltIGRvIHVuc2FmZV9zZXQgYXJyIGkgKGYgaSkgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0gZiA9XG4gICAgZm9yIGkgPSAxIHRvIGRpbSBkbyB1bnNhZmVfc2V0IGFyciBpIChmIGkpIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbSBmID1cbiAgICBsZXQgYXJyID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjX2luaXQgYXJyIGRpbSBmOyBhcnJcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5faW5pdCBhcnIgZGltIGY7IGFyclxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IChBcnJheS5sZW5ndGggZGF0YSkgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkYXRhIC0gMSBkbyB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSBkYXRhLihpKSBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MiA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbTE7IGRpbTJ8XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8yXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYVxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzJcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycilcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6XG4gICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdCBhIG4gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF1cbiAgbGV0IHNsaWNlX3JpZ2h0IGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltMSBkaW0yIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbTEgZG9cbiAgICAgIGZvciBqID0gMCB0byBwcmVkIGRpbTIgZG9cbiAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIChmIGkgailcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBmID1cbiAgICBmb3IgaiA9IDEgdG8gZGltMiBkb1xuICAgICAgZm9yIGkgPSAxIHRvIGRpbTEgZG9cbiAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIChmIGkgailcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW0xIGRpbTIgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0xIGRpbTIgZjsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkyLm9mX2FycmF5OiBub24tcmVjdGFuZ3VsYXIgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgcm93LihqKVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5tb2R1bGUgQXJyYXkzID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yOyBkaW0zfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzNcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3NldF8zXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfM1wiXG4gIGV4dGVybmFsIGRpbTE6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBkaW0yOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8yXCJcbiAgZXh0ZXJuYWwgZGltMzogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fM1wiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycikgKiAoZGltMyBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZV9sZWZ0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xuOyBtfF1cbiAgbGV0IHNsaWNlX3JpZ2h0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9sZWZ0XzIgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZiA9XG4gICAgZm9yIGkgPSAwIHRvIHByZWQgZGltMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIHByZWQgZGltMiBkb1xuICAgICAgICBmb3IgayA9IDAgdG8gcHJlZCBkaW0zIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIGsgKGYgaSBqIGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGZvciBrID0gMSB0byBkaW0zIGRvXG4gICAgICBmb3IgaiA9IDEgdG8gZGltMiBkb1xuICAgICAgICBmb3IgaSA9IDEgdG8gZGltMSBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiBrIChmIGkgaiBrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltMSBkaW0yIGRpbTMgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGY7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBkaW0zID0gaWYgZGltMiA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gZGltMSAtIDEgZG9cbiAgICAgIGxldCByb3cgPSBkYXRhLihpKSBpblxuICAgICAgaWYgQXJyYXkubGVuZ3RoIHJvdyA8PiBkaW0yIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgZm9yIGogPSAwIHRvIGRpbTIgLSAxIGRvXG4gICAgICAgIGxldCBjb2wgPSByb3cuKGopIGluXG4gICAgICAgIGlmIEFycmF5Lmxlbmd0aCBjb2wgPD4gZGltMyB0aGVuXG4gICAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgICBmb3IgayA9IDAgdG8gZGltMyAtIDEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgKGsgKyBvZnMpIGNvbC4oaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTA6ICgnYSwgJ2IsICdjKSBBcnJheTAudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTE6ICgnYSwgJ2IsICdjKSBBcnJheTEudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTI6ICgnYSwgJ2IsICdjKSBBcnJheTIudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTM6ICgnYSwgJ2IsICdjKSBBcnJheTMudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5sZXQgYXJyYXkwX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMCB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MF9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkxX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMSB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MV9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkyX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMiB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5Ml9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkzX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMyB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5M19vZl9nZW5hcnJheVwiXG5cbmV4dGVybmFsIHJlc2hhcGU6XG4gICAoJ2EsICdiLCAnYykgR2VuYXJyYXkudCAtPiBpbnQgYXJyYXkgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCJjYW1sX2JhX3Jlc2hhcGVcIlxubGV0IHJlc2hhcGVfMCBhID0gcmVzaGFwZSBhIFt8fF1cbmxldCByZXNoYXBlXzEgYSBkaW0xID0gcmVzaGFwZSBhIFt8ZGltMXxdXG5sZXQgcmVzaGFwZV8yIGEgZGltMSBkaW0yID0gcmVzaGFwZSBhIFt8ZGltMTtkaW0yfF1cbmxldCByZXNoYXBlXzMgYSBkaW0xIGRpbTIgZGltMyA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMjtkaW0zfF1cblxuKCogRm9yY2UgY2FtbF9iYV9nZXRfezEsMiwzLE59IHRvIGJlIGxpbmtlZCBpbiwgc2luY2Ugd2UgZG9uJ3QgcmVmZXJcbiAgIHRvIHRob3NlIHByaW1pdGl2ZXMgZGlyZWN0bHkgaW4gdGhpcyBmaWxlICopXG5cbmxldCBfID1cbiAgbGV0IF8gPSBHZW5hcnJheS5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTEuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkyLmdldCBpblxuICBsZXQgXyA9IEFycmF5My5nZXQgaW5cbiAgKClcblxuW0BAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cbmV4dGVybmFsIGdldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfMVwiXG5leHRlcm5hbCBnZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzJcIlxuZXh0ZXJuYWwgZ2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8zXCJcbmV4dGVybmFsIHNldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfMVwiXG5leHRlcm5hbCBzZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzJcIlxuZXh0ZXJuYWwgc2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8zXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMjEgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gaW5fY2hhbm5lbFxuXG50eXBlIG9wZW5fZmxhZyA9IFN0ZGxpYi5vcGVuX2ZsYWcgPVxuICB8IE9wZW5fcmRvbmx5XG4gIHwgT3Blbl93cm9ubHlcbiAgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXRcbiAgfCBPcGVuX3RydW5jXG4gIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnlcbiAgfCBPcGVuX3RleHRcbiAgfCBPcGVuX25vbmJsb2NrXG5cbmxldCBzdGRpbiA9IFN0ZGxpYi5zdGRpblxubGV0IG9wZW5fYmluID0gU3RkbGliLm9wZW5faW5fYmluXG5sZXQgb3Blbl90ZXh0ID0gU3RkbGliLm9wZW5faW5cbmxldCBvcGVuX2dlbiA9IFN0ZGxpYi5vcGVuX2luX2dlblxuXG5sZXQgd2l0aF9vcGVuIG9wZW5mdW4gcyBmID1cbiAgbGV0IGljID0gb3BlbmZ1biBzIGluXG4gIEZ1bi5wcm90ZWN0IH5maW5hbGx5OihmdW4gKCkgLT4gU3RkbGliLmNsb3NlX2luX25vZXJyIGljKVxuICAgIChmdW4gKCkgLT4gZiBpYylcblxubGV0IHdpdGhfb3Blbl9iaW4gcyBmID1cbiAgd2l0aF9vcGVuIFN0ZGxpYi5vcGVuX2luX2JpbiBzIGZcblxubGV0IHdpdGhfb3Blbl90ZXh0IHMgZiA9XG4gIHdpdGhfb3BlbiBTdGRsaWIub3Blbl9pbiBzIGZcblxubGV0IHdpdGhfb3Blbl9nZW4gZmxhZ3MgcGVybSBzIGYgPVxuICB3aXRoX29wZW4gKFN0ZGxpYi5vcGVuX2luX2dlbiBmbGFncyBwZXJtKSBzIGZcblxubGV0IHNlZWsgPSBTdGRsaWIuTGFyZ2VGaWxlLnNlZWtfaW5cbmxldCBwb3MgPSBTdGRsaWIuTGFyZ2VGaWxlLnBvc19pblxubGV0IGxlbmd0aCA9IFN0ZGxpYi5MYXJnZUZpbGUuaW5fY2hhbm5lbF9sZW5ndGhcbmxldCBjbG9zZSA9IFN0ZGxpYi5jbG9zZV9pblxubGV0IGNsb3NlX25vZXJyID0gU3RkbGliLmNsb3NlX2luX25vZXJyXG5cbmxldCBpbnB1dF9jaGFyIGljID1cbiAgbWF0Y2ggU3RkbGliLmlucHV0X2NoYXIgaWMgd2l0aFxuICB8IGMgLT4gU29tZSBjXG4gIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+IE5vbmVcblxubGV0IGlucHV0X2J5dGUgaWMgPVxuICBtYXRjaCBTdGRsaWIuaW5wdXRfYnl0ZSBpYyB3aXRoXG4gIHwgbiAtPiBTb21lIG5cbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTm9uZVxuXG5sZXQgaW5wdXRfbGluZSBpYyA9XG4gIG1hdGNoIFN0ZGxpYi5pbnB1dF9saW5lIGljIHdpdGhcbiAgfCBzIC0+IFNvbWUgc1xuICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPiBOb25lXG5cbmxldCBpbnB1dCA9IFN0ZGxpYi5pbnB1dFxuXG5sZXQgcmVhbGx5X2lucHV0IGljIGJ1ZiBwb3MgbGVuID1cbiAgbWF0Y2ggU3RkbGliLnJlYWxseV9pbnB1dCBpYyBidWYgcG9zIGxlbiB3aXRoXG4gIHwgKCkgLT4gU29tZSAoKVxuICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPiBOb25lXG5cbmxldCByZWFsbHlfaW5wdXRfc3RyaW5nIGljIGxlbiA9XG4gIG1hdGNoIFN0ZGxpYi5yZWFsbHlfaW5wdXRfc3RyaW5nIGljIGxlbiB3aXRoXG4gIHwgcyAtPiBTb21lIHNcbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTm9uZVxuXG4oKiBSZWFkIHVwIHRvIFtsZW5dIGJ5dGVzIGludG8gW2J1Zl0sIHN0YXJ0aW5nIGF0IFtvZnNdLiBSZXR1cm4gdG90YWwgYnl0ZXNcbiAgIHJlYWQuICopXG5sZXQgcmVhZF91cHRvIGljIGJ1ZiBvZnMgbGVuID1cbiAgbGV0IHJlYyBsb29wIG9mcyBsZW4gPVxuICAgIGlmIGxlbiA9IDAgdGhlbiBvZnNcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IFN0ZGxpYi5pbnB1dCBpYyBidWYgb2ZzIGxlbiBpblxuICAgICAgaWYgciA9IDAgdGhlblxuICAgICAgICBvZnNcbiAgICAgIGVsc2VcbiAgICAgICAgbG9vcCAob2ZzICsgcikgKGxlbiAtIHIpXG4gICAgZW5kXG4gIGluXG4gIGxvb3Agb2ZzIGxlbiAtIG9mc1xuXG4oKiBCZXN0IGVmZm9ydCBhdHRlbXB0IHRvIHJldHVybiBhIGJ1ZmZlciB3aXRoID49IChvZnMgKyBuKSBieXRlcyBvZiBzdG9yYWdlLFxuICAgYW5kIHN1Y2ggdGhhdCBpdCBjb2luY2lkZXMgd2l0aCBbYnVmXSBhdCBpbmRpY2VzIDwgW29mc10uXG5cbiAgIFRoZSByZXR1cm5lZCBidWZmZXIgaXMgZXF1YWwgdG8gW2J1Zl0gaXRzZWxmIGlmIGl0IGFscmVhZHkgaGFzIHN1ZmZpY2llbnRcbiAgIGZyZWUgc3BhY2UuXG5cbiAgIFRoZSByZXR1cm5lZCBidWZmZXIgbWF5IGhhdmUgKmZld2VyKiB0aGFuIFtvZnMgKyBuXSBieXRlcyBvZiBzdG9yYWdlIGlmIHRoaXNcbiAgIG51bWJlciBpcyA+IFtTeXMubWF4X3N0cmluZ19sZW5ndGhdLiBIb3dldmVyIHRoZSByZXR1cm5lZCBidWZmZXIgd2lsbFxuICAgKmFsd2F5cyogaGF2ZSA+IFtvZnNdIGJ5dGVzIG9mIHN0b3JhZ2UuIEluIHRoZSBsaW1pdGluZyBjYXNlIHdoZW4gW29mcyA9IGxlblxuICAgPSBTeXMubWF4X3N0cmluZ19sZW5ndGhdIChzbyB0aGF0IGl0IGlzIG5vdCBwb3NzaWJsZSB0byByZXNpemUgdGhlIGJ1ZmZlciBhdFxuICAgYWxsKSwgYW4gZXhjZXB0aW9uIGlzIHJhaXNlZC4gKilcblxubGV0IGVuc3VyZSBidWYgb2ZzIG4gPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJ1ZiBpblxuICBpZiBsZW4gPj0gb2ZzICsgbiB0aGVuIGJ1ZlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG5ld19sZW4gPSByZWYgbGVuIGluXG4gICAgd2hpbGUgIW5ld19sZW4gPCBvZnMgKyBuIGRvXG4gICAgICBuZXdfbGVuIDo9IDIgKiAhbmV3X2xlbiArIDFcbiAgICBkb25lO1xuICAgIGxldCBuZXdfbGVuID0gIW5ld19sZW4gaW5cbiAgICBsZXQgbmV3X2xlbiA9XG4gICAgICBpZiBuZXdfbGVuIDw9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuXG4gICAgICAgIG5ld19sZW5cbiAgICAgIGVsc2UgaWYgb2ZzIDwgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgICAgU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgICBlbHNlXG4gICAgICAgIGZhaWx3aXRoIFwiSW5fY2hhbm5lbC5pbnB1dF9hbGw6IGNoYW5uZWwgY29udGVudCBcXFxuICAgICAgICAgICAgICAgICAgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSBzdHJpbmcgbGVuZ3RoXCJcbiAgICBpblxuICAgIGxldCBuZXdfYnVmID0gQnl0ZXMuY3JlYXRlIG5ld19sZW4gaW5cbiAgICBCeXRlcy5ibGl0IGJ1ZiAwIG5ld19idWYgMCBvZnM7XG4gICAgbmV3X2J1ZlxuICBlbmRcblxubGV0IGlucHV0X2FsbCBpYyA9XG4gIGxldCBjaHVua19zaXplID0gNjU1MzYgaW4gKCogSU9fQlVGRkVSX1NJWkUgKilcbiAgbGV0IGluaXRpYWxfc2l6ZSA9XG4gICAgdHJ5XG4gICAgICBTdGRsaWIuaW5fY2hhbm5lbF9sZW5ndGggaWMgLSBTdGRsaWIucG9zX2luIGljXG4gICAgd2l0aCBTeXNfZXJyb3IgXyAtPlxuICAgICAgLTFcbiAgaW5cbiAgbGV0IGluaXRpYWxfc2l6ZSA9IGlmIGluaXRpYWxfc2l6ZSA8IDAgdGhlbiBjaHVua19zaXplIGVsc2UgaW5pdGlhbF9zaXplIGluXG4gIGxldCBpbml0aWFsX3NpemUgPVxuICAgIGlmIGluaXRpYWxfc2l6ZSA8PSBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgaW5pdGlhbF9zaXplXG4gICAgZWxzZVxuICAgICAgU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gIGluXG4gIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgaW5pdGlhbF9zaXplIGluXG4gIGxldCBucmVhZCA9IHJlYWRfdXB0byBpYyBidWYgMCBpbml0aWFsX3NpemUgaW5cbiAgaWYgbnJlYWQgPCBpbml0aWFsX3NpemUgdGhlbiAoKiBFT0YgcmVhY2hlZCwgYnVmZmVyIHBhcnRpYWxseSBmaWxsZWQgKilcbiAgICBCeXRlcy5zdWJfc3RyaW5nIGJ1ZiAwIG5yZWFkXG4gIGVsc2UgYmVnaW4gKCogbnJlYWQgPSBpbml0aWFsX3NpemUsIG1heWJlIEVPRiByZWFjaGVkICopXG4gICAgbWF0Y2ggU3RkbGliLmlucHV0X2NoYXIgaWMgd2l0aFxuICAgIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+XG4gICAgICAgICgqIEVPRiByZWFjaGVkLCBidWZmZXIgaXMgY29tcGxldGVseSBmaWxsZWQgKilcbiAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcbiAgICB8IGMgLT5cbiAgICAgICAgKCogRU9GIG5vdCByZWFjaGVkICopXG4gICAgICAgIGxldCByZWMgbG9vcCBidWYgb2ZzID1cbiAgICAgICAgICBsZXQgYnVmID0gZW5zdXJlIGJ1ZiBvZnMgY2h1bmtfc2l6ZSBpblxuICAgICAgICAgIGxldCByZW0gPSBCeXRlcy5sZW5ndGggYnVmIC0gb2ZzIGluXG4gICAgICAgICAgKCogW3JlbV0gY2FuIGJlIDwgW2NodW5rX3NpemVdIGlmIGJ1ZmZlciBzaXplIGNsb3NlIHRvXG4gICAgICAgICAgICAgW1N5cy5tYXhfc3RyaW5nX2xlbmd0aF0gKilcbiAgICAgICAgICBsZXQgciA9IHJlYWRfdXB0byBpYyBidWYgb2ZzIHJlbSBpblxuICAgICAgICAgIGlmIHIgPCByZW0gdGhlbiAoKiBFT0YgcmVhY2hlZCAqKVxuICAgICAgICAgICAgQnl0ZXMuc3ViX3N0cmluZyBidWYgMCAob2ZzICsgcilcbiAgICAgICAgICBlbHNlICgqIHIgPSByZW0gKilcbiAgICAgICAgICAgIGxvb3AgYnVmIChvZnMgKyByZW0pXG4gICAgICAgIGluXG4gICAgICAgIGxldCBidWYgPSBlbnN1cmUgYnVmIG5yZWFkIChjaHVua19zaXplICsgMSkgaW5cbiAgICAgICAgQnl0ZXMuc2V0IGJ1ZiBucmVhZCBjO1xuICAgICAgICBsb29wIGJ1ZiAobnJlYWQgKyAxKVxuICBlbmRcblxubGV0IHNldF9iaW5hcnlfbW9kZSA9IFN0ZGxpYi5zZXRfYmluYXJ5X21vZGVfaW5cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMjEgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gb3V0X2NoYW5uZWxcblxudHlwZSBvcGVuX2ZsYWcgPSBTdGRsaWIub3Blbl9mbGFnID1cbiAgfCBPcGVuX3Jkb25seVxuICB8IE9wZW5fd3Jvbmx5XG4gIHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0XG4gIHwgT3Blbl90cnVuY1xuICB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5XG4gIHwgT3Blbl90ZXh0XG4gIHwgT3Blbl9ub25ibG9ja1xuXG5sZXQgc3Rkb3V0ID0gU3RkbGliLnN0ZG91dFxubGV0IHN0ZGVyciA9IFN0ZGxpYi5zdGRlcnJcbmxldCBvcGVuX2JpbiA9IFN0ZGxpYi5vcGVuX291dF9iaW5cbmxldCBvcGVuX3RleHQgPSBTdGRsaWIub3Blbl9vdXRcbmxldCBvcGVuX2dlbiA9IFN0ZGxpYi5vcGVuX291dF9nZW5cblxubGV0IHdpdGhfb3BlbiBvcGVuZnVuIHMgZiA9XG4gIGxldCBvYyA9IG9wZW5mdW4gcyBpblxuICBGdW4ucHJvdGVjdCB+ZmluYWxseTooZnVuICgpIC0+IFN0ZGxpYi5jbG9zZV9vdXRfbm9lcnIgb2MpXG4gICAgKGZ1biAoKSAtPiBmIG9jKVxuXG5sZXQgd2l0aF9vcGVuX2JpbiBzIGYgPVxuICB3aXRoX29wZW4gU3RkbGliLm9wZW5fb3V0X2JpbiBzIGZcblxubGV0IHdpdGhfb3Blbl90ZXh0IHMgZiA9XG4gIHdpdGhfb3BlbiBTdGRsaWIub3Blbl9vdXQgcyBmXG5cbmxldCB3aXRoX29wZW5fZ2VuIGZsYWdzIHBlcm0gcyBmID1cbiAgd2l0aF9vcGVuIChTdGRsaWIub3Blbl9vdXRfZ2VuIGZsYWdzIHBlcm0pIHMgZlxuXG5sZXQgc2VlayA9IFN0ZGxpYi5MYXJnZUZpbGUuc2Vla19vdXRcbmxldCBwb3MgPSBTdGRsaWIuTGFyZ2VGaWxlLnBvc19vdXRcbmxldCBsZW5ndGggPSBTdGRsaWIuTGFyZ2VGaWxlLm91dF9jaGFubmVsX2xlbmd0aFxubGV0IGNsb3NlID0gU3RkbGliLmNsb3NlX291dFxubGV0IGNsb3NlX25vZXJyID0gU3RkbGliLmNsb3NlX291dF9ub2VyclxubGV0IGZsdXNoID0gU3RkbGliLmZsdXNoXG5sZXQgZmx1c2hfYWxsID0gU3RkbGliLmZsdXNoX2FsbFxubGV0IG91dHB1dF9jaGFyID0gU3RkbGliLm91dHB1dF9jaGFyXG5sZXQgb3V0cHV0X2J5dGUgPSBTdGRsaWIub3V0cHV0X2J5dGVcbmxldCBvdXRwdXRfc3RyaW5nID0gU3RkbGliLm91dHB1dF9zdHJpbmdcbmxldCBvdXRwdXRfYnl0ZXMgPSBTdGRsaWIub3V0cHV0X2J5dGVzXG5sZXQgb3V0cHV0ID0gU3RkbGliLm91dHB1dFxubGV0IG91dHB1dF9zdWJzdHJpbmcgPSBTdGRsaWIub3V0cHV0X3N1YnN0cmluZ1xubGV0IHNldF9iaW5hcnlfbW9kZSA9IFN0ZGxpYi5zZXRfYmluYXJ5X21vZGVfb3V0XG5cbmV4dGVybmFsIHNldF9idWZmZXJlZCA6IHQgLT4gYm9vbCAtPiB1bml0ID0gXCJjYW1sX21sX3NldF9idWZmZXJlZFwiXG5cbmV4dGVybmFsIGlzX2J1ZmZlcmVkIDogdCAtPiBib29sID0gXCJjYW1sX21sX2lzX2J1ZmZlcmVkXCJcbiIsIigqIGdlbmVyYXRlZCBieSBkdW5lICopXG5cbigqKiBAY2Fub25pY2FsIEpzb29fcnVudGltZS5SdW50aW1lX3ZlcnNpb24gKilcbm1vZHVsZSBSdW50aW1lX3ZlcnNpb24gPSBKc29vX3J1bnRpbWVfX1J1bnRpbWVfdmVyc2lvblxuXG5tb2R1bGUgSnNvb19ydW50aW1lX18gPSBzdHJ1Y3QgZW5kXG5bQEBkZXByZWNhdGVkIFwidGhpcyBtb2R1bGUgaXMgc2hhZG93ZWRcIl1cbiIsIm1vZHVsZSBKcyA9IHN0cnVjdFxuICB0eXBlIHRcblxuICB0eXBlICdhIGpzX2FycmF5ID0gdFxuXG4gIHR5cGUgKCdhLCAnYikgbWV0aF9jYWxsYmFjayA9IHRcblxuICBleHRlcm5hbCBzdHJpbmcgOiBzdHJpbmcgLT4gdCA9IFwiY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcIlxuXG4gIGV4dGVybmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nID0gXCJjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1wiXG5cbiAgZXh0ZXJuYWwgYnl0ZXN0cmluZyA6IHN0cmluZyAtPiB0ID0gXCJjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXCJcblxuICBleHRlcm5hbCB0b19ieXRlc3RyaW5nIDogdCAtPiBzdHJpbmcgPSBcImNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcIlxuXG4gIGV4dGVybmFsIGJvb2wgOiBib29sIC0+IHQgPSBcImNhbWxfanNfZnJvbV9ib29sXCJcblxuICBleHRlcm5hbCB0b19ib29sIDogdCAtPiBib29sID0gXCJjYW1sX2pzX3RvX2Jvb2xcIlxuXG4gIGV4dGVybmFsIGFycmF5IDogJ2EgYXJyYXkgLT4gdCA9IFwiY2FtbF9qc19mcm9tX2FycmF5XCJcblxuICBleHRlcm5hbCB0b19hcnJheSA6IHQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfanNfdG9fYXJyYXlcIlxuXG4gIGV4dGVybmFsIG51bWJlcl9vZl9mbG9hdCA6IGZsb2F0IC0+IHQgPSBcImNhbWxfanNfZnJvbV9mbG9hdFwiXG5cbiAgZXh0ZXJuYWwgZmxvYXRfb2ZfbnVtYmVyIDogdCAtPiBmbG9hdCA9IFwiY2FtbF9qc190b19mbG9hdFwiXG5cbiAgZXh0ZXJuYWwgbnVtYmVyX29mX2ludDMyIDogaW50MzIgLT4gdCA9IFwiY2FtbF9qc19mcm9tX2ludDMyXCJcblxuICBleHRlcm5hbCBpbnQzMl9vZl9udW1iZXIgOiB0IC0+IGludDMyID0gXCJjYW1sX2pzX3RvX2ludDMyXCJcblxuICBleHRlcm5hbCBudW1iZXJfb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IHQgPSBcImNhbWxfanNfZnJvbV9uYXRpdmVpbnRcIlxuXG4gIGV4dGVybmFsIG5hdGl2ZWludF9vZl9udW1iZXIgOiB0IC0+IG5hdGl2ZWludCA9IFwiY2FtbF9qc190b19uYXRpdmVpbnRcIlxuXG4gIGV4dGVybmFsIHR5cGVvZiA6IHQgLT4gdCA9IFwiY2FtbF9qc190eXBlb2ZcIlxuXG4gIGV4dGVybmFsIGluc3RhbmNlb2YgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9qc19pbnN0YW5jZW9mXCJcblxuICBleHRlcm5hbCBkZWJ1Z2dlciA6IHVuaXQgLT4gdW5pdCA9IFwiZGVidWdnZXJcIlxuXG4gIGV4dGVybmFsIGdldCA6IHQgLT4gdCAtPiB0ID0gXCJjYW1sX2pzX2dldFwiXG5cbiAgZXh0ZXJuYWwgc2V0IDogdCAtPiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9qc19zZXRcIlxuXG4gIGV4dGVybmFsIGRlbGV0ZSA6IHQgLT4gdCAtPiB1bml0ID0gXCJjYW1sX2pzX2RlbGV0ZVwiXG5cbiAgZXh0ZXJuYWwgY2FsbCA6IHQgLT4gdCAtPiB0IGFycmF5IC0+IHQgPSBcImNhbWxfanNfY2FsbFwiXG5cbiAgZXh0ZXJuYWwgZnVuX2NhbGwgOiB0IC0+IHQgYXJyYXkgLT4gdCA9IFwiY2FtbF9qc19mdW5fY2FsbFwiXG5cbiAgZXh0ZXJuYWwgbWV0aF9jYWxsIDogdCAtPiBzdHJpbmcgLT4gdCBhcnJheSAtPiB0ID0gXCJjYW1sX2pzX21ldGhfY2FsbFwiXG5cbiAgZXh0ZXJuYWwgbmV3X29iaiA6IHQgLT4gdCBhcnJheSAtPiB0ID0gXCJjYW1sX2pzX25ld1wiXG5cbiAgZXh0ZXJuYWwgbmV3X29ial9hcnIgOiB0IC0+IHQganNfYXJyYXkgLT4gdCA9IFwiY2FtbF9vanNfbmV3X2FyclwiXG5cbiAgZXh0ZXJuYWwgb2JqIDogKHN0cmluZyAqIHQpIGFycmF5IC0+IHQgPSBcImNhbWxfanNfb2JqZWN0XCJcblxuICBleHRlcm5hbCBlcXVhbHMgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9qc19lcXVhbHNcIlxuXG4gIGV4dGVybmFsIHN0cmljdF9lcXVhbHMgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9qc19zdHJpY3RfZXF1YWxzXCJcblxuICBleHRlcm5hbCBwdXJlX2V4cHIgOiAodW5pdCAtPiAnYSkgLT4gJ2EgPSBcImNhbWxfanNfcHVyZV9leHByXCJcblxuICBleHRlcm5hbCBldmFsX3N0cmluZyA6IHN0cmluZyAtPiAnYSA9IFwiY2FtbF9qc19ldmFsX3N0cmluZ1wiXG5cbiAgZXh0ZXJuYWwganNfZXhwciA6IHN0cmluZyAtPiAnYSA9IFwiY2FtbF9qc19leHByXCJcblxuICBleHRlcm5hbCBwdXJlX2pzX2V4cHIgOiBzdHJpbmcgLT4gJ2EgPSBcImNhbWxfcHVyZV9qc19leHByXCJcblxuICBleHRlcm5hbCBjYWxsYmFjayA6ICgnYiAtPiAnYSkgLT4gKCdiLCAnYSkgbWV0aF9jYWxsYmFja1xuICAgID0gXCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfdW5zYWZlXCJcblxuICBleHRlcm5hbCBjYWxsYmFja193aXRoX2FyZ3VtZW50cyA6XG4gICAgKHQganNfYXJyYXkgLT4gJ2IpIC0+ICgnYywgdCBqc19hcnJheSAtPiAnYikgbWV0aF9jYWxsYmFja1xuICAgID0gXCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzXCJcblxuICBleHRlcm5hbCBjYWxsYmFja193aXRoX2FyaXR5IDogaW50IC0+ICgnYSAtPiAnYikgLT4gKCdjLCAnYSAtPiAnYikgbWV0aF9jYWxsYmFja1xuICAgID0gXCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0XCJcblxuICBleHRlcm5hbCBtZXRoX2NhbGxiYWNrIDogKCdiIC0+ICdhKSAtPiAoJ2IsICdhKSBtZXRoX2NhbGxiYWNrXG4gICAgPSBcImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZVwiXG5cbiAgZXh0ZXJuYWwgbWV0aF9jYWxsYmFja193aXRoX2FyaXR5IDogaW50IC0+ICgnYiAtPiAnYSkgLT4gKCdiLCAnYSkgbWV0aF9jYWxsYmFja1xuICAgID0gXCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3RcIlxuXG4gIGV4dGVybmFsIG1ldGhfY2FsbGJhY2tfd2l0aF9hcmd1bWVudHMgOlxuICAgICgnYiAtPiB0IGpzX2FycmF5IC0+ICdhKSAtPiAoJ2IsIHQganNfYXJyYXkgLT4gJ2EpIG1ldGhfY2FsbGJhY2tcbiAgICA9IFwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzXCJcblxuICBleHRlcm5hbCB3cmFwX2NhbGxiYWNrIDogKCdhIC0+ICdiKSAtPiAoJ2MsICdhIC0+ICdiKSBtZXRoX2NhbGxiYWNrXG4gICAgPSBcImNhbWxfanNfd3JhcF9jYWxsYmFja1wiXG5cbiAgZXh0ZXJuYWwgd3JhcF9tZXRoX2NhbGxiYWNrIDogKCdhIC0+ICdiKSAtPiAoJ2EsICdiKSBtZXRoX2NhbGxiYWNrXG4gICAgPSBcImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrXCJcbmVuZFxuXG5tb2R1bGUgU3lzID0gc3RydWN0XG4gIHR5cGUgJ2EgY2FsbGJhY2sgPSAnYVxuXG4gIGV4dGVybmFsIGNyZWF0ZV9maWxlIDogbmFtZTpzdHJpbmcgLT4gY29udGVudDpzdHJpbmcgLT4gdW5pdCA9IFwiY2FtbF9jcmVhdGVfZmlsZVwiXG5cbiAgZXh0ZXJuYWwgcmVhZF9maWxlIDogbmFtZTpzdHJpbmcgLT4gc3RyaW5nID0gXCJjYW1sX3JlYWRfZmlsZV9jb250ZW50XCJcblxuICBleHRlcm5hbCBzZXRfY2hhbm5lbF9vdXRwdXQnIDogb3V0X2NoYW5uZWwgLT4gKGpzX3N0cmluZzpKcy50IC0+IHVuaXQpIGNhbGxiYWNrIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXRcIlxuXG4gIGV4dGVybmFsIHNldF9jaGFubmVsX2lucHV0JyA6IGluX2NoYW5uZWwgLT4gKHVuaXQgLT4gc3RyaW5nKSBjYWxsYmFjayAtPiB1bml0XG4gICAgPSBcImNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsXCJcblxuICBleHRlcm5hbCBtb3VudF9wb2ludCA6IHVuaXQgLT4gc3RyaW5nIGxpc3QgPSBcImNhbWxfbGlzdF9tb3VudF9wb2ludFwiXG5cbiAgZXh0ZXJuYWwgbW91bnRfYXV0b2xvYWQgOiBzdHJpbmcgLT4gKHN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nIG9wdGlvbikgY2FsbGJhY2sgLT4gdW5pdFxuICAgID0gXCJjYW1sX21vdW50X2F1dG9sb2FkXCJcblxuICBleHRlcm5hbCB1bm1vdW50IDogc3RyaW5nIC0+IHVuaXQgPSBcImNhbWxfdW5tb3VudFwiXG5cbiAgdHlwZSByZWRpcmVjdGlvblxuXG4gIGV4dGVybmFsIHJlZGlyZWN0X2NoYW5uZWwgOiBvdXRfY2hhbm5lbCAtPiBpbnRvOm91dF9jaGFubmVsIC0+IHJlZGlyZWN0aW9uXG4gICAgPSBcImNhbWxfbWxfY2hhbm5lbF9yZWRpcmVjdFwiXG5cbiAgZXh0ZXJuYWwgcmVzdG9yZV9jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gcmVkaXJlY3Rpb24gLT4gdW5pdFxuICAgID0gXCJjYW1sX21sX2NoYW5uZWxfcmVzdG9yZVwiXG5cbiAgbW9kdWxlIENvbmZpZyA9IHN0cnVjdFxuICAgIGV4dGVybmFsIHVzZV9qc19zdHJpbmcgOiB1bml0IC0+IGJvb2wgPSBcImNhbWxfanNvb19mbGFnc191c2VfanNfc3RyaW5nXCJcblxuICAgIGV4dGVybmFsIGVmZmVjdHMgOiB1bml0IC0+IGJvb2wgPSBcImNhbWxfanNvb19mbGFnc19lZmZlY3RzXCJcbiAgZW5kXG5cbiAgbGV0IHZlcnNpb24gPSBSdW50aW1lX3ZlcnNpb24uc1xuXG4gIGxldCBnaXRfdmVyc2lvbiA9IFJ1bnRpbWVfdmVyc2lvbi5naXRfdmVyc2lvblxuZW5kXG5cbm1vZHVsZSBFcnJvciA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgcmFpc2VfIDogdCAtPiAnYVxuXG4gIHZhbCBhdHRhY2hfanNfYmFja3RyYWNlIDogZXhuIC0+IGZvcmNlOmJvb2wgLT4gZXhuXG4gICgqKiBBdHRhY2ggYSBKYXZhc1NjcmlwdCBlcnJvciB0byBhbiBPQ2FtbCBleGNlcHRpb24uICBpZiBbZm9yY2UgPSBmYWxzZV0gYW5kIGFcbiAgICBKYXZhc1NjcmlwdCBlcnJvciBpcyBhbHJlYWR5IGF0dGFjaGVkLCBpdCB3aWxsIGRvIG5vdGhpbmcuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIHRvXG4gICAgc3RvcmUgYW5kIHJldHJpZXZlIGluZm9ybWF0aW9uIGFib3V0IEphdmFTY3JpcHQgc3RhY2sgdHJhY2VzLlxuXG4gICAgQXR0YWNoaW5nIEphdmFzU2NyaXB0IGVycm9ycyB3aWxsIGhhcHBlbiBhdXRvbWF0aWNhbGx5IHdoZW4gY29tcGlsaW5nIHdpdGhcbiAgICBbLS1lbmFibGUgd2l0aC1qcy1lcnJvcl0uICopXG5cbiAgdmFsIG9mX2V4biA6IGV4biAtPiB0IG9wdGlvblxuICAoKiogRXh0cmFjdCBhIEphdmFTY3JpcHQgZXJyb3IgYXR0YWNoZWQgdG8gYW4gT0NhbWwgZXhjZXB0aW9uLCBpZiBhbnkuICBUaGlzIGlzIHVzZWZ1bCB0b1xuICAgICAgaW5zcGVjdCBhbiBldmVudHVhbCBzdGFjayBzdHJhY2UsIGVzcGVjaWFsbHkgd2hlbiBzb3VyY2VtYXAgaXMgZW5hYmxlZC4gKilcblxuICBleGNlcHRpb24gRXhuIG9mIHRcbiAgKCoqIFRoZSBbRXJyb3JdIGV4Y2VwdGlvbiB3cmFwIGphdmFzY3JpcHQgZXhjZXB0aW9ucyB3aGVuIGNhdWdodCBieSBPQ2FtbCBjb2RlLlxuICAgICAgSW4gY2FzZSB0aGUgamF2YXNjcmlwdCBleGNlcHRpb24gaXMgbm90IGFuIGluc3RhbmNlIG9mIGphdmFzY3JpcHQgW0Vycm9yXSxcbiAgICAgIGl0IHdpbGwgYmUgc2VyaWFsaXplZCBhbmQgd3JhcHBlZCBpbnRvIGEgW0ZhaWx1cmVdIGV4Y2VwdGlvbi5cbiAgKilcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHRcblxuICBleGNlcHRpb24gRXhuIG9mIHRcblxuICBsZXQgXyA9IENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcImpzRXJyb3JcIiAoRXhuIChPYmoubWFnaWMgW3x8XSkpXG5cbiAgbGV0IHJhaXNlXyA6IHQgLT4gJ2EgPSBKcy5qc19leHByIFwiKGZ1bmN0aW9uIChleG4pIHsgdGhyb3cgZXhuIH0pXCJcblxuICBleHRlcm5hbCBvZl9leG4gOiBleG4gLT4gdCBvcHRpb24gPSBcImNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvblwiXG5cbiAgZXh0ZXJuYWwgYXR0YWNoX2pzX2JhY2t0cmFjZSA6IGV4biAtPiBmb3JjZTpib29sIC0+IGV4biA9IFwiY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2VcIlxuZW5kXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTMyLTYwXCJdXG5cbm1vZHVsZSBGb3JfY29tcGF0aWJpbGl0eV9vbmx5ID0gc3RydWN0XG4gICgqIEFkZCBwcmltaXRpdmVzIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnMuIEV4aXN0aW5nIHVzZXJzIG1pZ2h0XG4gICAgIGRlcGVuZCBvbiBpdCAoZS5nLiBnZW5fanNfYXBpKSwgd2UgZG9udCB3YW50IHRoZSBvY2FtbCBjb21waWxlclxuICAgICB0byBjb21wbGFpbiBhYm91dCB0aGVzZXMgbWlzc2luZyBwcmltaXRpdmVzLiAqKVxuXG4gIGV4dGVybmFsIGNhbWxfanNfZnJvbV9zdHJpbmcgOiBzdHJpbmcgLT4gSnMudCA9IFwiY2FtbF9qc19mcm9tX3N0cmluZ1wiXG5cbiAgZXh0ZXJuYWwgY2FtbF9qc190b19ieXRlX3N0cmluZyA6IEpzLnQgLT4gc3RyaW5nID0gXCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nXCJcblxuICBleHRlcm5hbCBjYW1sX2pzX3RvX3N0cmluZyA6IEpzLnQgLT4gc3RyaW5nID0gXCJjYW1sX2pzX3RvX3N0cmluZ1wiXG5cbiAgZXh0ZXJuYWwgY2FtbF9saXN0X29mX2pzX2FycmF5IDogJ2EgSnMuanNfYXJyYXkgLT4gJ2EgbGlzdCA9IFwiY2FtbF9saXN0X29mX2pzX2FycmF5XCJcblxuICBleHRlcm5hbCBjYW1sX2xpc3RfdG9fanNfYXJyYXkgOiAnYSBsaXN0IC0+ICdhIEpzLmpzX2FycmF5ID0gXCJjYW1sX2xpc3RfdG9fanNfYXJyYXlcIlxuXG4gIGV4dGVybmFsIHZhcmlhYmxlIDogc3RyaW5nIC0+ICdhID0gXCJjYW1sX2pzX3ZhclwiXG5lbmRcblxubW9kdWxlIFR5cGVkX2FycmF5ID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdHlwZWRBcnJheSA9IEpzLnRcblxuICB0eXBlIGFycmF5QnVmZmVyID0gSnMudFxuXG4gIHR5cGUgdWludDhBcnJheSA9IEpzLnRcblxuICBleHRlcm5hbCBraW5kIDogKCdhLCAnYikgdHlwZWRBcnJheSAtPiAoJ2EsICdiKSBCaWdhcnJheS5raW5kXG4gICAgPSBcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheVwiXG5cbiAgZXh0ZXJuYWwgZnJvbV9nZW5hcnJheSA6XG4gICAgKCdhLCAnYiwgQmlnYXJyYXkuY19sYXlvdXQpIEJpZ2FycmF5LkdlbmFycmF5LnQgLT4gKCdhLCAnYikgdHlwZWRBcnJheVxuICAgID0gXCJjYW1sX2JhX3RvX3R5cGVkX2FycmF5XCJcblxuICBleHRlcm5hbCB0b19nZW5hcnJheSA6XG4gICAgKCdhLCAnYikgdHlwZWRBcnJheSAtPiAoJ2EsICdiLCBCaWdhcnJheS5jX2xheW91dCkgQmlnYXJyYXkuR2VuYXJyYXkudFxuICAgID0gXCJjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXlcIlxuXG4gIG1vZHVsZSBCaWdzdHJpbmcgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSAoY2hhciwgQmlnYXJyYXkuaW50OF91bnNpZ25lZF9lbHQsIEJpZ2FycmF5LmNfbGF5b3V0KSBCaWdhcnJheS5BcnJheTEudFxuXG4gICAgZXh0ZXJuYWwgdG9fYXJyYXlCdWZmZXIgOiB0IC0+IGFycmF5QnVmZmVyID0gXCJiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyXCJcblxuICAgIGV4dGVybmFsIHRvX3VpbnQ4QXJyYXkgOiB0IC0+IHVpbnQ4QXJyYXkgPSBcImJpZ3N0cmluZ190b190eXBlZF9hcnJheVwiXG5cbiAgICBleHRlcm5hbCBvZl9hcnJheUJ1ZmZlciA6IGFycmF5QnVmZmVyIC0+IHQgPSBcImJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXJcIlxuXG4gICAgZXh0ZXJuYWwgb2ZfdWludDhBcnJheSA6IHVpbnQ4QXJyYXkgLT4gdCA9IFwiYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5XCJcbiAgZW5kXG5cbiAgZXh0ZXJuYWwgb2ZfdWludDhBcnJheSA6IHVpbnQ4QXJyYXkgLT4gc3RyaW5nID0gXCJjYW1sX3N0cmluZ19vZl9hcnJheVwiXG5lbmRcblxubW9kdWxlIEludDY0ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZV9pbnQ2NF9sb19taV9oaSA6IGludCAtPiBpbnQgLT4gaW50IC0+IEludDY0LnRcbiAgICA9IFwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGlcIlxuZW5kXG4iLCIoKiBUaGUgZ2VuX2pzX2FwaSBpcyByZWxlYXNlZCB1bmRlciB0aGUgdGVybXMgb2YgYW4gTUlULWxpa2UgbGljZW5zZS4gICAgICopXG4oKiBTZWUgdGhlIGF0dGFjaGVkIExJQ0VOU0UgZmlsZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiBDb3B5cmlnaHQgMjAxNSBieSBMZXhpRmkuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG5cbigqIFRoaXMgbW9kdWxlIChtb3N0bHkpIGFic3RyYWN0cyBhd2F5IGZyb20ganNfb2Zfb2NhbWwgZW5jb2Rpbmcgb2ZcbiAgIE9DYW1sIHZhbHVlcy4gIEl0IHNlcnZlcyBhcyBhIHN1cHBvcnQgbGlicmFyeSBmb3IgdGhlIGNvZGUgZ2VuZXJhdGVkXG4gICBieSBnZW5fanNfYXBpLlxuXG4gICBUaGUgbW9kdWxlIGNvdWxkIG1vc3RseSBiZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2YganNfb2Zfb2NhbWwncyBKcyBtb2R1bGVcbiAgIChhbmQgaW4gcGFydGljdWxhciBKcy5VbnNhZmUpLCBidXQgd2UgcHJlZmVyIHRvIGRyb3AgdGhlIGRlcGVuZGVuY3lcbiAgIHRvIGpzX29mX29jYW1sJ3MgbGlicmFyeSBhbmQgdG8gcmVseSBvbmx5IG9uIGl0cyBjb21waWxlciBhbmQgSlNcbiAgIHJ1bnRpbWUgY29kZS5cbiopXG5cblxudHlwZSB0XG5cbmV4dGVybmFsIHRfb2ZfanM6IHQgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHRfdG9fanM6IHQgLT4gdCA9IFwiJWlkZW50aXR5XCJcblxuZXh0ZXJuYWwgc3RyaW5nX29mX2pzOiB0IC0+IHN0cmluZyA9IFwiY2FtbF9qc190b19zdHJpbmdcIlxuZXh0ZXJuYWwgc3RyaW5nX3RvX2pzOiBzdHJpbmcgLT4gdCA9IFwiY2FtbF9qc19mcm9tX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludF9vZl9qczogdCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBpbnRfdG9fanM6IGludCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuXG5leHRlcm5hbCBib29sX29mX2pzOiB0IC0+IGJvb2wgPSBcImNhbWxfanNfdG9fYm9vbFwiXG5leHRlcm5hbCBib29sX3RvX2pzOiBib29sIC0+IHQgPSBcImNhbWxfanNfZnJvbV9ib29sXCJcblxuZXh0ZXJuYWwgZmxvYXRfb2ZfanM6IHQgLT4gZmxvYXQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBmbG9hdF90b19qczogZmxvYXQgLT4gdCA9IFwiJWlkZW50aXR5XCJcblxuZXh0ZXJuYWwgb2JqOiAoc3RyaW5nICogdCkgYXJyYXkgLT4gdCA9IFwiY2FtbF9qc19vYmplY3RcIlxuXG5leHRlcm5hbCB2YXJpYWJsZTogc3RyaW5nIC0+IHQgPSBcImNhbWxfanNfdmFyXCJcblxuZXh0ZXJuYWwgZ2V0OiB0IC0+IHN0cmluZyAtPiB0ID0gXCJjYW1sX2pzX2dldFwiXG5leHRlcm5hbCBzZXQ6IHQgLT4gc3RyaW5nIC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9qc19zZXRcIlxuZXh0ZXJuYWwgZGVsZXRlOiB0IC0+IHN0cmluZyAtPiB1bml0ID0gXCJjYW1sX2pzX2RlbGV0ZVwiXG5cbmV4dGVybmFsIGdldF9wcm9wOiB0IC0+IHQgLT4gdCA9IFwiY2FtbF9qc19nZXRcIlxuZXh0ZXJuYWwgc2V0X3Byb3A6IHQgLT4gdCAtPiB0IC0+IHVuaXQgPSBcImNhbWxfanNfc2V0XCJcbmV4dGVybmFsIGRlbGV0ZV9wcm9wOiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9qc19kZWxldGVcIlxuXG5leHRlcm5hbCBnZXRfcHJvcF9hc2NpaTogdCAtPiBzdHJpbmcgLT4gdCA9IFwiY2FtbF9qc19nZXRcIlxuZXh0ZXJuYWwgc2V0X3Byb3BfYXNjaWk6IHQgLT4gc3RyaW5nIC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9qc19zZXRcIlxuZXh0ZXJuYWwgZGVsZXRlX3Byb3BfYXNjaWk6IHQgLT4gc3RyaW5nIC0+IHVuaXQgPSBcImNhbWxfanNfZGVsZXRlXCJcblxuZXh0ZXJuYWwgaW50ZXJuYWxfdHlwZV9vZjogdCAtPiB0ID0gXCJjYW1sX2pzX3R5cGVvZlwiXG5sZXQgdHlwZV9vZiB4ID0gc3RyaW5nX29mX2pzIChpbnRlcm5hbF90eXBlX29mIHgpXG5cbmV4dGVybmFsIGludGVybmFsX2luc3RhbmNlX29mOiB0IC0+IHQgLT4gdCA9IFwiY2FtbF9qc19pbnN0YW5jZW9mXCJcbmxldCBpbnN0YW5jZV9vZiB4IH5jb25zdHIgPSBib29sX29mX2pzIChpbnRlcm5hbF9pbnN0YW5jZV9vZiB4IGNvbnN0cilcblxuZXh0ZXJuYWwgcHVyZV9qc19leHByOiBzdHJpbmcgLT4gdCA9IFwiY2FtbF9wdXJlX2pzX2V4cHJcIlxubGV0IG51bGwgPSBwdXJlX2pzX2V4cHIgXCJudWxsXCJcbmxldCB1bmRlZmluZWQgPSBwdXJlX2pzX2V4cHIgXCJ1bmRlZmluZWRcIlxuXG5leHRlcm5hbCBlcXVhbHM6IHQgLT4gdCAtPiBib29sID0gXCJjYW1sX2pzX2VxdWFsc1wiXG5cbmxldCBnbG9iYWwgPSBwdXJlX2pzX2V4cHIgXCJqb29fZ2xvYmFsX29iamVjdFwiXG5cbmV4dGVybmFsIG5ld19vYmo6IHQgLT4gdCBhcnJheSAtPiB0ID0gXCJjYW1sX2pzX25ld1wiXG5cbmV4dGVybmFsIGNhbGw6IHQgLT4gc3RyaW5nIC0+IHQgYXJyYXkgLT4gdCA9IFwiY2FtbF9qc19tZXRoX2NhbGxcIlxuZXh0ZXJuYWwgYXBwbHk6IHQgLT4gdCBhcnJheSAtPiB0ID0gXCJjYW1sX2pzX2Z1bl9jYWxsXCJcblxubGV0IGFycmF5X21ha2UgbiA9IG5ld19vYmogKGdldF9wcm9wX2FzY2lpIGdsb2JhbCBcIkFycmF5XCIpIFt8aW50X3RvX2pzIG58XVxubGV0IGFycmF5X2dldCB0IGkgPSBnZXRfcHJvcCB0IChpbnRfdG9fanMgaSlcbmxldCBhcnJheV9zZXQgdCBpIHggPSBzZXRfcHJvcCB0IChpbnRfdG9fanMgaSkgeFxuXG5sZXQgYXJyYXlfb2ZfanNfZnJvbSBmIG9ianMgc3RhcnQgPVxuICBsZXQgbiA9IGludF9vZl9qcyAoZ2V0X3Byb3BfYXNjaWkgb2JqcyBcImxlbmd0aFwiKSBpblxuICBBcnJheS5pbml0IChuIC0gc3RhcnQpIChmdW4gaSAtPiBmIChhcnJheV9nZXQgb2JqcyAoc3RhcnQgKyBpKSkpXG5cbmxldCBhcnJheV9vZl9qcyBmIG9ianMgPSBhcnJheV9vZl9qc19mcm9tIGYgb2JqcyAwXG5cbmxldCBhcnJheV90b19qcyBmIGFyciA9XG4gIGxldCBuID0gQXJyYXkubGVuZ3RoIGFyciBpblxuICBsZXQgYSA9IGFycmF5X21ha2UgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICBhcnJheV9zZXQgYSBpIChmIGFyci4oaSkpXG4gIGRvbmU7XG4gIGFcblxubGV0IGxpc3Rfb2ZfanNfZnJvbSBmIG9ianMgc3RhcnQgPSBBcnJheS50b19saXN0IChhcnJheV9vZl9qc19mcm9tIGYgb2JqcyBzdGFydClcblxubGV0IGxpc3Rfb2ZfanMgZiBvYmpzID0gbGlzdF9vZl9qc19mcm9tIGYgb2JqcyAwXG5cbmxldCBsaXN0X3RvX2pzIGYgbCA9XG4gIGFycmF5X3RvX2pzIGYgKEFycmF5Lm9mX2xpc3QgbClcblxubGV0IG9wdGlvbl9vZl9qcyBmIHggPVxuICBpZiBlcXVhbHMgeCBudWxsIHx8IHggPT0gdW5kZWZpbmVkIHRoZW4gTm9uZVxuICBlbHNlIFNvbWUgKGYgeClcblxubGV0IG9wdGlvbl90b19qcyBmID0gZnVuY3Rpb25cbiAgfCBTb21lIHggLT4gZiB4XG4gIHwgTm9uZSAtPiBudWxsXG5cbmxldCB1bml0X3RvX2pzICgpID0gdW5kZWZpbmVkXG5sZXQgdW5pdF9vZl9qcyBfID0gKClcblxuY2xhc3Mgb2JqICh4OnQpID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHRvX2pzID0geFxuICBlbmRcblxuZXh0ZXJuYWwgZnVuX3RvX2pzOiBpbnQgLT4gKHQgLT4gJ2EpIC0+IHQgPSBcImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3RcIlxuZXh0ZXJuYWwgZnVuX3RvX2pzX2FyZ3M6ICh0IC0+ICdhKSAtPiB0ID0gXCJjYW1sX29qc193cmFwX2Z1bl9hcmd1bWVudHNcIlxuXG5sZXQgaGFzX3Byb3BlcnR5IG8geCA9XG4gIHR5cGVfb2YgbyA9IFwib2JqZWN0XCIgJiYgbyAhPSBudWxsXG4gICYmIGdldF9wcm9wIG8gKHN0cmluZ190b19qcyB4KSAhPSB1bmRlZmluZWRcblxuZXh0ZXJuYWwgbmV3X29ial9hcnI6IHQgLT4gdCAtPiB0ID0gXCJjYW1sX29qc19uZXdfYXJyXCJcblxubGV0IGVtcHR5X29iaiAoKSA9IG5ld19vYmogKGdldF9wcm9wX2FzY2lpIGdsb2JhbCBcIk9iamVjdFwiKSBbfHxdXG5cbmV4dGVybmFsIGl0ZXJfcHJvcGVydGllc191bnR5cGVkIDogdCAtPiB0IC0+IHVuaXQgPSBcImNhbWxfb2pzX2l0ZXJhdGVfcHJvcGVydGllc1wiXG5sZXQgaXRlcl9wcm9wZXJ0aWVzIHggZiA9XG4gIGl0ZXJfcHJvcGVydGllc191bnR5cGVkIHggKGZ1bl90b19qcyAxIChmdW4geCAtPiBmIChzdHJpbmdfb2ZfanMgeCkpKVxuXG5sZXQgYXBwbHlfYXJyIG8gYXJyID0gY2FsbCBvIFwiYXBwbHlcIiBbfCBudWxsOyBhcnIgfF1cbmxldCBjYWxsX2FyciBvIHMgYXJyID0gY2FsbCAoZ2V0X3Byb3AgbyAoc3RyaW5nX3RvX2pzIHMpKSBcImFwcGx5XCIgW3wgbzsgYXJyIHxdXG5cbmxldCBpc19udWxsIHggPVxuICBlcXVhbHMgeCBudWxsXG5cbmxldCBvYmpfdHlwZSB4ID1cbiAgc3RyaW5nX29mX2pzIChjYWxsIChwdXJlX2pzX2V4cHIgXCJPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXCIpIFwiY2FsbFwiIFt8eHxdKVxuXG5tb2R1bGUgdHlwZSBUID0gc2lnXG4gIHR5cGUganMgOj0gdFxuICB0eXBlIHRcbiAgdmFsIHRfdG9fanMgOiB0IC0+IGpzXG4gIHZhbCB0X29mX2pzIDoganMgLT4gdFxuZW5kXG5cbigqIE9qcy5UIGluc3RhbmNlcyBmb3IgYnVpbHQtaW4gdHlwZXMgKilcbm1vZHVsZSBJbnQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50XG4gIGxldCB0X3RvX2pzID0gaW50X3RvX2pzXG4gIGxldCB0X29mX2pzID0gaW50X29mX2pzXG4gZW5kXG5tb2R1bGUgU3RyaW5nID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZ1xuICBsZXQgdF90b19qcyA9IHN0cmluZ190b19qc1xuICBsZXQgdF9vZl9qcyA9IHN0cmluZ19vZl9qc1xuZW5kXG5tb2R1bGUgQm9vbCA9IHN0cnVjdFxuICB0eXBlIHQgPSBib29sXG4gIGxldCB0X3RvX2pzID0gYm9vbF90b19qc1xuICBsZXQgdF9vZl9qcyA9IGJvb2xfb2ZfanNcbmVuZFxubW9kdWxlIEZsb2F0ID0gc3RydWN0XG4gIHR5cGUgdCA9IGZsb2F0XG4gIGxldCB0X3RvX2pzID0gZmxvYXRfdG9fanNcbiAgbGV0IHRfb2ZfanMgPSBmbG9hdF9vZl9qc1xuZW5kXG5tb2R1bGUgQXJyYXkgKEE6IFQpID0gc3RydWN0XG4gIHR5cGUgdCA9IEEudCBhcnJheVxuICBsZXQgdF90b19qcyA9IGFycmF5X3RvX2pzIEEudF90b19qc1xuICBsZXQgdF9vZl9qcyA9IGFycmF5X29mX2pzIEEudF9vZl9qc1xuZW5kXG5tb2R1bGUgTGlzdCAoQTogVCkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gQS50IGxpc3RcbiAgbGV0IHRfdG9fanMgPSBsaXN0X3RvX2pzIEEudF90b19qc1xuICBsZXQgdF9vZl9qcyA9IGxpc3Rfb2ZfanMgQS50X29mX2pzXG5lbmRcbm1vZHVsZSBPcHRpb24gKEE6IFQpID0gc3RydWN0XG4gIHR5cGUgdCA9IEEudCBvcHRpb25cbiAgbGV0IHRfdG9fanMgPSBvcHRpb25fdG9fanMgQS50X3RvX2pzXG4gIGxldCB0X29mX2pzID0gb3B0aW9uX29mX2pzIEEudF9vZl9qc1xuZW5kXG4iLCIoKiBUaGUgZ2VuX2pzX2FwaSBpcyByZWxlYXNlZCB1bmRlciB0aGUgdGVybXMgb2YgYW4gTUlULWxpa2UgbGljZW5zZS4gICAgICopXG4oKiBTZWUgdGhlIGF0dGFjaGVkIExJQ0VOU0UgZmlsZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiBDb3B5cmlnaHQgMjAxNSBieSBMZXhpRmkuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG5cbnR5cGUgdCA9IEpzb29fcnVudGltZS5FcnJvci50XG5cbmV4dGVybmFsIGNvZXJjZSA6IHQgLT4gT2pzLnQgPSBcIiVpZGVudGl0eVwiXG5sZXQgbmFtZSB4ID0gT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpIChjb2VyY2UgeCkgXCJuYW1lXCIpXG5sZXQgbWVzc2FnZSB4ID0gT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpIChjb2VyY2UgeCkgXCJtZXNzYWdlXCIpXG5sZXQgc3RhY2sgeCA9IE9qcy5vcHRpb25fb2ZfanMgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpIChjb2VyY2UgeCkgXCJzdGFja1wiKVxubGV0IHRvX3N0cmluZyB4ID0gT2pzLnN0cmluZ19vZl9qcyAoT2pzLmNhbGwgKGNvZXJjZSB4KSBcInRvU3RyaW5nXCIgW3x8XSlcblxuZXhjZXB0aW9uIEVycm9yID0gSnNvb19ydW50aW1lLkVycm9yLkV4blxuXG5sZXQgKCkgPVxuICBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIChmdW5jdGlvblxuICAgICAgfCBFcnJvciB4IC0+IFNvbWUgKHRvX3N0cmluZyB4KVxuICAgICAgfCBfIC0+IE5vbmVcbiAgICApXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgb2NhbWwtdmRvbSBwYWNrYWdlLCByZWxlYXNlZCB1bmRlciB0aGUgdGVybXMgb2YgYW4gTUlULWxpa2UgbGljZW5zZS4gICAgICopXG4oKiBTZWUgdGhlIGF0dGFjaGVkIExJQ0VOU0UgZmlsZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiBDb3B5cmlnaHQgKEMpIDIwMDAtMjAyMyBMZXhpRmkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG5cblxubW9kdWxlIENtZCA9IHN0cnVjdFxuICB0eXBlICdtc2cgdCA9IC4uXG5cbiAgdHlwZSAnbXNnIHQgKz1cbiAgICB8IEVjaG8gb2YgJ21zZ1xuICAgIHwgQmF0Y2ggb2YgJ21zZyB0IGxpc3RcbiAgICB8IEJpbmQ6ICdhIHQgKiAoJ2EgLT4gJ21zZyB0KSAtPiAnbXNnIHRcbiAgICB8IE1hcDogKCdhIC0+ICdtc2cpICogJ2EgdCAtPiAnbXNnIHRcblxuICBsZXQgZWNobyBtc2cgPSBFY2hvIG1zZ1xuICBsZXQgYmF0Y2ggbCA9IEJhdGNoIGxcbiAgbGV0IG1hcCBmIHggPSBNYXAgKGYsIHgpXG4gIGxldCBiaW5kIHggZiA9IEJpbmQgKHgsIGYpXG5lbmRcblxubW9kdWxlIEN1c3RvbSA9IHN0cnVjdFxuICB0eXBlIHQgPSAuLlxuICB0eXBlIGV2ZW50ID0gLi5cbmVuZFxuXG50eXBlIG1vdXNlX2V2ZW50ID0ge3g6IGZsb2F0OyB5OiBmbG9hdDsgcGFnZV94OiBmbG9hdDsgcGFnZV95OiBmbG9hdDsgZWxlbWVudF94OiBmbG9hdCBMYXp5LnQ7IGVsZW1lbnRfeTogZmxvYXQgTGF6eS50OyBidXR0b25zOiBpbnQ7IGFsdF9rZXk6IGJvb2w7IGN0cmxfa2V5OiBib29sOyBzaGlmdF9rZXk6IGJvb2x9XG5cbnR5cGUga2V5X2V2ZW50ID0ge3doaWNoOiBpbnQ7IGFsdF9rZXk6IGJvb2w7IGN0cmxfa2V5OiBib29sOyBzaGlmdF9rZXk6IGJvb2x9XG5cbnR5cGUgcGFzdGVfZXZlbnQgPSB7dGV4dDogc3RyaW5nOyBzZWxlY3Rpb25fc3RhcnQ6IGludDsgc2VsZWN0aW9uX2VuZDogaW50fVxuXG50eXBlIGpzX29iamVjdCA9IC4uICgqIGZvcndhcmQgZGVjbGFyYXRpb24gaW4gVmRvbV9ibGl0LCB0byBhdm9pZCBkZXBlbmRpbmcgdG8gRE9NIEFQSSBoZXJlICopXG5cbm1vZHVsZSBEZWNvZGVyID0gc3RydWN0XG5cbiAgdHlwZSBhcmdfdmFsdWUgPVxuICAgIHwgU3RyaW5nQXJnIG9mIHN0cmluZ1xuICAgIHwgQm9vbEFyZyBvZiBib29sXG4gICAgfCBGbG9hdEFyZyBvZiBmbG9hdFxuICAgIHwgSW50QXJnIG9mIGludFxuXG4gIHR5cGUgXyB0ID1cbiAgICB8IEZpZWxkIDogc3RyaW5nICogJ21zZyB0IC0+ICdtc2cgdFxuICAgIHwgTWV0aG9kIDogc3RyaW5nICogYXJnX3ZhbHVlIGxpc3QgKiAnbXNnIHQgLT4gJ21zZyB0XG4gICAgfCBCaW5kIDogKCdhIC0+ICdtc2cgdCkgKiAnYSB0IC0+ICdtc2cgdFxuICAgIHwgQ29uc3QgOiAnbXNnIC0+ICdtc2cgdFxuICAgIHwgRmFjdG9yIDogKCdhIC0+ICdtc2cgdCkgLT4gKCdhIC0+ICgnbXNnLCBzdHJpbmcpIFJlc3VsdC50KSB0XG4gICAgfCBTdHJpbmcgOiBzdHJpbmcgdFxuICAgIHwgSW50IDogaW50IHRcbiAgICB8IEZsb2F0IDogZmxvYXQgdFxuICAgIHwgQm9vbCA6IGJvb2wgdFxuICAgIHwgT2JqZWN0IDoganNfb2JqZWN0IHRcbiAgICB8IExpc3QgOiAnYSB0IC0+ICdhIGxpc3QgdFxuICAgIHwgRmFpbCA6IHN0cmluZyAtPiAnbXNnIHRcbiAgICB8IFRyeSA6ICdhIHQgLT4gJ2Egb3B0aW9uIHRcblxuICBsZXQgZmllbGQga2V5IGQgPSBGaWVsZCAoa2V5LCBkKVxuXG4gIGxldCBtZXRob2RfIG5hbWUgYXJnIGQgPSBNZXRob2QgKG5hbWUsIGFyZywgZClcblxuICBsZXQgYmluZCBmIGQgPSBCaW5kIChmLCBkKVxuXG4gIGxldCAoIGxldCogKSBkIGYgPSBiaW5kIGYgZFxuXG4gIGxldCBjb25zdCBtc2cgPSBDb25zdCBtc2dcblxuICBsZXQgcmV0dXJuID0gY29uc3RcblxuICBsZXQgZmFjdG9yIGYgPSBGYWN0b3IgZlxuXG4gIGxldCBtYXAgZiBkID0gbGV0KiBtc2cgPSBkIGluIGNvbnN0IChmIG1zZylcblxuICBsZXQgKCBsZXQrICkgZCBmID0gbWFwIGYgZFxuXG4gIGxldCBwYWlyIGQxIGQyID0gbGV0KiB4MSA9IGQxIGluIGxldCsgeDIgPSBkMiBpbiAoeDEsIHgyKVxuXG4gIGxldCAoIGFuZCsgKSA9IHBhaXJcblxuICBsZXQgYXBwIGYgZCA9IGxldCogZmYgPSBmIGluIG1hcCBmZiBkXG5cbiAgbGV0IG1hcDIgZiBkMSBkMiA9IGxldCogeDEgPSBkMSBpbiBsZXQrIHgyID0gZDIgaW4gZiB4MSB4MlxuXG4gIGxldCBtYXBfc29tZSBmID0gbWFwIChmdW4geCAtPiBTb21lIChmIHgpKVxuXG4gIGxldCBzdHJpbmcgPSBTdHJpbmdcblxuICBsZXQgaW50ID0gSW50XG5cbiAgbGV0IGZsb2F0ID0gRmxvYXRcblxuICBsZXQgYm9vbCA9IEJvb2xcblxuICBsZXQgdW5pdCA9IGNvbnN0ICgpXG5cbiAgbGV0IG9iamVjdF8gPSBPYmplY3RcblxuICBsZXQgbGlzdCBkID0gTGlzdCBkXG5cbiAgbGV0IGZhaWwgZXJyb3IgPSBGYWlsIGVycm9yXG5cbiAgbGV0IHRyeV8gZCA9IFRyeSBkXG5cbiAgbGV0IG1vdXNlX2V2ZW50ID1cbiAgICBsZXQrIHggPSBmaWVsZCBcImNsaWVudFhcIiBmbG9hdFxuICAgIGFuZCsgeSA9IGZpZWxkIFwiY2xpZW50WVwiIGZsb2F0XG4gICAgYW5kKyBsZWZ0X3RvcCA9IGZhY3RvciAoZnVuICgpIC0+XG4gICAgICAgIGZpZWxkIFwiY3VycmVudFRhcmdldFwiIEBAXG4gICAgICAgIG1ldGhvZF8gXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIiBbXSBAQFxuICAgICAgICBsZXQrIGxlZnQgPSBmaWVsZCBcImxlZnRcIiBmbG9hdFxuICAgICAgICBhbmQrIHRvcCA9IGZpZWxkIFwidG9wXCIgZmxvYXQgaW5cbiAgICAgICAgKGxlZnQsIHRvcCkpXG4gICAgYW5kKyBwYWdlX3ggPSBmaWVsZCBcInBhZ2VYXCIgZmxvYXRcbiAgICBhbmQrIHBhZ2VfeSA9IGZpZWxkIFwicGFnZVlcIiBmbG9hdFxuICAgIGFuZCsgYnV0dG9ucyA9IGZpZWxkIFwiYnV0dG9uc1wiIGludFxuICAgIGFuZCsgYWx0X2tleSA9IGZpZWxkIFwiYWx0S2V5XCIgYm9vbFxuICAgIGFuZCsgY3RybF9rZXkgPSBmaWVsZCBcImN0cmxLZXlcIiBib29sXG4gICAgYW5kKyBzaGlmdF9rZXkgPSBmaWVsZCBcInNoaWZ0S2V5XCIgYm9vbFxuICAgIGluXG4gICAgbGV0IGxlZnRfdG9wID0gTGF6eS5mcm9tX2Z1biBsZWZ0X3RvcCBpblxuICAgIGxldCBnZXQgeCA9XG4gICAgICBtYXRjaCBMYXp5LmZvcmNlIHggd2l0aFxuICAgICAgfCBPayB4IC0+IHhcbiAgICAgIHwgRXJyb3IgZXJyIC0+IGZhaWx3aXRoIGVyclxuICAgIGluXG4gICAgbGV0IGVsZW1lbnRfeCA9IGxhenkgKHggLS4gZnN0IChnZXQgbGVmdF90b3ApKSBpblxuICAgIGxldCBlbGVtZW50X3kgPSBsYXp5ICh5IC0uIHNuZCAoZ2V0IGxlZnRfdG9wKSkgaW5cbiAgICB7XG4gICAgICB4O1xuICAgICAgeTtcbiAgICAgIHBhZ2VfeDtcbiAgICAgIHBhZ2VfeTtcbiAgICAgIGVsZW1lbnRfeDtcbiAgICAgIGVsZW1lbnRfeTtcbiAgICAgIGJ1dHRvbnM7XG4gICAgICBhbHRfa2V5O1xuICAgICAgY3RybF9rZXk7XG4gICAgICBzaGlmdF9rZXk7XG4gICAgfVxuXG4gIGxldCBrZXlfZXZlbnQgPVxuICAgIGxldCsgd2hpY2ggPSBmaWVsZCBcIndoaWNoXCIgaW50XG4gICAgYW5kKyBhbHRfa2V5ID0gZmllbGQgXCJhbHRLZXlcIiBib29sXG4gICAgYW5kKyBjdHJsX2tleSA9IGZpZWxkIFwiY3RybEtleVwiIGJvb2xcbiAgICBhbmQrIHNoaWZ0X2tleSA9IGZpZWxkIFwic2hpZnRLZXlcIiBib29sIGluXG4gICAge3doaWNoOyBhbHRfa2V5OyBjdHJsX2tleTsgc2hpZnRfa2V5fVxuXG4gIGxldCBwYXN0ZV9ldmVudCA9XG4gICAgbGV0KyB0ZXh0ID1cbiAgICAgIGZpZWxkIFwiY2xpcGJvYXJkRGF0YVwiXG4gICAgICBAQCBtZXRob2RfIFwiZ2V0RGF0YVwiIFtTdHJpbmdBcmcgXCJ0ZXh0XCJdIHN0cmluZ1xuICAgIGFuZCsgc2VsZWN0aW9uX3N0YXJ0ID0gZmllbGQgXCJjdXJyZW50VGFyZ2V0LnNlbGVjdGlvblN0YXJ0XCIgaW50XG4gICAgYW5kKyBzZWxlY3Rpb25fZW5kID0gZmllbGQgXCJjdXJyZW50VGFyZ2V0LnNlbGVjdGlvbkVuZFwiIGludCBpblxuICAgIHt0ZXh0OyBzZWxlY3Rpb25fc3RhcnQ7IHNlbGVjdGlvbl9lbmR9XG5cbmVuZFxuXG50eXBlICdtc2cgbXNnX29wdGlvbnMgPSB7bXNnOiAnbXNnIG9wdGlvbjsgc3RvcF9wcm9wYWdhdGlvbjogYm9vbDsgcHJldmVudF9kZWZhdWx0OiBib29sfVxuXG50eXBlICsnbXNnIGV2ZW50X2hhbmRsZXIgPVxuICB8IERlY29kZXIgOiB7IGV2ZW50X3R5cGUgOiBzdHJpbmc7IGRlY29kZXIgOiAnYSBtc2dfb3B0aW9ucyBEZWNvZGVyLnQ7IG1hcCA6ICdhIG9wdGlvbiAtPiAnbXNnIG9wdGlvbiB9IC0+ICdtc2cgZXZlbnRfaGFuZGxlclxuICB8IEN1c3RvbUV2ZW50IG9mIChDdXN0b20uZXZlbnQgLT4gJ21zZyBvcHRpb24pXG5cbnR5cGUgcHJvcF92YWwgPVxuICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgfCBJbnQgb2YgaW50XG4gIHwgRmxvYXQgb2YgZmxvYXRcbiAgfCBCb29sIG9mIGJvb2xcblxudHlwZSArJ21zZyBhdHRyaWJ1dGUgPVxuICB8IFByb3BlcnR5IG9mIHN0cmluZyAqIHByb3BfdmFsXG4gIHwgU3R5bGUgb2Ygc3RyaW5nICogc3RyaW5nXG4gIHwgSGFuZGxlciBvZiAnbXNnIGV2ZW50X2hhbmRsZXJcbiAgfCBBdHRyaWJ1dGUgb2Ygc3RyaW5nICogc3RyaW5nXG5cbmxldCBvbl93aXRoX29wdGlvbnMgZXZlbnRfdHlwZSBkZWNvZGVyID1cbiAgSGFuZGxlciAoRGVjb2RlciB7ZXZlbnRfdHlwZTsgZGVjb2RlcjsgbWFwID0gRnVuLmlkfSlcblxubGV0IG9uID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gZXZlbnRfdHlwZSBkZWNvZGVyID1cbiAgbGV0IHByZXZlbnRfZGVmYXVsdCA9IG1hdGNoIHByZXZlbnRfZGVmYXVsdCB3aXRoIFNvbWUgKCkgLT4gdHJ1ZSB8IE5vbmUgLT4gZmFsc2UgaW5cbiAgbGV0IHN0b3BfcHJvcGFnYXRpb24gPSBtYXRjaCBzdG9wX3Byb3BhZ2F0aW9uIHdpdGggU29tZSAoKSAtPiB0cnVlIHwgTm9uZSAtPiBmYWxzZSBpblxuICBvbl93aXRoX29wdGlvbnMgZXZlbnRfdHlwZVxuICAgIERlY29kZXIuKGxldCsgbXNnID0gZGVjb2RlciBpblxuICAgICAgICAgICAgIHttc2c7IHN0b3BfcHJvcGFnYXRpb247IHByZXZlbnRfZGVmYXVsdH0pXG5cbmxldCBvbl9jYW5jZWwgP3N0b3BfcHJvcGFnYXRpb24gZXZlbnRfdHlwZSBkZWNvZGVyID1cbiAgbGV0IHN0b3BfcHJvcGFnYXRpb24gPSBtYXRjaCBzdG9wX3Byb3BhZ2F0aW9uIHdpdGggU29tZSAoKSAtPiB0cnVlIHwgTm9uZSAtPiBmYWxzZSBpblxuICBvbl93aXRoX29wdGlvbnMgZXZlbnRfdHlwZVxuICAgIERlY29kZXIuKGxldCsgbXNnID0gZGVjb2RlciBpblxuICAgICAgICAgICAgIG1hdGNoIG1zZyB3aXRoXG4gICAgICAgICAgICAgfCBTb21lIF8gLT4ge21zZzsgc3RvcF9wcm9wYWdhdGlvbjsgcHJldmVudF9kZWZhdWx0ID0gdHJ1ZX1cbiAgICAgICAgICAgICB8IE5vbmUgLT4gICB7bXNnOyBzdG9wX3Byb3BhZ2F0aW9uOyBwcmV2ZW50X2RlZmF1bHQgPSBmYWxzZX0pXG5cbmxldCBvbl9qc193aXRoX29wdGlvbnMgZXZlbnRfdHlwZSBoYW5kbGVyID1cbiAgb25fd2l0aF9vcHRpb25zIGV2ZW50X3R5cGVcbiAgICBEZWNvZGVyLihsZXQrIG8gPSBvYmplY3RfIGluIGhhbmRsZXIgbylcblxubGV0IG9uX2pzID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gZXZlbnRfdHlwZSBoYW5kbGVyID1cbiAgbGV0IHByZXZlbnRfZGVmYXVsdCA9IG1hdGNoIHByZXZlbnRfZGVmYXVsdCB3aXRoIFNvbWUgKCkgLT4gdHJ1ZSB8IE5vbmUgLT4gZmFsc2UgaW5cbiAgbGV0IHN0b3BfcHJvcGFnYXRpb24gPSBtYXRjaCBzdG9wX3Byb3BhZ2F0aW9uIHdpdGggU29tZSAoKSAtPiB0cnVlIHwgTm9uZSAtPiBmYWxzZSBpblxuICBvbl9qc193aXRoX29wdGlvbnMgZXZlbnRfdHlwZVxuICAgIChmdW4gZSAtPiB7bXNnID0gaGFuZGxlciBlOyBzdG9wX3Byb3BhZ2F0aW9uOyBwcmV2ZW50X2RlZmF1bHR9KVxuXG5sZXQgb25tb3VzZWV2ZW50ID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gdHlwZV8gbXNnID0gb24gP3ByZXZlbnRfZGVmYXVsdCA/c3RvcF9wcm9wYWdhdGlvbiB0eXBlXyAoRGVjb2Rlci5tYXBfc29tZSBtc2cgRGVjb2Rlci5tb3VzZV9ldmVudClcbmxldCBvbm1vdXNlZXZlbnRfY2FuY2VsID9zdG9wX3Byb3BhZ2F0aW9uIHR5cGVfIG1zZyA9IG9uX2NhbmNlbCA/c3RvcF9wcm9wYWdhdGlvbiB0eXBlXyAoRGVjb2Rlci5tYXAgbXNnIERlY29kZXIubW91c2VfZXZlbnQpXG5sZXQgb25tb3VzZWRvd24gP3ByZXZlbnRfZGVmYXVsdCA/c3RvcF9wcm9wYWdhdGlvbiBtc2cgPSBvbm1vdXNlZXZlbnQgP3ByZXZlbnRfZGVmYXVsdCA/c3RvcF9wcm9wYWdhdGlvbiBcIm1vdXNlZG93blwiIG1zZ1xubGV0IG9ubW91c2Vkb3duX2NhbmNlbCA/c3RvcF9wcm9wYWdhdGlvbiBtc2cgPSBvbm1vdXNlZXZlbnRfY2FuY2VsID9zdG9wX3Byb3BhZ2F0aW9uIFwibW91c2Vkb3duXCIgbXNnXG5sZXQgb25tb3VzZXVwID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gbXNnID0gb25tb3VzZWV2ZW50ID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gXCJtb3VzZXVwXCIgbXNnXG5sZXQgb25jbGljayA/cHJldmVudF9kZWZhdWx0ID9zdG9wX3Byb3BhZ2F0aW9uIG1zZyA9IG9ubW91c2VldmVudCA/cHJldmVudF9kZWZhdWx0ID9zdG9wX3Byb3BhZ2F0aW9uIFwiY2xpY2tcIiBtc2dcbmxldCBvbmNsaWNrX2NhbmNlbCA/c3RvcF9wcm9wYWdhdGlvbiBtc2cgPSBvbm1vdXNlZXZlbnRfY2FuY2VsID9zdG9wX3Byb3BhZ2F0aW9uIFwiY2xpY2tcIiBtc2dcbmxldCBvbmRibGNsaWNrID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gbXNnID0gb25tb3VzZWV2ZW50ID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gXCJkYmxjbGlja1wiIG1zZ1xubGV0IG9uY29udGV4dG1lbnUgP3N0b3BfcHJvcGFnYXRpb24gbXNnID0gb25tb3VzZWV2ZW50IH5wcmV2ZW50X2RlZmF1bHQ6KCkgP3N0b3BfcHJvcGFnYXRpb24gXCJjb250ZXh0bWVudVwiIG1zZ1xubGV0IG9ubW91c2Vtb3ZlID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gbXNnID0gb25tb3VzZWV2ZW50ID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gXCJtb3VzZW1vdmVcIiBtc2dcbmxldCBvbm1vdXNlZW50ZXIgP3ByZXZlbnRfZGVmYXVsdCA/c3RvcF9wcm9wYWdhdGlvbiBtc2cgPVxuICBvbiA/cHJldmVudF9kZWZhdWx0ID9zdG9wX3Byb3BhZ2F0aW9uIFwibW91c2VlbnRlclwiIERlY29kZXIuKFxuICAgICAgbGV0KiB0YXJnZXQgPSBmaWVsZCBcInRhcmdldFwiIG9iamVjdF9cbiAgICAgIGFuZCsgY3VycmVudF90YXJnZXQgPSBmaWVsZCBcImN1cnJlbnRUYXJnZXRcIiBvYmplY3RfIGluXG4gICAgICBpZiB0YXJnZXQgPSBjdXJyZW50X3RhcmdldCB0aGVuXG4gICAgICAgIG1hcF9zb21lIG1zZyBtb3VzZV9ldmVudFxuICAgICAgZWxzZVxuICAgICAgICBjb25zdCBOb25lXG4gICAgKVxubGV0IG9ubW91c2VsZWF2ZSA/cHJldmVudF9kZWZhdWx0ID9zdG9wX3Byb3BhZ2F0aW9uIG1zZyA9XG4gIG9uID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gXCJtb3VzZWxlYXZlXCIgRGVjb2Rlci4oXG4gICAgICBsZXQqIHRhcmdldCA9IGZpZWxkIFwidGFyZ2V0XCIgb2JqZWN0X1xuICAgICAgYW5kKyBjdXJyZW50X3RhcmdldCA9IGZpZWxkIFwiY3VycmVudFRhcmdldFwiIG9iamVjdF8gaW5cbiAgICAgIGlmIHRhcmdldCA9IGN1cnJlbnRfdGFyZ2V0IHRoZW5cbiAgICAgICAgbWFwX3NvbWUgbXNnIG1vdXNlX2V2ZW50XG4gICAgICBlbHNlXG4gICAgICAgIGNvbnN0IE5vbmVcbiAgICApXG5sZXQgb25tb3VzZW92ZXIgP3ByZXZlbnRfZGVmYXVsdCA/c3RvcF9wcm9wYWdhdGlvbiBtc2cgPSBvbm1vdXNlZXZlbnQgP3ByZXZlbnRfZGVmYXVsdCA/c3RvcF9wcm9wYWdhdGlvbiBcIm1vdXNlb3ZlclwiIG1zZ1xuXG5sZXQgb25mb2N1cyA/cHJldmVudF9kZWZhdWx0ID9zdG9wX3Byb3BhZ2F0aW9uIG1zZyA9IG9uID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gXCJmb2N1c1wiIChEZWNvZGVyLmNvbnN0IChTb21lIG1zZykpXG5sZXQgb25ibHVyID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gbXNnID0gb24gP3ByZXZlbnRfZGVmYXVsdCA/c3RvcF9wcm9wYWdhdGlvbiBcImJsdXJcIiAoRGVjb2Rlci5jb25zdCAoU29tZSBtc2cpKVxuXG5sZXQgb25pbnB1dCA/cHJldmVudF9kZWZhdWx0ID9zdG9wX3Byb3BhZ2F0aW9uIG1zZyA9IG9uID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gXCJpbnB1dFwiIERlY29kZXIuKG1hcF9zb21lIG1zZyAoZmllbGQgXCJ0YXJnZXQudmFsdWVcIiBzdHJpbmcpKVxubGV0IG9uY2hhbmdlID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gbXNnID0gb24gP3ByZXZlbnRfZGVmYXVsdCA/c3RvcF9wcm9wYWdhdGlvbiBcImNoYW5nZVwiIERlY29kZXIuKG1hcF9zb21lIG1zZyAoZmllbGQgXCJ0YXJnZXQudmFsdWVcIiBzdHJpbmcpKVxuXG5sZXQgb25jaGFuZ2VfaW5kZXggP3ByZXZlbnRfZGVmYXVsdCA/c3RvcF9wcm9wYWdhdGlvbiBtc2cgPSBvbiA/cHJldmVudF9kZWZhdWx0ID9zdG9wX3Byb3BhZ2F0aW9uIFwiY2hhbmdlXCIgRGVjb2Rlci4obWFwX3NvbWUgbXNnIChmaWVsZCBcInRhcmdldC5zZWxlY3RlZEluZGV4XCIgaW50KSlcbmxldCBvbmNoYW5nZV9jaGVja2VkID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gbXNnID0gb24gP3ByZXZlbnRfZGVmYXVsdCA/c3RvcF9wcm9wYWdhdGlvbiBcImNsaWNrXCIgRGVjb2Rlci4obWFwX3NvbWUgbXNnIChmaWVsZCBcInRhcmdldC5jaGVja2VkXCIgYm9vbCkpXG5cbmxldCBvbmtleWV2ZW50ID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gdHlwZV8gbXNnID0gb24gP3ByZXZlbnRfZGVmYXVsdCA/c3RvcF9wcm9wYWdhdGlvbiB0eXBlXyAoRGVjb2Rlci5tYXBfc29tZSBtc2cgRGVjb2Rlci5rZXlfZXZlbnQpXG5sZXQgb25rZXlldmVudF9jYW5jZWwgP3N0b3BfcHJvcGFnYXRpb24gdHlwZV8gbXNnID0gb25fY2FuY2VsID9zdG9wX3Byb3BhZ2F0aW9uIHR5cGVfIChEZWNvZGVyLm1hcCBtc2cgRGVjb2Rlci5rZXlfZXZlbnQpXG5sZXQgb25rZXlkb3duID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gbXNnID0gb25rZXlldmVudCA/cHJldmVudF9kZWZhdWx0ID9zdG9wX3Byb3BhZ2F0aW9uIFwia2V5ZG93blwiIG1zZ1xubGV0IG9ua2V5ZG93bl9jYW5jZWwgP3N0b3BfcHJvcGFnYXRpb24gbXNnID0gb25rZXlldmVudF9jYW5jZWwgP3N0b3BfcHJvcGFnYXRpb24gXCJrZXlkb3duXCIgbXNnXG5sZXQgb25rZXl1cCA/cHJldmVudF9kZWZhdWx0ID9zdG9wX3Byb3BhZ2F0aW9uIG1zZyA9IG9ua2V5ZXZlbnQgP3ByZXZlbnRfZGVmYXVsdCA/c3RvcF9wcm9wYWdhdGlvbiBcImtleXVwXCIgbXNnXG5sZXQgb25rZXl1cF9jYW5jZWwgP3N0b3BfcHJvcGFnYXRpb24gbXNnID0gb25rZXlldmVudF9jYW5jZWwgP3N0b3BfcHJvcGFnYXRpb24gXCJrZXl1cFwiIG1zZ1xuXG5sZXQgb25wYXN0ZSA/cHJldmVudF9kZWZhdWx0ID9zdG9wX3Byb3BhZ2F0aW9uIG1zZyA9IG9uID9wcmV2ZW50X2RlZmF1bHQgP3N0b3BfcHJvcGFnYXRpb24gXCJwYXN0ZVwiIChEZWNvZGVyLm1hcCBtc2cgRGVjb2Rlci5wYXN0ZV9ldmVudClcblxubGV0IG9uY3VzdG9tZXZlbnQgbXNnID0gSGFuZGxlciAoQ3VzdG9tRXZlbnQgbXNnKVxuXG5cbmxldCBzdHJfcHJvcCBrIHYgPSBQcm9wZXJ0eSAoaywgU3RyaW5nIHYpXG5sZXQgaW50X3Byb3AgayB2ID0gUHJvcGVydHkgKGssIEludCB2KVxubGV0IGJvb2xfcHJvcCBrIHYgPSBQcm9wZXJ0eSAoaywgQm9vbCB2KVxubGV0IGZsb2F0X3Byb3AgayB2ID0gUHJvcGVydHkgKGssIEZsb2F0IHYpXG5sZXQgc3R5bGUgayB2ID0gU3R5bGUgKGssIHYpXG5sZXQgYXR0ciBrIHYgPSBBdHRyaWJ1dGUgKGssIHYpXG5sZXQgaW50X2F0dHIgayB2ID0gQXR0cmlidXRlIChrLCBzdHJpbmdfb2ZfaW50IHYpXG5sZXQgZmxvYXRfYXR0ciBrIHYgPSBBdHRyaWJ1dGUgKGssIHN0cmluZ19vZl9mbG9hdCB2KVxubGV0IHNjcm9sbF90b19zaG93IH5hbGlnbl90b3AgPSBib29sX3Byb3AgXCJzY3JvbGwtdG8tc2hvd1wiIGFsaWduX3RvcFxubGV0IGF1dG9mb2N1cyA9IGJvb2xfcHJvcCBcImF1dG9mb2N1c1wiIHRydWVcbmxldCBhdXRvZm9jdXNfY291bnRlciB4ID0gaW50X3Byb3AgXCJhdXRvZm9jdXNcIiB4XG5sZXQgYXV0b2ZvY3VzX2lmX3Zpc2libGUgPSBzdHJfcHJvcCBcImF1dG9mb2N1c1wiIFwiaWYtdmlzaWJsZVwiXG5sZXQgYXV0b3N1Ym1pdCA9IGJvb2xfcHJvcCBcImF1dG9zdWJtaXRcIiB0cnVlXG5sZXQgc2VsZWN0ID0gYm9vbF9wcm9wIFwic2VsZWN0XCIgdHJ1ZVxuXG5sZXQgY2xhc3NfIHggPSBQcm9wZXJ0eSAoXCJjbGFzc05hbWVcIiwgU3RyaW5nIHgpXG5sZXQgdHlwZV8geCA9IFByb3BlcnR5IChcInR5cGVcIiwgU3RyaW5nIHgpXG5sZXQgdHlwZV9idXR0b24gPSB0eXBlXyBcImJ1dHRvblwiXG5sZXQgdmFsdWUgeCA9IFByb3BlcnR5IChcInZhbHVlXCIsIFN0cmluZyB4KVxubGV0IGRpc2FibGVkIHggPSBQcm9wZXJ0eSAoXCJkaXNhYmxlZFwiLCBCb29sIHgpXG5cbmxldCBhZGRfY2xhc3MgeCBhdHRycyA9XG4gIGxldCBoYXNfY2xhc3NOYW1lID1cbiAgICBMaXN0LmV4aXN0cyAoZnVuY3Rpb24gUHJvcGVydHkgKFwiY2xhc3NOYW1lXCIsIF8pIC0+IHRydWUgfCBfIC0+IGZhbHNlKSBhdHRyc1xuICBpblxuICBpZiBoYXNfY2xhc3NOYW1lIHRoZW5cbiAgICBMaXN0Lm1hcCAoZnVuY3Rpb25cbiAgICAgICAgfCBQcm9wZXJ0eSAoXCJjbGFzc05hbWVcIiwgU3RyaW5nIHMpIC0+XG4gICAgICAgICAgICBQcm9wZXJ0eSAoXCJjbGFzc05hbWVcIiwgU3RyaW5nIChQcmludGYuc3ByaW50ZiBcIiVzICVzXCIgcyB4KSlcbiAgICAgICAgfCBhIC0+XG4gICAgICAgICAgICBhXG4gICAgICApIGF0dHJzXG4gIGVsc2VcbiAgICBjbGFzc18geCA6OiBhdHRyc1xuXG50eXBlICsnbXNnIHZkb20gPVxuICB8IFRleHQgb2ZcbiAgICAgIHtcbiAgICAgICAga2V5OiBzdHJpbmc7XG4gICAgICAgIHR4dDogc3RyaW5nO1xuICAgICAgfVxuICB8IEZyYWdtZW50IG9mXG4gICAgICB7XG4gICAgICAgIGtleTogc3RyaW5nO1xuICAgICAgICBjaGlsZHJlbjogJ21zZyB2ZG9tIGxpc3Q7XG4gICAgICB9XG4gIHwgRWxlbWVudCBvZlxuICAgICAge1xuICAgICAgICBrZXk6IHN0cmluZztcbiAgICAgICAgbnM6IHN0cmluZztcbiAgICAgICAgdGFnOiBzdHJpbmc7XG4gICAgICAgIGF0dHJpYnV0ZXM6ICdtc2cgYXR0cmlidXRlIGxpc3Q7XG4gICAgICAgIGNoaWxkcmVuOiAnbXNnIHZkb20gbGlzdDtcbiAgICAgIH1cbiAgfCBNYXA6XG4gICAgICB7XG4gICAgICAgIGtleTogc3RyaW5nO1xuICAgICAgICBmOiAoJ3N1Ym1zZyAtPiAnbXNnKTtcbiAgICAgICAgY2hpbGQ6ICdzdWJtc2cgdmRvbTtcbiAgICAgIH0gLT4gJ21zZyB2ZG9tXG4gIHwgTWVtbzpcbiAgICAgIHtcbiAgICAgICAga2V5OiBzdHJpbmc7XG4gICAgICAgIGY6ICgnYSAtPiAnbXNnIHZkb20pO1xuICAgICAgICBhcmc6ICdhO1xuICAgICAgfSAtPiAnbXNnIHZkb21cbiAgfCBDdXN0b20gb2ZcbiAgICAgIHtcbiAgICAgICAga2V5OiBzdHJpbmc7XG4gICAgICAgIGVsdDogQ3VzdG9tLnQ7XG4gICAgICAgIGF0dHJpYnV0ZXM6ICdtc2cgYXR0cmlidXRlIGxpc3Q7XG4gICAgICAgIHByb3BhZ2F0ZV9ldmVudHM6IGJvb2w7XG4gICAgICB9XG5cbmxldCB0ZXh0ID8oa2V5ID1cIl90eHRcIikgdHh0ID0gVGV4dCB7a2V5OyB0eHR9XG5cbmxldCBmcmFnbWVudCA/KGtleSA9XCJfZnJhZ21lbnRcIikgY2hpbGRyZW4gPSBGcmFnbWVudCB7a2V5OyBjaGlsZHJlbn1cblxudHlwZSAoJ21zZywgJ3JlcykgZWx0X2dlbiA9XG4gID9rZXk6c3RyaW5nIC0+XG4gID9hOidtc2cgYXR0cmlidXRlIGxpc3QgLT5cbiAgJ3Jlc1xuXG5sZXQgZWx0ID8obnMgPSBcIlwiKSB0YWcgP2tleSA/KGEgPSBbXSkgbCA9XG4gIEVsZW1lbnRcbiAgICB7XG4gICAgICBrZXkgPSAobWF0Y2gga2V5IHdpdGggTm9uZSAtPiB0YWcgfCBTb21lIGsgLT4gayk7XG4gICAgICBucztcbiAgICAgIHRhZztcbiAgICAgIGNoaWxkcmVuID0gbDtcbiAgICAgIGF0dHJpYnV0ZXMgPSBhO1xuICAgIH1cblxubGV0IHN2Z19ucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxubGV0IHN2Z19lbHQgdGFnID9rZXkgP2EgbCA9IGVsdCB+bnM6c3ZnX25zIHRhZyA/a2V5ID9hIGxcblxubGV0IGRpdiA/a2V5ID9hIGwgPSBlbHQgXCJkaXZcIiA/a2V5ID9hIGxcbmxldCBpbnB1dCA/a2V5ID9hIGwgPSBlbHQgXCJpbnB1dFwiID9rZXkgP2EgbFxubGV0IHR4dF9zcGFuID9rZXkgP2EgcyA9IGVsdCBcInNwYW5cIiA/a2V5ID9hIFt0ZXh0IHNdXG5cbmxldCBtYXBfYXR0ciBmID0gZnVuY3Rpb25cbiAgfCBDdXN0b20gKHsgYXR0cmlidXRlczsgXyB9IGFzIHgpIC0+XG4gICAgICBDdXN0b20geyB4IHdpdGggYXR0cmlidXRlcyA9IGYgYXR0cmlidXRlcyB9XG4gIHwgRWxlbWVudCAoeyBhdHRyaWJ1dGVzOyBfIH0gYXMgeCkgLT5cbiAgICAgIEVsZW1lbnQgeyB4IHdpdGggYXR0cmlidXRlcyA9IGYgYXR0cmlidXRlcyB9XG4gIHwgeCAtPiB4XG5cbmxldCBtYXAgPyhrZXkgPSBcIl9tYXBcIikgZiBjaGlsZCA9IE1hcCB7a2V5OyBmOyBjaGlsZH1cbmxldCBtZW1vID8oa2V5ID0gXCJfbWVtb1wiKSBmIGFyZyA9IE1lbW8ge2tleTsgZjsgYXJnfVxubGV0IGN1c3RvbSA/KGtleSA9XCJfY3VzdG9tXCIpID8oYSA9IFtdKSA/cHJvcGFnYXRlX2V2ZW50cyBlbHQgPSBDdXN0b20ge2tleTsgZWx0OyBhdHRyaWJ1dGVzID0gYTsgcHJvcGFnYXRlX2V2ZW50cyA9IChwcm9wYWdhdGVfZXZlbnRzID0gU29tZSAoKSl9XG5cbmxldCByZXR1cm4gPyhjID0gW10pIG1vZGVsID0gbW9kZWwsIENtZC5iYXRjaCBjXG5cbnR5cGUgKCdtb2RlbCwgJ21zZykgYXBwID1cbiAge1xuICAgIGluaXQ6ICgnbW9kZWwgKiAnbXNnIENtZC50KTtcbiAgICB1cGRhdGU6ICgnbW9kZWwgLT4gJ21zZyAtPiAnbW9kZWwgKiAnbXNnIENtZC50KTtcbiAgICB2aWV3OiAoJ21vZGVsIC0+ICdtc2cgdmRvbSk7XG4gIH1cblxubGV0IGFwcCB+aW5pdCB+dXBkYXRlIH52aWV3ICgpID1cbiAge2luaXQ7IHVwZGF0ZTsgdmlld31cblxubGV0IHNpbXBsZV9hcHAgfmluaXQgfnVwZGF0ZSB+dmlldyAoKSA9XG4gIGFwcFxuICAgIH5pbml0OihyZXR1cm4gaW5pdClcbiAgICB+dXBkYXRlOihmdW4gbW9kZWwgbXNnIC0+IHJldHVybiAodXBkYXRlIG1vZGVsIG1zZykpXG4gICAgfnZpZXdcbiAgICAoKVxuXG5cbmxldCB0cmltX2VuZCBjIHMgPVxuICBsZXQgbCA9IHJlZiAoU3RyaW5nLmxlbmd0aCBzKSBpblxuICB3aGlsZSAhbCA+IDAgJiYgcy5bIWwgLSAxXSA9IGMgZG9cbiAgICBkZWNyIGxcbiAgZG9uZTtcbiAgaWYgIWwgPCBTdHJpbmcubGVuZ3RoIHMgdGhlbiBTdHJpbmcuc3ViIHMgMCAhbCBlbHNlIHNcblxubGV0IHJlcGxhY2VfY2hhciBzIGMgeCA9XG4gIG1hdGNoIFN0cmluZy5pbmRleF9vcHQgcyBjIHdpdGhcbiAgfCBOb25lIC0+IHNcbiAgfCBTb21lIGkwIC0+XG4gICAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBpblxuICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIHMgMCBpMDtcbiAgICAgIGZvciBpID0gaTAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgICBsZXQgdSA9IHMuW2ldIGluXG4gICAgICAgIGlmIHUgPSBjIHRoZW4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIHhcbiAgICAgICAgZWxzZSBCdWZmZXIuYWRkX2NoYXIgYnVmIHVcbiAgICAgIGRvbmU7XG4gICAgICBCdWZmZXIuY29udGVudHMgYnVmXG5cbmxldCB0b19odG1sIHZkb20gPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgNjU0IGluXG4gIGxldCByZWMgYXV4OiB0eXBlIGEuIGEgdmRvbSAtPiB1bml0ID0gZnVuY3Rpb25cbiAgICB8IFRleHQge2tleT1fOyB0eHR9IC0+IEJ1ZmZlci5hZGRfc3RyaW5nIGIgdHh0XG4gICAgfCBFbGVtZW50IHtrZXk9XzsgbnM7IHRhZzsgYXR0cmlidXRlczsgY2hpbGRyZW59IC0+XG4gICAgICAgIGxldCBjb25jYXRfdHVwbGUgcyAoeDEsIHgyKSA9IHgxIF4gcyBeIHgyIGluXG4gICAgICAgIGxldCBhdHRycywgc3R5bGVzID1cbiAgICAgICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgICAgICAgKGZ1biAoYXR0cnMsIHN0eWxlcykgLT4gZnVuY3Rpb25cbiAgICAgICAgICAgICAgIHwgUHJvcGVydHkgKG5hbWUsIHZhbHVlKSAtPlxuICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICBtYXRjaCB2YWx1ZSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICB8IFN0cmluZyBzIC0+IHNcbiAgICAgICAgICAgICAgICAgICAgIHwgSW50IGkgLT4gc3RyaW5nX29mX2ludCBpXG4gICAgICAgICAgICAgICAgICAgICB8IEZsb2F0IGYgLT4gdHJpbV9lbmQgJy4nIChzdHJpbmdfb2ZfZmxvYXQgZilcbiAgICAgICAgICAgICAgICAgICAgIHwgQm9vbCBiIC0+IHN0cmluZ19vZl9ib29sIGJcbiAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID1cbiAgICAgICAgICAgICAgICAgICAgIG1hdGNoIG5hbWUgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgfCBcImNsYXNzTmFtZVwiIC0+IFwiY2xhc3NcIlxuICAgICAgICAgICAgICAgICAgICAgfCBfIC0+IG5hbWVcbiAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgIChuYW1lLCB2YWx1ZSkgOjogYXR0cnMsIHN0eWxlc1xuICAgICAgICAgICAgICAgfCBTdHlsZSAobmFtZSwgdmFsdWUpIC0+XG4gICAgICAgICAgICAgICAgICAgYXR0cnMsIChuYW1lLCB2YWx1ZSkgOjogc3R5bGVzXG4gICAgICAgICAgICAgICB8IEhhbmRsZXIgXyAtPiBhdHRycywgc3R5bGVzXG4gICAgICAgICAgICAgICB8IEF0dHJpYnV0ZSAobmFtZSwgdmFsdWUpIC0+XG4gICAgICAgICAgICAgICAgICAgKG5hbWUsIHZhbHVlKSA6OiBhdHRycywgc3R5bGVzXG4gICAgICAgICAgICApIChbXSwgW10pIGF0dHJpYnV0ZXNcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGF0dHJzID1cbiAgICAgICAgICBtYXRjaCBzdHlsZXMgd2l0aFxuICAgICAgICAgIHwgW10gLT4gYXR0cnNcbiAgICAgICAgICB8IHN0eWxlcyAtPlxuICAgICAgICAgICAgICBsZXQgc3R5bGVzID1cbiAgICAgICAgICAgICAgICBMaXN0Lm1hcCAoY29uY2F0X3R1cGxlIFwiOlwiKSBzdHlsZXNcbiAgICAgICAgICAgICAgICB8PiBTdHJpbmcuY29uY2F0IFwiO1wiXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIChcInN0eWxlXCIsIHN0eWxlcykgOjogYXR0cnNcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGF0dHJzID0gTGlzdC5yZXYgYXR0cnMgaW5cbiAgICAgICAgbGV0IGF0dHJzID0gaWYgbnMgPSBcIlwiIHRoZW4gYXR0cnMgZWxzZSAoXCJ4bWxuc1wiLCBucykgOjogYXR0cnMgaW5cbiAgICAgICAgbGV0IGF0dHJzID1cbiAgICAgICAgICBMaXN0Lm1hcCAoZnVuIChrLCB2KSAtPlxuICAgICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIiVzPVxcXCIlc1xcXCJcIiBrXG4gICAgICAgICAgICAgICAgKHJlcGxhY2VfY2hhciB2ICdcIicgXCImcXVvdGU7XCIpXG4gICAgICAgICAgICApIGF0dHJzXG4gICAgICAgICAgfD4gU3RyaW5nLmNvbmNhdCBcIiBcIlxuICAgICAgICBpblxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnPCc7XG4gICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGIgdGFnO1xuICAgICAgICBpZiBhdHRycyA8PiBcIlwiIHRoZW4gYmVnaW5cbiAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnICc7XG4gICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYiBhdHRyc1xuICAgICAgICBlbmQ7XG4gICAgICAgIGlmIGNoaWxkcmVuID0gW10gdGhlblxuICAgICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCIvPlwiXG4gICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnPic7XG4gICAgICAgICAgTGlzdC5pdGVyIGF1eCBjaGlsZHJlbjtcbiAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBiIFwiPC9cIjtcbiAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBiIHRhZztcbiAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnPidcbiAgICAgICAgZW5kXG4gICAgfCBGcmFnbWVudCB7a2V5PV87IGNoaWxkcmVufSAtPlxuICAgICAgICBMaXN0Lml0ZXIgYXV4IGNoaWxkcmVuXG4gICAgfCBNYXAge2tleT1fOyBmPV87IGNoaWxkfSAtPlxuICAgICAgICBhdXggY2hpbGRcbiAgICB8IE1lbW8ge2tleT1fOyBmOyBhcmd9IC0+XG4gICAgICAgIGF1eCAoZiBhcmcpXG4gICAgfCBDdXN0b20gXyAtPiAoKVxuICBpblxuICBhdXggdmRvbTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJcbiIsIltAQEBqcy5kdW1teSBcIiEhIFRoaXMgY29kZSBoYXMgYmVlbiBnZW5lcmF0ZWQgYnkgZ2VuX2pzX2FwaSAhIVwiXVxuW0BAQG9jYW1sLndhcm5pbmcgXCItNy0zMi0zOVwiXVxubW9kdWxlIFByb21pc2UgPVxuICBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAoKE9qcy50IC0+ICdhKSAqIE9qcy50KVxuICAgIGxldCB0X29mX2pzIGYgeCA9IChmLCB4KVxuICAgIGxldCAodGhlbl8gOlxuICAgICAgT2pzLnQgLT5cbiAgICAgICAgc3VjY2VzczooT2pzLnQgLT4gdW5pdCkgLT4gZXJyb3I6KE9qcy50IC0+IHVuaXQpIG9wdGlvbiAtPiB1bml0KVxuICAgICAgPVxuICAgICAgZnVuICh4NiA6IE9qcy50KSAtPlxuICAgICAgICBmdW4gfnN1Y2Nlc3M6KHgxIDogT2pzLnQgLT4gdW5pdCkgLT5cbiAgICAgICAgICBmdW4gfmVycm9yOih4MyA6IChPanMudCAtPiB1bml0KSBvcHRpb24pIC0+XG4gICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgKE9qcy5jYWxsIHg2IFwidGhlblwiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5mdW5fdG9fanMgMSB4MSk7KE9qcy5vcHRpb25fdG9fanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuICh4NCA6IE9qcy50IC0+IHVuaXQpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2pzLmZ1bl90b19qcyAxIHg0KSB4Myl8XSlcbiAgICBsZXQgdGhlbl8gP2Vycm9yICB+c3VjY2VzcyAgKGFscGhhX29mX2pzLCBvanMpID1cbiAgICAgIHRoZW5fIG9qcyB+c3VjY2VzczooZnVuIHggLT4gc3VjY2VzcyAoYWxwaGFfb2ZfanMgeCkpIH5lcnJvclxuICBlbmRcbm1vZHVsZSBTdG9yYWdlID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjIHRfb2ZfanMgOiBPanMudCAtPiB0ID0gZnVuICh4OCA6IE9qcy50KSAtPiB4OFxuICAgIGFuZCB0X3RvX2pzIDogdCAtPiBPanMudCA9IGZ1biAoeDcgOiBPanMudCkgLT4geDdcbiAgICBsZXQgKGxlbmd0aCA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4gKHg5IDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg5KSBcImxlbmd0aFwiKVxuICAgIGxldCAoa2V5IDogdCAtPiBpbnQgLT4gc3RyaW5nIG9wdGlvbikgPVxuICAgICAgZnVuICh4MTEgOiB0KSAtPlxuICAgICAgICBmdW4gKHgxMCA6IGludCkgLT5cbiAgICAgICAgICBPanMub3B0aW9uX29mX2pzIE9qcy5zdHJpbmdfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MTEpIFwia2V5XCIgW3woT2pzLmludF90b19qcyB4MTApfF0pXG4gICAgbGV0IChnZXRfaXRlbSA6IHQgLT4gc3RyaW5nIC0+IHN0cmluZyBvcHRpb24pID1cbiAgICAgIGZ1biAoeDE0IDogdCkgLT5cbiAgICAgICAgZnVuICh4MTMgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLm9wdGlvbl9vZl9qcyBPanMuc3RyaW5nX29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDE0KSBcImdldEl0ZW1cIiBbfChPanMuc3RyaW5nX3RvX2pzIHgxMyl8XSlcbiAgICBsZXQgKHNldF9pdGVtIDogdCAtPiBzdHJpbmcgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDE4IDogdCkgLT5cbiAgICAgICAgZnVuICh4MTYgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgZnVuICh4MTcgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgxOCkgXCJzZXRJdGVtXCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4MTYpOyhPanMuc3RyaW5nX3RvX2pzIHgxNyl8XSlcbiAgICBsZXQgKHJlbW92ZV9pdGVtIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MjAgOiB0KSAtPlxuICAgICAgICBmdW4gKHgxOSA6IHN0cmluZykgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MjApIFwicmVtb3ZlSXRlbVwiIFt8KE9qcy5zdHJpbmdfdG9fanMgeDE5KXxdKVxuICAgIGxldCAoY2xlYXIgOiB0IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDIxIDogdCkgLT4gaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4MjEpIFwiY2xlYXJcIiBbfHxdKVxuICBlbmRcbm1vZHVsZSBSZWdFeHAgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgdF9vZl9qcyA6IE9qcy50IC0+IHQgPSBmdW4gKHgyMyA6IE9qcy50KSAtPiB4MjNcbiAgICBhbmQgdF90b19qcyA6IHQgLT4gT2pzLnQgPSBmdW4gKHgyMiA6IE9qcy50KSAtPiB4MjJcbiAgICBsZXQgKG5ld19yZWdfZXhwIDogc3RyaW5nIC0+ID9mbGFnczpzdHJpbmcgLT4gdW5pdCAtPiB0KSA9XG4gICAgICBmdW4gKHgyNCA6IHN0cmluZykgLT5cbiAgICAgICAgZnVuID9mbGFnczooeDI1IDogc3RyaW5nIG9wdGlvbikgLT5cbiAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgIHRfb2ZfanNcbiAgICAgICAgICAgICAgKE9qcy5uZXdfb2JqX2FyciAoT2pzLmdldF9wcm9wX2FzY2lpIE9qcy5nbG9iYWwgXCJSZWdFeHBcIilcbiAgICAgICAgICAgICAgICAgKGxldCB4MjYgPVxuICAgICAgICAgICAgICAgICAgICBPanMubmV3X29iaiAoT2pzLmdldF9wcm9wX2FzY2lpIE9qcy5nbG9iYWwgXCJBcnJheVwiKSBbfHxdIGluXG4gICAgICAgICAgICAgICAgICBpZ25vcmUgKE9qcy5jYWxsIHgyNiBcInB1c2hcIiBbfChPanMuc3RyaW5nX3RvX2pzIHgyNCl8XSk7XG4gICAgICAgICAgICAgICAgICAobWF0Y2ggeDI1IHdpdGhcbiAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDI3IC0+XG4gICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuY2FsbCB4MjYgXCJwdXNoXCIgW3woT2pzLnN0cmluZ190b19qcyB4MjcpfF0pXG4gICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgIHgyNikpXG4gIGVuZFxubW9kdWxlIEpzU3RyaW5nID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjIHRfb2ZfanMgOiBPanMudCAtPiB0ID0gZnVuICh4MjkgOiBPanMudCkgLT4geDI5XG4gICAgYW5kIHRfdG9fanMgOiB0IC0+IE9qcy50ID0gZnVuICh4MjggOiBPanMudCkgLT4geDI4XG4gICAgbGV0IG9mX3N0cmluZyBzID0gT2pzLnN0cmluZ190b19qcyBzXG4gICAgbGV0IHRvX3N0cmluZyB4ID0gT2pzLnN0cmluZ19vZl9qcyB4XG4gICAgbGV0IChsZW5ndGggOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4MzAgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDMwKSBcImxlbmd0aFwiKVxuICAgIGxldCAoY2hhcl9jb2RlX2F0IDogdCAtPiBpbnQgLT4gaW50KSA9XG4gICAgICBmdW4gKHgzMiA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDMxIDogaW50KSAtPlxuICAgICAgICAgIE9qcy5pbnRfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MzIpIFwiY2hhckNvZGVBdFwiIFt8KE9qcy5pbnRfdG9fanMgeDMxKXxdKVxuICAgIGxldCAodG9fbG93ZXJfY2FzZSA6IHQgLT4gdCkgPVxuICAgICAgZnVuICh4MzMgOiB0KSAtPiB0X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4MzMpIFwidG9Mb3dlckNhc2VcIiBbfHxdKVxuICAgIGxldCAodG9fdXBwZXJfY2FzZSA6IHQgLT4gdCkgPVxuICAgICAgZnVuICh4MzQgOiB0KSAtPiB0X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4MzQpIFwidG9VcHBlckNhc2VcIiBbfHxdKVxuICAgIGxldCAoY29uY2F0IDogdCAtPiB0IGxpc3QgLT4gdCkgPVxuICAgICAgZnVuICh4MzggOiB0KSAtPlxuICAgICAgICBmdW4gKHgzNSA6IHQgbGlzdCkgLT5cbiAgICAgICAgICB0X29mX2pzXG4gICAgICAgICAgICAobGV0IHgzOSA9IHRfdG9fanMgeDM4IGluXG4gICAgICAgICAgICAgT2pzLmNhbGwgKE9qcy5nZXRfcHJvcF9hc2NpaSB4MzkgXCJjb25jYXRcIikgXCJhcHBseVwiXG4gICAgICAgICAgICAgICBbfHgzOTsoKGxldCB4MzYgPVxuICAgICAgICAgICAgICAgICAgICAgICAgIE9qcy5uZXdfb2JqIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcIkFycmF5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBbfHxdIGluXG4gICAgICAgICAgICAgICAgICAgICAgIExpc3QuaXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgIChmdW4gKHgzNyA6IHQpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlIChPanMuY2FsbCB4MzYgXCJwdXNoXCIgW3wodF90b19qcyB4MzcpfF0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgIHgzNTtcbiAgICAgICAgICAgICAgICAgICAgICAgeDM2KSl8XSlcbiAgICBsZXQgKGluY2x1ZGVzIDogdCAtPiB0IC0+IGJvb2wpID1cbiAgICAgIGZ1biAoeDQxIDogdCkgLT5cbiAgICAgICAgZnVuICh4NDAgOiB0KSAtPlxuICAgICAgICAgIE9qcy5ib29sX29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQxKSBcImluY2x1ZGVzXCIgW3wodF90b19qcyB4NDApfF0pXG4gICAgbGV0IChlbmRzX3dpdGggOiB0IC0+IHQgLT4gYm9vbCkgPVxuICAgICAgZnVuICh4NDMgOiB0KSAtPlxuICAgICAgICBmdW4gKHg0MiA6IHQpIC0+XG4gICAgICAgICAgT2pzLmJvb2xfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NDMpIFwiZW5kc1dpdGhcIiBbfCh0X3RvX2pzIHg0Mil8XSlcbiAgICBsZXQgKGluZGV4X29mIDogdCAtPiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4NDUgOiB0KSAtPlxuICAgICAgICBmdW4gKHg0NCA6IHQpIC0+XG4gICAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDQ1KSBcImluZGV4T2ZcIiBbfCh0X3RvX2pzIHg0NCl8XSlcbiAgICBsZXQgKHJlcGVhdCA6IHQgLT4gaW50IC0+IHQpID1cbiAgICAgIGZ1biAoeDQ3IDogdCkgLT5cbiAgICAgICAgZnVuICh4NDYgOiBpbnQpIC0+XG4gICAgICAgICAgdF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDQ3KSBcInJlcGVhdFwiIFt8KE9qcy5pbnRfdG9fanMgeDQ2KXxdKVxuICAgIGxldCAoc2VhcmNoIDogdCAtPiBSZWdFeHAudCAtPiBpbnQpID1cbiAgICAgIGZ1biAoeDQ5IDogdCkgLT5cbiAgICAgICAgZnVuICh4NDggOiBSZWdFeHAudCkgLT5cbiAgICAgICAgICBPanMuaW50X29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQ5KSBcInNlYXJjaFwiIFt8KFJlZ0V4cC50X3RvX2pzIHg0OCl8XSlcbiAgICBsZXQgKHRyaW0gOiB0IC0+IHQpID1cbiAgICAgIGZ1biAoeDUwIDogdCkgLT4gdF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDUwKSBcInRyaW1cIiBbfHxdKVxuICBlbmRcbm1vZHVsZSBEYXRlID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjIHRfb2ZfanMgOiBPanMudCAtPiB0ID0gZnVuICh4NTIgOiBPanMudCkgLT4geDUyXG4gICAgYW5kIHRfdG9fanMgOiB0IC0+IE9qcy50ID0gZnVuICh4NTEgOiBPanMudCkgLT4geDUxXG4gICAgbGV0IChuZXdfZGF0ZSA6IGZsb2F0IC0+IHQpID1cbiAgICAgIGZ1biAoeDUzIDogZmxvYXQpIC0+XG4gICAgICAgIHRfb2ZfanNcbiAgICAgICAgICAoT2pzLm5ld19vYmogKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwiRGF0ZVwiKVxuICAgICAgICAgICAgIFt8KE9qcy5mbG9hdF90b19qcyB4NTMpfF0pXG4gICAgbGV0IChub3cgOiB1bml0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4gKCkgLT5cbiAgICAgICAgT2pzLmZsb2F0X29mX2pzXG4gICAgICAgICAgKE9qcy5jYWxsIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcIkRhdGVcIikgXCJub3dcIiBbfHxdKVxuICAgIGxldCAocGFyc2UgOiBzdHJpbmcgLT4gdCkgPVxuICAgICAgZnVuICh4NTQgOiBzdHJpbmcpIC0+XG4gICAgICAgIHRfb2ZfanNcbiAgICAgICAgICAoT2pzLmNhbGwgKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwiRGF0ZVwiKSBcInBhcnNlXCJcbiAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg1NCl8XSlcbiAgICBsZXQgKGdldF9kYXRlIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biAoeDU1IDogdCkgLT4gT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDU1KSBcImdldERhdGVcIiBbfHxdKVxuICAgIGxldCAoZ2V0X2RheSA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4gKHg1NiA6IHQpIC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHg1NikgXCJnZXREYXlcIiBbfHxdKVxuICAgIGxldCAoZ2V0X2Z1bGxfeWVhciA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4gKHg1NyA6IHQpIC0+XG4gICAgICAgIE9qcy5pbnRfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHg1NykgXCJnZXRGdWxsWWVhclwiIFt8fF0pXG4gICAgbGV0IChnZXRfaG91cnMgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4NTggOiB0KSAtPiBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NTgpIFwiZ2V0SG91cnNcIiBbfHxdKVxuICAgIGxldCAoZ2V0X21pbGxpc2Vjb25kcyA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4gKHg1OSA6IHQpIC0+XG4gICAgICAgIE9qcy5pbnRfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHg1OSkgXCJnZXRNaWxsaXNlY29uZHNcIiBbfHxdKVxuICAgIGxldCAoZ2V0X21pbnV0ZXMgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4NjAgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NjApIFwiZ2V0TWludXRlc1wiIFt8fF0pXG4gICAgbGV0IChnZXRfbW9udGggOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4NjEgOiB0KSAtPiBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NjEpIFwiZ2V0TW9udGhcIiBbfHxdKVxuICAgIGxldCAoZ2V0X3NlY29uZHMgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4NjIgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NjIpIFwiZ2V0U2Vjb25kc1wiIFt8fF0pXG4gICAgbGV0IChnZXRfdGltZSA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4gKHg2MyA6IHQpIC0+IE9qcy5pbnRfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHg2MykgXCJnZXRUaW1lXCIgW3x8XSlcbiAgICBsZXQgKGdldF90aW1lem9uZV9vZmZzZXQgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4NjQgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NjQpIFwiZ2V0VGltZXpvbmVPZmZzZXRcIiBbfHxdKVxuICAgIGxldCAoZ2V0X1VUQ19kYXRlIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biAoeDY1IDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDY1KSBcImdldFVUQ0RhdGVcIiBbfHxdKVxuICAgIGxldCAoZ2V0X1VUQ19kYXkgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4NjYgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NjYpIFwiZ2V0VVRDRGF5XCIgW3x8XSlcbiAgICBsZXQgKGdldF9VVENfZnVsbF95ZWFyIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biAoeDY3IDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDY3KSBcImdldFVUQ0Z1bGxZZWFyXCIgW3x8XSlcbiAgICBsZXQgKGdldF9VVENfaG91cnMgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4NjggOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NjgpIFwiZ2V0VVRDSG91cnNcIiBbfHxdKVxuICAgIGxldCAoZ2V0X1VUQ19taWxsaXNlY29uZHMgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4NjkgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NjkpIFwiZ2V0VVRDTWlsbGlzZWNvbmRzXCIgW3x8XSlcbiAgICBsZXQgKGdldF9VVENfbWludXRlcyA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4gKHg3MCA6IHQpIC0+XG4gICAgICAgIE9qcy5pbnRfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHg3MCkgXCJnZXRVVENNaW51dGVzXCIgW3x8XSlcbiAgICBsZXQgKGdldF9VVENfbW9udGggOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4NzEgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NzEpIFwiZ2V0VVRDTW9udGhcIiBbfHxdKVxuICAgIGxldCAoZ2V0X1VUQ19zZWNvbmRzIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biAoeDcyIDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDcyKSBcImdldFVUQ1NlY29uZHNcIiBbfHxdKVxuICAgIGxldCAoZ2V0X3llYXIgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4NzMgOiB0KSAtPiBPanMuaW50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4NzMpIFwiZ2V0WWVhclwiIFt8fF0pXG4gICAgbGV0IChzZXRfZGF0ZSA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDc1IDogdCkgLT5cbiAgICAgICAgZnVuICh4NzQgOiBpbnQpIC0+XG4gICAgICAgICAgaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4NzUpIFwic2V0RGF0ZVwiIFt8KE9qcy5pbnRfdG9fanMgeDc0KXxdKVxuICAgIGxldCAoc2V0X2Z1bGxfeWVhciA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDc3IDogdCkgLT5cbiAgICAgICAgZnVuICh4NzYgOiBpbnQpIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDc3KSBcInNldEZ1bGxZZWFyXCIgW3woT2pzLmludF90b19qcyB4NzYpfF0pXG4gICAgbGV0IChzZXRfaG91cnMgOiB0IC0+IGludCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg3OSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDc4IDogaW50KSAtPlxuICAgICAgICAgIGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDc5KSBcInNldEhvdXJzXCIgW3woT2pzLmludF90b19qcyB4NzgpfF0pXG4gICAgbGV0IChzZXRfbWlsbGlzZWNvbmRzIDogdCAtPiBpbnQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4ODEgOiB0KSAtPlxuICAgICAgICBmdW4gKHg4MCA6IGludCkgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4ODEpIFwic2V0TWlsbGlzZWNvbmRzXCIgW3woT2pzLmludF90b19qcyB4ODApfF0pXG4gICAgbGV0IChzZXRfbWludXRlcyA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDgzIDogdCkgLT5cbiAgICAgICAgZnVuICh4ODIgOiBpbnQpIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDgzKSBcInNldE1pbnV0ZXNcIiBbfChPanMuaW50X3RvX2pzIHg4Mil8XSlcbiAgICBsZXQgKHNldF9tb250aCA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDg1IDogdCkgLT5cbiAgICAgICAgZnVuICh4ODQgOiBpbnQpIC0+XG4gICAgICAgICAgaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4ODUpIFwic2V0TW9udGhcIiBbfChPanMuaW50X3RvX2pzIHg4NCl8XSlcbiAgICBsZXQgKHNldF9zZWNvbmRzIDogdCAtPiBpbnQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4ODcgOiB0KSAtPlxuICAgICAgICBmdW4gKHg4NiA6IGludCkgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4ODcpIFwic2V0U2Vjb25kc1wiIFt8KE9qcy5pbnRfdG9fanMgeDg2KXxdKVxuICAgIGxldCAoc2V0X3RpbWUgOiB0IC0+IGludCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg4OSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDg4IDogaW50KSAtPlxuICAgICAgICAgIGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDg5KSBcInNldFRpbWVcIiBbfChPanMuaW50X3RvX2pzIHg4OCl8XSlcbiAgICBsZXQgKHNldF9VVENfZGF0ZSA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDkxIDogdCkgLT5cbiAgICAgICAgZnVuICh4OTAgOiBpbnQpIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDkxKSBcInNldFVUQ0RhdGVcIiBbfChPanMuaW50X3RvX2pzIHg5MCl8XSlcbiAgICBsZXQgKHNldF9VVENfZnVsbF95ZWFyIDogdCAtPiBpbnQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4OTMgOiB0KSAtPlxuICAgICAgICBmdW4gKHg5MiA6IGludCkgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4OTMpIFwic2V0VVRDRnVsbFllYXJcIiBbfChPanMuaW50X3RvX2pzIHg5Mil8XSlcbiAgICBsZXQgKHNldF9VVENfaG91cnMgOiB0IC0+IGludCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg5NSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDk0IDogaW50KSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg5NSkgXCJzZXRVVENIb3Vyc1wiIFt8KE9qcy5pbnRfdG9fanMgeDk0KXxdKVxuICAgIGxldCAoc2V0X1VUQ19taWxsaXNlY29uZHMgOiB0IC0+IGludCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg5NyA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDk2IDogaW50KSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg5NykgXCJzZXRVVENNaWxsaXNlY29uZHNcIlxuICAgICAgICAgICAgICAgW3woT2pzLmludF90b19qcyB4OTYpfF0pXG4gICAgbGV0IChzZXRfVVRDX21pbnV0ZXMgOiB0IC0+IGludCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg5OSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDk4IDogaW50KSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg5OSkgXCJzZXRVVENNaW51dGVzXCIgW3woT2pzLmludF90b19qcyB4OTgpfF0pXG4gICAgbGV0IChzZXRfVVRDX21vbnRoIDogdCAtPiBpbnQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MTAxIDogdCkgLT5cbiAgICAgICAgZnVuICh4MTAwIDogaW50KSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgxMDEpIFwic2V0VVRDTW9udGhcIiBbfChPanMuaW50X3RvX2pzIHgxMDApfF0pXG4gICAgbGV0IChzZXRfVVRDX3NlY29uZHMgOiB0IC0+IGludCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgxMDMgOiB0KSAtPlxuICAgICAgICBmdW4gKHgxMDIgOiBpbnQpIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDEwMykgXCJzZXRVVENTZWNvbmRzXCIgW3woT2pzLmludF90b19qcyB4MTAyKXxdKVxuICAgIGxldCAoc2V0X3llYXIgOiB0IC0+IGludCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgxMDUgOiB0KSAtPlxuICAgICAgICBmdW4gKHgxMDQgOiBpbnQpIC0+XG4gICAgICAgICAgaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4MTA1KSBcInNldFllYXJcIiBbfChPanMuaW50X3RvX2pzIHgxMDQpfF0pXG4gICAgbGV0ICh0b19kYXRlX3N0cmluZyA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHgxMDYgOiB0KSAtPlxuICAgICAgICBPanMuc3RyaW5nX29mX2pzIChPanMuY2FsbCAodF90b19qcyB4MTA2KSBcInRvRGF0ZVN0cmluZ1wiIFt8fF0pXG4gICAgbGV0ICh0b19HTVRfc3RyaW5nIDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biAoeDEwNyA6IHQpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHgxMDcpIFwidG9HTVRTdHJpbmdcIiBbfHxdKVxuICAgIGxldCAodG9fSVNPX3N0cmluZyA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHgxMDggOiB0KSAtPlxuICAgICAgICBPanMuc3RyaW5nX29mX2pzIChPanMuY2FsbCAodF90b19qcyB4MTA4KSBcInRvSVNPU3RyaW5nXCIgW3x8XSlcbiAgICBsZXQgKHRvX2xvY2FsZV9zdHJpbmcgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4MTA5IDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDEwOSkgXCJ0b0xvY2FsZVN0cmluZ1wiIFt8fF0pXG4gICAgbGV0ICh0b19zdHJpbmcgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4MTEwIDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDExMCkgXCJ0b1N0cmluZ1wiIFt8fF0pXG4gICAgbGV0ICh0b190aW1lX3N0cmluZyA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHgxMTEgOiB0KSAtPlxuICAgICAgICBPanMuc3RyaW5nX29mX2pzIChPanMuY2FsbCAodF90b19qcyB4MTExKSBcInRvVGltZVN0cmluZ1wiIFt8fF0pXG4gICAgbGV0ICh0b19VVENfc3RyaW5nIDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biAoeDExMiA6IHQpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHgxMTIpIFwidG9VVENTdHJpbmdcIiBbfHxdKVxuICBlbmRcbm1vZHVsZSBBcnJheUJ1ZmZlciA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IE9qcy50XG4gICAgbGV0IHJlYyB0X29mX2pzIDogT2pzLnQgLT4gdCA9IGZ1biAoeDExNCA6IE9qcy50KSAtPiB4MTE0XG4gICAgYW5kIHRfdG9fanMgOiB0IC0+IE9qcy50ID0gZnVuICh4MTEzIDogT2pzLnQpIC0+IHgxMTNcbiAgICBsZXQgKGNyZWF0ZSA6IGludCAtPiB0KSA9XG4gICAgICBmdW4gKHgxMTUgOiBpbnQpIC0+XG4gICAgICAgIHRfb2ZfanNcbiAgICAgICAgICAoT2pzLm5ld19vYmogKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwiQXJyYXlCdWZmZXJcIilcbiAgICAgICAgICAgICBbfChPanMuaW50X3RvX2pzIHgxMTUpfF0pXG4gIGVuZFxubW9kdWxlIEJsb2IgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIG9wdGlvbnMgPSBPanMudFxuICAgIGxldCByZWMgb3B0aW9uc19vZl9qcyA6IE9qcy50IC0+IG9wdGlvbnMgPSBmdW4gKHgxMTcgOiBPanMudCkgLT4geDExN1xuICAgIGFuZCBvcHRpb25zX3RvX2pzIDogb3B0aW9ucyAtPiBPanMudCA9IGZ1biAoeDExNiA6IE9qcy50KSAtPiB4MTE2XG4gICAgbGV0IChvcHRpb25zIDogP3R5cGVfOnN0cmluZyAtPiA/ZW5kaW5nczpzdHJpbmcgLT4gdW5pdCAtPiBvcHRpb25zKSA9XG4gICAgICBmdW4gP3R5cGVfOih4MTE4IDogc3RyaW5nIG9wdGlvbikgLT5cbiAgICAgICAgZnVuID9lbmRpbmdzOih4MTE5IDogc3RyaW5nIG9wdGlvbikgLT5cbiAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgIGxldCB4MTIwID0gT2pzLmVtcHR5X29iaiAoKSBpblxuICAgICAgICAgICAgKG1hdGNoIHgxMTggd2l0aFxuICAgICAgICAgICAgIHwgU29tZSB4MTIyIC0+XG4gICAgICAgICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSB4MTIwIFwidHlwZVwiIChPanMuc3RyaW5nX3RvX2pzIHgxMjIpXG4gICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgIChtYXRjaCB4MTE5IHdpdGhcbiAgICAgICAgICAgICB8IFNvbWUgeDEyMSAtPlxuICAgICAgICAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgeDEyMCBcImVuZGluZ3NcIiAoT2pzLnN0cmluZ190b19qcyB4MTIxKVxuICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICBvcHRpb25zX29mX2pzIHgxMjBcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgdF9vZl9qcyA6IE9qcy50IC0+IHQgPSBmdW4gKHgxMjQgOiBPanMudCkgLT4geDEyNFxuICAgIGFuZCB0X3RvX2pzIDogdCAtPiBPanMudCA9IGZ1biAoeDEyMyA6IE9qcy50KSAtPiB4MTIzXG4gICAgbGV0IChjcmVhdGUgOiBPanMudCBsaXN0IC0+ID9vcHRpb25zOm9wdGlvbnMgLT4gdW5pdCAtPiB0KSA9XG4gICAgICBmdW4gKHgxMjUgOiBPanMudCBsaXN0KSAtPlxuICAgICAgICBmdW4gP29wdGlvbnM6KHgxMjYgOiBvcHRpb25zIG9wdGlvbikgLT5cbiAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgIHRfb2ZfanNcbiAgICAgICAgICAgICAgKE9qcy5uZXdfb2JqX2FyciAoT2pzLmdldF9wcm9wX2FzY2lpIE9qcy5nbG9iYWwgXCJCbG9iXCIpXG4gICAgICAgICAgICAgICAgIChsZXQgeDEyNyA9XG4gICAgICAgICAgICAgICAgICAgIE9qcy5uZXdfb2JqIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcIkFycmF5XCIpIFt8fF0gaW5cbiAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAoT2pzLmNhbGwgeDEyNyBcInB1c2hcIlxuICAgICAgICAgICAgICAgICAgICAgICBbfChPanMubGlzdF90b19qcyAoZnVuICh4MTI5IDogT2pzLnQpIC0+IHgxMjkpIHgxMjUpfF0pO1xuICAgICAgICAgICAgICAgICAgKG1hdGNoIHgxMjYgd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgU29tZSB4MTI4IC0+XG4gICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZSAoT2pzLmNhbGwgeDEyNyBcInB1c2hcIiBbfChvcHRpb25zX3RvX2pzIHgxMjgpfF0pXG4gICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgIHgxMjcpKVxuICAgIGxldCAoc2l6ZSA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4gKHgxMzAgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDEzMCkgXCJzaXplXCIpXG4gICAgbGV0ICh0eXBlXyA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHgxMzEgOiB0KSAtPlxuICAgICAgICBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDEzMSkgXCJ0eXBlXCIpXG4gICAgbGV0ICh0ZXh0IDogdCAtPiB1bml0IC0+IHN0cmluZyBQcm9taXNlLnQpID1cbiAgICAgIGZ1biAoeDEzMiA6IHQpIC0+XG4gICAgICAgIGZ1biAoKSAtPlxuICAgICAgICAgIFByb21pc2UudF9vZl9qcyBPanMuc3RyaW5nX29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDEzMikgXCJ0ZXh0XCIgW3x8XSlcbiAgZW5kXG5tb2R1bGUgRmlsZSA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IEJsb2IudFxuICAgIGxldCByZWMgdF9vZl9qcyA6IE9qcy50IC0+IHQgPSBmdW4gKHgxMzUgOiBPanMudCkgLT4gQmxvYi50X29mX2pzIHgxMzVcbiAgICBhbmQgdF90b19qcyA6IHQgLT4gT2pzLnQgPSBmdW4gKHgxMzQgOiBCbG9iLnQpIC0+IEJsb2IudF90b19qcyB4MTM0XG4gICAgdHlwZSBvcHRpb25zID0gT2pzLnRcbiAgICBsZXQgcmVjIG9wdGlvbnNfb2ZfanMgOiBPanMudCAtPiBvcHRpb25zID0gZnVuICh4MTM3IDogT2pzLnQpIC0+IHgxMzdcbiAgICBhbmQgb3B0aW9uc190b19qcyA6IG9wdGlvbnMgLT4gT2pzLnQgPSBmdW4gKHgxMzYgOiBPanMudCkgLT4geDEzNlxuICAgIGxldCAob3B0aW9ucyA6ID90eXBlXzpzdHJpbmcgLT4gP2xhc3RfbW9kaWZpZWQ6ZmxvYXQgLT4gdW5pdCAtPiBvcHRpb25zKVxuICAgICAgPVxuICAgICAgZnVuID90eXBlXzooeDEzOCA6IHN0cmluZyBvcHRpb24pIC0+XG4gICAgICAgIGZ1biA/bGFzdF9tb2RpZmllZDooeDEzOSA6IGZsb2F0IG9wdGlvbikgLT5cbiAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgIGxldCB4MTQwID0gT2pzLmVtcHR5X29iaiAoKSBpblxuICAgICAgICAgICAgKG1hdGNoIHgxMzggd2l0aFxuICAgICAgICAgICAgIHwgU29tZSB4MTQyIC0+XG4gICAgICAgICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSB4MTQwIFwidHlwZVwiIChPanMuc3RyaW5nX3RvX2pzIHgxNDIpXG4gICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgIChtYXRjaCB4MTM5IHdpdGhcbiAgICAgICAgICAgICB8IFNvbWUgeDE0MSAtPlxuICAgICAgICAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgeDE0MCBcImxhc3RNb2RpZmllZFwiXG4gICAgICAgICAgICAgICAgICAgKE9qcy5mbG9hdF90b19qcyB4MTQxKVxuICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICBvcHRpb25zX29mX2pzIHgxNDBcbiAgICBsZXQgKGNyZWF0ZSA6IEJsb2IudCBhcnJheSAtPiBzdHJpbmcgLT4gb3B0aW9ucyAtPiB0KSA9XG4gICAgICBmdW4gKHgxNDMgOiBCbG9iLnQgYXJyYXkpIC0+XG4gICAgICAgIGZ1biAoeDE0NSA6IHN0cmluZykgLT5cbiAgICAgICAgICBmdW4gKHgxNDYgOiBvcHRpb25zKSAtPlxuICAgICAgICAgICAgdF9vZl9qc1xuICAgICAgICAgICAgICAoT2pzLm5ld19vYmogKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwiRmlsZVwiKVxuICAgICAgICAgICAgICAgICBbfChPanMuYXJyYXlfdG9fanMgQmxvYi50X3RvX2pzIHgxNDMpOyhPanMuc3RyaW5nX3RvX2pzIHgxNDUpOyhcbiAgICAgICAgICAgICAgICAgICBvcHRpb25zX3RvX2pzIHgxNDYpfF0pXG4gICAgbGV0IChuYW1lIDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biAoeDE0NyA6IHQpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MTQ3KSBcIm5hbWVcIilcbiAgZW5kXG5tb2R1bGUgRGF0YVRyYW5zZmVyID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjIHRfb2ZfanMgOiBPanMudCAtPiB0ID0gZnVuICh4MTQ5IDogT2pzLnQpIC0+IHgxNDlcbiAgICBhbmQgdF90b19qcyA6IHQgLT4gT2pzLnQgPSBmdW4gKHgxNDggOiBPanMudCkgLT4geDE0OFxuICAgIGxldCAoZmlsZXMgOiB0IC0+IEZpbGUudCBsaXN0KSA9XG4gICAgICBmdW4gKHgxNTAgOiB0KSAtPlxuICAgICAgICBPanMubGlzdF9vZl9qcyBGaWxlLnRfb2ZfanNcbiAgICAgICAgICAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgxNTApIFwiZmlsZXNcIilcbiAgICBsZXQgKGdldF9kYXRhIDogdCAtPiBzdHJpbmcgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHgxNTMgOiB0KSAtPlxuICAgICAgICBmdW4gKHgxNTIgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnN0cmluZ19vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgxNTMpIFwiZ2V0RGF0YVwiIFt8KE9qcy5zdHJpbmdfdG9fanMgeDE1Mil8XSlcbiAgZW5kXG5tb2R1bGUgRXZlbnQgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgdF9vZl9qcyA6IE9qcy50IC0+IHQgPSBmdW4gKHgxNTUgOiBPanMudCkgLT4geDE1NVxuICAgIGFuZCB0X3RvX2pzIDogdCAtPiBPanMudCA9IGZ1biAoeDE1NCA6IE9qcy50KSAtPiB4MTU0XG4gICAgdHlwZSBraW5kID1cbiAgICAgIHwgQWJvcnQgXG4gICAgICB8IEFmdGVycHJpbnQgXG4gICAgICB8IEFuaW1hdGlvbmVuZCBcbiAgICAgIHwgQW5pbWF0aW9uaXRlcmF0aW9uIFxuICAgICAgfCBBbmltYXRpb25zdGFydCBcbiAgICAgIHwgQXBwaW5zdGFsbGVkIFxuICAgICAgfCBBdWRpb2VuZCBcbiAgICAgIHwgQXVkaW9wcm9jZXNzIFxuICAgICAgfCBBdWRpb3N0YXJ0IFxuICAgICAgfCBCZWZvcmVwcmludCBcbiAgICAgIHwgQmVmb3JldW5sb2FkIFxuICAgICAgfCBCZWdpbkV2ZW50IFxuICAgICAgfCBCbG9ja2VkIFxuICAgICAgfCBCbHVyIFxuICAgICAgfCBCb3VuZGFyeSBcbiAgICAgIHwgQ2FjaGVkIFxuICAgICAgfCBDYW5wbGF5IFxuICAgICAgfCBDYW5wbGF5dGhyb3VnaCBcbiAgICAgIHwgQ2hhbmdlIFxuICAgICAgfCBDaGFyZ2luZ2NoYW5nZSBcbiAgICAgIHwgQ2hhcmdpbmd0aW1lY2hhbmdlIFxuICAgICAgfCBDaGVja2luZyBcbiAgICAgIHwgQ2xpY2sgXG4gICAgICB8IENsb3NlIFxuICAgICAgfCBDb21wbGV0ZSBcbiAgICAgIHwgQ29tcG9zaXRpb25lbmQgXG4gICAgICB8IENvbXBvc2l0aW9uc3RhcnQgXG4gICAgICB8IENvbXBvc2l0aW9udXBkYXRlIFxuICAgICAgfCBDb250ZXh0bWVudSBcbiAgICAgIHwgQ29weSBcbiAgICAgIHwgQ3V0IFxuICAgICAgfCBEYmxjbGljayBcbiAgICAgIHwgRGV2aWNlY2hhbmdlIFxuICAgICAgfCBEZXZpY2VsaWdodCBcbiAgICAgIHwgRGV2aWNlbW90aW9uIFxuICAgICAgfCBEZXZpY2VvcmllbnRhdGlvbiBcbiAgICAgIHwgRGV2aWNlcHJveGltaXR5IFxuICAgICAgfCBEaXNjaGFyZ2luZ3RpbWVjaGFuZ2UgXG4gICAgICB8IERPTUFjdGl2YXRlIFxuICAgICAgfCBET01BdHRyaWJ1dGVOYW1lQ2hhbmdlZCBcbiAgICAgIHwgRE9NQXR0ck1vZGlmaWVkIFxuICAgICAgfCBET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWQgXG4gICAgICB8IERPTUNvbnRlbnRMb2FkZWQgXG4gICAgICB8IERPTUVsZW1lbnROYW1lQ2hhbmdlZCBcbiAgICAgIHwgRE9NRm9jdXNJbiBcbiAgICAgIHwgRE9NRm9jdXNPdXQgXG4gICAgICB8IERPTU5vZGVJbnNlcnRlZCBcbiAgICAgIHwgRE9NTm9kZUluc2VydGVkSW50b0RvY3VtZW50IFxuICAgICAgfCBET01Ob2RlUmVtb3ZlZCBcbiAgICAgIHwgRE9NTm9kZVJlbW92ZWRGcm9tRG9jdW1lbnQgXG4gICAgICB8IERPTVN1YnRyZWVNb2RpZmllZCBcbiAgICAgIHwgRG93bmxvYWRpbmcgXG4gICAgICB8IERyYWcgXG4gICAgICB8IERyYWdlbmQgXG4gICAgICB8IERyYWdlbnRlciBcbiAgICAgIHwgRHJhZ2xlYXZlIFxuICAgICAgfCBEcmFnb3ZlciBcbiAgICAgIHwgRHJhZ3N0YXJ0IFxuICAgICAgfCBEcm9wIFxuICAgICAgfCBEdXJhdGlvbmNoYW5nZSBcbiAgICAgIHwgRW1wdGllZCBcbiAgICAgIHwgRW5kIFxuICAgICAgfCBFbmRlZCBcbiAgICAgIHwgRW5kRXZlbnQgXG4gICAgICB8IEVycm9yIFxuICAgICAgfCBGb2N1cyBcbiAgICAgIHwgRm9jdXNpbiBcbiAgICAgIHwgRm9jdXNvdXQgXG4gICAgICB8IEZ1bGxzY3JlZW5jaGFuZ2UgXG4gICAgICB8IEZ1bGxzY3JlZW5lcnJvciBcbiAgICAgIHwgR2FtZXBhZGNvbm5lY3RlZCBcbiAgICAgIHwgR2FtZXBhZGRpc2Nvbm5lY3RlZCBcbiAgICAgIHwgR290cG9pbnRlcmNhcHR1cmUgXG4gICAgICB8IEhhc2hjaGFuZ2UgXG4gICAgICB8IElucHV0IFxuICAgICAgfCBJbnZhbGlkIFxuICAgICAgfCBLZXlkb3duIFxuICAgICAgfCBLZXlwcmVzcyBcbiAgICAgIHwgS2V5dXAgXG4gICAgICB8IExhbmd1YWdlY2hhbmdlIFxuICAgICAgfCBMZXZlbGNoYW5nZSBcbiAgICAgIHwgTG9hZCBcbiAgICAgIHwgTG9hZGVkZGF0YSBcbiAgICAgIHwgTG9hZGVkbWV0YWRhdGEgXG4gICAgICB8IExvYWRlbmQgXG4gICAgICB8IExvYWRzdGFydCBcbiAgICAgIHwgTG9zdHBvaW50ZXJjYXB0dXJlIFxuICAgICAgfCBNYXJrIFxuICAgICAgfCBNZXNzYWdlIFxuICAgICAgfCBNZXNzYWdlZXJyb3IgXG4gICAgICB8IE1vdXNlZG93biBcbiAgICAgIHwgTW91c2VlbnRlciBcbiAgICAgIHwgTW91c2VsZWF2ZSBcbiAgICAgIHwgTW91c2Vtb3ZlIFxuICAgICAgfCBNb3VzZW91dCBcbiAgICAgIHwgTW91c2VvdmVyIFxuICAgICAgfCBNb3VzZXVwIFxuICAgICAgfCBOb21hdGNoIFxuICAgICAgfCBOb3RpZmljYXRpb25jbGljayBcbiAgICAgIHwgTm91cGRhdGUgXG4gICAgICB8IE9ic29sZXRlIFxuICAgICAgfCBPZmZsaW5lIFxuICAgICAgfCBPbmxpbmUgXG4gICAgICB8IE9wZW4gXG4gICAgICB8IE9yaWVudGF0aW9uY2hhbmdlIFxuICAgICAgfCBQYWdlaGlkZSBcbiAgICAgIHwgUGFnZXNob3cgXG4gICAgICB8IFBhc3RlIFxuICAgICAgfCBQYXVzZSBcbiAgICAgIHwgUGxheSBcbiAgICAgIHwgUGxheWluZyBcbiAgICAgIHwgUG9pbnRlcmNhbmNlbCBcbiAgICAgIHwgUG9pbnRlcmRvd24gXG4gICAgICB8IFBvaW50ZXJlbnRlciBcbiAgICAgIHwgUG9pbnRlcmxlYXZlIFxuICAgICAgfCBQb2ludGVybG9ja2NoYW5nZSBcbiAgICAgIHwgUG9pbnRlcmxvY2tlcnJvciBcbiAgICAgIHwgUG9pbnRlcm1vdmUgXG4gICAgICB8IFBvaW50ZXJvdXQgXG4gICAgICB8IFBvaW50ZXJvdmVyIFxuICAgICAgfCBQb2ludGVydXAgXG4gICAgICB8IFBvcHN0YXRlIFxuICAgICAgfCBQcm9ncmVzcyBcbiAgICAgIHwgUHVzaCBcbiAgICAgIHwgUHVzaHN1YnNjcmlwdGlvbmNoYW5nZSBcbiAgICAgIHwgUmF0ZWNoYW5nZSBcbiAgICAgIHwgUmVhZHlzdGF0ZWNoYW5nZSBcbiAgICAgIHwgUmVwZWF0RXZlbnQgXG4gICAgICB8IFJlc2V0IFxuICAgICAgfCBSZXNpemUgXG4gICAgICB8IFJlc291cmNldGltaW5nYnVmZmVyZnVsbCBcbiAgICAgIHwgUmVzdWx0IFxuICAgICAgfCBSZXN1bWUgXG4gICAgICB8IFNjcm9sbCBcbiAgICAgIHwgU2Vla2VkIFxuICAgICAgfCBTZWVraW5nIFxuICAgICAgfCBTZWxlY3QgXG4gICAgICB8IFNlbGVjdGlvbmNoYW5nZSBcbiAgICAgIHwgU2VsZWN0c3RhcnQgXG4gICAgICB8IFNob3cgXG4gICAgICB8IFNsb3RjaGFuZ2UgXG4gICAgICB8IFNvdW5kZW5kIFxuICAgICAgfCBTb3VuZHN0YXJ0IFxuICAgICAgfCBTcGVlY2hlbmQgXG4gICAgICB8IFNwZWVjaHN0YXJ0IFxuICAgICAgfCBTdGFsbGVkIFxuICAgICAgfCBTdGFydCBcbiAgICAgIHwgU3RvcmFnZSBcbiAgICAgIHwgU3VibWl0IFxuICAgICAgfCBTdWNjZXNzIFxuICAgICAgfCBTdXNwZW5kIFxuICAgICAgfCBTVkdBYm9ydCBcbiAgICAgIHwgU1ZHRXJyb3IgXG4gICAgICB8IFNWR0xvYWQgXG4gICAgICB8IFNWR1Jlc2l6ZSBcbiAgICAgIHwgU1ZHU2Nyb2xsIFxuICAgICAgfCBTVkdVbmxvYWQgXG4gICAgICB8IFNWR1pvb20gXG4gICAgICB8IFRpbWVvdXQgXG4gICAgICB8IFRpbWV1cGRhdGUgXG4gICAgICB8IFRvdWNoY2FuY2VsIFxuICAgICAgfCBUb3VjaGVuZCBcbiAgICAgIHwgVG91Y2htb3ZlIFxuICAgICAgfCBUb3VjaHN0YXJ0IFxuICAgICAgfCBUcmFuc2l0aW9uZW5kIFxuICAgICAgfCBVbmxvYWQgXG4gICAgICB8IFVwZGF0ZXJlYWR5IFxuICAgICAgfCBVcGdyYWRlbmVlZGVkIFxuICAgICAgfCBVc2VycHJveGltaXR5IFxuICAgICAgfCBWZXJzaW9uY2hhbmdlIFxuICAgICAgfCBWaXNpYmlsaXR5Y2hhbmdlIFxuICAgICAgfCBWb2ljZXNjaGFuZ2VkIFxuICAgICAgfCBWb2x1bWVjaGFuZ2UgXG4gICAgICB8IFdhaXRpbmcgXG4gICAgICB8IFdoZWVsIFxuICAgICAgfCBOb25TdGFuZGFyZCBvZiBzdHJpbmcgXG4gICAgbGV0IHJlYyBraW5kX29mX2pzIDogT2pzLnQgLT4ga2luZCA9XG4gICAgICBmdW4gKHgxNTggOiBPanMudCkgLT5cbiAgICAgICAgbGV0IHgxNTkgPSB4MTU4IGluXG4gICAgICAgIG1hdGNoIE9qcy5zdHJpbmdfb2ZfanMgeDE1OSB3aXRoXG4gICAgICAgIHwgXCJhYm9ydFwiIC0+IEFib3J0XG4gICAgICAgIHwgXCJhZnRlcnByaW50XCIgLT4gQWZ0ZXJwcmludFxuICAgICAgICB8IFwiYW5pbWF0aW9uZW5kXCIgLT4gQW5pbWF0aW9uZW5kXG4gICAgICAgIHwgXCJhbmltYXRpb25pdGVyYXRpb25cIiAtPiBBbmltYXRpb25pdGVyYXRpb25cbiAgICAgICAgfCBcImFuaW1hdGlvbnN0YXJ0XCIgLT4gQW5pbWF0aW9uc3RhcnRcbiAgICAgICAgfCBcImFwcGluc3RhbGxlZFwiIC0+IEFwcGluc3RhbGxlZFxuICAgICAgICB8IFwiYXVkaW9lbmRcIiAtPiBBdWRpb2VuZFxuICAgICAgICB8IFwiYXVkaW9wcm9jZXNzXCIgLT4gQXVkaW9wcm9jZXNzXG4gICAgICAgIHwgXCJhdWRpb3N0YXJ0XCIgLT4gQXVkaW9zdGFydFxuICAgICAgICB8IFwiYmVmb3JlcHJpbnRcIiAtPiBCZWZvcmVwcmludFxuICAgICAgICB8IFwiYmVmb3JldW5sb2FkXCIgLT4gQmVmb3JldW5sb2FkXG4gICAgICAgIHwgXCJiZWdpbkV2ZW50XCIgLT4gQmVnaW5FdmVudFxuICAgICAgICB8IFwiYmxvY2tlZFwiIC0+IEJsb2NrZWRcbiAgICAgICAgfCBcImJsdXJcIiAtPiBCbHVyXG4gICAgICAgIHwgXCJib3VuZGFyeVwiIC0+IEJvdW5kYXJ5XG4gICAgICAgIHwgXCJjYWNoZWRcIiAtPiBDYWNoZWRcbiAgICAgICAgfCBcImNhbnBsYXlcIiAtPiBDYW5wbGF5XG4gICAgICAgIHwgXCJjYW5wbGF5dGhyb3VnaFwiIC0+IENhbnBsYXl0aHJvdWdoXG4gICAgICAgIHwgXCJjaGFuZ2VcIiAtPiBDaGFuZ2VcbiAgICAgICAgfCBcImNoYXJnaW5nY2hhbmdlXCIgLT4gQ2hhcmdpbmdjaGFuZ2VcbiAgICAgICAgfCBcImNoYXJnaW5ndGltZWNoYW5nZVwiIC0+IENoYXJnaW5ndGltZWNoYW5nZVxuICAgICAgICB8IFwiY2hlY2tpbmdcIiAtPiBDaGVja2luZ1xuICAgICAgICB8IFwiY2xpY2tcIiAtPiBDbGlja1xuICAgICAgICB8IFwiY2xvc2VcIiAtPiBDbG9zZVxuICAgICAgICB8IFwiY29tcGxldGVcIiAtPiBDb21wbGV0ZVxuICAgICAgICB8IFwiY29tcG9zaXRpb25lbmRcIiAtPiBDb21wb3NpdGlvbmVuZFxuICAgICAgICB8IFwiY29tcG9zaXRpb25zdGFydFwiIC0+IENvbXBvc2l0aW9uc3RhcnRcbiAgICAgICAgfCBcImNvbXBvc2l0aW9udXBkYXRlXCIgLT4gQ29tcG9zaXRpb251cGRhdGVcbiAgICAgICAgfCBcImNvbnRleHRtZW51XCIgLT4gQ29udGV4dG1lbnVcbiAgICAgICAgfCBcImNvcHlcIiAtPiBDb3B5XG4gICAgICAgIHwgXCJjdXRcIiAtPiBDdXRcbiAgICAgICAgfCBcImRibGNsaWNrXCIgLT4gRGJsY2xpY2tcbiAgICAgICAgfCBcImRldmljZWNoYW5nZVwiIC0+IERldmljZWNoYW5nZVxuICAgICAgICB8IFwiZGV2aWNlbGlnaHRcIiAtPiBEZXZpY2VsaWdodFxuICAgICAgICB8IFwiZGV2aWNlbW90aW9uXCIgLT4gRGV2aWNlbW90aW9uXG4gICAgICAgIHwgXCJkZXZpY2VvcmllbnRhdGlvblwiIC0+IERldmljZW9yaWVudGF0aW9uXG4gICAgICAgIHwgXCJkZXZpY2Vwcm94aW1pdHlcIiAtPiBEZXZpY2Vwcm94aW1pdHlcbiAgICAgICAgfCBcImRpc2NoYXJnaW5ndGltZWNoYW5nZVwiIC0+IERpc2NoYXJnaW5ndGltZWNoYW5nZVxuICAgICAgICB8IFwiRE9NQWN0aXZhdGVcIiAtPiBET01BY3RpdmF0ZVxuICAgICAgICB8IFwiRE9NQXR0cmlidXRlTmFtZUNoYW5nZWRcIiAtPiBET01BdHRyaWJ1dGVOYW1lQ2hhbmdlZFxuICAgICAgICB8IFwiRE9NQXR0ck1vZGlmaWVkXCIgLT4gRE9NQXR0ck1vZGlmaWVkXG4gICAgICAgIHwgXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiAtPiBET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcbiAgICAgICAgfCBcIkRPTUNvbnRlbnRMb2FkZWRcIiAtPiBET01Db250ZW50TG9hZGVkXG4gICAgICAgIHwgXCJET01FbGVtZW50TmFtZUNoYW5nZWRcIiAtPiBET01FbGVtZW50TmFtZUNoYW5nZWRcbiAgICAgICAgfCBcIkRPTUZvY3VzSW5cIiAtPiBET01Gb2N1c0luXG4gICAgICAgIHwgXCJET01Gb2N1c091dFwiIC0+IERPTUZvY3VzT3V0XG4gICAgICAgIHwgXCJET01Ob2RlSW5zZXJ0ZWRcIiAtPiBET01Ob2RlSW5zZXJ0ZWRcbiAgICAgICAgfCBcIkRPTU5vZGVJbnNlcnRlZEludG9Eb2N1bWVudFwiIC0+IERPTU5vZGVJbnNlcnRlZEludG9Eb2N1bWVudFxuICAgICAgICB8IFwiRE9NTm9kZVJlbW92ZWRcIiAtPiBET01Ob2RlUmVtb3ZlZFxuICAgICAgICB8IFwiRE9NTm9kZVJlbW92ZWRGcm9tRG9jdW1lbnRcIiAtPiBET01Ob2RlUmVtb3ZlZEZyb21Eb2N1bWVudFxuICAgICAgICB8IFwiRE9NU3VidHJlZU1vZGlmaWVkXCIgLT4gRE9NU3VidHJlZU1vZGlmaWVkXG4gICAgICAgIHwgXCJkb3dubG9hZGluZ1wiIC0+IERvd25sb2FkaW5nXG4gICAgICAgIHwgXCJkcmFnXCIgLT4gRHJhZ1xuICAgICAgICB8IFwiZHJhZ2VuZFwiIC0+IERyYWdlbmRcbiAgICAgICAgfCBcImRyYWdlbnRlclwiIC0+IERyYWdlbnRlclxuICAgICAgICB8IFwiZHJhZ2xlYXZlXCIgLT4gRHJhZ2xlYXZlXG4gICAgICAgIHwgXCJkcmFnb3ZlclwiIC0+IERyYWdvdmVyXG4gICAgICAgIHwgXCJkcmFnc3RhcnRcIiAtPiBEcmFnc3RhcnRcbiAgICAgICAgfCBcImRyb3BcIiAtPiBEcm9wXG4gICAgICAgIHwgXCJkdXJhdGlvbmNoYW5nZVwiIC0+IER1cmF0aW9uY2hhbmdlXG4gICAgICAgIHwgXCJlbXB0aWVkXCIgLT4gRW1wdGllZFxuICAgICAgICB8IFwiZW5kXCIgLT4gRW5kXG4gICAgICAgIHwgXCJlbmRlZFwiIC0+IEVuZGVkXG4gICAgICAgIHwgXCJlbmRFdmVudFwiIC0+IEVuZEV2ZW50XG4gICAgICAgIHwgXCJlcnJvclwiIC0+IEVycm9yXG4gICAgICAgIHwgXCJmb2N1c1wiIC0+IEZvY3VzXG4gICAgICAgIHwgXCJmb2N1c2luXCIgLT4gRm9jdXNpblxuICAgICAgICB8IFwiZm9jdXNvdXRcIiAtPiBGb2N1c291dFxuICAgICAgICB8IFwiZnVsbHNjcmVlbmNoYW5nZVwiIC0+IEZ1bGxzY3JlZW5jaGFuZ2VcbiAgICAgICAgfCBcImZ1bGxzY3JlZW5lcnJvclwiIC0+IEZ1bGxzY3JlZW5lcnJvclxuICAgICAgICB8IFwiZ2FtZXBhZGNvbm5lY3RlZFwiIC0+IEdhbWVwYWRjb25uZWN0ZWRcbiAgICAgICAgfCBcImdhbWVwYWRkaXNjb25uZWN0ZWRcIiAtPiBHYW1lcGFkZGlzY29ubmVjdGVkXG4gICAgICAgIHwgXCJnb3Rwb2ludGVyY2FwdHVyZVwiIC0+IEdvdHBvaW50ZXJjYXB0dXJlXG4gICAgICAgIHwgXCJoYXNoY2hhbmdlXCIgLT4gSGFzaGNoYW5nZVxuICAgICAgICB8IFwiaW5wdXRcIiAtPiBJbnB1dFxuICAgICAgICB8IFwiaW52YWxpZFwiIC0+IEludmFsaWRcbiAgICAgICAgfCBcImtleWRvd25cIiAtPiBLZXlkb3duXG4gICAgICAgIHwgXCJrZXlwcmVzc1wiIC0+IEtleXByZXNzXG4gICAgICAgIHwgXCJrZXl1cFwiIC0+IEtleXVwXG4gICAgICAgIHwgXCJsYW5ndWFnZWNoYW5nZVwiIC0+IExhbmd1YWdlY2hhbmdlXG4gICAgICAgIHwgXCJsZXZlbGNoYW5nZVwiIC0+IExldmVsY2hhbmdlXG4gICAgICAgIHwgXCJsb2FkXCIgLT4gTG9hZFxuICAgICAgICB8IFwibG9hZGVkZGF0YVwiIC0+IExvYWRlZGRhdGFcbiAgICAgICAgfCBcImxvYWRlZG1ldGFkYXRhXCIgLT4gTG9hZGVkbWV0YWRhdGFcbiAgICAgICAgfCBcImxvYWRlbmRcIiAtPiBMb2FkZW5kXG4gICAgICAgIHwgXCJsb2Fkc3RhcnRcIiAtPiBMb2Fkc3RhcnRcbiAgICAgICAgfCBcImxvc3Rwb2ludGVyY2FwdHVyZVwiIC0+IExvc3Rwb2ludGVyY2FwdHVyZVxuICAgICAgICB8IFwibWFya1wiIC0+IE1hcmtcbiAgICAgICAgfCBcIm1lc3NhZ2VcIiAtPiBNZXNzYWdlXG4gICAgICAgIHwgXCJtZXNzYWdlZXJyb3JcIiAtPiBNZXNzYWdlZXJyb3JcbiAgICAgICAgfCBcIm1vdXNlZG93blwiIC0+IE1vdXNlZG93blxuICAgICAgICB8IFwibW91c2VlbnRlclwiIC0+IE1vdXNlZW50ZXJcbiAgICAgICAgfCBcIm1vdXNlbGVhdmVcIiAtPiBNb3VzZWxlYXZlXG4gICAgICAgIHwgXCJtb3VzZW1vdmVcIiAtPiBNb3VzZW1vdmVcbiAgICAgICAgfCBcIm1vdXNlb3V0XCIgLT4gTW91c2VvdXRcbiAgICAgICAgfCBcIm1vdXNlb3ZlclwiIC0+IE1vdXNlb3ZlclxuICAgICAgICB8IFwibW91c2V1cFwiIC0+IE1vdXNldXBcbiAgICAgICAgfCBcIm5vbWF0Y2hcIiAtPiBOb21hdGNoXG4gICAgICAgIHwgXCJub3RpZmljYXRpb25jbGlja1wiIC0+IE5vdGlmaWNhdGlvbmNsaWNrXG4gICAgICAgIHwgXCJub3VwZGF0ZVwiIC0+IE5vdXBkYXRlXG4gICAgICAgIHwgXCJvYnNvbGV0ZVwiIC0+IE9ic29sZXRlXG4gICAgICAgIHwgXCJvZmZsaW5lXCIgLT4gT2ZmbGluZVxuICAgICAgICB8IFwib25saW5lXCIgLT4gT25saW5lXG4gICAgICAgIHwgXCJvcGVuXCIgLT4gT3BlblxuICAgICAgICB8IFwib3JpZW50YXRpb25jaGFuZ2VcIiAtPiBPcmllbnRhdGlvbmNoYW5nZVxuICAgICAgICB8IFwicGFnZWhpZGVcIiAtPiBQYWdlaGlkZVxuICAgICAgICB8IFwicGFnZXNob3dcIiAtPiBQYWdlc2hvd1xuICAgICAgICB8IFwicGFzdGVcIiAtPiBQYXN0ZVxuICAgICAgICB8IFwicGF1c2VcIiAtPiBQYXVzZVxuICAgICAgICB8IFwicGxheVwiIC0+IFBsYXlcbiAgICAgICAgfCBcInBsYXlpbmdcIiAtPiBQbGF5aW5nXG4gICAgICAgIHwgXCJwb2ludGVyY2FuY2VsXCIgLT4gUG9pbnRlcmNhbmNlbFxuICAgICAgICB8IFwicG9pbnRlcmRvd25cIiAtPiBQb2ludGVyZG93blxuICAgICAgICB8IFwicG9pbnRlcmVudGVyXCIgLT4gUG9pbnRlcmVudGVyXG4gICAgICAgIHwgXCJwb2ludGVybGVhdmVcIiAtPiBQb2ludGVybGVhdmVcbiAgICAgICAgfCBcInBvaW50ZXJsb2NrY2hhbmdlXCIgLT4gUG9pbnRlcmxvY2tjaGFuZ2VcbiAgICAgICAgfCBcInBvaW50ZXJsb2NrZXJyb3JcIiAtPiBQb2ludGVybG9ja2Vycm9yXG4gICAgICAgIHwgXCJwb2ludGVybW92ZVwiIC0+IFBvaW50ZXJtb3ZlXG4gICAgICAgIHwgXCJwb2ludGVyb3V0XCIgLT4gUG9pbnRlcm91dFxuICAgICAgICB8IFwicG9pbnRlcm92ZXJcIiAtPiBQb2ludGVyb3ZlclxuICAgICAgICB8IFwicG9pbnRlcnVwXCIgLT4gUG9pbnRlcnVwXG4gICAgICAgIHwgXCJwb3BzdGF0ZVwiIC0+IFBvcHN0YXRlXG4gICAgICAgIHwgXCJwcm9ncmVzc1wiIC0+IFByb2dyZXNzXG4gICAgICAgIHwgXCJwdXNoXCIgLT4gUHVzaFxuICAgICAgICB8IFwicHVzaHN1YnNjcmlwdGlvbmNoYW5nZVwiIC0+IFB1c2hzdWJzY3JpcHRpb25jaGFuZ2VcbiAgICAgICAgfCBcInJhdGVjaGFuZ2VcIiAtPiBSYXRlY2hhbmdlXG4gICAgICAgIHwgXCJyZWFkeXN0YXRlY2hhbmdlXCIgLT4gUmVhZHlzdGF0ZWNoYW5nZVxuICAgICAgICB8IFwicmVwZWF0RXZlbnRcIiAtPiBSZXBlYXRFdmVudFxuICAgICAgICB8IFwicmVzZXRcIiAtPiBSZXNldFxuICAgICAgICB8IFwicmVzaXplXCIgLT4gUmVzaXplXG4gICAgICAgIHwgXCJyZXNvdXJjZXRpbWluZ2J1ZmZlcmZ1bGxcIiAtPiBSZXNvdXJjZXRpbWluZ2J1ZmZlcmZ1bGxcbiAgICAgICAgfCBcInJlc3VsdFwiIC0+IFJlc3VsdFxuICAgICAgICB8IFwicmVzdW1lXCIgLT4gUmVzdW1lXG4gICAgICAgIHwgXCJzY3JvbGxcIiAtPiBTY3JvbGxcbiAgICAgICAgfCBcInNlZWtlZFwiIC0+IFNlZWtlZFxuICAgICAgICB8IFwic2Vla2luZ1wiIC0+IFNlZWtpbmdcbiAgICAgICAgfCBcInNlbGVjdFwiIC0+IFNlbGVjdFxuICAgICAgICB8IFwic2VsZWN0aW9uY2hhbmdlXCIgLT4gU2VsZWN0aW9uY2hhbmdlXG4gICAgICAgIHwgXCJzZWxlY3RzdGFydFwiIC0+IFNlbGVjdHN0YXJ0XG4gICAgICAgIHwgXCJzaG93XCIgLT4gU2hvd1xuICAgICAgICB8IFwic2xvdGNoYW5nZVwiIC0+IFNsb3RjaGFuZ2VcbiAgICAgICAgfCBcInNvdW5kZW5kXCIgLT4gU291bmRlbmRcbiAgICAgICAgfCBcInNvdW5kc3RhcnRcIiAtPiBTb3VuZHN0YXJ0XG4gICAgICAgIHwgXCJzcGVlY2hlbmRcIiAtPiBTcGVlY2hlbmRcbiAgICAgICAgfCBcInNwZWVjaHN0YXJ0XCIgLT4gU3BlZWNoc3RhcnRcbiAgICAgICAgfCBcInN0YWxsZWRcIiAtPiBTdGFsbGVkXG4gICAgICAgIHwgXCJzdGFydFwiIC0+IFN0YXJ0XG4gICAgICAgIHwgXCJzdG9yYWdlXCIgLT4gU3RvcmFnZVxuICAgICAgICB8IFwic3VibWl0XCIgLT4gU3VibWl0XG4gICAgICAgIHwgXCJzdWNjZXNzXCIgLT4gU3VjY2Vzc1xuICAgICAgICB8IFwic3VzcGVuZFwiIC0+IFN1c3BlbmRcbiAgICAgICAgfCBcIlNWR0Fib3J0XCIgLT4gU1ZHQWJvcnRcbiAgICAgICAgfCBcIlNWR0Vycm9yXCIgLT4gU1ZHRXJyb3JcbiAgICAgICAgfCBcIlNWR0xvYWRcIiAtPiBTVkdMb2FkXG4gICAgICAgIHwgXCJTVkdSZXNpemVcIiAtPiBTVkdSZXNpemVcbiAgICAgICAgfCBcIlNWR1Njcm9sbFwiIC0+IFNWR1Njcm9sbFxuICAgICAgICB8IFwiU1ZHVW5sb2FkXCIgLT4gU1ZHVW5sb2FkXG4gICAgICAgIHwgXCJTVkdab29tXCIgLT4gU1ZHWm9vbVxuICAgICAgICB8IFwidGltZW91dFwiIC0+IFRpbWVvdXRcbiAgICAgICAgfCBcInRpbWV1cGRhdGVcIiAtPiBUaW1ldXBkYXRlXG4gICAgICAgIHwgXCJ0b3VjaGNhbmNlbFwiIC0+IFRvdWNoY2FuY2VsXG4gICAgICAgIHwgXCJ0b3VjaGVuZFwiIC0+IFRvdWNoZW5kXG4gICAgICAgIHwgXCJ0b3VjaG1vdmVcIiAtPiBUb3VjaG1vdmVcbiAgICAgICAgfCBcInRvdWNoc3RhcnRcIiAtPiBUb3VjaHN0YXJ0XG4gICAgICAgIHwgXCJ0cmFuc2l0aW9uZW5kXCIgLT4gVHJhbnNpdGlvbmVuZFxuICAgICAgICB8IFwidW5sb2FkXCIgLT4gVW5sb2FkXG4gICAgICAgIHwgXCJ1cGRhdGVyZWFkeVwiIC0+IFVwZGF0ZXJlYWR5XG4gICAgICAgIHwgXCJ1cGdyYWRlbmVlZGVkXCIgLT4gVXBncmFkZW5lZWRlZFxuICAgICAgICB8IFwidXNlcnByb3hpbWl0eVwiIC0+IFVzZXJwcm94aW1pdHlcbiAgICAgICAgfCBcInZlcnNpb25jaGFuZ2VcIiAtPiBWZXJzaW9uY2hhbmdlXG4gICAgICAgIHwgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIgLT4gVmlzaWJpbGl0eWNoYW5nZVxuICAgICAgICB8IFwidm9pY2VzY2hhbmdlZFwiIC0+IFZvaWNlc2NoYW5nZWRcbiAgICAgICAgfCBcInZvbHVtZWNoYW5nZVwiIC0+IFZvbHVtZWNoYW5nZVxuICAgICAgICB8IFwid2FpdGluZ1wiIC0+IFdhaXRpbmdcbiAgICAgICAgfCBcIndoZWVsXCIgLT4gV2hlZWxcbiAgICAgICAgfCB4MTYwIC0+IE5vblN0YW5kYXJkIHgxNjBcbiAgICBhbmQga2luZF90b19qcyA6IGtpbmQgLT4gT2pzLnQgPVxuICAgICAgZnVuICh4MTU2IDoga2luZCkgLT5cbiAgICAgICAgbWF0Y2ggeDE1NiB3aXRoXG4gICAgICAgIHwgQWJvcnQgLT4gT2pzLnN0cmluZ190b19qcyBcImFib3J0XCJcbiAgICAgICAgfCBBZnRlcnByaW50IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJhZnRlcnByaW50XCJcbiAgICAgICAgfCBBbmltYXRpb25lbmQgLT4gT2pzLnN0cmluZ190b19qcyBcImFuaW1hdGlvbmVuZFwiXG4gICAgICAgIHwgQW5pbWF0aW9uaXRlcmF0aW9uIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJhbmltYXRpb25pdGVyYXRpb25cIlxuICAgICAgICB8IEFuaW1hdGlvbnN0YXJ0IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJhbmltYXRpb25zdGFydFwiXG4gICAgICAgIHwgQXBwaW5zdGFsbGVkIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJhcHBpbnN0YWxsZWRcIlxuICAgICAgICB8IEF1ZGlvZW5kIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJhdWRpb2VuZFwiXG4gICAgICAgIHwgQXVkaW9wcm9jZXNzIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJhdWRpb3Byb2Nlc3NcIlxuICAgICAgICB8IEF1ZGlvc3RhcnQgLT4gT2pzLnN0cmluZ190b19qcyBcImF1ZGlvc3RhcnRcIlxuICAgICAgICB8IEJlZm9yZXByaW50IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJiZWZvcmVwcmludFwiXG4gICAgICAgIHwgQmVmb3JldW5sb2FkIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJiZWZvcmV1bmxvYWRcIlxuICAgICAgICB8IEJlZ2luRXZlbnQgLT4gT2pzLnN0cmluZ190b19qcyBcImJlZ2luRXZlbnRcIlxuICAgICAgICB8IEJsb2NrZWQgLT4gT2pzLnN0cmluZ190b19qcyBcImJsb2NrZWRcIlxuICAgICAgICB8IEJsdXIgLT4gT2pzLnN0cmluZ190b19qcyBcImJsdXJcIlxuICAgICAgICB8IEJvdW5kYXJ5IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJib3VuZGFyeVwiXG4gICAgICAgIHwgQ2FjaGVkIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJjYWNoZWRcIlxuICAgICAgICB8IENhbnBsYXkgLT4gT2pzLnN0cmluZ190b19qcyBcImNhbnBsYXlcIlxuICAgICAgICB8IENhbnBsYXl0aHJvdWdoIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJjYW5wbGF5dGhyb3VnaFwiXG4gICAgICAgIHwgQ2hhbmdlIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJjaGFuZ2VcIlxuICAgICAgICB8IENoYXJnaW5nY2hhbmdlIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJjaGFyZ2luZ2NoYW5nZVwiXG4gICAgICAgIHwgQ2hhcmdpbmd0aW1lY2hhbmdlIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJjaGFyZ2luZ3RpbWVjaGFuZ2VcIlxuICAgICAgICB8IENoZWNraW5nIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJjaGVja2luZ1wiXG4gICAgICAgIHwgQ2xpY2sgLT4gT2pzLnN0cmluZ190b19qcyBcImNsaWNrXCJcbiAgICAgICAgfCBDbG9zZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwiY2xvc2VcIlxuICAgICAgICB8IENvbXBsZXRlIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJjb21wbGV0ZVwiXG4gICAgICAgIHwgQ29tcG9zaXRpb25lbmQgLT4gT2pzLnN0cmluZ190b19qcyBcImNvbXBvc2l0aW9uZW5kXCJcbiAgICAgICAgfCBDb21wb3NpdGlvbnN0YXJ0IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJjb21wb3NpdGlvbnN0YXJ0XCJcbiAgICAgICAgfCBDb21wb3NpdGlvbnVwZGF0ZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwiY29tcG9zaXRpb251cGRhdGVcIlxuICAgICAgICB8IENvbnRleHRtZW51IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJjb250ZXh0bWVudVwiXG4gICAgICAgIHwgQ29weSAtPiBPanMuc3RyaW5nX3RvX2pzIFwiY29weVwiXG4gICAgICAgIHwgQ3V0IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJjdXRcIlxuICAgICAgICB8IERibGNsaWNrIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJkYmxjbGlja1wiXG4gICAgICAgIHwgRGV2aWNlY2hhbmdlIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJkZXZpY2VjaGFuZ2VcIlxuICAgICAgICB8IERldmljZWxpZ2h0IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJkZXZpY2VsaWdodFwiXG4gICAgICAgIHwgRGV2aWNlbW90aW9uIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJkZXZpY2Vtb3Rpb25cIlxuICAgICAgICB8IERldmljZW9yaWVudGF0aW9uIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJkZXZpY2VvcmllbnRhdGlvblwiXG4gICAgICAgIHwgRGV2aWNlcHJveGltaXR5IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJkZXZpY2Vwcm94aW1pdHlcIlxuICAgICAgICB8IERpc2NoYXJnaW5ndGltZWNoYW5nZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwiZGlzY2hhcmdpbmd0aW1lY2hhbmdlXCJcbiAgICAgICAgfCBET01BY3RpdmF0ZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwiRE9NQWN0aXZhdGVcIlxuICAgICAgICB8IERPTUF0dHJpYnV0ZU5hbWVDaGFuZ2VkIC0+XG4gICAgICAgICAgICBPanMuc3RyaW5nX3RvX2pzIFwiRE9NQXR0cmlidXRlTmFtZUNoYW5nZWRcIlxuICAgICAgICB8IERPTUF0dHJNb2RpZmllZCAtPiBPanMuc3RyaW5nX3RvX2pzIFwiRE9NQXR0ck1vZGlmaWVkXCJcbiAgICAgICAgfCBET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWQgLT5cbiAgICAgICAgICAgIE9qcy5zdHJpbmdfdG9fanMgXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIlxuICAgICAgICB8IERPTUNvbnRlbnRMb2FkZWQgLT4gT2pzLnN0cmluZ190b19qcyBcIkRPTUNvbnRlbnRMb2FkZWRcIlxuICAgICAgICB8IERPTUVsZW1lbnROYW1lQ2hhbmdlZCAtPiBPanMuc3RyaW5nX3RvX2pzIFwiRE9NRWxlbWVudE5hbWVDaGFuZ2VkXCJcbiAgICAgICAgfCBET01Gb2N1c0luIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJET01Gb2N1c0luXCJcbiAgICAgICAgfCBET01Gb2N1c091dCAtPiBPanMuc3RyaW5nX3RvX2pzIFwiRE9NRm9jdXNPdXRcIlxuICAgICAgICB8IERPTU5vZGVJbnNlcnRlZCAtPiBPanMuc3RyaW5nX3RvX2pzIFwiRE9NTm9kZUluc2VydGVkXCJcbiAgICAgICAgfCBET01Ob2RlSW5zZXJ0ZWRJbnRvRG9jdW1lbnQgLT5cbiAgICAgICAgICAgIE9qcy5zdHJpbmdfdG9fanMgXCJET01Ob2RlSW5zZXJ0ZWRJbnRvRG9jdW1lbnRcIlxuICAgICAgICB8IERPTU5vZGVSZW1vdmVkIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJET01Ob2RlUmVtb3ZlZFwiXG4gICAgICAgIHwgRE9NTm9kZVJlbW92ZWRGcm9tRG9jdW1lbnQgLT5cbiAgICAgICAgICAgIE9qcy5zdHJpbmdfdG9fanMgXCJET01Ob2RlUmVtb3ZlZEZyb21Eb2N1bWVudFwiXG4gICAgICAgIHwgRE9NU3VidHJlZU1vZGlmaWVkIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJET01TdWJ0cmVlTW9kaWZpZWRcIlxuICAgICAgICB8IERvd25sb2FkaW5nIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJkb3dubG9hZGluZ1wiXG4gICAgICAgIHwgRHJhZyAtPiBPanMuc3RyaW5nX3RvX2pzIFwiZHJhZ1wiXG4gICAgICAgIHwgRHJhZ2VuZCAtPiBPanMuc3RyaW5nX3RvX2pzIFwiZHJhZ2VuZFwiXG4gICAgICAgIHwgRHJhZ2VudGVyIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJkcmFnZW50ZXJcIlxuICAgICAgICB8IERyYWdsZWF2ZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwiZHJhZ2xlYXZlXCJcbiAgICAgICAgfCBEcmFnb3ZlciAtPiBPanMuc3RyaW5nX3RvX2pzIFwiZHJhZ292ZXJcIlxuICAgICAgICB8IERyYWdzdGFydCAtPiBPanMuc3RyaW5nX3RvX2pzIFwiZHJhZ3N0YXJ0XCJcbiAgICAgICAgfCBEcm9wIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJkcm9wXCJcbiAgICAgICAgfCBEdXJhdGlvbmNoYW5nZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwiZHVyYXRpb25jaGFuZ2VcIlxuICAgICAgICB8IEVtcHRpZWQgLT4gT2pzLnN0cmluZ190b19qcyBcImVtcHRpZWRcIlxuICAgICAgICB8IEVuZCAtPiBPanMuc3RyaW5nX3RvX2pzIFwiZW5kXCJcbiAgICAgICAgfCBFbmRlZCAtPiBPanMuc3RyaW5nX3RvX2pzIFwiZW5kZWRcIlxuICAgICAgICB8IEVuZEV2ZW50IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJlbmRFdmVudFwiXG4gICAgICAgIHwgRXJyb3IgLT4gT2pzLnN0cmluZ190b19qcyBcImVycm9yXCJcbiAgICAgICAgfCBGb2N1cyAtPiBPanMuc3RyaW5nX3RvX2pzIFwiZm9jdXNcIlxuICAgICAgICB8IEZvY3VzaW4gLT4gT2pzLnN0cmluZ190b19qcyBcImZvY3VzaW5cIlxuICAgICAgICB8IEZvY3Vzb3V0IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJmb2N1c291dFwiXG4gICAgICAgIHwgRnVsbHNjcmVlbmNoYW5nZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwiZnVsbHNjcmVlbmNoYW5nZVwiXG4gICAgICAgIHwgRnVsbHNjcmVlbmVycm9yIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJmdWxsc2NyZWVuZXJyb3JcIlxuICAgICAgICB8IEdhbWVwYWRjb25uZWN0ZWQgLT4gT2pzLnN0cmluZ190b19qcyBcImdhbWVwYWRjb25uZWN0ZWRcIlxuICAgICAgICB8IEdhbWVwYWRkaXNjb25uZWN0ZWQgLT4gT2pzLnN0cmluZ190b19qcyBcImdhbWVwYWRkaXNjb25uZWN0ZWRcIlxuICAgICAgICB8IEdvdHBvaW50ZXJjYXB0dXJlIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJnb3Rwb2ludGVyY2FwdHVyZVwiXG4gICAgICAgIHwgSGFzaGNoYW5nZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwiaGFzaGNoYW5nZVwiXG4gICAgICAgIHwgSW5wdXQgLT4gT2pzLnN0cmluZ190b19qcyBcImlucHV0XCJcbiAgICAgICAgfCBJbnZhbGlkIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJpbnZhbGlkXCJcbiAgICAgICAgfCBLZXlkb3duIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJrZXlkb3duXCJcbiAgICAgICAgfCBLZXlwcmVzcyAtPiBPanMuc3RyaW5nX3RvX2pzIFwia2V5cHJlc3NcIlxuICAgICAgICB8IEtleXVwIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJrZXl1cFwiXG4gICAgICAgIHwgTGFuZ3VhZ2VjaGFuZ2UgLT4gT2pzLnN0cmluZ190b19qcyBcImxhbmd1YWdlY2hhbmdlXCJcbiAgICAgICAgfCBMZXZlbGNoYW5nZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwibGV2ZWxjaGFuZ2VcIlxuICAgICAgICB8IExvYWQgLT4gT2pzLnN0cmluZ190b19qcyBcImxvYWRcIlxuICAgICAgICB8IExvYWRlZGRhdGEgLT4gT2pzLnN0cmluZ190b19qcyBcImxvYWRlZGRhdGFcIlxuICAgICAgICB8IExvYWRlZG1ldGFkYXRhIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJsb2FkZWRtZXRhZGF0YVwiXG4gICAgICAgIHwgTG9hZGVuZCAtPiBPanMuc3RyaW5nX3RvX2pzIFwibG9hZGVuZFwiXG4gICAgICAgIHwgTG9hZHN0YXJ0IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJsb2Fkc3RhcnRcIlxuICAgICAgICB8IExvc3Rwb2ludGVyY2FwdHVyZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwibG9zdHBvaW50ZXJjYXB0dXJlXCJcbiAgICAgICAgfCBNYXJrIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJtYXJrXCJcbiAgICAgICAgfCBNZXNzYWdlIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJtZXNzYWdlXCJcbiAgICAgICAgfCBNZXNzYWdlZXJyb3IgLT4gT2pzLnN0cmluZ190b19qcyBcIm1lc3NhZ2VlcnJvclwiXG4gICAgICAgIHwgTW91c2Vkb3duIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJtb3VzZWRvd25cIlxuICAgICAgICB8IE1vdXNlZW50ZXIgLT4gT2pzLnN0cmluZ190b19qcyBcIm1vdXNlZW50ZXJcIlxuICAgICAgICB8IE1vdXNlbGVhdmUgLT4gT2pzLnN0cmluZ190b19qcyBcIm1vdXNlbGVhdmVcIlxuICAgICAgICB8IE1vdXNlbW92ZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwibW91c2Vtb3ZlXCJcbiAgICAgICAgfCBNb3VzZW91dCAtPiBPanMuc3RyaW5nX3RvX2pzIFwibW91c2VvdXRcIlxuICAgICAgICB8IE1vdXNlb3ZlciAtPiBPanMuc3RyaW5nX3RvX2pzIFwibW91c2VvdmVyXCJcbiAgICAgICAgfCBNb3VzZXVwIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJtb3VzZXVwXCJcbiAgICAgICAgfCBOb21hdGNoIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJub21hdGNoXCJcbiAgICAgICAgfCBOb3RpZmljYXRpb25jbGljayAtPiBPanMuc3RyaW5nX3RvX2pzIFwibm90aWZpY2F0aW9uY2xpY2tcIlxuICAgICAgICB8IE5vdXBkYXRlIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJub3VwZGF0ZVwiXG4gICAgICAgIHwgT2Jzb2xldGUgLT4gT2pzLnN0cmluZ190b19qcyBcIm9ic29sZXRlXCJcbiAgICAgICAgfCBPZmZsaW5lIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJvZmZsaW5lXCJcbiAgICAgICAgfCBPbmxpbmUgLT4gT2pzLnN0cmluZ190b19qcyBcIm9ubGluZVwiXG4gICAgICAgIHwgT3BlbiAtPiBPanMuc3RyaW5nX3RvX2pzIFwib3BlblwiXG4gICAgICAgIHwgT3JpZW50YXRpb25jaGFuZ2UgLT4gT2pzLnN0cmluZ190b19qcyBcIm9yaWVudGF0aW9uY2hhbmdlXCJcbiAgICAgICAgfCBQYWdlaGlkZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwicGFnZWhpZGVcIlxuICAgICAgICB8IFBhZ2VzaG93IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJwYWdlc2hvd1wiXG4gICAgICAgIHwgUGFzdGUgLT4gT2pzLnN0cmluZ190b19qcyBcInBhc3RlXCJcbiAgICAgICAgfCBQYXVzZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwicGF1c2VcIlxuICAgICAgICB8IFBsYXkgLT4gT2pzLnN0cmluZ190b19qcyBcInBsYXlcIlxuICAgICAgICB8IFBsYXlpbmcgLT4gT2pzLnN0cmluZ190b19qcyBcInBsYXlpbmdcIlxuICAgICAgICB8IFBvaW50ZXJjYW5jZWwgLT4gT2pzLnN0cmluZ190b19qcyBcInBvaW50ZXJjYW5jZWxcIlxuICAgICAgICB8IFBvaW50ZXJkb3duIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJwb2ludGVyZG93blwiXG4gICAgICAgIHwgUG9pbnRlcmVudGVyIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJwb2ludGVyZW50ZXJcIlxuICAgICAgICB8IFBvaW50ZXJsZWF2ZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwicG9pbnRlcmxlYXZlXCJcbiAgICAgICAgfCBQb2ludGVybG9ja2NoYW5nZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwicG9pbnRlcmxvY2tjaGFuZ2VcIlxuICAgICAgICB8IFBvaW50ZXJsb2NrZXJyb3IgLT4gT2pzLnN0cmluZ190b19qcyBcInBvaW50ZXJsb2NrZXJyb3JcIlxuICAgICAgICB8IFBvaW50ZXJtb3ZlIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJwb2ludGVybW92ZVwiXG4gICAgICAgIHwgUG9pbnRlcm91dCAtPiBPanMuc3RyaW5nX3RvX2pzIFwicG9pbnRlcm91dFwiXG4gICAgICAgIHwgUG9pbnRlcm92ZXIgLT4gT2pzLnN0cmluZ190b19qcyBcInBvaW50ZXJvdmVyXCJcbiAgICAgICAgfCBQb2ludGVydXAgLT4gT2pzLnN0cmluZ190b19qcyBcInBvaW50ZXJ1cFwiXG4gICAgICAgIHwgUG9wc3RhdGUgLT4gT2pzLnN0cmluZ190b19qcyBcInBvcHN0YXRlXCJcbiAgICAgICAgfCBQcm9ncmVzcyAtPiBPanMuc3RyaW5nX3RvX2pzIFwicHJvZ3Jlc3NcIlxuICAgICAgICB8IFB1c2ggLT4gT2pzLnN0cmluZ190b19qcyBcInB1c2hcIlxuICAgICAgICB8IFB1c2hzdWJzY3JpcHRpb25jaGFuZ2UgLT4gT2pzLnN0cmluZ190b19qcyBcInB1c2hzdWJzY3JpcHRpb25jaGFuZ2VcIlxuICAgICAgICB8IFJhdGVjaGFuZ2UgLT4gT2pzLnN0cmluZ190b19qcyBcInJhdGVjaGFuZ2VcIlxuICAgICAgICB8IFJlYWR5c3RhdGVjaGFuZ2UgLT4gT2pzLnN0cmluZ190b19qcyBcInJlYWR5c3RhdGVjaGFuZ2VcIlxuICAgICAgICB8IFJlcGVhdEV2ZW50IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJyZXBlYXRFdmVudFwiXG4gICAgICAgIHwgUmVzZXQgLT4gT2pzLnN0cmluZ190b19qcyBcInJlc2V0XCJcbiAgICAgICAgfCBSZXNpemUgLT4gT2pzLnN0cmluZ190b19qcyBcInJlc2l6ZVwiXG4gICAgICAgIHwgUmVzb3VyY2V0aW1pbmdidWZmZXJmdWxsIC0+XG4gICAgICAgICAgICBPanMuc3RyaW5nX3RvX2pzIFwicmVzb3VyY2V0aW1pbmdidWZmZXJmdWxsXCJcbiAgICAgICAgfCBSZXN1bHQgLT4gT2pzLnN0cmluZ190b19qcyBcInJlc3VsdFwiXG4gICAgICAgIHwgUmVzdW1lIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJyZXN1bWVcIlxuICAgICAgICB8IFNjcm9sbCAtPiBPanMuc3RyaW5nX3RvX2pzIFwic2Nyb2xsXCJcbiAgICAgICAgfCBTZWVrZWQgLT4gT2pzLnN0cmluZ190b19qcyBcInNlZWtlZFwiXG4gICAgICAgIHwgU2Vla2luZyAtPiBPanMuc3RyaW5nX3RvX2pzIFwic2Vla2luZ1wiXG4gICAgICAgIHwgU2VsZWN0IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJzZWxlY3RcIlxuICAgICAgICB8IFNlbGVjdGlvbmNoYW5nZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwic2VsZWN0aW9uY2hhbmdlXCJcbiAgICAgICAgfCBTZWxlY3RzdGFydCAtPiBPanMuc3RyaW5nX3RvX2pzIFwic2VsZWN0c3RhcnRcIlxuICAgICAgICB8IFNob3cgLT4gT2pzLnN0cmluZ190b19qcyBcInNob3dcIlxuICAgICAgICB8IFNsb3RjaGFuZ2UgLT4gT2pzLnN0cmluZ190b19qcyBcInNsb3RjaGFuZ2VcIlxuICAgICAgICB8IFNvdW5kZW5kIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJzb3VuZGVuZFwiXG4gICAgICAgIHwgU291bmRzdGFydCAtPiBPanMuc3RyaW5nX3RvX2pzIFwic291bmRzdGFydFwiXG4gICAgICAgIHwgU3BlZWNoZW5kIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJzcGVlY2hlbmRcIlxuICAgICAgICB8IFNwZWVjaHN0YXJ0IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJzcGVlY2hzdGFydFwiXG4gICAgICAgIHwgU3RhbGxlZCAtPiBPanMuc3RyaW5nX3RvX2pzIFwic3RhbGxlZFwiXG4gICAgICAgIHwgU3RhcnQgLT4gT2pzLnN0cmluZ190b19qcyBcInN0YXJ0XCJcbiAgICAgICAgfCBTdG9yYWdlIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJzdG9yYWdlXCJcbiAgICAgICAgfCBTdWJtaXQgLT4gT2pzLnN0cmluZ190b19qcyBcInN1Ym1pdFwiXG4gICAgICAgIHwgU3VjY2VzcyAtPiBPanMuc3RyaW5nX3RvX2pzIFwic3VjY2Vzc1wiXG4gICAgICAgIHwgU3VzcGVuZCAtPiBPanMuc3RyaW5nX3RvX2pzIFwic3VzcGVuZFwiXG4gICAgICAgIHwgU1ZHQWJvcnQgLT4gT2pzLnN0cmluZ190b19qcyBcIlNWR0Fib3J0XCJcbiAgICAgICAgfCBTVkdFcnJvciAtPiBPanMuc3RyaW5nX3RvX2pzIFwiU1ZHRXJyb3JcIlxuICAgICAgICB8IFNWR0xvYWQgLT4gT2pzLnN0cmluZ190b19qcyBcIlNWR0xvYWRcIlxuICAgICAgICB8IFNWR1Jlc2l6ZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwiU1ZHUmVzaXplXCJcbiAgICAgICAgfCBTVkdTY3JvbGwgLT4gT2pzLnN0cmluZ190b19qcyBcIlNWR1Njcm9sbFwiXG4gICAgICAgIHwgU1ZHVW5sb2FkIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJTVkdVbmxvYWRcIlxuICAgICAgICB8IFNWR1pvb20gLT4gT2pzLnN0cmluZ190b19qcyBcIlNWR1pvb21cIlxuICAgICAgICB8IFRpbWVvdXQgLT4gT2pzLnN0cmluZ190b19qcyBcInRpbWVvdXRcIlxuICAgICAgICB8IFRpbWV1cGRhdGUgLT4gT2pzLnN0cmluZ190b19qcyBcInRpbWV1cGRhdGVcIlxuICAgICAgICB8IFRvdWNoY2FuY2VsIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJ0b3VjaGNhbmNlbFwiXG4gICAgICAgIHwgVG91Y2hlbmQgLT4gT2pzLnN0cmluZ190b19qcyBcInRvdWNoZW5kXCJcbiAgICAgICAgfCBUb3VjaG1vdmUgLT4gT2pzLnN0cmluZ190b19qcyBcInRvdWNobW92ZVwiXG4gICAgICAgIHwgVG91Y2hzdGFydCAtPiBPanMuc3RyaW5nX3RvX2pzIFwidG91Y2hzdGFydFwiXG4gICAgICAgIHwgVHJhbnNpdGlvbmVuZCAtPiBPanMuc3RyaW5nX3RvX2pzIFwidHJhbnNpdGlvbmVuZFwiXG4gICAgICAgIHwgVW5sb2FkIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJ1bmxvYWRcIlxuICAgICAgICB8IFVwZGF0ZXJlYWR5IC0+IE9qcy5zdHJpbmdfdG9fanMgXCJ1cGRhdGVyZWFkeVwiXG4gICAgICAgIHwgVXBncmFkZW5lZWRlZCAtPiBPanMuc3RyaW5nX3RvX2pzIFwidXBncmFkZW5lZWRlZFwiXG4gICAgICAgIHwgVXNlcnByb3hpbWl0eSAtPiBPanMuc3RyaW5nX3RvX2pzIFwidXNlcnByb3hpbWl0eVwiXG4gICAgICAgIHwgVmVyc2lvbmNoYW5nZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwidmVyc2lvbmNoYW5nZVwiXG4gICAgICAgIHwgVmlzaWJpbGl0eWNoYW5nZSAtPiBPanMuc3RyaW5nX3RvX2pzIFwidmlzaWJpbGl0eWNoYW5nZVwiXG4gICAgICAgIHwgVm9pY2VzY2hhbmdlZCAtPiBPanMuc3RyaW5nX3RvX2pzIFwidm9pY2VzY2hhbmdlZFwiXG4gICAgICAgIHwgVm9sdW1lY2hhbmdlIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJ2b2x1bWVjaGFuZ2VcIlxuICAgICAgICB8IFdhaXRpbmcgLT4gT2pzLnN0cmluZ190b19qcyBcIndhaXRpbmdcIlxuICAgICAgICB8IFdoZWVsIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJ3aGVlbFwiXG4gICAgICAgIHwgTm9uU3RhbmRhcmQgeDE1NyAtPiBPanMuc3RyaW5nX3RvX2pzIHgxNTdcbiAgICBsZXQgKHRhcmdldCA6IHQgLT4gT2pzLnQpID1cbiAgICAgIGZ1biAoeDE2MSA6IHQpIC0+IE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MTYxKSBcInRhcmdldFwiXG4gICAgbGV0IChyZWxhdGVkX3RhcmdldCA6IHQgLT4gT2pzLnQgb3B0aW9uKSA9XG4gICAgICBmdW4gKHgxNjIgOiB0KSAtPlxuICAgICAgICBPanMub3B0aW9uX29mX2pzIChmdW4gKHgxNjMgOiBPanMudCkgLT4geDE2MylcbiAgICAgICAgICAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgxNjIpIFwicmVsYXRlZFRhcmdldFwiKVxuICAgIGxldCAocHJldmVudF9kZWZhdWx0IDogdCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgxNjQgOiB0KSAtPlxuICAgICAgICBpZ25vcmUgKE9qcy5jYWxsICh0X3RvX2pzIHgxNjQpIFwicHJldmVudERlZmF1bHRcIiBbfHxdKVxuICAgIGxldCAoc3RvcF9wcm9wYWdhdGlvbiA6IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MTY1IDogdCkgLT5cbiAgICAgICAgaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4MTY1KSBcInN0b3BQcm9wYWdhdGlvblwiIFt8fF0pXG4gICAgbGV0ICh0eXBlXyA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHgxNjYgOiB0KSAtPlxuICAgICAgICBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDE2NikgXCJ0eXBlXCIpXG4gICAgbGV0IChpbml0X2V2ZW50IDogdCAtPiBraW5kIC0+IGJvb2wgLT4gYm9vbCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgxNzAgOiB0KSAtPlxuICAgICAgICBmdW4gKHgxNjcgOiBraW5kKSAtPlxuICAgICAgICAgIGZ1biAoeDE2OCA6IGJvb2wpIC0+XG4gICAgICAgICAgICBmdW4gKHgxNjkgOiBib29sKSAtPlxuICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDE3MCkgXCJpbml0RXZlbnRcIlxuICAgICAgICAgICAgICAgICAgIFt8KGtpbmRfdG9fanMgeDE2Nyk7KE9qcy5ib29sX3RvX2pzIHgxNjgpOyhPanMuYm9vbF90b19qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxNjkpfF0pXG4gICAgbGV0IChjbGllbnRfeCA6IHQgLT4gZmxvYXQpID1cbiAgICAgIGZ1biAoeDE3MSA6IHQpIC0+XG4gICAgICAgIE9qcy5mbG9hdF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgxNzEpIFwiY2xpZW50WFwiKVxuICAgIGxldCAoY2xpZW50X3kgOiB0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4gKHgxNzIgOiB0KSAtPlxuICAgICAgICBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MTcyKSBcImNsaWVudFlcIilcbiAgICBsZXQgKHBhZ2VfeCA6IHQgLT4gZmxvYXQpID1cbiAgICAgIGZ1biAoeDE3MyA6IHQpIC0+XG4gICAgICAgIE9qcy5mbG9hdF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgxNzMpIFwicGFnZVhcIilcbiAgICBsZXQgKHBhZ2VfeSA6IHQgLT4gZmxvYXQpID1cbiAgICAgIGZ1biAoeDE3NCA6IHQpIC0+XG4gICAgICAgIE9qcy5mbG9hdF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgxNzQpIFwicGFnZVlcIilcbiAgICBsZXQgKHNjcmVlbl94IDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biAoeDE3NSA6IHQpIC0+XG4gICAgICAgIE9qcy5pbnRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MTc1KSBcInNjcmVlblhcIilcbiAgICBsZXQgKHNjcmVlbl95IDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biAoeDE3NiA6IHQpIC0+XG4gICAgICAgIE9qcy5pbnRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MTc2KSBcInNjcmVlbllcIilcbiAgICBsZXQgKG1vdmVtZW50X3ggOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4MTc3IDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgxNzcpIFwibW92ZW1lbnRYXCIpXG4gICAgbGV0IChtb3ZlbWVudF95IDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biAoeDE3OCA6IHQpIC0+XG4gICAgICAgIE9qcy5pbnRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MTc4KSBcIm1vdmVtZW50WVwiKVxuICAgIGxldCAoYnV0dG9ucyA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4gKHgxNzkgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDE3OSkgXCJidXR0b25zXCIpXG4gICAgbGV0IChhbHRfa2V5IDogdCAtPiBib29sKSA9XG4gICAgICBmdW4gKHgxODAgOiB0KSAtPlxuICAgICAgICBPanMuYm9vbF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgxODApIFwiYWx0S2V5XCIpXG4gICAgbGV0IChjdHJsX2tleSA6IHQgLT4gYm9vbCkgPVxuICAgICAgZnVuICh4MTgxIDogdCkgLT5cbiAgICAgICAgT2pzLmJvb2xfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MTgxKSBcImN0cmxLZXlcIilcbiAgICBsZXQgKHNoaWZ0X2tleSA6IHQgLT4gYm9vbCkgPVxuICAgICAgZnVuICh4MTgyIDogdCkgLT5cbiAgICAgICAgT2pzLmJvb2xfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MTgyKSBcInNoaWZ0S2V5XCIpXG4gICAgbGV0ICh3aGljaCA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4gKHgxODMgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDE4MykgXCJ3aGljaFwiKVxuICAgIGxldCAoY29kZSA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHgxODQgOiB0KSAtPlxuICAgICAgICBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDE4NCkgXCJjb2RlXCIpXG4gICAgbGV0IChrZXkgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4MTg1IDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgxODUpIFwia2V5XCIpXG4gICAgbGV0IChkZWx0YV95IDogdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuICh4MTg2IDogdCkgLT5cbiAgICAgICAgT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDE4NikgXCJkZWx0YVlcIilcbiAgICBsZXQgKGRlbHRhX3ggOiB0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4gKHgxODcgOiB0KSAtPlxuICAgICAgICBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MTg3KSBcImRlbHRhWFwiKVxuICAgIGxldCAoZGF0YV90cmFuc2ZlciA6IHQgLT4gRGF0YVRyYW5zZmVyLnQpID1cbiAgICAgIGZ1biAoeDE4OCA6IHQpIC0+XG4gICAgICAgIERhdGFUcmFuc2Zlci50X29mX2pzXG4gICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MTg4KSBcImRhdGFUcmFuc2ZlclwiKVxuICAgIGxldCAoY2xpcGJvYXJkX2RhdGEgOiB0IC0+IERhdGFUcmFuc2Zlci50KSA9XG4gICAgICBmdW4gKHgxODkgOiB0KSAtPlxuICAgICAgICBEYXRhVHJhbnNmZXIudF9vZl9qc1xuICAgICAgICAgIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDE4OSkgXCJjbGlwYm9hcmREYXRhXCIpXG4gICAgbGV0IChkYXRhIDogdCAtPiBPanMudCkgPVxuICAgICAgZnVuICh4MTkwIDogdCkgLT4gT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgxOTApIFwiZGF0YVwiXG4gICAgbGV0IChvcmlnaW4gOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4MTkxIDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgxOTEpIFwib3JpZ2luXCIpXG4gICAgbGV0IChzdGF0ZSA6IHQgLT4gT2pzLnQpID1cbiAgICAgIGZ1biAoeDE5MiA6IHQpIC0+IE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MTkyKSBcInN0YXRlXCJcbiAgZW5kXG5tb2R1bGUgUmVjdCA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IE9qcy50XG4gICAgbGV0IHJlYyB0X29mX2pzIDogT2pzLnQgLT4gdCA9IGZ1biAoeDE5NCA6IE9qcy50KSAtPiB4MTk0XG4gICAgYW5kIHRfdG9fanMgOiB0IC0+IE9qcy50ID0gZnVuICh4MTkzIDogT2pzLnQpIC0+IHgxOTNcbiAgICBsZXQgKGhlaWdodCA6IHQgLT4gZmxvYXQpID1cbiAgICAgIGZ1biAoeDE5NSA6IHQpIC0+XG4gICAgICAgIE9qcy5mbG9hdF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgxOTUpIFwiaGVpZ2h0XCIpXG4gICAgbGV0ICh3aWR0aCA6IHQgLT4gZmxvYXQpID1cbiAgICAgIGZ1biAoeDE5NiA6IHQpIC0+XG4gICAgICAgIE9qcy5mbG9hdF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgxOTYpIFwid2lkdGhcIilcbiAgICBsZXQgKGxlZnQgOiB0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4gKHgxOTcgOiB0KSAtPlxuICAgICAgICBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MTk3KSBcImxlZnRcIilcbiAgICBsZXQgKHJpZ2h0IDogdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuICh4MTk4IDogdCkgLT5cbiAgICAgICAgT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDE5OCkgXCJyaWdodFwiKVxuICAgIGxldCAodG9wIDogdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuICh4MTk5IDogdCkgLT5cbiAgICAgICAgT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDE5OSkgXCJ0b3BcIilcbiAgICBsZXQgKGJvdHRvbSA6IHQgLT4gZmxvYXQpID1cbiAgICAgIGZ1biAoeDIwMCA6IHQpIC0+XG4gICAgICAgIE9qcy5mbG9hdF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgyMDApIFwiYm90dG9tXCIpXG4gIGVuZFxubW9kdWxlIFNWR1JlY3QgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgdF9vZl9qcyA6IE9qcy50IC0+IHQgPSBmdW4gKHgyMDIgOiBPanMudCkgLT4geDIwMlxuICAgIGFuZCB0X3RvX2pzIDogdCAtPiBPanMudCA9IGZ1biAoeDIwMSA6IE9qcy50KSAtPiB4MjAxXG4gICAgbGV0ICh4IDogdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuICh4MjAzIDogdCkgLT5cbiAgICAgICAgT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDIwMykgXCJ4XCIpXG4gICAgbGV0ICh5IDogdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuICh4MjA0IDogdCkgLT5cbiAgICAgICAgT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDIwNCkgXCJ5XCIpXG4gICAgbGV0IChoZWlnaHQgOiB0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4gKHgyMDUgOiB0KSAtPlxuICAgICAgICBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MjA1KSBcImhlaWdodFwiKVxuICAgIGxldCAod2lkdGggOiB0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4gKHgyMDYgOiB0KSAtPlxuICAgICAgICBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MjA2KSBcIndpZHRoXCIpXG4gIGVuZFxubW9kdWxlIFN0eWxlID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjIHRfb2ZfanMgOiBPanMudCAtPiB0ID0gZnVuICh4MjA4IDogT2pzLnQpIC0+IHgyMDhcbiAgICBhbmQgdF90b19qcyA6IHQgLT4gT2pzLnQgPSBmdW4gKHgyMDcgOiBPanMudCkgLT4geDIwN1xuICAgIGxldCBzZXQgc3R5bGUgcHJvcCB2YWx1ZSA9XG4gICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgc3R5bGUpIHByb3AgKE9qcy5zdHJpbmdfdG9fanMgdmFsdWUpXG4gICAgbGV0IChzZXRfY29sb3IgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgyMDkgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyMTAgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgyMDkpIFwiY29sb3JcIiAoT2pzLnN0cmluZ190b19qcyB4MjEwKVxuICAgIGxldCAoc2V0X2JvcmRlciA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDIxMSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDIxMiA6IHN0cmluZykgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDIxMSkgXCJib3JkZXJcIiAoT2pzLnN0cmluZ190b19qcyB4MjEyKVxuICAgIGxldCAoc2V0X2JhY2tncm91bmQgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgyMTMgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyMTQgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgyMTMpIFwiYmFja2dyb3VuZFwiXG4gICAgICAgICAgICAoT2pzLnN0cmluZ190b19qcyB4MjE0KVxuICAgIGxldCAoc2V0X2JhY2tncm91bmRfY29sb3IgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgyMTUgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyMTYgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgyMTUpIFwiYmFja2dyb3VuZENvbG9yXCJcbiAgICAgICAgICAgIChPanMuc3RyaW5nX3RvX2pzIHgyMTYpXG4gICAgbGV0IChzZXRfaGVpZ2h0IDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MjE3IDogdCkgLT5cbiAgICAgICAgZnVuICh4MjE4IDogc3RyaW5nKSAtPlxuICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MjE3KSBcImhlaWdodFwiIChPanMuc3RyaW5nX3RvX2pzIHgyMTgpXG4gICAgbGV0IChzZXRfd2lkdGggOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgyMTkgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyMjAgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgyMTkpIFwid2lkdGhcIiAoT2pzLnN0cmluZ190b19qcyB4MjIwKVxuICAgIGxldCAoc2V0X2JvdHRvbSA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDIyMSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDIyMiA6IHN0cmluZykgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDIyMSkgXCJib3R0b21cIiAoT2pzLnN0cmluZ190b19qcyB4MjIyKVxuICAgIGxldCAoc2V0X2xlZnQgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgyMjMgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyMjQgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgyMjMpIFwibGVmdFwiIChPanMuc3RyaW5nX3RvX2pzIHgyMjQpXG4gICAgbGV0IChzZXRfdG9wIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MjI1IDogdCkgLT5cbiAgICAgICAgZnVuICh4MjI2IDogc3RyaW5nKSAtPlxuICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MjI1KSBcInRvcFwiIChPanMuc3RyaW5nX3RvX2pzIHgyMjYpXG4gICAgbGV0IChzZXRfcmlnaHQgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgyMjcgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyMjggOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgyMjcpIFwicmlnaHRcIiAoT2pzLnN0cmluZ190b19qcyB4MjI4KVxuICAgIGxldCAoc2V0X3Bvc2l0aW9uIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MjI5IDogdCkgLT5cbiAgICAgICAgZnVuICh4MjMwIDogc3RyaW5nKSAtPlxuICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MjI5KSBcInBvc2l0aW9uXCJcbiAgICAgICAgICAgIChPanMuc3RyaW5nX3RvX2pzIHgyMzApXG4gICAgbGV0IChzZXRfY3Vyc29yIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MjMxIDogdCkgLT5cbiAgICAgICAgZnVuICh4MjMyIDogc3RyaW5nKSAtPlxuICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MjMxKSBcImN1cnNvclwiIChPanMuc3RyaW5nX3RvX2pzIHgyMzIpXG4gICAgbGV0IChzZXRfZGlzcGxheSA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDIzMyA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDIzNCA6IHN0cmluZykgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDIzMykgXCJkaXNwbGF5XCIgKE9qcy5zdHJpbmdfdG9fanMgeDIzNClcbiAgICBsZXQgKHNldF92aXNpYmlsaXR5IDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MjM1IDogdCkgLT5cbiAgICAgICAgZnVuICh4MjM2IDogc3RyaW5nKSAtPlxuICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MjM1KSBcInZpc2liaWxpdHlcIlxuICAgICAgICAgICAgKE9qcy5zdHJpbmdfdG9fanMgeDIzNilcbiAgICBsZXQgZ2V0IHN0eWxlIHByb3AgPVxuICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHN0eWxlKSBwcm9wKVxuICAgIGxldCB1bnNldCBzdHlsZSBwcm9wID0gT2pzLnNldF9wcm9wX2FzY2lpICh0X3RvX2pzIHN0eWxlKSBwcm9wIE9qcy5udWxsXG4gIGVuZFxubW9kdWxlIENsYXNzTGlzdCA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IE9qcy50XG4gICAgbGV0IHJlYyB0X29mX2pzIDogT2pzLnQgLT4gdCA9IGZ1biAoeDIzOCA6IE9qcy50KSAtPiB4MjM4XG4gICAgYW5kIHRfdG9fanMgOiB0IC0+IE9qcy50ID0gZnVuICh4MjM3IDogT2pzLnQpIC0+IHgyMzdcbiAgICBsZXQgKGFkZCA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDI0MCA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDIzOSA6IHN0cmluZykgLT5cbiAgICAgICAgICBpZ25vcmUgKE9qcy5jYWxsICh0X3RvX2pzIHgyNDApIFwiYWRkXCIgW3woT2pzLnN0cmluZ190b19qcyB4MjM5KXxdKVxuICAgIGxldCAocmVtb3ZlIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MjQyIDogdCkgLT5cbiAgICAgICAgZnVuICh4MjQxIDogc3RyaW5nKSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgyNDIpIFwicmVtb3ZlXCIgW3woT2pzLnN0cmluZ190b19qcyB4MjQxKXxdKVxuICAgIGxldCAoY29udGFpbnMgOiB0IC0+IHN0cmluZyAtPiBib29sKSA9XG4gICAgICBmdW4gKHgyNDQgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyNDMgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLmJvb2xfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MjQ0KSBcImNvbnRhaW5zXCIgW3woT2pzLnN0cmluZ190b19qcyB4MjQzKXxdKVxuICAgIGxldCAocmVwbGFjZSA6IHQgLT4gc3RyaW5nIC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgyNDcgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyNDUgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgZnVuICh4MjQ2IDogc3RyaW5nKSAtPlxuICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MjQ3KSBcInJlcGxhY2VcIlxuICAgICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHgyNDUpOyhPanMuc3RyaW5nX3RvX2pzIHgyNDYpfF0pXG4gICAgbGV0ICh0b2dnbGUgOiB0IC0+IHN0cmluZyAtPiBib29sIC0+IGJvb2wpID1cbiAgICAgIGZ1biAoeDI1MCA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDI0OCA6IHN0cmluZykgLT5cbiAgICAgICAgICBmdW4gKHgyNDkgOiBib29sKSAtPlxuICAgICAgICAgICAgT2pzLmJvb2xfb2ZfanNcbiAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgyNTApIFwidG9nZ2xlXCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4MjQ4KTsoT2pzLmJvb2xfdG9fanMgeDI0OSl8XSlcbiAgZW5kXG5tb2R1bGUgRWxlbWVudCA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IE9qcy50XG4gICAgbGV0IHJlYyB0X29mX2pzIDogT2pzLnQgLT4gdCA9IGZ1biAoeDI1MiA6IE9qcy50KSAtPiB4MjUyXG4gICAgYW5kIHRfdG9fanMgOiB0IC0+IE9qcy50ID0gZnVuICh4MjUxIDogT2pzLnQpIC0+IHgyNTFcbiAgICBsZXQgbnVsbCA9IHRfb2ZfanMgT2pzLm51bGxcbiAgICBsZXQgKGlkIDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biAoeDI1MyA6IHQpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MjUzKSBcImlkXCIpXG4gICAgbGV0IChzZXRfaWQgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgyNTQgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyNTUgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgyNTQpIFwiaWRcIiAoT2pzLnN0cmluZ190b19qcyB4MjU1KVxuICAgIHR5cGUgbm9kZV90eXBlID1cbiAgICAgIHwgRUxFTUVOVF9OT0RFIFxuICAgICAgfCBURVhUX05PREUgXG4gICAgICB8IFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSBcbiAgICAgIHwgQ09NTUVOVF9OT0RFIFxuICAgICAgfCBET0NVTUVOVF9OT0RFIFxuICAgICAgfCBET0NVTUVOVF9UWVBFX05PREUgXG4gICAgICB8IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgXG4gICAgbGV0IHJlYyBub2RlX3R5cGVfb2ZfanMgOiBPanMudCAtPiBub2RlX3R5cGUgPVxuICAgICAgZnVuICh4MjU3IDogT2pzLnQpIC0+XG4gICAgICAgIGxldCB4MjU4ID0geDI1NyBpblxuICAgICAgICBtYXRjaCBPanMuaW50X29mX2pzIHgyNTggd2l0aFxuICAgICAgICB8IDEgLT4gRUxFTUVOVF9OT0RFXG4gICAgICAgIHwgMyAtPiBURVhUX05PREVcbiAgICAgICAgfCA3IC0+IFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERVxuICAgICAgICB8IDggLT4gQ09NTUVOVF9OT0RFXG4gICAgICAgIHwgOSAtPiBET0NVTUVOVF9OT0RFXG4gICAgICAgIHwgMTAgLT4gRE9DVU1FTlRfVFlQRV9OT0RFXG4gICAgICAgIHwgMTEgLT4gRE9DVU1FTlRfRlJBR01FTlRfTk9ERVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgYW5kIG5vZGVfdHlwZV90b19qcyA6IG5vZGVfdHlwZSAtPiBPanMudCA9XG4gICAgICBmdW4gKHgyNTYgOiBub2RlX3R5cGUpIC0+XG4gICAgICAgIG1hdGNoIHgyNTYgd2l0aFxuICAgICAgICB8IEVMRU1FTlRfTk9ERSAtPiBPanMuaW50X3RvX2pzIDFcbiAgICAgICAgfCBURVhUX05PREUgLT4gT2pzLmludF90b19qcyAzXG4gICAgICAgIHwgUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFIC0+IE9qcy5pbnRfdG9fanMgN1xuICAgICAgICB8IENPTU1FTlRfTk9ERSAtPiBPanMuaW50X3RvX2pzIDhcbiAgICAgICAgfCBET0NVTUVOVF9OT0RFIC0+IE9qcy5pbnRfdG9fanMgOVxuICAgICAgICB8IERPQ1VNRU5UX1RZUEVfTk9ERSAtPiBPanMuaW50X3RvX2pzIDEwXG4gICAgICAgIHwgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAtPiBPanMuaW50X3RvX2pzIDExXG4gICAgbGV0IChub2RlX3R5cGUgOiB0IC0+IG5vZGVfdHlwZSkgPVxuICAgICAgZnVuICh4MjU5IDogdCkgLT5cbiAgICAgICAgbm9kZV90eXBlX29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDI1OSkgXCJub2RlVHlwZVwiKVxuICAgIGxldCAoY2xvbmVfbm9kZSA6IHQgLT4gYm9vbCAtPiB0KSA9XG4gICAgICBmdW4gKHgyNjEgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyNjAgOiBib29sKSAtPlxuICAgICAgICAgIHRfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MjYxKSBcImNsb25lTm9kZVwiIFt8KE9qcy5ib29sX3RvX2pzIHgyNjApfF0pXG4gICAgbGV0IChjb250YWlucyA6IHQgLT4gdCAtPiBib29sKSA9XG4gICAgICBmdW4gKHgyNjMgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyNjIgOiB0KSAtPlxuICAgICAgICAgIE9qcy5ib29sX29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDI2MykgXCJjb250YWluc1wiIFt8KHRfdG9fanMgeDI2Mil8XSlcbiAgICBsZXQgKGFwcGVuZF9jaGlsZCA6IHQgLT4gdCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgyNjUgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyNjQgOiB0KSAtPlxuICAgICAgICAgIGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDI2NSkgXCJhcHBlbmRDaGlsZFwiIFt8KHRfdG9fanMgeDI2NCl8XSlcbiAgICBsZXQgKGluc2VydF9iZWZvcmUgOiB0IC0+IHQgLT4gdCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgyNjggOiB0KSAtPlxuICAgICAgICBmdW4gKHgyNjYgOiB0KSAtPlxuICAgICAgICAgIGZ1biAoeDI2NyA6IHQpIC0+XG4gICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgyNjgpIFwiaW5zZXJ0QmVmb3JlXCJcbiAgICAgICAgICAgICAgICAgW3wodF90b19qcyB4MjY2KTsodF90b19qcyB4MjY3KXxdKVxuICAgIGxldCAocmVwbGFjZV9jaGlsZCA6IHQgLT4gdCAtPiB0IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDI3MSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDI2OSA6IHQpIC0+XG4gICAgICAgICAgZnVuICh4MjcwIDogdCkgLT5cbiAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDI3MSkgXCJyZXBsYWNlQ2hpbGRcIlxuICAgICAgICAgICAgICAgICBbfCh0X3RvX2pzIHgyNjkpOyh0X3RvX2pzIHgyNzApfF0pXG4gICAgbGV0IChyZW1vdmVfY2hpbGQgOiB0IC0+IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MjczIDogdCkgLT5cbiAgICAgICAgZnVuICh4MjcyIDogdCkgLT5cbiAgICAgICAgICBpZ25vcmUgKE9qcy5jYWxsICh0X3RvX2pzIHgyNzMpIFwicmVtb3ZlQ2hpbGRcIiBbfCh0X3RvX2pzIHgyNzIpfF0pXG4gICAgbGV0IChmaXJzdF9jaGlsZCA6IHQgLT4gdCkgPVxuICAgICAgZnVuICh4Mjc0IDogdCkgLT5cbiAgICAgICAgdF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgyNzQpIFwiZmlyc3RDaGlsZFwiKVxuICAgIGxldCAobGFzdF9jaGlsZCA6IHQgLT4gdCkgPVxuICAgICAgZnVuICh4Mjc1IDogdCkgLT5cbiAgICAgICAgdF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgyNzUpIFwibGFzdENoaWxkXCIpXG4gICAgbGV0IChuZXh0X3NpYmxpbmcgOiB0IC0+IHQpID1cbiAgICAgIGZ1biAoeDI3NiA6IHQpIC0+XG4gICAgICAgIHRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4Mjc2KSBcIm5leHRTaWJsaW5nXCIpXG4gICAgbGV0IHJlbW92ZV9hbGxfY2hpbGRyZW4geCA9XG4gICAgICBsZXQgcmVjIGxvb3AgY2hpbGQgPVxuICAgICAgICBpZiBjaGlsZCA9IG51bGxcbiAgICAgICAgdGhlbiAoKVxuICAgICAgICBlbHNlIChyZW1vdmVfY2hpbGQgeCBjaGlsZDsgbG9vcCAoZmlyc3RfY2hpbGQgeCkpIGluXG4gICAgICBsb29wIChmaXJzdF9jaGlsZCB4KVxuICAgIGxldCAoaGFzX2NoaWxkX25vZGVzIDogdCAtPiBib29sKSA9XG4gICAgICBmdW4gKHgyNzcgOiB0KSAtPlxuICAgICAgICBPanMuYm9vbF9vZl9qcyAoT2pzLmNhbGwgKHRfdG9fanMgeDI3NykgXCJoYXNDaGlsZE5vZGVzXCIgW3x8XSlcbiAgICBsZXQgKGFkZF9ldmVudF9saXN0ZW5lciA6XG4gICAgICB0IC0+IEV2ZW50LmtpbmQgLT4gKEV2ZW50LnQgLT4gdW5pdCkgLT4gYm9vbCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgyODIgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyNzggOiBFdmVudC5raW5kKSAtPlxuICAgICAgICAgIGZ1biAoeDI3OSA6IEV2ZW50LnQgLT4gdW5pdCkgLT5cbiAgICAgICAgICAgIGZ1biAoeDI4MSA6IGJvb2wpIC0+XG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MjgyKSBcImFkZEV2ZW50TGlzdGVuZXJcIlxuICAgICAgICAgICAgICAgICAgIFt8KEV2ZW50LmtpbmRfdG9fanMgeDI3OCk7KE9qcy5mdW5fdG9fanMgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1biAoeDI4MCA6IE9qcy50KSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDI3OSAoRXZlbnQudF9vZl9qcyB4MjgwKSkpOyhcbiAgICAgICAgICAgICAgICAgICAgIE9qcy5ib29sX3RvX2pzIHgyODEpfF0pXG4gICAgbGV0IChhZGRfZXZlbnRfbGlzdGVuZXJfaW50ZXJuYWwgOlxuICAgICAgdCAtPiBFdmVudC5raW5kIC0+IE9qcy50IC0+IGJvb2wgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4Mjg2IDogdCkgLT5cbiAgICAgICAgZnVuICh4MjgzIDogRXZlbnQua2luZCkgLT5cbiAgICAgICAgICBmdW4gKHgyODQgOiBPanMudCkgLT5cbiAgICAgICAgICAgIGZ1biAoeDI4NSA6IGJvb2wpIC0+XG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4Mjg2KSBcImFkZEV2ZW50TGlzdGVuZXJcIlxuICAgICAgICAgICAgICAgICAgIFt8KEV2ZW50LmtpbmRfdG9fanMgeDI4Myk7eDI4NDsoT2pzLmJvb2xfdG9fanMgeDI4NSl8XSlcbiAgICBsZXQgKHJlbW92ZV9ldmVudF9saXN0ZW5lcl9pbnRlcm5hbCA6XG4gICAgICB0IC0+IEV2ZW50LmtpbmQgLT4gT2pzLnQgLT4gYm9vbCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgyOTAgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyODcgOiBFdmVudC5raW5kKSAtPlxuICAgICAgICAgIGZ1biAoeDI4OCA6IE9qcy50KSAtPlxuICAgICAgICAgICAgZnVuICh4Mjg5IDogYm9vbCkgLT5cbiAgICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgyOTApIFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiXG4gICAgICAgICAgICAgICAgICAgW3woRXZlbnQua2luZF90b19qcyB4Mjg3KTt4Mjg4OyhPanMuYm9vbF90b19qcyB4Mjg5KXxdKVxuICAgIGxldCBhZGRfY2FuY2VsbGFibGVfZXZlbnRfbGlzdGVuZXIgeCBrIGYgYyA9XG4gICAgICBsZXQgZiA9IE9qcy5mdW5fdG9fanMgMSAoZnVuIHggLT4gZiAoRXZlbnQudF9vZl9qcyB4KSkgaW5cbiAgICAgIGFkZF9ldmVudF9saXN0ZW5lcl9pbnRlcm5hbCB4IGsgZiBjO1xuICAgICAgKGZ1biAoKSAtPiByZW1vdmVfZXZlbnRfbGlzdGVuZXJfaW50ZXJuYWwgeCBrIGYgYylcbiAgICBsZXQgKGlubmVyX3RleHQgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4MjkxIDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgyOTEpIFwiaW5uZXJUZXh0XCIpXG4gICAgbGV0IChnZXRfZWxlbWVudHNfYnlfdGFnX25hbWUgOiB0IC0+IHN0cmluZyAtPiB0IGFycmF5KSA9XG4gICAgICBmdW4gKHgyOTMgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyOTIgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLmFycmF5X29mX2pzIHRfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MjkzKSBcImdldEVsZW1lbnRzQnlUYWdOYW1lXCJcbiAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDI5Mil8XSlcbiAgICBsZXQgKGdldF9lbGVtZW50c19ieV9jbGFzc19uYW1lIDogdCAtPiBzdHJpbmcgLT4gdCBhcnJheSkgPVxuICAgICAgZnVuICh4Mjk2IDogdCkgLT5cbiAgICAgICAgZnVuICh4Mjk1IDogc3RyaW5nKSAtPlxuICAgICAgICAgIE9qcy5hcnJheV9vZl9qcyB0X29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDI5NikgXCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lXCJcbiAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDI5NSl8XSlcbiAgICBsZXQgKGhhc19hdHRyaWJ1dGUgOiB0IC0+IHN0cmluZyAtPiBib29sKSA9XG4gICAgICBmdW4gKHgyOTkgOiB0KSAtPlxuICAgICAgICBmdW4gKHgyOTggOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLmJvb2xfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4Mjk5KSBcImhhc0F0dHJpYnV0ZVwiXG4gICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHgyOTgpfF0pXG4gICAgbGV0IChnZXRfYXR0cmlidXRlIDogdCAtPiBzdHJpbmcgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHgzMDEgOiB0KSAtPlxuICAgICAgICBmdW4gKHgzMDAgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnN0cmluZ19vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgzMDEpIFwiZ2V0QXR0cmlidXRlXCJcbiAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDMwMCl8XSlcbiAgICBsZXQgKHJlbW92ZV9hdHRyaWJ1dGUgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgzMDMgOiB0KSAtPlxuICAgICAgICBmdW4gKHgzMDIgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDMwMykgXCJyZW1vdmVBdHRyaWJ1dGVcIlxuICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4MzAyKXxdKVxuICAgIGxldCAoc2V0X2F0dHJpYnV0ZSA6IHQgLT4gc3RyaW5nIC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgzMDYgOiB0KSAtPlxuICAgICAgICBmdW4gKHgzMDQgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgZnVuICh4MzA1IDogc3RyaW5nKSAtPlxuICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MzA2KSBcInNldEF0dHJpYnV0ZVwiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDMwNCk7KE9qcy5zdHJpbmdfdG9fanMgeDMwNSl8XSlcbiAgICBsZXQgKGdldF9ib3VuZGluZ19jbGllbnRfcmVjdCA6IHQgLT4gUmVjdC50KSA9XG4gICAgICBmdW4gKHgzMDcgOiB0KSAtPlxuICAgICAgICBSZWN0LnRfb2ZfanMgKE9qcy5jYWxsICh0X3RvX2pzIHgzMDcpIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIgW3x8XSlcbiAgICBsZXQgKGdldF9ib3VuZGluZ19ib3ggOiB0IC0+IFNWR1JlY3QudCkgPVxuICAgICAgZnVuICh4MzA4IDogdCkgLT5cbiAgICAgICAgU1ZHUmVjdC50X29mX2pzIChPanMuY2FsbCAodF90b19qcyB4MzA4KSBcImdldEJCb3hcIiBbfHxdKVxuICAgIHR5cGUgc2hhZG93X21vZGUgPVxuICAgICAgfCBPcGVuIFxuICAgICAgfCBDbG9zZWQgXG4gICAgbGV0IHJlYyBzaGFkb3dfbW9kZV9vZl9qcyA6IE9qcy50IC0+IHNoYWRvd19tb2RlID1cbiAgICAgIGZ1biAoeDMxMCA6IE9qcy50KSAtPlxuICAgICAgICBsZXQgeDMxMSA9IHgzMTAgaW5cbiAgICAgICAgbWF0Y2ggT2pzLnN0cmluZ19vZl9qcyB4MzExIHdpdGhcbiAgICAgICAgfCBcIm9wZW5cIiAtPiBPcGVuXG4gICAgICAgIHwgXCJjbG9zZWRcIiAtPiBDbG9zZWRcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgIGFuZCBzaGFkb3dfbW9kZV90b19qcyA6IHNoYWRvd19tb2RlIC0+IE9qcy50ID1cbiAgICAgIGZ1biAoeDMwOSA6IHNoYWRvd19tb2RlKSAtPlxuICAgICAgICBtYXRjaCB4MzA5IHdpdGhcbiAgICAgICAgfCBPcGVuIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJvcGVuXCJcbiAgICAgICAgfCBDbG9zZWQgLT4gT2pzLnN0cmluZ190b19qcyBcImNsb3NlZFwiXG4gICAgaW5jbHVkZVxuICAgICAgc3RydWN0XG4gICAgICAgIHR5cGUgc2hhZG93X3Jvb3RfaW5pdCA9IHtcbiAgICAgICAgICBtb2RlOiBzaGFkb3dfbW9kZSB9XG4gICAgICAgIFtAQEBvY2FtbC53YXJuaW5nIFwiLTctMzItMzlcIl1cbiAgICAgICAgbGV0IHJlYyBzaGFkb3dfcm9vdF9pbml0X29mX2pzIDogT2pzLnQgLT4gc2hhZG93X3Jvb3RfaW5pdCA9XG4gICAgICAgICAgZnVuICh4MzEzIDogT2pzLnQpIC0+XG4gICAgICAgICAgICB7IG1vZGUgPSAoc2hhZG93X21vZGVfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSB4MzEzIFwibW9kZVwiKSkgfVxuICAgICAgICBhbmQgc2hhZG93X3Jvb3RfaW5pdF90b19qcyA6IHNoYWRvd19yb290X2luaXQgLT4gT2pzLnQgPVxuICAgICAgICAgIGZ1biAoeDMxMiA6IHNoYWRvd19yb290X2luaXQpIC0+XG4gICAgICAgICAgICBPanMub2JqIFt8KFwibW9kZVwiLCAoc2hhZG93X21vZGVfdG9fanMgeDMxMi5tb2RlKSl8XVxuICAgICAgZW5kXG4gICAgbGV0IChhdHRhY2hfc2hhZG93IDogdCAtPiBzaGFkb3dfcm9vdF9pbml0IC0+IHQpID1cbiAgICAgIGZ1biAoeDMxNSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDMxNCA6IHNoYWRvd19yb290X2luaXQpIC0+XG4gICAgICAgICAgdF9vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgzMTUpIFwiYXR0YWNoU2hhZG93XCJcbiAgICAgICAgICAgICAgIFt8KHNoYWRvd19yb290X2luaXRfdG9fanMgeDMxNCl8XSlcbiAgICBsZXQgYXR0YWNoX3NoYWRvdyB+bW9kZSAgZWxlbWVudCA9IGF0dGFjaF9zaGFkb3cgZWxlbWVudCB7IG1vZGUgfVxuICAgIGxldCAobm9ybWFsaXplIDogdCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgzMTYgOiB0KSAtPiBpZ25vcmUgKE9qcy5jYWxsICh0X3RvX2pzIHgzMTYpIFwibm9ybWFsaXplXCIgW3x8XSlcbiAgICBsZXQgKHZhbHVlIDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biAoeDMxNyA6IHQpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MzE3KSBcInZhbHVlXCIpXG4gICAgbGV0IChzZXRfdmFsdWUgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgzMTggOiB0KSAtPlxuICAgICAgICBmdW4gKHgzMTkgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzMTgpIFwidmFsdWVcIiAoT2pzLnN0cmluZ190b19qcyB4MzE5KVxuICAgIGxldCAoc2VsZWN0IDogdCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgzMjAgOiB0KSAtPiBpZ25vcmUgKE9qcy5jYWxsICh0X3RvX2pzIHgzMjApIFwic2VsZWN0XCIgW3x8XSlcbiAgICBsZXQgKGZpbGVzIDogdCAtPiBGaWxlLnQgbGlzdCkgPVxuICAgICAgZnVuICh4MzIxIDogdCkgLT5cbiAgICAgICAgT2pzLmxpc3Rfb2ZfanMgRmlsZS50X29mX2pzXG4gICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MzIxKSBcImZpbGVzXCIpXG4gICAgbGV0IChzdWJtaXQgOiB0IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDMyMyA6IHQpIC0+IGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDMyMykgXCJzdWJtaXRcIiBbfHxdKVxuICAgIGxldCAoc2hvd19waWNrZXIgOiB0IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDMyNCA6IHQpIC0+IGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDMyNCkgXCJzaG93UGlja2VyXCIgW3x8XSlcbiAgICBsZXQgKHNlbGVjdGVkX2luZGV4IDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biAoeDMyNSA6IHQpIC0+XG4gICAgICAgIE9qcy5pbnRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MzI1KSBcInNlbGVjdGVkSW5kZXhcIilcbiAgICBsZXQgKGNoZWNrZWQgOiB0IC0+IGJvb2wpID1cbiAgICAgIGZ1biAoeDMyNiA6IHQpIC0+XG4gICAgICAgIE9qcy5ib29sX29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDMyNikgXCJjaGVja2VkXCIpXG4gICAgbGV0IChzZXRfY2hlY2tlZCA6IHQgLT4gYm9vbCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgzMjcgOiB0KSAtPlxuICAgICAgICBmdW4gKHgzMjggOiBib29sKSAtPlxuICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MzI3KSBcImNoZWNrZWRcIiAoT2pzLmJvb2xfdG9fanMgeDMyOClcbiAgICBsZXQgKG5vZGVfdmFsdWUgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4MzI5IDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzMjkpIFwibm9kZVZhbHVlXCIpXG4gICAgbGV0IChzZXRfbm9kZV92YWx1ZSA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDMzMCA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDMzMSA6IHN0cmluZykgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDMzMCkgXCJub2RlVmFsdWVcIlxuICAgICAgICAgICAgKE9qcy5zdHJpbmdfdG9fanMgeDMzMSlcbiAgICBsZXQgKHBhcmVudF9ub2RlIDogdCAtPiB0KSA9XG4gICAgICBmdW4gKHgzMzIgOiB0KSAtPlxuICAgICAgICB0X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDMzMikgXCJwYXJlbnROb2RlXCIpXG4gICAgbGV0IChub2RlX25hbWUgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4MzMzIDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzMzMpIFwibm9kZU5hbWVcIilcbiAgICBsZXQgKGRpc3BhdGNoX2V2ZW50IDogdCAtPiBFdmVudC50IC0+IGJvb2wpID1cbiAgICAgIGZ1biAoeDMzNSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDMzNCA6IEV2ZW50LnQpIC0+XG4gICAgICAgICAgT2pzLmJvb2xfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4MzM1KSBcImRpc3BhdGNoRXZlbnRcIiBbfChFdmVudC50X3RvX2pzIHgzMzQpfF0pXG4gICAgbGV0IChzdHlsZSA6IHQgLT4gU3R5bGUudCkgPVxuICAgICAgZnVuICh4MzM2IDogdCkgLT5cbiAgICAgICAgU3R5bGUudF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzMzYpIFwic3R5bGVcIilcbiAgICBsZXQgKGlubmVyX0hUTUwgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4MzM3IDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzMzcpIFwiaW5uZXJIVE1MXCIpXG4gICAgbGV0IChvdXRlcl9IVE1MIDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biAoeDMzOCA6IHQpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MzM4KSBcIm91dGVySFRNTFwiKVxuICAgIGxldCAoc2V0X2lubmVyX0hUTUwgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgzMzkgOiB0KSAtPlxuICAgICAgICBmdW4gKHgzNDAgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzMzkpIFwiaW5uZXJIVE1MXCJcbiAgICAgICAgICAgIChPanMuc3RyaW5nX3RvX2pzIHgzNDApXG4gICAgbGV0IChzZXRfdGV4dF9jb250ZW50IDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MzQxIDogdCkgLT5cbiAgICAgICAgZnVuICh4MzQyIDogc3RyaW5nKSAtPlxuICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MzQxKSBcInRleHRDb250ZW50XCJcbiAgICAgICAgICAgIChPanMuc3RyaW5nX3RvX2pzIHgzNDIpXG4gICAgbGV0IChzZXRfY2xhc3NfbmFtZSA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDM0MyA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDM0NCA6IHN0cmluZykgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDM0MykgXCJjbGFzc05hbWVcIlxuICAgICAgICAgICAgKE9qcy5zdHJpbmdfdG9fanMgeDM0NClcbiAgICBsZXQgKGNsYXNzX25hbWUgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4MzQ1IDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzNDUpIFwiY2xhc3NOYW1lXCIpXG4gICAgbGV0IChjbGllbnRfd2lkdGggOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4MzQ2IDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzNDYpIFwiY2xpZW50V2lkdGhcIilcbiAgICBsZXQgKGNsaWVudF9oZWlnaHQgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4MzQ3IDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzNDcpIFwiY2xpZW50SGVpZ2h0XCIpXG4gICAgbGV0IChzY3JvbGxfd2lkdGggOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4MzQ4IDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzNDgpIFwic2Nyb2xsV2lkdGhcIilcbiAgICBsZXQgKHNjcm9sbF9oZWlnaHQgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4MzQ5IDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzNDkpIFwic2Nyb2xsSGVpZ2h0XCIpXG4gICAgbGV0ICh3aWR0aCA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4gKHgzNTAgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDM1MCkgXCJ3aWR0aFwiKVxuICAgIGxldCAoaGVpZ2h0IDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biAoeDM1MSA6IHQpIC0+XG4gICAgICAgIE9qcy5pbnRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MzUxKSBcImhlaWdodFwiKVxuICAgIGxldCAob2Zmc2V0X3BhcmVudCA6IHQgLT4gdCBvcHRpb24pID1cbiAgICAgIGZ1biAoeDM1MiA6IHQpIC0+XG4gICAgICAgIE9qcy5vcHRpb25fb2ZfanMgdF9vZl9qc1xuICAgICAgICAgIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDM1MikgXCJvZmZzZXRQYXJlbnRcIilcbiAgICBsZXQgKG9mZnNldF90b3AgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4MzU0IDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzNTQpIFwib2Zmc2V0VG9wXCIpXG4gICAgbGV0IChvZmZzZXRfbGVmdCA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4gKHgzNTUgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDM1NSkgXCJvZmZzZXRMZWZ0XCIpXG4gICAgbGV0IChvZmZzZXRfd2lkdGggOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4MzU2IDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzNTYpIFwib2Zmc2V0V2lkdGhcIilcbiAgICBsZXQgKG9mZnNldF9oZWlnaHQgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4MzU3IDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzNTcpIFwib2Zmc2V0SGVpZ2h0XCIpXG4gICAgbGV0IChzY3JvbGxfdG9wIDogdCAtPiBmbG9hdCkgPVxuICAgICAgZnVuICh4MzU4IDogdCkgLT5cbiAgICAgICAgT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDM1OCkgXCJzY3JvbGxUb3BcIilcbiAgICBsZXQgKHNldF9zY3JvbGxfdG9wIDogdCAtPiBmbG9hdCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgzNTkgOiB0KSAtPlxuICAgICAgICBmdW4gKHgzNjAgOiBmbG9hdCkgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDM1OSkgXCJzY3JvbGxUb3BcIlxuICAgICAgICAgICAgKE9qcy5mbG9hdF90b19qcyB4MzYwKVxuICAgIGxldCAoc2Nyb2xsX2ludG9fdmlldyA6IHQgLT4gYm9vbCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgzNjIgOiB0KSAtPlxuICAgICAgICBmdW4gKHgzNjEgOiBib29sKSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgzNjIpIFwic2Nyb2xsSW50b1ZpZXdcIlxuICAgICAgICAgICAgICAgW3woT2pzLmJvb2xfdG9fanMgeDM2MSl8XSlcbiAgICBsZXQgKGZvY3VzIDogdCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgzNjMgOiB0KSAtPiBpZ25vcmUgKE9qcy5jYWxsICh0X3RvX2pzIHgzNjMpIFwiZm9jdXNcIiBbfHxdKVxuICAgIGxldCAoYmx1ciA6IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MzY0IDogdCkgLT4gaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4MzY0KSBcImJsdXJcIiBbfHxdKVxuICAgIHR5cGUgc2Nyb2xsX2ludG9fdmlld19vcHRpb25zID0ge1xuICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yIG9wdGlvbiB9XG4gICAgYW5kIGJlaGF2aW9yID1cbiAgICAgIHwgQXV0byBcbiAgICAgIHwgSW5zdGFudCBcbiAgICAgIHwgU21vb3RoIFxuICAgIGxldCByZWMgc2Nyb2xsX2ludG9fdmlld19vcHRpb25zX29mX2pzIDpcbiAgICAgIE9qcy50IC0+IHNjcm9sbF9pbnRvX3ZpZXdfb3B0aW9ucyA9XG4gICAgICBmdW4gKHgzNjcgOiBPanMudCkgLT5cbiAgICAgICAge1xuICAgICAgICAgIGJlaGF2aW9yID1cbiAgICAgICAgICAgIChPanMub3B0aW9uX29mX2pzIGJlaGF2aW9yX29mX2pzXG4gICAgICAgICAgICAgICAoT2pzLmdldF9wcm9wX2FzY2lpIHgzNjcgXCJiZWhhdmlvclwiKSlcbiAgICAgICAgfVxuICAgIGFuZCBzY3JvbGxfaW50b192aWV3X29wdGlvbnNfdG9fanMgOiBzY3JvbGxfaW50b192aWV3X29wdGlvbnMgLT4gT2pzLnQgPVxuICAgICAgZnVuICh4MzY1IDogc2Nyb2xsX2ludG9fdmlld19vcHRpb25zKSAtPlxuICAgICAgICBPanMub2JqXG4gICAgICAgICAgW3woXCJiZWhhdmlvclwiLCAoT2pzLm9wdGlvbl90b19qcyBiZWhhdmlvcl90b19qcyB4MzY1LmJlaGF2aW9yKSl8XVxuICAgIGFuZCBiZWhhdmlvcl9vZl9qcyA6IE9qcy50IC0+IGJlaGF2aW9yID1cbiAgICAgIGZ1biAoeDM3MCA6IE9qcy50KSAtPlxuICAgICAgICBsZXQgeDM3MSA9IHgzNzAgaW5cbiAgICAgICAgbWF0Y2ggT2pzLnN0cmluZ19vZl9qcyB4MzcxIHdpdGhcbiAgICAgICAgfCBcImF1dG9cIiAtPiBBdXRvXG4gICAgICAgIHwgXCJpbnN0YW50XCIgLT4gSW5zdGFudFxuICAgICAgICB8IFwic21vb3RoXCIgLT4gU21vb3RoXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICBhbmQgYmVoYXZpb3JfdG9fanMgOiBiZWhhdmlvciAtPiBPanMudCA9XG4gICAgICBmdW4gKHgzNjkgOiBiZWhhdmlvcikgLT5cbiAgICAgICAgbWF0Y2ggeDM2OSB3aXRoXG4gICAgICAgIHwgQXV0byAtPiBPanMuc3RyaW5nX3RvX2pzIFwiYXV0b1wiXG4gICAgICAgIHwgSW5zdGFudCAtPiBPanMuc3RyaW5nX3RvX2pzIFwiaW5zdGFudFwiXG4gICAgICAgIHwgU21vb3RoIC0+IE9qcy5zdHJpbmdfdG9fanMgXCJzbW9vdGhcIlxuICAgIGxldCAoc2Nyb2xsX2ludG9fdmlld19vcHRpb25zIDogdCAtPiBzY3JvbGxfaW50b192aWV3X29wdGlvbnMgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MzczIDogdCkgLT5cbiAgICAgICAgZnVuICh4MzcyIDogc2Nyb2xsX2ludG9fdmlld19vcHRpb25zKSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgzNzMpIFwic2Nyb2xsSW50b1ZpZXdcIlxuICAgICAgICAgICAgICAgW3woc2Nyb2xsX2ludG9fdmlld19vcHRpb25zX3RvX2pzIHgzNzIpfF0pXG4gICAgdHlwZSBzY3JvbGxfYnlfb3B0aW9ucyA9XG4gICAgICB7XG4gICAgICB0b3A6IGZsb2F0IDtcbiAgICAgIGxlZnQ6IGZsb2F0IDtcbiAgICAgIGJlaGF2aW9yOiBiZWhhdmlvciBvcHRpb24gfVxuICAgIGxldCByZWMgc2Nyb2xsX2J5X29wdGlvbnNfb2ZfanMgOiBPanMudCAtPiBzY3JvbGxfYnlfb3B0aW9ucyA9XG4gICAgICBmdW4gKHgzNzYgOiBPanMudCkgLT5cbiAgICAgICAge1xuICAgICAgICAgIHRvcCA9IChPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSB4Mzc2IFwidG9wXCIpKTtcbiAgICAgICAgICBsZWZ0ID0gKE9qcy5mbG9hdF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpIHgzNzYgXCJsZWZ0XCIpKTtcbiAgICAgICAgICBiZWhhdmlvciA9XG4gICAgICAgICAgICAoT2pzLm9wdGlvbl9vZl9qcyBiZWhhdmlvcl9vZl9qc1xuICAgICAgICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSB4Mzc2IFwiYmVoYXZpb3JcIikpXG4gICAgICAgIH1cbiAgICBhbmQgc2Nyb2xsX2J5X29wdGlvbnNfdG9fanMgOiBzY3JvbGxfYnlfb3B0aW9ucyAtPiBPanMudCA9XG4gICAgICBmdW4gKHgzNzQgOiBzY3JvbGxfYnlfb3B0aW9ucykgLT5cbiAgICAgICAgT2pzLm9ialxuICAgICAgICAgIFt8KFwidG9wXCIsIChPanMuZmxvYXRfdG9fanMgeDM3NC50b3ApKTsoXCJsZWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuZmxvYXRfdG9fanMgeDM3NC5sZWZ0KSk7XG4gICAgICAgICAgICAoXCJiZWhhdmlvclwiLCAoT2pzLm9wdGlvbl90b19qcyBiZWhhdmlvcl90b19qcyB4Mzc0LmJlaGF2aW9yKSl8XVxuICAgIGxldCAoc2Nyb2xsX2J5IDogdCAtPiBzY3JvbGxfYnlfb3B0aW9ucyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHgzNzkgOiB0KSAtPlxuICAgICAgICBmdW4gKHgzNzggOiBzY3JvbGxfYnlfb3B0aW9ucykgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4Mzc5KSBcInNjcm9sbEJ5XCJcbiAgICAgICAgICAgICAgIFt8KHNjcm9sbF9ieV9vcHRpb25zX3RvX2pzIHgzNzgpfF0pXG4gICAgbGV0IChzZWxlY3Rpb25fc3RhcnQgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4MzgwIDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzODApIFwic2VsZWN0aW9uU3RhcnRcIilcbiAgICBsZXQgKHNlbGVjdGlvbl9lbmQgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4MzgxIDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHgzODEpIFwic2VsZWN0aW9uRW5kXCIpXG4gICAgbGV0IChzZXRfc2VsZWN0aW9uX3N0YXJ0IDogdCAtPiBpbnQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4MzgyIDogdCkgLT5cbiAgICAgICAgZnVuICh4MzgzIDogaW50KSAtPlxuICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MzgyKSBcInNlbGVjdGlvblN0YXJ0XCJcbiAgICAgICAgICAgIChPanMuaW50X3RvX2pzIHgzODMpXG4gICAgbGV0IChzZXRfc2VsZWN0aW9uX2VuZCA6IHQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDM4NCA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDM4NSA6IGludCkgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDM4NCkgXCJzZWxlY3Rpb25FbmRcIlxuICAgICAgICAgICAgKE9qcy5pbnRfdG9fanMgeDM4NSlcbiAgICBsZXQgKHJlbW92ZSA6IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4Mzg2IDogdCkgLT4gaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4Mzg2KSBcInJlbW92ZVwiIFt8fF0pXG4gICAgbGV0IChjbGljayA6IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4Mzg3IDogdCkgLT4gaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4Mzg3KSBcImNsaWNrXCIgW3x8XSlcbiAgICBsZXQgKHF1ZXJ5X3NlbGVjdG9yIDogdCAtPiBzdHJpbmcgLT4gdCkgPVxuICAgICAgZnVuICh4Mzg5IDogdCkgLT5cbiAgICAgICAgZnVuICh4Mzg4IDogc3RyaW5nKSAtPlxuICAgICAgICAgIHRfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4Mzg5KSBcInF1ZXJ5U2VsZWN0b3JcIlxuICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4Mzg4KXxdKVxuICAgIGxldCAocXVlcnlfc2VsZWN0b3JfYWxsIDogdCAtPiBzdHJpbmcgLT4gdCBsaXN0KSA9XG4gICAgICBmdW4gKHgzOTEgOiB0KSAtPlxuICAgICAgICBmdW4gKHgzOTAgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLmxpc3Rfb2ZfanMgdF9vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHgzOTEpIFwicXVlcnlTZWxlY3RvckFsbFwiXG4gICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHgzOTApfF0pXG4gICAgbGV0IChjbGFzc19saXN0IDogdCAtPiBDbGFzc0xpc3QudCkgPVxuICAgICAgZnVuICh4MzkzIDogdCkgLT5cbiAgICAgICAgQ2xhc3NMaXN0LnRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4MzkzKSBcImNsYXNzTGlzdFwiKVxuICBlbmRcbm1vZHVsZSBEb2N1bWVudCA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IE9qcy50XG4gICAgbGV0IHJlYyB0X29mX2pzIDogT2pzLnQgLT4gdCA9IGZ1biAoeDM5NSA6IE9qcy50KSAtPiB4Mzk1XG4gICAgYW5kIHRfdG9fanMgOiB0IC0+IE9qcy50ID0gZnVuICh4Mzk0IDogT2pzLnQpIC0+IHgzOTRcbiAgICBsZXQgKGNyZWF0ZV9lbGVtZW50IDogdCAtPiBzdHJpbmcgLT4gRWxlbWVudC50KSA9XG4gICAgICBmdW4gKHgzOTcgOiB0KSAtPlxuICAgICAgICBmdW4gKHgzOTYgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgRWxlbWVudC50X29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDM5NykgXCJjcmVhdGVFbGVtZW50XCJcbiAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDM5Nil8XSlcbiAgICBsZXQgKGNyZWF0ZV9lbGVtZW50X25zIDogdCAtPiBzdHJpbmcgLT4gc3RyaW5nIC0+IEVsZW1lbnQudCkgPVxuICAgICAgZnVuICh4NDAwIDogdCkgLT5cbiAgICAgICAgZnVuICh4Mzk4IDogc3RyaW5nKSAtPlxuICAgICAgICAgIGZ1biAoeDM5OSA6IHN0cmluZykgLT5cbiAgICAgICAgICAgIEVsZW1lbnQudF9vZl9qc1xuICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQwMCkgXCJjcmVhdGVFbGVtZW50TlNcIlxuICAgICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHgzOTgpOyhPanMuc3RyaW5nX3RvX2pzIHgzOTkpfF0pXG4gICAgbGV0IChjcmVhdGVfdGV4dF9ub2RlIDogdCAtPiBzdHJpbmcgLT4gRWxlbWVudC50KSA9XG4gICAgICBmdW4gKHg0MDIgOiB0KSAtPlxuICAgICAgICBmdW4gKHg0MDEgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgRWxlbWVudC50X29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQwMikgXCJjcmVhdGVUZXh0Tm9kZVwiXG4gICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg0MDEpfF0pXG4gICAgbGV0IChjcmVhdGVfZXZlbnQgOiB0IC0+IHN0cmluZyAtPiBFdmVudC50KSA9XG4gICAgICBmdW4gKHg0MDQgOiB0KSAtPlxuICAgICAgICBmdW4gKHg0MDMgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgRXZlbnQudF9vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg0MDQpIFwiY3JlYXRlRXZlbnRcIlxuICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NDAzKXxdKVxuICAgIGxldCAoZ2V0X2VsZW1lbnRfYnlfaWQgOiB0IC0+IHN0cmluZyAtPiBFbGVtZW50LnQgb3B0aW9uKSA9XG4gICAgICBmdW4gKHg0MDYgOiB0KSAtPlxuICAgICAgICBmdW4gKHg0MDUgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLm9wdGlvbl9vZl9qcyBFbGVtZW50LnRfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NDA2KSBcImdldEVsZW1lbnRCeUlkXCJcbiAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDQwNSl8XSlcbiAgICBsZXQgKGdldF9lbGVtZW50c19ieV9jbGFzc19uYW1lIDogdCAtPiBzdHJpbmcgLT4gRWxlbWVudC50IGFycmF5KSA9XG4gICAgICBmdW4gKHg0MDkgOiB0KSAtPlxuICAgICAgICBmdW4gKHg0MDggOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLmFycmF5X29mX2pzIEVsZW1lbnQudF9vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg0MDkpIFwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZVwiXG4gICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg0MDgpfF0pXG4gICAgbGV0IChib2R5IDogdCAtPiBFbGVtZW50LnQpID1cbiAgICAgIGZ1biAoeDQxMSA6IHQpIC0+XG4gICAgICAgIEVsZW1lbnQudF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg0MTEpIFwiYm9keVwiKVxuICAgIGxldCAoZG9jdW1lbnRfZWxlbWVudCA6IHQgLT4gRWxlbWVudC50KSA9XG4gICAgICBmdW4gKHg0MTIgOiB0KSAtPlxuICAgICAgICBFbGVtZW50LnRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NDEyKSBcImRvY3VtZW50RWxlbWVudFwiKVxuICAgIGxldCAoYWN0aXZlX2VsZW1lbnQgOiB0IC0+IEVsZW1lbnQudCkgPVxuICAgICAgZnVuICh4NDEzIDogdCkgLT5cbiAgICAgICAgRWxlbWVudC50X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDQxMykgXCJhY3RpdmVFbGVtZW50XCIpXG4gICAgbGV0IChjb29raWUgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4NDE0IDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg0MTQpIFwiY29va2llXCIpXG4gICAgbGV0IChzZXRfY29va2llIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NDE1IDogdCkgLT5cbiAgICAgICAgZnVuICh4NDE2IDogc3RyaW5nKSAtPlxuICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NDE1KSBcImNvb2tpZVwiIChPanMuc3RyaW5nX3RvX2pzIHg0MTYpXG4gICAgbGV0IChzZXRfdGl0bGUgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg0MTcgOiB0KSAtPlxuICAgICAgICBmdW4gKHg0MTggOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg0MTcpIFwidGl0bGVcIiAoT2pzLnN0cmluZ190b19qcyB4NDE4KVxuICAgIGxldCAob3Blbl8gOlxuICAgICAgdCAtPiA/bWltZV90eXBlOnN0cmluZyAtPiA/aGlzdG9yeV9tb2RlOnN0cmluZyAtPiB1bml0IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDQyNCA6IHQpIC0+XG4gICAgICAgIGZ1biA/bWltZV90eXBlOih4NDE5IDogc3RyaW5nIG9wdGlvbikgLT5cbiAgICAgICAgICBmdW4gP2hpc3RvcnlfbW9kZTooeDQyMCA6IHN0cmluZyBvcHRpb24pIC0+XG4gICAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgICAgKGxldCB4NDI1ID0gdF90b19qcyB4NDI0IGluXG4gICAgICAgICAgICAgICAgIE9qcy5jYWxsIChPanMuZ2V0X3Byb3BfYXNjaWkgeDQyNSBcIm9wZW5cIikgXCJhcHBseVwiXG4gICAgICAgICAgICAgICAgICAgW3x4NDI1OygobGV0IHg0MjEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2pzLm5ld19vYmpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwiQXJyYXlcIikgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt8fF0gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2ggeDQxOSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU29tZSB4NDIzIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIHg0MjEgXCJwdXNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NDIzKXxdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXRjaCB4NDIwIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTb21lIHg0MjIgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoT2pzLmNhbGwgeDQyMSBcInB1c2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg0MjIpfF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDQyMSkpfF0pXG4gICAgbGV0ICh3cml0ZSA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDQyNyA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDQyNiA6IHN0cmluZykgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NDI3KSBcIndyaXRlXCIgW3woT2pzLnN0cmluZ190b19qcyB4NDI2KXxdKVxuICAgIGxldCAod3JpdGVsbiA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDQyOSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDQyOCA6IHN0cmluZykgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NDI5KSBcIndyaXRlbG5cIiBbfChPanMuc3RyaW5nX3RvX2pzIHg0MjgpfF0pXG4gICAgbGV0IChjbG9zZSA6IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NDMwIDogdCkgLT4gaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4NDMwKSBcImNsb3NlXCIgW3x8XSlcbiAgICBsZXQgKGV4ZWNfY29tbWFuZCA6IHQgLT4gc3RyaW5nIC0+IGJvb2wpID1cbiAgICAgIGZ1biAoeDQzMiA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDQzMSA6IHN0cmluZykgLT5cbiAgICAgICAgICBPanMuYm9vbF9vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg0MzIpIFwiZXhlY0NvbW1hbmRcIlxuICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NDMxKXxdKVxuICAgIGxldCAocXVlcnlfc2VsZWN0b3IgOiB0IC0+IHN0cmluZyAtPiBFbGVtZW50LnQpID1cbiAgICAgIGZ1biAoeDQzNCA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDQzMyA6IHN0cmluZykgLT5cbiAgICAgICAgICBFbGVtZW50LnRfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NDM0KSBcInF1ZXJ5U2VsZWN0b3JcIlxuICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NDMzKXxdKVxuICAgIGxldCAocXVlcnlfc2VsZWN0b3JfYWxsIDogdCAtPiBzdHJpbmcgLT4gRWxlbWVudC50IGxpc3QpID1cbiAgICAgIGZ1biAoeDQzNiA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDQzNSA6IHN0cmluZykgLT5cbiAgICAgICAgICBPanMubGlzdF9vZl9qcyBFbGVtZW50LnRfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NDM2KSBcInF1ZXJ5U2VsZWN0b3JBbGxcIlxuICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NDM1KXxdKVxuICAgIGxldCAocmVtb3ZlX2FsbF9zZWxlY3Rpb25fcmFuZ2VzIDogdCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg0MzggOiB0KSAtPlxuICAgICAgICBpZ25vcmVcbiAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQzOCkgXCJnZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXNcIiBbfHxdKVxuICBlbmRcbm1vZHVsZSBIaXN0b3J5ID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjIHRfb2ZfanMgOiBPanMudCAtPiB0ID0gZnVuICh4NDQwIDogT2pzLnQpIC0+IHg0NDBcbiAgICBhbmQgdF90b19qcyA6IHQgLT4gT2pzLnQgPSBmdW4gKHg0MzkgOiBPanMudCkgLT4geDQzOVxuICAgIGxldCAobGVuZ3RoIDogdCAtPiBpbnQpID1cbiAgICAgIGZ1biAoeDQ0MSA6IHQpIC0+XG4gICAgICAgIE9qcy5pbnRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NDQxKSBcImxlbmd0aFwiKVxuICAgIGxldCAoYmFjayA6IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NDQyIDogdCkgLT4gaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4NDQyKSBcImJhY2tcIiBbfHxdKVxuICAgIGxldCAoZm9yd2FyZCA6IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NDQzIDogdCkgLT4gaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4NDQzKSBcImZvcndhcmRcIiBbfHxdKVxuICAgIGxldCAoZ28gOiB0IC0+IFsgYE9mZnNldCBvZiBpbnQgIHwgYFVybCBvZiBzdHJpbmcgXSAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg0NDcgOiB0KSAtPlxuICAgICAgICBmdW4gKHg0NDQgOiBbIGBPZmZzZXQgb2YgaW50ICB8IGBVcmwgb2Ygc3RyaW5nIF0pIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQ0NykgXCJnb1wiXG4gICAgICAgICAgICAgICBbfCgobWF0Y2ggeDQ0NCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBgT2Zmc2V0IHg0NDUgLT4gT2pzLmludF90b19qcyB4NDQ1XG4gICAgICAgICAgICAgICAgICAgfCBgVXJsIHg0NDYgLT4gT2pzLnN0cmluZ190b19qcyB4NDQ2KSl8XSlcbiAgICBsZXQgKHJlcGxhY2Vfc3RhdGUgOiB0IC0+IE9qcy50IC0+IHN0cmluZyAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NDUxIDogdCkgLT5cbiAgICAgICAgZnVuICh4NDQ4IDogT2pzLnQpIC0+XG4gICAgICAgICAgZnVuICh4NDQ5IDogc3RyaW5nKSAtPlxuICAgICAgICAgICAgZnVuICh4NDUwIDogc3RyaW5nKSAtPlxuICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQ1MSkgXCJyZXBsYWNlU3RhdGVcIlxuICAgICAgICAgICAgICAgICAgIFt8eDQ0ODsoT2pzLnN0cmluZ190b19qcyB4NDQ5KTsoT2pzLnN0cmluZ190b19qcyB4NDUwKXxdKVxuICAgIGxldCAocHVzaF9zdGF0ZSA6IHQgLT4gT2pzLnQgLT4gc3RyaW5nIC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg0NTUgOiB0KSAtPlxuICAgICAgICBmdW4gKHg0NTIgOiBPanMudCkgLT5cbiAgICAgICAgICBmdW4gKHg0NTMgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgICBmdW4gKHg0NTQgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NDU1KSBcInB1c2hTdGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgW3x4NDUyOyhPanMuc3RyaW5nX3RvX2pzIHg0NTMpOyhPanMuc3RyaW5nX3RvX2pzIHg0NTQpfF0pXG4gIGVuZFxubW9kdWxlIExvY2F0aW9uID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjIHRfb2ZfanMgOiBPanMudCAtPiB0ID0gZnVuICh4NDU3IDogT2pzLnQpIC0+IHg0NTdcbiAgICBhbmQgdF90b19qcyA6IHQgLT4gT2pzLnQgPSBmdW4gKHg0NTYgOiBPanMudCkgLT4geDQ1NlxuICAgIGxldCAoZ2V0X2hhc2ggOiB1bml0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICgpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanNcbiAgICAgICAgICAoT2pzLmdldF9wcm9wX2FzY2lpIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcImxvY2F0aW9uXCIpXG4gICAgICAgICAgICAgXCJoYXNoXCIpXG4gICAgbGV0IChzZXRfaGFzaCA6IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg0NTggOiBzdHJpbmcpIC0+XG4gICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAoT2pzLmdldF9wcm9wX2FzY2lpIE9qcy5nbG9iYWwgXCJsb2NhdGlvblwiKSBcImhhc2hcIlxuICAgICAgICAgIChPanMuc3RyaW5nX3RvX2pzIHg0NTgpXG4gICAgbGV0IChob3N0IDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biAoeDQ1OSA6IHQpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NDU5KSBcImhvc3RcIilcbiAgICBsZXQgKHNldF9ob3N0IDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NDYwIDogdCkgLT5cbiAgICAgICAgZnVuICh4NDYxIDogc3RyaW5nKSAtPlxuICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NDYwKSBcImhvc3RcIiAoT2pzLnN0cmluZ190b19qcyB4NDYxKVxuICAgIGxldCAoaG9zdG5hbWUgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4NDYyIDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg0NjIpIFwiaG9zdG5hbWVcIilcbiAgICBsZXQgKHNldF9ob3N0bmFtZSA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDQ2MyA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDQ2NCA6IHN0cmluZykgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDQ2MykgXCJob3N0bmFtZVwiXG4gICAgICAgICAgICAoT2pzLnN0cmluZ190b19qcyB4NDY0KVxuICAgIGxldCAoaHJlZiA6IHVuaXQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qc1xuICAgICAgICAgIChPanMuZ2V0X3Byb3BfYXNjaWkgKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwibG9jYXRpb25cIilcbiAgICAgICAgICAgICBcImhyZWZcIilcbiAgICBsZXQgKHNldF9ocmVmIDogc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDQ2NSA6IHN0cmluZykgLT5cbiAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcImxvY2F0aW9uXCIpIFwiaHJlZlwiXG4gICAgICAgICAgKE9qcy5zdHJpbmdfdG9fanMgeDQ2NSlcbiAgICBsZXQgKHBhdGhuYW1lIDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biAoeDQ2NiA6IHQpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NDY2KSBcInBhdGhuYW1lXCIpXG4gICAgbGV0IChzZXRfcGF0aG5hbWUgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg0NjcgOiB0KSAtPlxuICAgICAgICBmdW4gKHg0NjggOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg0NjcpIFwicGF0aG5hbWVcIlxuICAgICAgICAgICAgKE9qcy5zdHJpbmdfdG9fanMgeDQ2OClcbiAgICBsZXQgKHBvcnQgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4NDY5IDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg0NjkpIFwicG9ydFwiKVxuICAgIGxldCAoc2V0X3BvcnQgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg0NzAgOiB0KSAtPlxuICAgICAgICBmdW4gKHg0NzEgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg0NzApIFwicG9ydFwiIChPanMuc3RyaW5nX3RvX2pzIHg0NzEpXG4gICAgbGV0IChwcm90b2NvbCA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHg0NzIgOiB0KSAtPlxuICAgICAgICBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDQ3MikgXCJwcm90b2NvbFwiKVxuICAgIGxldCAoc2V0X3Byb3RvY29sIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NDczIDogdCkgLT5cbiAgICAgICAgZnVuICh4NDc0IDogc3RyaW5nKSAtPlxuICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NDczKSBcInByb3RvY29sXCJcbiAgICAgICAgICAgIChPanMuc3RyaW5nX3RvX2pzIHg0NzQpXG4gICAgbGV0IChzZWFyY2ggOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4NDc1IDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg0NzUpIFwic2VhcmNoXCIpXG4gICAgbGV0IChzZXRfc2VhcmNoIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NDc2IDogdCkgLT5cbiAgICAgICAgZnVuICh4NDc3IDogc3RyaW5nKSAtPlxuICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NDc2KSBcInNlYXJjaFwiIChPanMuc3RyaW5nX3RvX2pzIHg0NzcpXG4gICAgbGV0IChvcmlnaW4gOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4NDc4IDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg0NzgpIFwib3JpZ2luXCIpXG4gICAgbGV0IChhc3NpZ24gOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg0ODAgOiB0KSAtPlxuICAgICAgICBmdW4gKHg0NzkgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQ4MCkgXCJhc3NpZ25cIiBbfChPanMuc3RyaW5nX3RvX2pzIHg0NzkpfF0pXG4gICAgbGV0IChyZWxvYWQgOiB0IC0+ID9mb3JjZTpib29sIC0+IHVuaXQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NDg0IDogdCkgLT5cbiAgICAgICAgZnVuID9mb3JjZTooeDQ4MSA6IGJvb2wgb3B0aW9uKSAtPlxuICAgICAgICAgIGZ1biAoKSAtPlxuICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgIChsZXQgeDQ4NSA9IHRfdG9fanMgeDQ4NCBpblxuICAgICAgICAgICAgICAgT2pzLmNhbGwgKE9qcy5nZXRfcHJvcF9hc2NpaSB4NDg1IFwicmVsb2FkXCIpIFwiYXBwbHlcIlxuICAgICAgICAgICAgICAgICBbfHg0ODU7KChsZXQgeDQ4MiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2pzLm5ld19vYmpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcIkFycmF5XCIpIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3x8XSBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2ggeDQ4MSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDQ4MyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIHg0ODIgXCJwdXNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt8KE9qcy5ib29sX3RvX2pzIHg0ODMpfF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB4NDgyKSl8XSlcbiAgICBsZXQgKHJlcGxhY2UgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg0ODcgOiB0KSAtPlxuICAgICAgICBmdW4gKHg0ODYgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQ4NykgXCJyZXBsYWNlXCIgW3woT2pzLnN0cmluZ190b19qcyB4NDg2KXxdKVxuICBlbmRcbm1vZHVsZSBXaW5kb3cgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgdF9vZl9qcyA6IE9qcy50IC0+IHQgPSBmdW4gKHg0ODkgOiBPanMudCkgLT4geDQ4OVxuICAgIGFuZCB0X3RvX2pzIDogdCAtPiBPanMudCA9IGZ1biAoeDQ4OCA6IE9qcy50KSAtPiB4NDg4XG4gICAgdHlwZSB0aW1lb3V0X2lkID0gT2pzLnRcbiAgICBsZXQgcmVjIHRpbWVvdXRfaWRfb2ZfanMgOiBPanMudCAtPiB0aW1lb3V0X2lkID1cbiAgICAgIGZ1biAoeDQ5MSA6IE9qcy50KSAtPiB4NDkxXG4gICAgYW5kIHRpbWVvdXRfaWRfdG9fanMgOiB0aW1lb3V0X2lkIC0+IE9qcy50ID0gZnVuICh4NDkwIDogT2pzLnQpIC0+IHg0OTBcbiAgICB0eXBlIGludGVydmFsX2lkID0gT2pzLnRcbiAgICBsZXQgcmVjIGludGVydmFsX2lkX29mX2pzIDogT2pzLnQgLT4gaW50ZXJ2YWxfaWQgPVxuICAgICAgZnVuICh4NDkzIDogT2pzLnQpIC0+IHg0OTNcbiAgICBhbmQgaW50ZXJ2YWxfaWRfdG9fanMgOiBpbnRlcnZhbF9pZCAtPiBPanMudCA9IGZ1biAoeDQ5MiA6IE9qcy50KSAtPiB4NDkyXG4gICAgbGV0IChhZGRfZXZlbnRfbGlzdGVuZXIgOlxuICAgICAgdCAtPiBFdmVudC5raW5kIC0+IChFdmVudC50IC0+IHVuaXQpIC0+IGJvb2wgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NDk4IDogdCkgLT5cbiAgICAgICAgZnVuICh4NDk0IDogRXZlbnQua2luZCkgLT5cbiAgICAgICAgICBmdW4gKHg0OTUgOiBFdmVudC50IC0+IHVuaXQpIC0+XG4gICAgICAgICAgICBmdW4gKHg0OTcgOiBib29sKSAtPlxuICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDQ5OCkgXCJhZGRFdmVudExpc3RlbmVyXCJcbiAgICAgICAgICAgICAgICAgICBbfChFdmVudC5raW5kX3RvX2pzIHg0OTQpOyhPanMuZnVuX3RvX2pzIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW4gKHg0OTYgOiBPanMudCkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg0OTUgKEV2ZW50LnRfb2ZfanMgeDQ5NikpKTsoXG4gICAgICAgICAgICAgICAgICAgICBPanMuYm9vbF90b19qcyB4NDk3KXxdKVxuICAgIGxldCAoYWRkX2V2ZW50X2xpc3RlbmVyX2ludGVybmFsIDpcbiAgICAgIHQgLT4gRXZlbnQua2luZCAtPiBPanMudCAtPiBib29sIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDUwMiA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDQ5OSA6IEV2ZW50LmtpbmQpIC0+XG4gICAgICAgICAgZnVuICh4NTAwIDogT2pzLnQpIC0+XG4gICAgICAgICAgICBmdW4gKHg1MDEgOiBib29sKSAtPlxuICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDUwMikgXCJhZGRFdmVudExpc3RlbmVyXCJcbiAgICAgICAgICAgICAgICAgICBbfChFdmVudC5raW5kX3RvX2pzIHg0OTkpO3g1MDA7KE9qcy5ib29sX3RvX2pzIHg1MDEpfF0pXG4gICAgbGV0IChyZW1vdmVfZXZlbnRfbGlzdGVuZXJfaW50ZXJuYWwgOlxuICAgICAgdCAtPiBFdmVudC5raW5kIC0+IE9qcy50IC0+IGJvb2wgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NTA2IDogdCkgLT5cbiAgICAgICAgZnVuICh4NTAzIDogRXZlbnQua2luZCkgLT5cbiAgICAgICAgICBmdW4gKHg1MDQgOiBPanMudCkgLT5cbiAgICAgICAgICAgIGZ1biAoeDUwNSA6IGJvb2wpIC0+XG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NTA2KSBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIlxuICAgICAgICAgICAgICAgICAgIFt8KEV2ZW50LmtpbmRfdG9fanMgeDUwMyk7eDUwNDsoT2pzLmJvb2xfdG9fanMgeDUwNSl8XSlcbiAgICBsZXQgYWRkX2NhbmNlbGxhYmxlX2V2ZW50X2xpc3RlbmVyIHggayBmIGMgPVxuICAgICAgbGV0IGYgPSBPanMuZnVuX3RvX2pzIDEgKGZ1biB4IC0+IGYgKEV2ZW50LnRfb2ZfanMgeCkpIGluXG4gICAgICBhZGRfZXZlbnRfbGlzdGVuZXJfaW50ZXJuYWwgeCBrIGYgYztcbiAgICAgIChmdW4gKCkgLT4gcmVtb3ZlX2V2ZW50X2xpc3RlbmVyX2ludGVybmFsIHggayBmIGMpXG4gICAgbGV0IChkb2N1bWVudCA6IHQgLT4gRG9jdW1lbnQudCkgPVxuICAgICAgZnVuICh4NTA3IDogdCkgLT5cbiAgICAgICAgRG9jdW1lbnQudF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg1MDcpIFwiZG9jdW1lbnRcIilcbiAgICBsZXQgKHNldF9vbmxvYWQgOiB0IC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDUwOCA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDUwOSA6IHVuaXQgLT4gdW5pdCkgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDUwOCkgXCJvbmxvYWRcIlxuICAgICAgICAgICAgKE9qcy5mdW5fdG9fanMgMSAoZnVuIF8gLT4geDUwOSAoKSkpXG4gICAgbGV0IChzZXRfaW50ZXJ2YWwgOiB0IC0+ICh1bml0IC0+IHVuaXQpIC0+IGludCAtPiBpbnRlcnZhbF9pZCkgPVxuICAgICAgZnVuICh4NTEyIDogdCkgLT5cbiAgICAgICAgZnVuICh4NTEwIDogdW5pdCAtPiB1bml0KSAtPlxuICAgICAgICAgIGZ1biAoeDUxMSA6IGludCkgLT5cbiAgICAgICAgICAgIGludGVydmFsX2lkX29mX2pzXG4gICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NTEyKSBcInNldEludGVydmFsXCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLmZ1bl90b19qcyAxIChmdW4gXyAtPiB4NTEwICgpKSk7KE9qcy5pbnRfdG9fanMgeDUxMSl8XSlcbiAgICBsZXQgKHNldF90aW1lb3V0IDogdCAtPiAodW5pdCAtPiB1bml0KSAtPiBpbnQgLT4gdGltZW91dF9pZCkgPVxuICAgICAgZnVuICh4NTE1IDogdCkgLT5cbiAgICAgICAgZnVuICh4NTEzIDogdW5pdCAtPiB1bml0KSAtPlxuICAgICAgICAgIGZ1biAoeDUxNCA6IGludCkgLT5cbiAgICAgICAgICAgIHRpbWVvdXRfaWRfb2ZfanNcbiAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg1MTUpIFwic2V0VGltZW91dFwiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5mdW5fdG9fanMgMSAoZnVuIF8gLT4geDUxMyAoKSkpOyhPanMuaW50X3RvX2pzIHg1MTQpfF0pXG4gICAgbGV0IChjbGVhcl90aW1lb3V0IDogdCAtPiB0aW1lb3V0X2lkIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDUxNyA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDUxNiA6IHRpbWVvdXRfaWQpIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDUxNykgXCJjbGVhclRpbWVvdXRcIlxuICAgICAgICAgICAgICAgW3wodGltZW91dF9pZF90b19qcyB4NTE2KXxdKVxuICAgIGxldCAoY2xlYXJfaW50ZXJ2YWwgOiB0IC0+IGludGVydmFsX2lkIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDUxOSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDUxOCA6IGludGVydmFsX2lkKSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg1MTkpIFwiY2xlYXJJbnRlcnZhbFwiXG4gICAgICAgICAgICAgICBbfChpbnRlcnZhbF9pZF90b19qcyB4NTE4KXxdKVxuICAgIGxldCAocmVxdWVzdF9hbmltYXRpb25fZnJhbWUgOiB0IC0+IChmbG9hdCAtPiB1bml0KSAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg1MjIgOiB0KSAtPlxuICAgICAgICBmdW4gKHg1MjAgOiBmbG9hdCAtPiB1bml0KSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg1MjIpIFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJcbiAgICAgICAgICAgICAgIFt8KE9qcy5mdW5fdG9fanMgMVxuICAgICAgICAgICAgICAgICAgICAoZnVuICh4NTIxIDogT2pzLnQpIC0+IHg1MjAgKE9qcy5mbG9hdF9vZl9qcyB4NTIxKSkpfF0pXG4gICAgbGV0IChvcGVuXyA6XG4gICAgICB0IC0+XG4gICAgICAgID91cmw6c3RyaW5nIC0+XG4gICAgICAgICAgP25hbWU6c3RyaW5nIC0+ID9mZWF0dXJlczpzdHJpbmcgLT4gP3JlcGxhY2U6Ym9vbCAtPiB1bml0IC0+IHQpXG4gICAgICA9XG4gICAgICBmdW4gKHg1MzIgOiB0KSAtPlxuICAgICAgICBmdW4gP3VybDooeDUyMyA6IHN0cmluZyBvcHRpb24pIC0+XG4gICAgICAgICAgZnVuID9uYW1lOih4NTI0IDogc3RyaW5nIG9wdGlvbikgLT5cbiAgICAgICAgICAgIGZ1biA/ZmVhdHVyZXM6KHg1MjUgOiBzdHJpbmcgb3B0aW9uKSAtPlxuICAgICAgICAgICAgICBmdW4gP3JlcGxhY2U6KHg1MjYgOiBib29sIG9wdGlvbikgLT5cbiAgICAgICAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgIHRfb2ZfanNcbiAgICAgICAgICAgICAgICAgICAgKGxldCB4NTMzID0gdF90b19qcyB4NTMyIGluXG4gICAgICAgICAgICAgICAgICAgICBPanMuY2FsbCAoT2pzLmdldF9wcm9wX2FzY2lpIHg1MzMgXCJvcGVuXCIpIFwiYXBwbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICBbfHg1MzM7KChsZXQgeDUyNyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2pzLm5ld19vYmpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcIkFycmF5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbfHxdIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXRjaCB4NTIzIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU29tZSB4NTMxIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoT2pzLmNhbGwgeDUyNyBcInB1c2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NTMxKXxdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoIHg1MjQgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTb21lIHg1MzAgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuY2FsbCB4NTI3IFwicHVzaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg1MzApfF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2ggeDUyNSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDUyOSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIHg1MjcgXCJwdXNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDUyOSl8XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXRjaCB4NTI2IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU29tZSB4NTI4IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoT2pzLmNhbGwgeDUyNyBcInB1c2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3woT2pzLmJvb2xfdG9fanMgeDUyOCl8XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg1MjcpKXxdKVxuICAgIGxldCAoYWxlcnQgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg1MzUgOiB0KSAtPlxuICAgICAgICBmdW4gKHg1MzQgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDUzNSkgXCJhbGVydFwiIFt8KE9qcy5zdHJpbmdfdG9fanMgeDUzNCl8XSlcbiAgICBsZXQgKHNlc3Npb25fc3RvcmFnZSA6IHQgLT4gU3RvcmFnZS50IG9wdGlvbikgPVxuICAgICAgZnVuICh4NTM2IDogdCkgLT5cbiAgICAgICAgT2pzLm9wdGlvbl9vZl9qcyBTdG9yYWdlLnRfb2ZfanNcbiAgICAgICAgICAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg1MzYpIFwic2Vzc2lvblN0b3JhZ2VcIilcbiAgICBsZXQgKGxvY2FsX3N0b3JhZ2UgOiB0IC0+IFN0b3JhZ2UudCBvcHRpb24pID1cbiAgICAgIGZ1biAoeDUzOCA6IHQpIC0+XG4gICAgICAgIE9qcy5vcHRpb25fb2ZfanMgU3RvcmFnZS50X29mX2pzXG4gICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NTM4KSBcImxvY2FsU3RvcmFnZVwiKVxuICAgIGxldCAoaW5uZXJfd2lkdGggOiB0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4gKHg1NDAgOiB0KSAtPlxuICAgICAgICBPanMuZmxvYXRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NTQwKSBcImlubmVyV2lkdGhcIilcbiAgICBsZXQgKGlubmVyX2hlaWdodCA6IHQgLT4gZmxvYXQpID1cbiAgICAgIGZ1biAoeDU0MSA6IHQpIC0+XG4gICAgICAgIE9qcy5mbG9hdF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg1NDEpIFwiaW5uZXJIZWlnaHRcIilcbiAgICBsZXQgKHBhZ2VfeF9vZmZzZXQgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4NTQyIDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg1NDIpIFwicGFnZVhPZmZzZXRcIilcbiAgICBsZXQgKHBhZ2VfeV9vZmZzZXQgOiB0IC0+IGludCkgPVxuICAgICAgZnVuICh4NTQzIDogdCkgLT5cbiAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg1NDMpIFwicGFnZVlPZmZzZXRcIilcbiAgICBsZXQgKHNjcm9sbF9ieSA6IHQgLT4gaW50IC0+IGludCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg1NDYgOiB0KSAtPlxuICAgICAgICBmdW4gKHg1NDQgOiBpbnQpIC0+XG4gICAgICAgICAgZnVuICh4NTQ1IDogaW50KSAtPlxuICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NTQ2KSBcInNjcm9sbEJ5XCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLmludF90b19qcyB4NTQ0KTsoT2pzLmludF90b19qcyB4NTQ1KXxdKVxuICAgIGxldCAoc2Nyb2xsX3RvIDogdCAtPiBpbnQgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDU0OSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDU0NyA6IGludCkgLT5cbiAgICAgICAgICBmdW4gKHg1NDggOiBpbnQpIC0+XG4gICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg1NDkpIFwic2Nyb2xsVG9cIlxuICAgICAgICAgICAgICAgICBbfChPanMuaW50X3RvX2pzIHg1NDcpOyhPanMuaW50X3RvX2pzIHg1NDgpfF0pXG4gICAgdHlwZSBzY3JvbGxfdG9fb3B0aW9ucyA9XG4gICAgICB7XG4gICAgICB0b3A6IGludCA7XG4gICAgICBsZWZ0OiBpbnQgO1xuICAgICAgYmVoYXZpb3I6IEVsZW1lbnQuYmVoYXZpb3Igb3B0aW9uIH1cbiAgICBsZXQgcmVjIHNjcm9sbF90b19vcHRpb25zX29mX2pzIDogT2pzLnQgLT4gc2Nyb2xsX3RvX29wdGlvbnMgPVxuICAgICAgZnVuICh4NTUyIDogT2pzLnQpIC0+XG4gICAgICAgIHtcbiAgICAgICAgICB0b3AgPSAoT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpIHg1NTIgXCJ0b3BcIikpO1xuICAgICAgICAgIGxlZnQgPSAoT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpIHg1NTIgXCJsZWZ0XCIpKTtcbiAgICAgICAgICBiZWhhdmlvciA9XG4gICAgICAgICAgICAoT2pzLm9wdGlvbl9vZl9qcyBFbGVtZW50LmJlaGF2aW9yX29mX2pzXG4gICAgICAgICAgICAgICAoT2pzLmdldF9wcm9wX2FzY2lpIHg1NTIgXCJiZWhhdmlvclwiKSlcbiAgICAgICAgfVxuICAgIGFuZCBzY3JvbGxfdG9fb3B0aW9uc190b19qcyA6IHNjcm9sbF90b19vcHRpb25zIC0+IE9qcy50ID1cbiAgICAgIGZ1biAoeDU1MCA6IHNjcm9sbF90b19vcHRpb25zKSAtPlxuICAgICAgICBPanMub2JqXG4gICAgICAgICAgW3woXCJ0b3BcIiwgKE9qcy5pbnRfdG9fanMgeDU1MC50b3ApKTsoXCJsZWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoT2pzLmludF90b19qcyB4NTUwLmxlZnQpKTtcbiAgICAgICAgICAgIChcImJlaGF2aW9yXCIsXG4gICAgICAgICAgICAgIChPanMub3B0aW9uX3RvX2pzIEVsZW1lbnQuYmVoYXZpb3JfdG9fanMgeDU1MC5iZWhhdmlvcikpfF1cbiAgICBsZXQgKHNjcm9sbF90b19vcHRpb25zIDogdCAtPiBzY3JvbGxfdG9fb3B0aW9ucyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg1NTUgOiB0KSAtPlxuICAgICAgICBmdW4gKHg1NTQgOiBzY3JvbGxfdG9fb3B0aW9ucykgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NTU1KSBcInNjcm9sbFRvXCJcbiAgICAgICAgICAgICAgIFt8KHNjcm9sbF90b19vcHRpb25zX3RvX2pzIHg1NTQpfF0pXG4gICAgbGV0IChoaXN0b3J5IDogdCAtPiBIaXN0b3J5LnQpID1cbiAgICAgIGZ1biAoeDU1NiA6IHQpIC0+XG4gICAgICAgIEhpc3RvcnkudF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg1NTYpIFwiaGlzdG9yeVwiKVxuICAgIGxldCAobG9jYXRpb24gOiB0IC0+IExvY2F0aW9uLnQpID1cbiAgICAgIGZ1biAoeDU1NyA6IHQpIC0+XG4gICAgICAgIExvY2F0aW9uLnRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NTU3KSBcImxvY2F0aW9uXCIpXG4gICAgbGV0IChmcmFtZV9lbGVtZW50IDogdCAtPiBFbGVtZW50LnQpID1cbiAgICAgIGZ1biAoeDU1OCA6IHQpIC0+XG4gICAgICAgIEVsZW1lbnQudF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg1NTgpIFwiZnJhbWVFbGVtZW50XCIpXG4gICAgbGV0IChnZXRfY29tcHV0ZWRfc3R5bGUgOiB0IC0+IEVsZW1lbnQudCAtPiBTdHlsZS50KSA9XG4gICAgICBmdW4gKHg1NjAgOiB0KSAtPlxuICAgICAgICBmdW4gKHg1NTkgOiBFbGVtZW50LnQpIC0+XG4gICAgICAgICAgU3R5bGUudF9vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg1NjApIFwiZ2V0Q29tcHV0ZWRTdHlsZVwiXG4gICAgICAgICAgICAgICBbfChFbGVtZW50LnRfdG9fanMgeDU1OSl8XSlcbiAgICBsZXQgKGRlY29kZV9VUklfY29tcG9uZW50IDogdCAtPiBzdHJpbmcgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHg1NjIgOiB0KSAtPlxuICAgICAgICBmdW4gKHg1NjEgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnN0cmluZ19vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg1NjIpIFwiZGVjb2RlVVJJQ29tcG9uZW50XCJcbiAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDU2MSl8XSlcbiAgICBsZXQgKGV2ZW50X3NvdXJjZSA6IEV2ZW50LnQgLT4gdCkgPVxuICAgICAgZnVuICh4NTYzIDogRXZlbnQudCkgLT5cbiAgICAgICAgdF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpIChFdmVudC50X3RvX2pzIHg1NjMpIFwic291cmNlXCIpXG4gICAgbGV0IChwb3N0X21lc3NhZ2UgOiB0IC0+IE9qcy50IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg1NjYgOiB0KSAtPlxuICAgICAgICBmdW4gKHg1NjQgOiBPanMudCkgLT5cbiAgICAgICAgICBmdW4gKHg1NjUgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg1NjYpIFwicG9zdE1lc3NhZ2VcIlxuICAgICAgICAgICAgICAgICBbfHg1NjQ7KE9qcy5zdHJpbmdfdG9fanMgeDU2NSl8XSlcbiAgZW5kXG5tb2R1bGUgSUZyYW1lID1cbiAgc3RydWN0XG4gICAgbGV0IChjb250ZW50X3dpbmRvdyA6IEVsZW1lbnQudCAtPiBXaW5kb3cudCBvcHRpb24pID1cbiAgICAgIGZ1biAoeDU2NyA6IEVsZW1lbnQudCkgLT5cbiAgICAgICAgT2pzLm9wdGlvbl9vZl9qcyBXaW5kb3cudF9vZl9qc1xuICAgICAgICAgIChPanMuZ2V0X3Byb3BfYXNjaWkgKEVsZW1lbnQudF90b19qcyB4NTY3KSBcImNvbnRlbnRXaW5kb3dcIilcbiAgICBsZXQgKGNvbnRlbnRfZG9jdW1lbnQgOiBFbGVtZW50LnQgLT4gRG9jdW1lbnQudCBvcHRpb24pID1cbiAgICAgIGZ1biAoeDU2OSA6IEVsZW1lbnQudCkgLT5cbiAgICAgICAgT2pzLm9wdGlvbl9vZl9qcyBEb2N1bWVudC50X29mX2pzXG4gICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSAoRWxlbWVudC50X3RvX2pzIHg1NjkpIFwiY29udGVudERvY3VtZW50XCIpXG4gIGVuZFxubW9kdWxlIEpTT04gPVxuICBzdHJ1Y3RcbiAgICBsZXQgKHBhcnNlIDogc3RyaW5nIC0+IE9qcy50KSA9XG4gICAgICBmdW4gKHg1NzEgOiBzdHJpbmcpIC0+XG4gICAgICAgIE9qcy5jYWxsIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcIkpTT05cIikgXCJwYXJzZVwiXG4gICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NTcxKXxdXG4gICAgbGV0IChzdHJpbmdpZnkgOiBPanMudCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biAoeDU3MiA6IE9qcy50KSAtPlxuICAgICAgICBPanMuc3RyaW5nX29mX2pzXG4gICAgICAgICAgKE9qcy5jYWxsIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcIkpTT05cIikgXCJzdHJpbmdpZnlcIlxuICAgICAgICAgICAgIFt8eDU3MnxdKVxuICBlbmRcbm1vZHVsZSBGaWxlUmVhZGVyID1cbiAgc3RydWN0XG4gICAgdHlwZSBzdGF0ZSA9XG4gICAgICB8IEVtcHR5IFxuICAgICAgfCBMb2FkaW5nIFxuICAgICAgfCBEb25lIFxuICAgIGxldCByZWMgc3RhdGVfb2ZfanMgOiBPanMudCAtPiBzdGF0ZSA9XG4gICAgICBmdW4gKHg1NzQgOiBPanMudCkgLT5cbiAgICAgICAgbGV0IHg1NzUgPSB4NTc0IGluXG4gICAgICAgIG1hdGNoIE9qcy5pbnRfb2ZfanMgeDU3NSB3aXRoXG4gICAgICAgIHwgMCAtPiBFbXB0eVxuICAgICAgICB8IDEgLT4gTG9hZGluZ1xuICAgICAgICB8IDIgLT4gRG9uZVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgYW5kIHN0YXRlX3RvX2pzIDogc3RhdGUgLT4gT2pzLnQgPVxuICAgICAgZnVuICh4NTczIDogc3RhdGUpIC0+XG4gICAgICAgIG1hdGNoIHg1NzMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IE9qcy5pbnRfdG9fanMgMFxuICAgICAgICB8IExvYWRpbmcgLT4gT2pzLmludF90b19qcyAxXG4gICAgICAgIHwgRG9uZSAtPiBPanMuaW50X3RvX2pzIDJcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgdF9vZl9qcyA6IE9qcy50IC0+IHQgPSBmdW4gKHg1NzcgOiBPanMudCkgLT4geDU3N1xuICAgIGFuZCB0X3RvX2pzIDogdCAtPiBPanMudCA9IGZ1biAoeDU3NiA6IE9qcy50KSAtPiB4NTc2XG4gICAgbGV0IChjcmVhdGUgOiB1bml0IC0+IHQpID1cbiAgICAgIGZ1biAoKSAtPlxuICAgICAgICB0X29mX2pzXG4gICAgICAgICAgKE9qcy5uZXdfb2JqIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcIkZpbGVSZWFkZXJcIikgW3x8XSlcbiAgICBsZXQgKHJlYWR5X3N0YXRlIDogdCAtPiBzdGF0ZSkgPVxuICAgICAgZnVuICh4NTc4IDogdCkgLT5cbiAgICAgICAgc3RhdGVfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NTc4KSBcInJlYWR5U3RhdGVcIilcbiAgICBsZXQgKHJlc3VsdCA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHg1NzkgOiB0KSAtPlxuICAgICAgICBPanMuc3RyaW5nX29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDU3OSkgXCJyZXN1bHRcIilcbiAgICBsZXQgKHNldF9vbmxvYWQgOiB0IC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDU4MCA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDU4MSA6IHVuaXQgLT4gdW5pdCkgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDU4MCkgXCJvbmxvYWRcIlxuICAgICAgICAgICAgKE9qcy5mdW5fdG9fanMgMSAoZnVuIF8gLT4geDU4MSAoKSkpXG4gICAgbGV0IChyZWFkX2FzX2JpbmFyeV9zdHJpbmcgOiB0IC0+IEZpbGUudCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg1ODMgOiB0KSAtPlxuICAgICAgICBmdW4gKHg1ODIgOiBGaWxlLnQpIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDU4MykgXCJyZWFkQXNCaW5hcnlTdHJpbmdcIlxuICAgICAgICAgICAgICAgW3woRmlsZS50X3RvX2pzIHg1ODIpfF0pXG4gICAgbGV0IChyZWFkX2FzX3RleHQgOiB0IC0+IEZpbGUudCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg1ODUgOiB0KSAtPlxuICAgICAgICBmdW4gKHg1ODQgOiBGaWxlLnQpIC0+XG4gICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDU4NSkgXCJyZWFkQXNUZXh0XCIgW3woRmlsZS50X3RvX2pzIHg1ODQpfF0pXG4gICAgbGV0IChyZWFkX2FzX2RhdGFfdXJsIDogdCAtPiBGaWxlLnQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NTg3IDogdCkgLT5cbiAgICAgICAgZnVuICh4NTg2IDogRmlsZS50KSAtPlxuICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg1ODcpIFwicmVhZEFzRGF0YVVSTFwiIFt8KEZpbGUudF90b19qcyB4NTg2KXxdKVxuICBlbmRcbm1vZHVsZSBYSFIgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgdF9vZl9qcyA6IE9qcy50IC0+IHQgPSBmdW4gKHg1ODkgOiBPanMudCkgLT4geDU4OVxuICAgIGFuZCB0X3RvX2pzIDogdCAtPiBPanMudCA9IGZ1biAoeDU4OCA6IE9qcy50KSAtPiB4NTg4XG4gICAgbGV0IChjcmVhdGUgOiB1bml0IC0+IHQpID1cbiAgICAgIGZ1biAoKSAtPlxuICAgICAgICB0X29mX2pzXG4gICAgICAgICAgKE9qcy5uZXdfb2JqIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcIlhNTEh0dHBSZXF1ZXN0XCIpIFt8fF0pXG4gICAgbGV0IChvcGVuXyA6IHQgLT4gc3RyaW5nIC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg1OTIgOiB0KSAtPlxuICAgICAgICBmdW4gKHg1OTAgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgZnVuICh4NTkxIDogc3RyaW5nKSAtPlxuICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NTkyKSBcIm9wZW5cIlxuICAgICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg1OTApOyhPanMuc3RyaW5nX3RvX2pzIHg1OTEpfF0pXG4gICAgbGV0IChzZW5kIDogdCAtPiBPanMudCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg1OTQgOiB0KSAtPlxuICAgICAgICBmdW4gKHg1OTMgOiBPanMudCkgLT5cbiAgICAgICAgICBpZ25vcmUgKE9qcy5jYWxsICh0X3RvX2pzIHg1OTQpIFwic2VuZFwiIFt8eDU5M3xdKVxuICAgIGxldCAoc2V0X3JlcXVlc3RfaGVhZGVyIDogdCAtPiBzdHJpbmcgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDU5NyA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDU5NSA6IHN0cmluZykgLT5cbiAgICAgICAgICBmdW4gKHg1OTYgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg1OTcpIFwic2V0UmVxdWVzdEhlYWRlclwiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDU5NSk7KE9qcy5zdHJpbmdfdG9fanMgeDU5Nil8XSlcbiAgICBsZXQgKGdldF9yZXNwb25zZV9oZWFkZXIgOiB0IC0+IHN0cmluZyAtPiBzdHJpbmcgb3B0aW9uKSA9XG4gICAgICBmdW4gKHg1OTkgOiB0KSAtPlxuICAgICAgICBmdW4gKHg1OTggOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLm9wdGlvbl9vZl9qcyBPanMuc3RyaW5nX29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKHRfdG9fanMgeDU5OSkgXCJnZXRSZXNwb25zZUhlYWRlclwiXG4gICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg1OTgpfF0pXG4gICAgbGV0IChnZXRfYWxsX3Jlc3BvbnNlX2hlYWRlcnMgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4NjAxIDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qc1xuICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NjAxKSBcImdldEFsbFJlc3BvbnNlSGVhZGVyc1wiIFt8fF0pXG4gICAgbGV0IChzZXRfcmVzcG9uc2VfdHlwZSA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDYwMiA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDYwMyA6IHN0cmluZykgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDYwMikgXCJyZXNwb25zZVR5cGVcIlxuICAgICAgICAgICAgKE9qcy5zdHJpbmdfdG9fanMgeDYwMylcbiAgICBsZXQgKG92ZXJyaWRlX21pbWVfdHlwZSA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDYwNSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDYwNCA6IHN0cmluZykgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NjA1KSBcIm92ZXJyaWRlTWltZVR5cGVcIlxuICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NjA0KXxdKVxuICAgIGxldCAoc2V0X3dpdGhfY3JlZGVudGlhbHMgOiB0IC0+IGJvb2wgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NjA2IDogdCkgLT5cbiAgICAgICAgZnVuICh4NjA3IDogYm9vbCkgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDYwNikgXCJ3aXRoQ3JlZGVudGlhbHNcIlxuICAgICAgICAgICAgKE9qcy5ib29sX3RvX2pzIHg2MDcpXG4gICAgdHlwZSByZWFkeV9zdGF0ZSA9XG4gICAgICB8IFVuc2VudCBcbiAgICAgIHwgT3BlbmVkIFxuICAgICAgfCBIZWFkZXJzX3JlY2VpdmVkIFxuICAgICAgfCBMb2FkaW5nIFxuICAgICAgfCBEb25lIFxuICAgICAgfCBPdGhlciBvZiBpbnQgXG4gICAgbGV0IHJlYyByZWFkeV9zdGF0ZV9vZl9qcyA6IE9qcy50IC0+IHJlYWR5X3N0YXRlID1cbiAgICAgIGZ1biAoeDYxMCA6IE9qcy50KSAtPlxuICAgICAgICBsZXQgeDYxMSA9IHg2MTAgaW5cbiAgICAgICAgbWF0Y2ggT2pzLmludF9vZl9qcyB4NjExIHdpdGhcbiAgICAgICAgfCAwIC0+IFVuc2VudFxuICAgICAgICB8IDEgLT4gT3BlbmVkXG4gICAgICAgIHwgMiAtPiBIZWFkZXJzX3JlY2VpdmVkXG4gICAgICAgIHwgMyAtPiBMb2FkaW5nXG4gICAgICAgIHwgNCAtPiBEb25lXG4gICAgICAgIHwgeDYxMiAtPiBPdGhlciB4NjEyXG4gICAgYW5kIHJlYWR5X3N0YXRlX3RvX2pzIDogcmVhZHlfc3RhdGUgLT4gT2pzLnQgPVxuICAgICAgZnVuICh4NjA4IDogcmVhZHlfc3RhdGUpIC0+XG4gICAgICAgIG1hdGNoIHg2MDggd2l0aFxuICAgICAgICB8IFVuc2VudCAtPiBPanMuaW50X3RvX2pzIDBcbiAgICAgICAgfCBPcGVuZWQgLT4gT2pzLmludF90b19qcyAxXG4gICAgICAgIHwgSGVhZGVyc19yZWNlaXZlZCAtPiBPanMuaW50X3RvX2pzIDJcbiAgICAgICAgfCBMb2FkaW5nIC0+IE9qcy5pbnRfdG9fanMgM1xuICAgICAgICB8IERvbmUgLT4gT2pzLmludF90b19qcyA0XG4gICAgICAgIHwgT3RoZXIgeDYwOSAtPiBPanMuaW50X3RvX2pzIHg2MDlcbiAgICBsZXQgKHN0YXR1cyA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4gKHg2MTMgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDYxMykgXCJzdGF0dXNcIilcbiAgICBsZXQgKHN0YXR1c190ZXh0IDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biAoeDYxNCA6IHQpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NjE0KSBcInN0YXR1c1RleHRcIilcbiAgICBsZXQgKHJlYWR5X3N0YXRlIDogdCAtPiByZWFkeV9zdGF0ZSkgPVxuICAgICAgZnVuICh4NjE1IDogdCkgLT5cbiAgICAgICAgcmVhZHlfc3RhdGVfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NjE1KSBcInJlYWR5U3RhdGVcIilcbiAgICBsZXQgKHJlc3BvbnNlX3R5cGUgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4NjE2IDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg2MTYpIFwicmVzcG9uc2VUeXBlXCIpXG4gICAgbGV0IChyZXNwb25zZV90ZXh0IDogdCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biAoeDYxNyA6IHQpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NjE3KSBcInJlc3BvbnNlVGV4dFwiKVxuICAgIGxldCAocmVzcG9uc2UgOiB0IC0+IE9qcy50KSA9XG4gICAgICBmdW4gKHg2MTggOiB0KSAtPiBPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDYxOCkgXCJyZXNwb25zZVwiXG4gICAgbGV0IChyZXNwb25zZV9VUkwgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4NjE5IDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg2MTkpIFwicmVzcG9uc2VVUkxcIilcbiAgICBsZXQgKHNldF9vbnJlYWR5c3RhdGVjaGFuZ2UgOiB0IC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDYyMCA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDYyMSA6IHVuaXQgLT4gdW5pdCkgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDYyMCkgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIlxuICAgICAgICAgICAgKE9qcy5mdW5fdG9fanMgMSAoZnVuIF8gLT4geDYyMSAoKSkpXG4gIGVuZFxubW9kdWxlIFdlYlNvY2tldCA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IE9qcy50XG4gICAgbGV0IHJlYyB0X29mX2pzIDogT2pzLnQgLT4gdCA9IGZ1biAoeDYyMyA6IE9qcy50KSAtPiB4NjIzXG4gICAgYW5kIHRfdG9fanMgOiB0IC0+IE9qcy50ID0gZnVuICh4NjIyIDogT2pzLnQpIC0+IHg2MjJcbiAgICB0eXBlIHJlYWR5X3N0YXRlID1cbiAgICAgIHwgQ29ubmVjdGluZyBcbiAgICAgIHwgT3BlbiBcbiAgICAgIHwgQ2xvc2luZyBcbiAgICAgIHwgQ2xvc2VkIFxuICAgIGxldCByZWMgcmVhZHlfc3RhdGVfb2ZfanMgOiBPanMudCAtPiByZWFkeV9zdGF0ZSA9XG4gICAgICBmdW4gKHg2MjUgOiBPanMudCkgLT5cbiAgICAgICAgbGV0IHg2MjYgPSB4NjI1IGluXG4gICAgICAgIG1hdGNoIE9qcy5pbnRfb2ZfanMgeDYyNiB3aXRoXG4gICAgICAgIHwgMCAtPiBDb25uZWN0aW5nXG4gICAgICAgIHwgMSAtPiBPcGVuXG4gICAgICAgIHwgMiAtPiBDbG9zaW5nXG4gICAgICAgIHwgMyAtPiBDbG9zZWRcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgIGFuZCByZWFkeV9zdGF0ZV90b19qcyA6IHJlYWR5X3N0YXRlIC0+IE9qcy50ID1cbiAgICAgIGZ1biAoeDYyNCA6IHJlYWR5X3N0YXRlKSAtPlxuICAgICAgICBtYXRjaCB4NjI0IHdpdGhcbiAgICAgICAgfCBDb25uZWN0aW5nIC0+IE9qcy5pbnRfdG9fanMgMFxuICAgICAgICB8IE9wZW4gLT4gT2pzLmludF90b19qcyAxXG4gICAgICAgIHwgQ2xvc2luZyAtPiBPanMuaW50X3RvX2pzIDJcbiAgICAgICAgfCBDbG9zZWQgLT4gT2pzLmludF90b19qcyAzXG4gICAgbGV0IChjcmVhdGUgOiBzdHJpbmcgLT4gP3Byb3RvY29sczpzdHJpbmcgbGlzdCAtPiB1bml0IC0+IHQpID1cbiAgICAgIGZ1biAoeDYyNyA6IHN0cmluZykgLT5cbiAgICAgICAgZnVuID9wcm90b2NvbHM6KHg2MjggOiBzdHJpbmcgbGlzdCBvcHRpb24pIC0+XG4gICAgICAgICAgZnVuICgpIC0+XG4gICAgICAgICAgICB0X29mX2pzXG4gICAgICAgICAgICAgIChPanMubmV3X29ial9hcnIgKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwiV2ViU29ja2V0XCIpXG4gICAgICAgICAgICAgICAgIChsZXQgeDYyOSA9XG4gICAgICAgICAgICAgICAgICAgIE9qcy5uZXdfb2JqIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcIkFycmF5XCIpIFt8fF0gaW5cbiAgICAgICAgICAgICAgICAgIGlnbm9yZSAoT2pzLmNhbGwgeDYyOSBcInB1c2hcIiBbfChPanMuc3RyaW5nX3RvX2pzIHg2MjcpfF0pO1xuICAgICAgICAgICAgICAgICAgKG1hdGNoIHg2Mjggd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgU29tZSB4NjMwIC0+XG4gICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuY2FsbCB4NjI5IFwicHVzaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3woT2pzLmxpc3RfdG9fanMgT2pzLnN0cmluZ190b19qcyB4NjMwKXxdKVxuICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICB4NjI5KSlcbiAgICBsZXQgKHNlbmQgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg2MzMgOiB0KSAtPlxuICAgICAgICBmdW4gKHg2MzIgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4NjMzKSBcInNlbmRcIiBbfChPanMuc3RyaW5nX3RvX2pzIHg2MzIpfF0pXG4gICAgbGV0IChjbG9zZSA6IHQgLT4gP2NvZGU6aW50IC0+ID9yZWFzb246c3RyaW5nIC0+IHVuaXQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NjM5IDogdCkgLT5cbiAgICAgICAgZnVuID9jb2RlOih4NjM0IDogaW50IG9wdGlvbikgLT5cbiAgICAgICAgICBmdW4gP3JlYXNvbjooeDYzNSA6IHN0cmluZyBvcHRpb24pIC0+XG4gICAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgICAgKGxldCB4NjQwID0gdF90b19qcyB4NjM5IGluXG4gICAgICAgICAgICAgICAgIE9qcy5jYWxsIChPanMuZ2V0X3Byb3BfYXNjaWkgeDY0MCBcImNsb3NlXCIpIFwiYXBwbHlcIlxuICAgICAgICAgICAgICAgICAgIFt8eDY0MDsoKGxldCB4NjM2ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9qcy5uZXdfb2JqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcIkFycmF5XCIpIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbfHxdIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoIHg2MzQgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDYzOCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuY2FsbCB4NjM2IFwicHVzaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt8KE9qcy5pbnRfdG9fanMgeDYzOCl8XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2ggeDYzNSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU29tZSB4NjM3IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIHg2MzYgXCJwdXNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NjM3KXxdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg2MzYpKXxdKVxuICAgIGxldCAoYmluYXJ5X3R5cGUgOiB0IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4NjQxIDogdCkgLT5cbiAgICAgICAgT2pzLnN0cmluZ19vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg2NDEpIFwiYmluYXJ5VHlwZVwiKVxuICAgIGxldCAoc2V0X2JpbmFyeV90eXBlIDogdCAtPiBzdHJpbmcgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NjQyIDogdCkgLT5cbiAgICAgICAgZnVuICh4NjQzIDogc3RyaW5nKSAtPlxuICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NjQyKSBcImJpbmFyeVR5cGVcIlxuICAgICAgICAgICAgKE9qcy5zdHJpbmdfdG9fanMgeDY0MylcbiAgICBsZXQgKHJlYWR5X3N0YXRlIDogdCAtPiByZWFkeV9zdGF0ZSkgPVxuICAgICAgZnVuICh4NjQ0IDogdCkgLT5cbiAgICAgICAgcmVhZHlfc3RhdGVfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NjQ0KSBcInJlYWR5U3RhdGVcIilcbiAgICBsZXQgKGFkZF9ldmVudF9saXN0ZW5lciA6XG4gICAgICB0IC0+IEV2ZW50LmtpbmQgLT4gKEV2ZW50LnQgLT4gdW5pdCkgLT4gYm9vbCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg2NDkgOiB0KSAtPlxuICAgICAgICBmdW4gKHg2NDUgOiBFdmVudC5raW5kKSAtPlxuICAgICAgICAgIGZ1biAoeDY0NiA6IEV2ZW50LnQgLT4gdW5pdCkgLT5cbiAgICAgICAgICAgIGZ1biAoeDY0OCA6IGJvb2wpIC0+XG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NjQ5KSBcImFkZEV2ZW50TGlzdGVuZXJcIlxuICAgICAgICAgICAgICAgICAgIFt8KEV2ZW50LmtpbmRfdG9fanMgeDY0NSk7KE9qcy5mdW5fdG9fanMgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1biAoeDY0NyA6IE9qcy50KSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDY0NiAoRXZlbnQudF9vZl9qcyB4NjQ3KSkpOyhcbiAgICAgICAgICAgICAgICAgICAgIE9qcy5ib29sX3RvX2pzIHg2NDgpfF0pXG4gICAgbW9kdWxlIENsb3NlRXZlbnQgPVxuICAgICAgc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEV2ZW50LnRcbiAgICAgICAgbGV0IHJlYyB0X29mX2pzIDogT2pzLnQgLT4gdCA9XG4gICAgICAgICAgZnVuICh4NjUxIDogT2pzLnQpIC0+IEV2ZW50LnRfb2ZfanMgeDY1MVxuICAgICAgICBhbmQgdF90b19qcyA6IHQgLT4gT2pzLnQgPSBmdW4gKHg2NTAgOiBFdmVudC50KSAtPiBFdmVudC50X3RvX2pzIHg2NTBcbiAgICAgICAgbGV0IChjb2RlIDogdCAtPiBpbnQpID1cbiAgICAgICAgICBmdW4gKHg2NTIgOiB0KSAtPlxuICAgICAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg2NTIpIFwiY29kZVwiKVxuICAgICAgZW5kXG4gIGVuZFxubGV0ICh3aW5kb3cgOiBXaW5kb3cudCkgPVxuICBXaW5kb3cudF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpIE9qcy5nbG9iYWwgXCJ3aW5kb3dcIilcbmxldCAoZG9jdW1lbnQgOiBEb2N1bWVudC50KSA9XG4gIERvY3VtZW50LnRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwiZG9jdW1lbnRcIilcbm1vZHVsZSBDYW52YXMgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGNvbnRleHQgPSBPanMudFxuICAgIGxldCByZWMgY29udGV4dF9vZl9qcyA6IE9qcy50IC0+IGNvbnRleHQgPSBmdW4gKHg2NTQgOiBPanMudCkgLT4geDY1NFxuICAgIGFuZCBjb250ZXh0X3RvX2pzIDogY29udGV4dCAtPiBPanMudCA9IGZ1biAoeDY1MyA6IE9qcy50KSAtPiB4NjUzXG4gICAgdHlwZSBncmFkaWVudCA9IE9qcy50XG4gICAgbGV0IHJlYyBncmFkaWVudF9vZl9qcyA6IE9qcy50IC0+IGdyYWRpZW50ID0gZnVuICh4NjU2IDogT2pzLnQpIC0+IHg2NTZcbiAgICBhbmQgZ3JhZGllbnRfdG9fanMgOiBncmFkaWVudCAtPiBPanMudCA9IGZ1biAoeDY1NSA6IE9qcy50KSAtPiB4NjU1XG4gICAgdHlwZSBjc3NfY29sb3IgPSBzdHJpbmdcbiAgICBsZXQgcmVjIGNzc19jb2xvcl9vZl9qcyA6IE9qcy50IC0+IGNzc19jb2xvciA9XG4gICAgICBmdW4gKHg2NTggOiBPanMudCkgLT4gT2pzLnN0cmluZ19vZl9qcyB4NjU4XG4gICAgYW5kIGNzc19jb2xvcl90b19qcyA6IGNzc19jb2xvciAtPiBPanMudCA9XG4gICAgICBmdW4gKHg2NTcgOiBzdHJpbmcpIC0+IE9qcy5zdHJpbmdfdG9fanMgeDY1N1xuICAgIHR5cGUgY29udGV4dF9hdHRyaWJ1dGUgPSB7XG4gICAgICBhbHBoYTogYm9vbCB9XG4gICAgbGV0IHJlYyBjb250ZXh0X2F0dHJpYnV0ZV9vZl9qcyA6IE9qcy50IC0+IGNvbnRleHRfYXR0cmlidXRlID1cbiAgICAgIGZ1biAoeDY2MCA6IE9qcy50KSAtPlxuICAgICAgICB7IGFscGhhID0gKE9qcy5ib29sX29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgeDY2MCBcImFscGhhXCIpKSB9XG4gICAgYW5kIGNvbnRleHRfYXR0cmlidXRlX3RvX2pzIDogY29udGV4dF9hdHRyaWJ1dGUgLT4gT2pzLnQgPVxuICAgICAgZnVuICh4NjU5IDogY29udGV4dF9hdHRyaWJ1dGUpIC0+XG4gICAgICAgIE9qcy5vYmogW3woXCJhbHBoYVwiLCAoT2pzLmJvb2xfdG9fanMgeDY1OS5hbHBoYSkpfF1cbiAgICBsZXQgKGdldF9jb250ZXh0X2ludGVybmFsIDpcbiAgICAgIEVsZW1lbnQudCAtPiBzdHJpbmcgLT4gY29udGV4dF9hdHRyaWJ1dGUgLT4gY29udGV4dCBvcHRpb24pID1cbiAgICAgIGZ1biAoeDY2MyA6IEVsZW1lbnQudCkgLT5cbiAgICAgICAgZnVuICh4NjYxIDogc3RyaW5nKSAtPlxuICAgICAgICAgIGZ1biAoeDY2MiA6IGNvbnRleHRfYXR0cmlidXRlKSAtPlxuICAgICAgICAgICAgT2pzLm9wdGlvbl9vZl9qcyBjb250ZXh0X29mX2pzXG4gICAgICAgICAgICAgIChPanMuY2FsbCAoRWxlbWVudC50X3RvX2pzIHg2NjMpIFwiZ2V0Q29udGV4dFwiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDY2MSk7KGNvbnRleHRfYXR0cmlidXRlX3RvX2pzIHg2NjIpfF0pXG4gICAgbGV0IGdldF9jb250ZXh0ID8oYWxwaGE9IHRydWUpICBjYW52YXMgPVxuICAgICAgZ2V0X2NvbnRleHRfaW50ZXJuYWwgY2FudmFzIFwiMmRcIiB7IGFscGhhIH1cbiAgICBsZXQgKHRvX2RhdGFfVVJMIDogRWxlbWVudC50IC0+IHN0cmluZykgPVxuICAgICAgZnVuICh4NjY1IDogRWxlbWVudC50KSAtPlxuICAgICAgICBPanMuc3RyaW5nX29mX2pzIChPanMuY2FsbCAoRWxlbWVudC50X3RvX2pzIHg2NjUpIFwidG9EYXRhVVJMXCIgW3x8XSlcbiAgICBsZXQgKHNldF9maWxsX3N0eWxlIDpcbiAgICAgIGNvbnRleHQgLT4gWyBgQ29sb3Igb2YgY3NzX2NvbG9yICB8IGBHcmFkaWVudCBvZiBncmFkaWVudCBdIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDY2NiA6IGNvbnRleHQpIC0+XG4gICAgICAgIGZ1biAoeDY2NyA6IFsgYENvbG9yIG9mIGNzc19jb2xvciAgfCBgR3JhZGllbnQgb2YgZ3JhZGllbnQgXSkgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKGNvbnRleHRfdG9fanMgeDY2NikgXCJmaWxsU3R5bGVcIlxuICAgICAgICAgICAgKG1hdGNoIHg2Njcgd2l0aFxuICAgICAgICAgICAgIHwgYENvbG9yIHg2NjggLT4gY3NzX2NvbG9yX3RvX2pzIHg2NjhcbiAgICAgICAgICAgICB8IGBHcmFkaWVudCB4NjY5IC0+IGdyYWRpZW50X3RvX2pzIHg2NjkpXG4gICAgbGV0IChzZXRfc3Ryb2tlX3N0eWxlIDpcbiAgICAgIGNvbnRleHQgLT4gWyBgQ29sb3Igb2YgY3NzX2NvbG9yICB8IGBHcmFkaWVudCBvZiBncmFkaWVudCBdIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDY3MCA6IGNvbnRleHQpIC0+XG4gICAgICAgIGZ1biAoeDY3MSA6IFsgYENvbG9yIG9mIGNzc19jb2xvciAgfCBgR3JhZGllbnQgb2YgZ3JhZGllbnQgXSkgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKGNvbnRleHRfdG9fanMgeDY3MCkgXCJzdHJva2VTdHlsZVwiXG4gICAgICAgICAgICAobWF0Y2ggeDY3MSB3aXRoXG4gICAgICAgICAgICAgfCBgQ29sb3IgeDY3MiAtPiBjc3NfY29sb3JfdG9fanMgeDY3MlxuICAgICAgICAgICAgIHwgYEdyYWRpZW50IHg2NzMgLT4gZ3JhZGllbnRfdG9fanMgeDY3MylcbiAgICBsZXQgKHNldF9saW5lX3dpZHRoIDogY29udGV4dCAtPiBmbG9hdCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg2NzQgOiBjb250ZXh0KSAtPlxuICAgICAgICBmdW4gKHg2NzUgOiBmbG9hdCkgLT5cbiAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgKGNvbnRleHRfdG9fanMgeDY3NCkgXCJsaW5lV2lkdGhcIlxuICAgICAgICAgICAgKE9qcy5mbG9hdF90b19qcyB4Njc1KVxuICAgIGxldCAoY3JlYXRlX2xpbmVhcl9ncmFkaWVudCA6XG4gICAgICBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGdyYWRpZW50KSA9XG4gICAgICBmdW4gKHg2ODAgOiBjb250ZXh0KSAtPlxuICAgICAgICBmdW4gKHg2NzYgOiBmbG9hdCkgLT5cbiAgICAgICAgICBmdW4gKHg2NzcgOiBmbG9hdCkgLT5cbiAgICAgICAgICAgIGZ1biAoeDY3OCA6IGZsb2F0KSAtPlxuICAgICAgICAgICAgICBmdW4gKHg2NzkgOiBmbG9hdCkgLT5cbiAgICAgICAgICAgICAgICBncmFkaWVudF9vZl9qc1xuICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIChjb250ZXh0X3RvX2pzIHg2ODApIFwiY3JlYXRlTGluZWFyR3JhZGllbnRcIlxuICAgICAgICAgICAgICAgICAgICAgW3woT2pzLmZsb2F0X3RvX2pzIHg2NzYpOyhPanMuZmxvYXRfdG9fanMgeDY3Nyk7KFxuICAgICAgICAgICAgICAgICAgICAgICBPanMuZmxvYXRfdG9fanMgeDY3OCk7KE9qcy5mbG9hdF90b19qcyB4Njc5KXxdKVxuICAgIGxldCAoYWRkX2NvbG9yX3N0b3AgOiBncmFkaWVudCAtPiBmbG9hdCAtPiBjc3NfY29sb3IgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NjgzIDogZ3JhZGllbnQpIC0+XG4gICAgICAgIGZ1biAoeDY4MSA6IGZsb2F0KSAtPlxuICAgICAgICAgIGZ1biAoeDY4MiA6IGNzc19jb2xvcikgLT5cbiAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAoT2pzLmNhbGwgKGdyYWRpZW50X3RvX2pzIHg2ODMpIFwiYWRkQ29sb3JTdG9wXCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLmZsb2F0X3RvX2pzIHg2ODEpOyhjc3NfY29sb3JfdG9fanMgeDY4Mil8XSlcbiAgICBsZXQgKGJlZ2luX3BhdGggOiBjb250ZXh0IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDY4NCA6IGNvbnRleHQpIC0+XG4gICAgICAgIGlnbm9yZSAoT2pzLmNhbGwgKGNvbnRleHRfdG9fanMgeDY4NCkgXCJiZWdpblBhdGhcIiBbfHxdKVxuICAgIGxldCAoY2xvc2VfcGF0aCA6IGNvbnRleHQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4Njg1IDogY29udGV4dCkgLT5cbiAgICAgICAgaWdub3JlIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4Njg1KSBcImNsb3NlUGF0aFwiIFt8fF0pXG4gICAgbGV0IChhcmMgOiBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQpXG4gICAgICA9XG4gICAgICBmdW4gKHg2OTEgOiBjb250ZXh0KSAtPlxuICAgICAgICBmdW4gKHg2ODYgOiBmbG9hdCkgLT5cbiAgICAgICAgICBmdW4gKHg2ODcgOiBmbG9hdCkgLT5cbiAgICAgICAgICAgIGZ1biAoeDY4OCA6IGZsb2F0KSAtPlxuICAgICAgICAgICAgICBmdW4gKHg2ODkgOiBmbG9hdCkgLT5cbiAgICAgICAgICAgICAgICBmdW4gKHg2OTAgOiBmbG9hdCkgLT5cbiAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAoT2pzLmNhbGwgKGNvbnRleHRfdG9fanMgeDY5MSkgXCJhcmNcIlxuICAgICAgICAgICAgICAgICAgICAgICBbfChPanMuZmxvYXRfdG9fanMgeDY4Nik7KE9qcy5mbG9hdF90b19qcyB4Njg3KTsoXG4gICAgICAgICAgICAgICAgICAgICAgICAgT2pzLmZsb2F0X3RvX2pzIHg2ODgpOyhPanMuZmxvYXRfdG9fanMgeDY4OSk7KFxuICAgICAgICAgICAgICAgICAgICAgICAgIE9qcy5mbG9hdF90b19qcyB4NjkwKXxdKVxuICAgIGxldCAobW92ZV90byA6IGNvbnRleHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4Njk0IDogY29udGV4dCkgLT5cbiAgICAgICAgZnVuICh4NjkyIDogZmxvYXQpIC0+XG4gICAgICAgICAgZnVuICh4NjkzIDogZmxvYXQpIC0+XG4gICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgKE9qcy5jYWxsIChjb250ZXh0X3RvX2pzIHg2OTQpIFwibW92ZVRvXCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLmZsb2F0X3RvX2pzIHg2OTIpOyhPanMuZmxvYXRfdG9fanMgeDY5Myl8XSlcbiAgICBsZXQgKGxpbmVfdG8gOiBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDY5NyA6IGNvbnRleHQpIC0+XG4gICAgICAgIGZ1biAoeDY5NSA6IGZsb2F0KSAtPlxuICAgICAgICAgIGZ1biAoeDY5NiA6IGZsb2F0KSAtPlxuICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICAgIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4Njk3KSBcImxpbmVUb1wiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5mbG9hdF90b19qcyB4Njk1KTsoT2pzLmZsb2F0X3RvX2pzIHg2OTYpfF0pXG4gICAgbGV0IChmaWxsIDogY29udGV4dCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg2OTggOiBjb250ZXh0KSAtPlxuICAgICAgICBpZ25vcmUgKE9qcy5jYWxsIChjb250ZXh0X3RvX2pzIHg2OTgpIFwiZmlsbFwiIFt8fF0pXG4gICAgbGV0IChzdHJva2UgOiBjb250ZXh0IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDY5OSA6IGNvbnRleHQpIC0+XG4gICAgICAgIGlnbm9yZSAoT2pzLmNhbGwgKGNvbnRleHRfdG9fanMgeDY5OSkgXCJzdHJva2VcIiBbfHxdKVxuICAgIGxldCAoc3Ryb2tlX3JlY3QgOiBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDcwNCA6IGNvbnRleHQpIC0+XG4gICAgICAgIGZ1biAoeDcwMCA6IGZsb2F0KSAtPlxuICAgICAgICAgIGZ1biAoeDcwMSA6IGZsb2F0KSAtPlxuICAgICAgICAgICAgZnVuICh4NzAyIDogZmxvYXQpIC0+XG4gICAgICAgICAgICAgIGZ1biAoeDcwMyA6IGZsb2F0KSAtPlxuICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIChjb250ZXh0X3RvX2pzIHg3MDQpIFwic3Ryb2tlUmVjdFwiXG4gICAgICAgICAgICAgICAgICAgICBbfChPanMuZmxvYXRfdG9fanMgeDcwMCk7KE9qcy5mbG9hdF90b19qcyB4NzAxKTsoXG4gICAgICAgICAgICAgICAgICAgICAgIE9qcy5mbG9hdF90b19qcyB4NzAyKTsoT2pzLmZsb2F0X3RvX2pzIHg3MDMpfF0pXG4gICAgbGV0IChmaWxsX3JlY3QgOiBjb250ZXh0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDcwOSA6IGNvbnRleHQpIC0+XG4gICAgICAgIGZ1biAoeDcwNSA6IGZsb2F0KSAtPlxuICAgICAgICAgIGZ1biAoeDcwNiA6IGZsb2F0KSAtPlxuICAgICAgICAgICAgZnVuICh4NzA3IDogZmxvYXQpIC0+XG4gICAgICAgICAgICAgIGZ1biAoeDcwOCA6IGZsb2F0KSAtPlxuICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgKE9qcy5jYWxsIChjb250ZXh0X3RvX2pzIHg3MDkpIFwiZmlsbFJlY3RcIlxuICAgICAgICAgICAgICAgICAgICAgW3woT2pzLmZsb2F0X3RvX2pzIHg3MDUpOyhPanMuZmxvYXRfdG9fanMgeDcwNik7KFxuICAgICAgICAgICAgICAgICAgICAgICBPanMuZmxvYXRfdG9fanMgeDcwNyk7KE9qcy5mbG9hdF90b19qcyB4NzA4KXxdKVxuICAgIGxldCAoc2V0X2ZvbnQgOiBjb250ZXh0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg3MTAgOiBjb250ZXh0KSAtPlxuICAgICAgICBmdW4gKHg3MTEgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIChjb250ZXh0X3RvX2pzIHg3MTApIFwiZm9udFwiXG4gICAgICAgICAgICAoT2pzLnN0cmluZ190b19qcyB4NzExKVxuICAgIGxldCAoZmlsbF90ZXh0IDogY29udGV4dCAtPiBzdHJpbmcgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NzE1IDogY29udGV4dCkgLT5cbiAgICAgICAgZnVuICh4NzEyIDogc3RyaW5nKSAtPlxuICAgICAgICAgIGZ1biAoeDcxMyA6IGZsb2F0KSAtPlxuICAgICAgICAgICAgZnVuICh4NzE0IDogZmxvYXQpIC0+XG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4NzE1KSBcImZpbGxUZXh0XCJcbiAgICAgICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg3MTIpOyhPanMuZmxvYXRfdG9fanMgeDcxMyk7KFxuICAgICAgICAgICAgICAgICAgICAgT2pzLmZsb2F0X3RvX2pzIHg3MTQpfF0pXG4gICAgbGV0IChzdHJva2VfdGV4dCA6IGNvbnRleHQgLT4gc3RyaW5nIC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDcxOSA6IGNvbnRleHQpIC0+XG4gICAgICAgIGZ1biAoeDcxNiA6IHN0cmluZykgLT5cbiAgICAgICAgICBmdW4gKHg3MTcgOiBmbG9hdCkgLT5cbiAgICAgICAgICAgIGZ1biAoeDcxOCA6IGZsb2F0KSAtPlxuICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAoT2pzLmNhbGwgKGNvbnRleHRfdG9fanMgeDcxOSkgXCJzdHJva2VUZXh0XCJcbiAgICAgICAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg3MTYpOyhPanMuZmxvYXRfdG9fanMgeDcxNyk7KFxuICAgICAgICAgICAgICAgICAgICAgT2pzLmZsb2F0X3RvX2pzIHg3MTgpfF0pXG4gICAgbW9kdWxlIFRleHRNZXRyaWNzID1cbiAgICAgIHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBPanMudFxuICAgICAgICBsZXQgcmVjIHRfb2ZfanMgOiBPanMudCAtPiB0ID0gZnVuICh4NzIxIDogT2pzLnQpIC0+IHg3MjFcbiAgICAgICAgYW5kIHRfdG9fanMgOiB0IC0+IE9qcy50ID0gZnVuICh4NzIwIDogT2pzLnQpIC0+IHg3MjBcbiAgICAgICAgbGV0ICh3aWR0aCA6IHQgLT4gZmxvYXQpID1cbiAgICAgICAgICBmdW4gKHg3MjIgOiB0KSAtPlxuICAgICAgICAgICAgT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDcyMikgXCJ3aWR0aFwiKVxuICAgICAgZW5kXG4gICAgbGV0IChtZWFzdXJlX3RleHQgOiBjb250ZXh0IC0+IHN0cmluZyAtPiBUZXh0TWV0cmljcy50KSA9XG4gICAgICBmdW4gKHg3MjQgOiBjb250ZXh0KSAtPlxuICAgICAgICBmdW4gKHg3MjMgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgVGV4dE1ldHJpY3MudF9vZl9qc1xuICAgICAgICAgICAgKE9qcy5jYWxsIChjb250ZXh0X3RvX2pzIHg3MjQpIFwibWVhc3VyZVRleHRcIlxuICAgICAgICAgICAgICAgW3woT2pzLnN0cmluZ190b19qcyB4NzIzKXxdKVxuICAgIGxldCAocm90YXRlIDogY29udGV4dCAtPiBmbG9hdCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg3MjYgOiBjb250ZXh0KSAtPlxuICAgICAgICBmdW4gKHg3MjUgOiBmbG9hdCkgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4NzI2KSBcInJvdGF0ZVwiXG4gICAgICAgICAgICAgICBbfChPanMuZmxvYXRfdG9fanMgeDcyNSl8XSlcbiAgICBsZXQgKHRyYW5zbGF0ZSA6IGNvbnRleHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NzI5IDogY29udGV4dCkgLT5cbiAgICAgICAgZnVuICh4NzI3IDogZmxvYXQpIC0+XG4gICAgICAgICAgZnVuICh4NzI4IDogZmxvYXQpIC0+XG4gICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgKE9qcy5jYWxsIChjb250ZXh0X3RvX2pzIHg3MjkpIFwidHJhbnNsYXRlXCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLmZsb2F0X3RvX2pzIHg3MjcpOyhPanMuZmxvYXRfdG9fanMgeDcyOCl8XSlcbiAgICBsZXQgKHNjYWxlIDogY29udGV4dCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg3MzIgOiBjb250ZXh0KSAtPlxuICAgICAgICBmdW4gKHg3MzAgOiBmbG9hdCkgLT5cbiAgICAgICAgICBmdW4gKHg3MzEgOiBmbG9hdCkgLT5cbiAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAoT2pzLmNhbGwgKGNvbnRleHRfdG9fanMgeDczMikgXCJzY2FsZVwiXG4gICAgICAgICAgICAgICAgIFt8KE9qcy5mbG9hdF90b19qcyB4NzMwKTsoT2pzLmZsb2F0X3RvX2pzIHg3MzEpfF0pXG4gICAgbGV0IChjbGVhcl9yZWN0IDogY29udGV4dCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg3MzcgOiBjb250ZXh0KSAtPlxuICAgICAgICBmdW4gKHg3MzMgOiBmbG9hdCkgLT5cbiAgICAgICAgICBmdW4gKHg3MzQgOiBmbG9hdCkgLT5cbiAgICAgICAgICAgIGZ1biAoeDczNSA6IGZsb2F0KSAtPlxuICAgICAgICAgICAgICBmdW4gKHg3MzYgOiBmbG9hdCkgLT5cbiAgICAgICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgICAgIChPanMuY2FsbCAoY29udGV4dF90b19qcyB4NzM3KSBcImNsZWFyUmVjdFwiXG4gICAgICAgICAgICAgICAgICAgICBbfChPanMuZmxvYXRfdG9fanMgeDczMyk7KE9qcy5mbG9hdF90b19qcyB4NzM0KTsoXG4gICAgICAgICAgICAgICAgICAgICAgIE9qcy5mbG9hdF90b19qcyB4NzM1KTsoT2pzLmZsb2F0X3RvX2pzIHg3MzYpfF0pXG4gIGVuZFxubW9kdWxlIFBlcmZvcm1hbmNlID1cbiAgc3RydWN0XG4gICAgbGV0IChub3cgOiB1bml0IC0+IGZsb2F0KSA9XG4gICAgICBmdW4gKCkgLT5cbiAgICAgICAgT2pzLmZsb2F0X29mX2pzXG4gICAgICAgICAgKE9qcy5jYWxsIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcInBlcmZvcm1hbmNlXCIpIFwibm93XCIgW3x8XSlcbiAgZW5kXG5tb2R1bGUgQ29uc29sZSA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IE9qcy50XG4gICAgbGV0IHJlYyB0X29mX2pzIDogT2pzLnQgLT4gdCA9IGZ1biAoeDczOSA6IE9qcy50KSAtPiB4NzM5XG4gICAgYW5kIHRfdG9fanMgOiB0IC0+IE9qcy50ID0gZnVuICh4NzM4IDogT2pzLnQpIC0+IHg3MzhcbiAgICBsZXQgKGxvZyA6IHQgLT4gT2pzLnQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NzQxIDogdCkgLT5cbiAgICAgICAgZnVuICh4NzQwIDogT2pzLnQpIC0+IGlnbm9yZSAoT2pzLmNhbGwgKHRfdG9fanMgeDc0MSkgXCJsb2dcIiBbfHg3NDB8XSlcbiAgICBsZXQgKHRpbWUgOiB0IC0+IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg3NDMgOiB0KSAtPlxuICAgICAgICBmdW4gKHg3NDIgOiBzdHJpbmcpIC0+XG4gICAgICAgICAgaWdub3JlIChPanMuY2FsbCAodF90b19qcyB4NzQzKSBcInRpbWVcIiBbfChPanMuc3RyaW5nX3RvX2pzIHg3NDIpfF0pXG4gICAgbGV0ICh0aW1lX2VuZCA6IHQgLT4gc3RyaW5nIC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDc0NSA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDc0NCA6IHN0cmluZykgLT5cbiAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4NzQ1KSBcInRpbWVFbmRcIiBbfChPanMuc3RyaW5nX3RvX2pzIHg3NDQpfF0pXG4gIGVuZFxubGV0IChjb25zb2xlIDogQ29uc29sZS50KSA9XG4gIENvbnNvbGUudF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpIE9qcy5nbG9iYWwgXCJjb25zb2xlXCIpXG5tb2R1bGUgVWludDhBcnJheSA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdCA9IEFycmF5QnVmZmVyLnRcbiAgICBsZXQgcmVjIHRfb2ZfanMgOiBPanMudCAtPiB0ID1cbiAgICAgIGZ1biAoeDc0NyA6IE9qcy50KSAtPiBBcnJheUJ1ZmZlci50X29mX2pzIHg3NDdcbiAgICBhbmQgdF90b19qcyA6IHQgLT4gT2pzLnQgPVxuICAgICAgZnVuICh4NzQ2IDogQXJyYXlCdWZmZXIudCkgLT4gQXJyYXlCdWZmZXIudF90b19qcyB4NzQ2XG4gICAgbGV0IChmcm9tX2J1ZmZlciA6IEFycmF5QnVmZmVyLnQgLT4gdCkgPVxuICAgICAgZnVuICh4NzQ4IDogQXJyYXlCdWZmZXIudCkgLT5cbiAgICAgICAgdF9vZl9qc1xuICAgICAgICAgIChPanMubmV3X29iaiAoT2pzLmdldF9wcm9wX2FzY2lpIE9qcy5nbG9iYWwgXCJVaW50OEFycmF5XCIpXG4gICAgICAgICAgICAgW3woQXJyYXlCdWZmZXIudF90b19qcyB4NzQ4KXxdKVxuICAgIGxldCAoY3JlYXRlIDogaW50IC0+IHQpID1cbiAgICAgIGZ1biAoeDc0OSA6IGludCkgLT5cbiAgICAgICAgdF9vZl9qc1xuICAgICAgICAgIChPanMubmV3X29iaiAoT2pzLmdldF9wcm9wX2FzY2lpIE9qcy5nbG9iYWwgXCJVaW50OEFycmF5XCIpXG4gICAgICAgICAgICAgW3woT2pzLmludF90b19qcyB4NzQ5KXxdKVxuICAgIGxldCAoc2V0IDogdCAtPiBpbnQgYXJyYXkgLT4gaW50IC0+IHVuaXQpID1cbiAgICAgIGZ1biAoeDc1MyA6IHQpIC0+XG4gICAgICAgIGZ1biAoeDc1MCA6IGludCBhcnJheSkgLT5cbiAgICAgICAgICBmdW4gKHg3NTIgOiBpbnQpIC0+XG4gICAgICAgICAgICBpZ25vcmVcbiAgICAgICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg3NTMpIFwic2V0XCJcbiAgICAgICAgICAgICAgICAgW3woT2pzLmFycmF5X3RvX2pzIE9qcy5pbnRfdG9fanMgeDc1MCk7KE9qcy5pbnRfdG9fanMgeDc1Mil8XSlcbiAgICBsZXQgKGxlbmd0aCA6IHQgLT4gaW50KSA9XG4gICAgICBmdW4gKHg3NTQgOiB0KSAtPlxuICAgICAgICBPanMuaW50X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDc1NCkgXCJsZW5ndGhcIilcbiAgICBsZXQgKHJhbmRvbSA6IHQgLT4gdW5pdCkgPVxuICAgICAgZnVuICh4NzU1IDogdCkgLT5cbiAgICAgICAgaWdub3JlXG4gICAgICAgICAgKE9qcy5jYWxsXG4gICAgICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSAoT2pzLmdldF9wcm9wX2FzY2lpIE9qcy5nbG9iYWwgXCJ3aW5kb3dcIilcbiAgICAgICAgICAgICAgICBcImNyeXB0b1wiKSBcImdldFJhbmRvbVZhbHVlc1wiIFt8KHRfdG9fanMgeDc1NSl8XSlcbiAgICBsZXQgKHRvX2FycmF5IDogdCAtPiBpbnQgYXJyYXkpID1cbiAgICAgIGZ1biAoeDc1NiA6IHQpIC0+IE9qcy5hcnJheV9vZl9qcyBPanMuaW50X29mX2pzICh0X3RvX2pzIHg3NTYpXG4gICAgbGV0IGdldCBhIGkgPSBPanMuaW50X29mX2pzIChPanMuYXJyYXlfZ2V0ICh0X3RvX2pzIGEpIGkpXG4gICAgbGV0IChmcm9tIDogT2pzLnQgLT4gKE9qcy50IC0+IGludCkgLT4gdCkgPVxuICAgICAgZnVuICh4NzU4IDogT2pzLnQpIC0+XG4gICAgICAgIGZ1biAoeDc1OSA6IE9qcy50IC0+IGludCkgLT5cbiAgICAgICAgICB0X29mX2pzXG4gICAgICAgICAgICAoT2pzLmNhbGwgKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwiVWludDhBcnJheVwiKSBcImZyb21cIlxuICAgICAgICAgICAgICAgW3x4NzU4OyhPanMuZnVuX3RvX2pzIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuICh4NzYwIDogT2pzLnQpIC0+IE9qcy5pbnRfdG9fanMgKHg3NTkgeDc2MCkpKXxdKVxuICBlbmRcbm1vZHVsZSBPYmplY3RVUkwgPVxuICBzdHJ1Y3RcbiAgICBsZXQgKG9mX2Jsb2IgOiBCbG9iLnQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHg3NjEgOiBCbG9iLnQpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanNcbiAgICAgICAgICAoT2pzLmNhbGwgKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwiVVJMXCIpIFwiY3JlYXRlT2JqZWN0VVJMXCJcbiAgICAgICAgICAgICBbfChCbG9iLnRfdG9fanMgeDc2MSl8XSlcbiAgICBsZXQgKG9mX2ZpbGUgOiBGaWxlLnQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHg3NjIgOiBGaWxlLnQpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanNcbiAgICAgICAgICAoT2pzLmNhbGwgKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwiVVJMXCIpIFwiY3JlYXRlT2JqZWN0VVJMXCJcbiAgICAgICAgICAgICBbfChGaWxlLnRfdG9fanMgeDc2Mil8XSlcbiAgICBsZXQgKHJldm9rZSA6IHN0cmluZyAtPiB1bml0KSA9XG4gICAgICBmdW4gKHg3NjMgOiBzdHJpbmcpIC0+XG4gICAgICAgIGlnbm9yZVxuICAgICAgICAgIChPanMuY2FsbCAoT2pzLmdldF9wcm9wX2FzY2lpIE9qcy5nbG9iYWwgXCJVUkxcIikgXCJyZXZva2VPYmplY3RVUkxcIlxuICAgICAgICAgICAgIFt8KE9qcy5zdHJpbmdfdG9fanMgeDc2Myl8XSlcbiAgZW5kXG5tb2R1bGUgU3ZnID1cbiAgc3RydWN0XG4gICAgbW9kdWxlIExlbmd0aCA9XG4gICAgICBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gT2pzLnRcbiAgICAgICAgbGV0IHJlYyB0X29mX2pzIDogT2pzLnQgLT4gdCA9IGZ1biAoeDc2NSA6IE9qcy50KSAtPiB4NzY1XG4gICAgICAgIGFuZCB0X3RvX2pzIDogdCAtPiBPanMudCA9IGZ1biAoeDc2NCA6IE9qcy50KSAtPiB4NzY0XG4gICAgICAgIGxldCAodW5pdF90eXBlIDogdCAtPiBpbnQpID1cbiAgICAgICAgICBmdW4gKHg3NjYgOiB0KSAtPlxuICAgICAgICAgICAgT2pzLmludF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg3NjYpIFwidW5pdFR5cGVcIilcbiAgICAgICAgbGV0ICh2YWx1ZSA6IHQgLT4gZmxvYXQpID1cbiAgICAgICAgICBmdW4gKHg3NjcgOiB0KSAtPlxuICAgICAgICAgICAgT2pzLmZsb2F0X29mX2pzIChPanMuZ2V0X3Byb3BfYXNjaWkgKHRfdG9fanMgeDc2NykgXCJ2YWx1ZVwiKVxuICAgICAgICBsZXQgKHZhbHVlX2FzX3N0cmluZyA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICAgICAgZnVuICh4NzY4IDogdCkgLT5cbiAgICAgICAgICAgIE9qcy5zdHJpbmdfb2ZfanNcbiAgICAgICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NzY4KSBcInZhbHVlQXNTdHJpbmdcIilcbiAgICAgICAgbGV0ICh2YWx1ZV9pbl9zcGVjaWZpZWRfdW5pdHMgOiB0IC0+IGZsb2F0KSA9XG4gICAgICAgICAgZnVuICh4NzY5IDogdCkgLT5cbiAgICAgICAgICAgIE9qcy5mbG9hdF9vZl9qc1xuICAgICAgICAgICAgICAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg3NjkpIFwidmFsdWVJblNwZWNpZmllZFVuaXRzXCIpXG4gICAgICBlbmRcbiAgICBtb2R1bGUgQW5pbWF0ZWRMZW5ndGggPVxuICAgICAgc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IE9qcy50XG4gICAgICAgIGxldCByZWMgdF9vZl9qcyA6IE9qcy50IC0+IHQgPSBmdW4gKHg3NzEgOiBPanMudCkgLT4geDc3MVxuICAgICAgICBhbmQgdF90b19qcyA6IHQgLT4gT2pzLnQgPSBmdW4gKHg3NzAgOiBPanMudCkgLT4geDc3MFxuICAgICAgICBsZXQgKGFuaW1fdmFsIDogdCAtPiBMZW5ndGgudCkgPVxuICAgICAgICAgIGZ1biAoeDc3MiA6IHQpIC0+XG4gICAgICAgICAgICBMZW5ndGgudF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg3NzIpIFwiYW5pbVZhbFwiKVxuICAgICAgICBsZXQgKGJhc2VfdmFsIDogdCAtPiBMZW5ndGgudCkgPVxuICAgICAgICAgIGZ1biAoeDc3MyA6IHQpIC0+XG4gICAgICAgICAgICBMZW5ndGgudF9vZl9qcyAoT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg3NzMpIFwiYmFzZVZhbFwiKVxuICAgICAgZW5kXG4gIGVuZFxubW9kdWxlIEJhc2U2NCA9XG4gIHN0cnVjdFxuICAgIGxldCAoZW5jb2RlIDogSnNTdHJpbmcudCAtPiBzdHJpbmcpID1cbiAgICAgIGZ1biAoeDc3NCA6IEpzU3RyaW5nLnQpIC0+XG4gICAgICAgIE9qcy5zdHJpbmdfb2ZfanNcbiAgICAgICAgICAoT2pzLmNhbGwgKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwid2luZG93XCIpIFwiYnRvYVwiXG4gICAgICAgICAgICAgW3woSnNTdHJpbmcudF90b19qcyB4Nzc0KXxdKVxuICAgIGxldCAoZGVjb2RlIDogc3RyaW5nIC0+IEpzU3RyaW5nLnQpID1cbiAgICAgIGZ1biAoeDc3NSA6IHN0cmluZykgLT5cbiAgICAgICAgSnNTdHJpbmcudF9vZl9qc1xuICAgICAgICAgIChPanMuY2FsbCAoT2pzLmdldF9wcm9wX2FzY2lpIE9qcy5nbG9iYWwgXCJ3aW5kb3dcIikgXCJhdG9iXCJcbiAgICAgICAgICAgICBbfChPanMuc3RyaW5nX3RvX2pzIHg3NzUpfF0pXG4gIGVuZFxubW9kdWxlIEZldGNoUmVzcG9uc2UgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBPanMudFxuICAgIGxldCByZWMgdF9vZl9qcyA6IE9qcy50IC0+IHQgPSBmdW4gKHg3NzcgOiBPanMudCkgLT4geDc3N1xuICAgIGFuZCB0X3RvX2pzIDogdCAtPiBPanMudCA9IGZ1biAoeDc3NiA6IE9qcy50KSAtPiB4Nzc2XG4gICAgbGV0IChibG9iIDogdCAtPiBPanMudCBQcm9taXNlLnQpID1cbiAgICAgIGZ1biAoeDc3OCA6IHQpIC0+XG4gICAgICAgIFByb21pc2UudF9vZl9qcyAoZnVuICh4Nzc5IDogT2pzLnQpIC0+IHg3NzkpXG4gICAgICAgICAgKE9qcy5jYWxsICh0X3RvX2pzIHg3NzgpIFwiYmxvYlwiIFt8fF0pXG4gIGVuZFxubGV0IChmZXRjaCA6IHN0cmluZyAtPiBGZXRjaFJlc3BvbnNlLnQgUHJvbWlzZS50KSA9XG4gIGZ1biAoeDc4MCA6IHN0cmluZykgLT5cbiAgICBQcm9taXNlLnRfb2ZfanMgRmV0Y2hSZXNwb25zZS50X29mX2pzXG4gICAgICAoT2pzLmNhbGwgT2pzLmdsb2JhbCBcImZldGNoXCIgW3woT2pzLnN0cmluZ190b19qcyB4NzgwKXxdKVxubW9kdWxlIFRleHREZWNvZGVyID1cbiAgc3RydWN0XG4gICAgdHlwZSB0ID0gT2pzLnRcbiAgICBsZXQgcmVjIHRfb2ZfanMgOiBPanMudCAtPiB0ID0gZnVuICh4NzgzIDogT2pzLnQpIC0+IHg3ODNcbiAgICBhbmQgdF90b19qcyA6IHQgLT4gT2pzLnQgPSBmdW4gKHg3ODIgOiBPanMudCkgLT4geDc4MlxuICAgIGxldCAoY3JlYXRlIDogP2xhYmVsOnN0cmluZyAtPiB1bml0IC0+IHQpID1cbiAgICAgIGZ1biA/bGFiZWw6KHg3ODQgOiBzdHJpbmcgb3B0aW9uKSAtPlxuICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICB0X29mX2pzXG4gICAgICAgICAgICAoT2pzLm5ld19vYmpfYXJyIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcIlRleHREZWNvZGVyXCIpXG4gICAgICAgICAgICAgICAobGV0IHg3ODUgPVxuICAgICAgICAgICAgICAgICAgT2pzLm5ld19vYmogKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwiQXJyYXlcIikgW3x8XSBpblxuICAgICAgICAgICAgICAgIChtYXRjaCB4Nzg0IHdpdGhcbiAgICAgICAgICAgICAgICAgfCBTb21lIHg3ODYgLT5cbiAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAoT2pzLmNhbGwgeDc4NSBcInB1c2hcIiBbfChPanMuc3RyaW5nX3RvX2pzIHg3ODYpfF0pXG4gICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgeDc4NSkpXG4gICAgbGV0IChkZWNvZGUgOiB0IC0+IEFycmF5QnVmZmVyLnQgLT4gc3RyaW5nKSA9XG4gICAgICBmdW4gKHg3ODggOiB0KSAtPlxuICAgICAgICBmdW4gKHg3ODcgOiBBcnJheUJ1ZmZlci50KSAtPlxuICAgICAgICAgIE9qcy5zdHJpbmdfb2ZfanNcbiAgICAgICAgICAgIChPanMuY2FsbCAodF90b19qcyB4Nzg4KSBcImRlY29kZVwiIFt8KEFycmF5QnVmZmVyLnRfdG9fanMgeDc4Nyl8XSlcbiAgZW5kXG5tb2R1bGUgTmF2aWdhdG9yID1cbiAgc3RydWN0XG4gICAgbW9kdWxlIEF1dGhlbnRpY2F0b3JBdHRlc3RhdGlvblJlc3BvbnNlID1cbiAgICAgIHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBPanMudFxuICAgICAgICBsZXQgcmVjIHRfb2ZfanMgOiBPanMudCAtPiB0ID0gZnVuICh4NzkwIDogT2pzLnQpIC0+IHg3OTBcbiAgICAgICAgYW5kIHRfdG9fanMgOiB0IC0+IE9qcy50ID0gZnVuICh4Nzg5IDogT2pzLnQpIC0+IHg3ODlcbiAgICAgICAgbGV0IChjbGllbnRfZGF0YV9qc29uIDogdCAtPiBBcnJheUJ1ZmZlci50KSA9XG4gICAgICAgICAgZnVuICh4NzkxIDogdCkgLT5cbiAgICAgICAgICAgIEFycmF5QnVmZmVyLnRfb2ZfanNcbiAgICAgICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NzkxKSBcImNsaWVudERhdGFKU09OXCIpXG4gICAgICAgIGxldCAoYXR0ZXN0YXRpb25fb2JqZWN0IDogdCAtPiBBcnJheUJ1ZmZlci50KSA9XG4gICAgICAgICAgZnVuICh4NzkyIDogdCkgLT5cbiAgICAgICAgICAgIEFycmF5QnVmZmVyLnRfb2ZfanNcbiAgICAgICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4NzkyKSBcImF0dGVzdGF0aW9uT2JqZWN0XCIpXG4gICAgICBlbmRcbiAgICBtb2R1bGUgQXV0aGVudGljYXRvckFzc2VydGlvblJlc3BvbnNlID1cbiAgICAgIHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBPanMudFxuICAgICAgICBsZXQgcmVjIHRfb2ZfanMgOiBPanMudCAtPiB0ID0gZnVuICh4Nzk0IDogT2pzLnQpIC0+IHg3OTRcbiAgICAgICAgYW5kIHRfdG9fanMgOiB0IC0+IE9qcy50ID0gZnVuICh4NzkzIDogT2pzLnQpIC0+IHg3OTNcbiAgICAgICAgbGV0IChjbGllbnRfZGF0YV9qc29uIDogdCAtPiBBcnJheUJ1ZmZlci50KSA9XG4gICAgICAgICAgZnVuICh4Nzk1IDogdCkgLT5cbiAgICAgICAgICAgIEFycmF5QnVmZmVyLnRfb2ZfanNcbiAgICAgICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4Nzk1KSBcImNsaWVudERhdGFKU09OXCIpXG4gICAgICAgIGxldCAoYXV0aGVudGljYXRvcl9kYXRhIDogdCAtPiBBcnJheUJ1ZmZlci50KSA9XG4gICAgICAgICAgZnVuICh4Nzk2IDogdCkgLT5cbiAgICAgICAgICAgIEFycmF5QnVmZmVyLnRfb2ZfanNcbiAgICAgICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4Nzk2KSBcImF1dGhlbnRpY2F0b3JEYXRhXCIpXG4gICAgICAgIGxldCAoc2lnbmF0dXJlIDogdCAtPiBBcnJheUJ1ZmZlci50KSA9XG4gICAgICAgICAgZnVuICh4Nzk3IDogdCkgLT5cbiAgICAgICAgICAgIEFycmF5QnVmZmVyLnRfb2ZfanNcbiAgICAgICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4Nzk3KSBcInNpZ25hdHVyZVwiKVxuICAgICAgICBsZXQgKHVzZXJfaGFuZGxlIDogdCAtPiBBcnJheUJ1ZmZlci50KSA9XG4gICAgICAgICAgZnVuICh4Nzk4IDogdCkgLT5cbiAgICAgICAgICAgIEFycmF5QnVmZmVyLnRfb2ZfanNcbiAgICAgICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4Nzk4KSBcInVzZXJIYW5kbGVcIilcbiAgICAgIGVuZFxuICAgIG1vZHVsZSBQdWJsaWNLZXlDcmVkZW50aWFsID1cbiAgICAgIHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBPanMudFxuICAgICAgICBsZXQgcmVjIHRfb2ZfanMgOiBPanMudCAtPiB0ID0gZnVuICh4ODAwIDogT2pzLnQpIC0+IHg4MDBcbiAgICAgICAgYW5kIHRfdG9fanMgOiB0IC0+IE9qcy50ID0gZnVuICh4Nzk5IDogT2pzLnQpIC0+IHg3OTlcbiAgICAgICAgbGV0ICh0eXBlXyA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICAgICAgZnVuICh4ODAxIDogdCkgLT5cbiAgICAgICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4ODAxKSBcInR5cGVcIilcbiAgICAgICAgbGV0IChpZCA6IHQgLT4gc3RyaW5nKSA9XG4gICAgICAgICAgZnVuICh4ODAyIDogdCkgLT5cbiAgICAgICAgICAgIE9qcy5zdHJpbmdfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4ODAyKSBcImlkXCIpXG4gICAgICAgIGxldCAocmF3X2lkIDogdCAtPiBBcnJheUJ1ZmZlci50KSA9XG4gICAgICAgICAgZnVuICh4ODAzIDogdCkgLT5cbiAgICAgICAgICAgIEFycmF5QnVmZmVyLnRfb2ZfanMgKE9qcy5nZXRfcHJvcF9hc2NpaSAodF90b19qcyB4ODAzKSBcInJhd0lkXCIpXG4gICAgICAgIGxldCAocmVzcG9uc2UgOiB0IC0+IE9qcy50KSA9XG4gICAgICAgICAgZnVuICh4ODA0IDogdCkgLT4gT2pzLmdldF9wcm9wX2FzY2lpICh0X3RvX2pzIHg4MDQpIFwicmVzcG9uc2VcIlxuICAgICAgZW5kXG4gICAgbW9kdWxlIENyZWRlbnRpYWwgPVxuICAgICAgc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IE9qcy50XG4gICAgICAgIGxldCByZWMgdF9vZl9qcyA6IE9qcy50IC0+IHQgPSBmdW4gKHg4MDYgOiBPanMudCkgLT4geDgwNlxuICAgICAgICBhbmQgdF90b19qcyA6IHQgLT4gT2pzLnQgPSBmdW4gKHg4MDUgOiBPanMudCkgLT4geDgwNVxuICAgICAgICB0eXBlIHJwX29wdGlvbnMgPSBPanMudFxuICAgICAgICBsZXQgcmVjIHJwX29wdGlvbnNfb2ZfanMgOiBPanMudCAtPiBycF9vcHRpb25zID1cbiAgICAgICAgICBmdW4gKHg4MDggOiBPanMudCkgLT4geDgwOFxuICAgICAgICBhbmQgcnBfb3B0aW9uc190b19qcyA6IHJwX29wdGlvbnMgLT4gT2pzLnQgPVxuICAgICAgICAgIGZ1biAoeDgwNyA6IE9qcy50KSAtPiB4ODA3XG4gICAgICAgIGxldCAocnBfb3B0aW9ucyA6ID9pZDpzdHJpbmcgLT4gP25hbWU6c3RyaW5nIC0+IHVuaXQgLT4gcnBfb3B0aW9ucykgPVxuICAgICAgICAgIGZ1biA/aWQ6KHg4MDkgOiBzdHJpbmcgb3B0aW9uKSAtPlxuICAgICAgICAgICAgZnVuID9uYW1lOih4ODEwIDogc3RyaW5nIG9wdGlvbikgLT5cbiAgICAgICAgICAgICAgZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgbGV0IHg4MTEgPSBPanMuZW1wdHlfb2JqICgpIGluXG4gICAgICAgICAgICAgICAgKG1hdGNoIHg4MDkgd2l0aFxuICAgICAgICAgICAgICAgICB8IFNvbWUgeDgxMyAtPlxuICAgICAgICAgICAgICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIHg4MTEgXCJpZFwiIChPanMuc3RyaW5nX3RvX2pzIHg4MTMpXG4gICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgKG1hdGNoIHg4MTAgd2l0aFxuICAgICAgICAgICAgICAgICB8IFNvbWUgeDgxMiAtPlxuICAgICAgICAgICAgICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIHg4MTEgXCJuYW1lXCIgKE9qcy5zdHJpbmdfdG9fanMgeDgxMilcbiAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICBycF9vcHRpb25zX29mX2pzIHg4MTFcbiAgICAgICAgdHlwZSB1c2VyX29wdGlvbnMgPSBPanMudFxuICAgICAgICBsZXQgcmVjIHVzZXJfb3B0aW9uc19vZl9qcyA6IE9qcy50IC0+IHVzZXJfb3B0aW9ucyA9XG4gICAgICAgICAgZnVuICh4ODE1IDogT2pzLnQpIC0+IHg4MTVcbiAgICAgICAgYW5kIHVzZXJfb3B0aW9uc190b19qcyA6IHVzZXJfb3B0aW9ucyAtPiBPanMudCA9XG4gICAgICAgICAgZnVuICh4ODE0IDogT2pzLnQpIC0+IHg4MTRcbiAgICAgICAgbGV0ICh1c2VyX29wdGlvbnMgOlxuICAgICAgICAgID9pZDpBcnJheUJ1ZmZlci50IC0+XG4gICAgICAgICAgICA/bmFtZTpzdHJpbmcgLT4gP2Rpc3BsYXlfbmFtZTpzdHJpbmcgLT4gdW5pdCAtPiB1c2VyX29wdGlvbnMpXG4gICAgICAgICAgPVxuICAgICAgICAgIGZ1biA/aWQ6KHg4MTYgOiBBcnJheUJ1ZmZlci50IG9wdGlvbikgLT5cbiAgICAgICAgICAgIGZ1biA/bmFtZTooeDgxNyA6IHN0cmluZyBvcHRpb24pIC0+XG4gICAgICAgICAgICAgIGZ1biA/ZGlzcGxheV9uYW1lOih4ODE4IDogc3RyaW5nIG9wdGlvbikgLT5cbiAgICAgICAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgIGxldCB4ODE5ID0gT2pzLmVtcHR5X29iaiAoKSBpblxuICAgICAgICAgICAgICAgICAgKG1hdGNoIHg4MTYgd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgU29tZSB4ODIyIC0+XG4gICAgICAgICAgICAgICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSB4ODE5IFwiaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIChBcnJheUJ1ZmZlci50X3RvX2pzIHg4MjIpXG4gICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgIChtYXRjaCB4ODE3IHdpdGhcbiAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDgyMSAtPlxuICAgICAgICAgICAgICAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgeDgxOSBcIm5hbWVcIiAoT2pzLnN0cmluZ190b19qcyB4ODIxKVxuICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICAobWF0Y2ggeDgxOCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBTb21lIHg4MjAgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIHg4MTkgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5zdHJpbmdfdG9fanMgeDgyMClcbiAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgdXNlcl9vcHRpb25zX29mX2pzIHg4MTlcbiAgICAgICAgdHlwZSBrZXlfcGFyYW0gPSBPanMudFxuICAgICAgICBsZXQgcmVjIGtleV9wYXJhbV9vZl9qcyA6IE9qcy50IC0+IGtleV9wYXJhbSA9XG4gICAgICAgICAgZnVuICh4ODI0IDogT2pzLnQpIC0+IHg4MjRcbiAgICAgICAgYW5kIGtleV9wYXJhbV90b19qcyA6IGtleV9wYXJhbSAtPiBPanMudCA9IGZ1biAoeDgyMyA6IE9qcy50KSAtPiB4ODIzXG4gICAgICAgIGxldCAoa2V5X3BhcmFtIDogP3R5cGVfOnN0cmluZyAtPiA/YWxnOmludCAtPiB1bml0IC0+IGtleV9wYXJhbSkgPVxuICAgICAgICAgIGZ1biA/dHlwZV86KHg4MjUgOiBzdHJpbmcgb3B0aW9uKSAtPlxuICAgICAgICAgICAgZnVuID9hbGc6KHg4MjYgOiBpbnQgb3B0aW9uKSAtPlxuICAgICAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICBsZXQgeDgyNyA9IE9qcy5lbXB0eV9vYmogKCkgaW5cbiAgICAgICAgICAgICAgICAobWF0Y2ggeDgyNSB3aXRoXG4gICAgICAgICAgICAgICAgIHwgU29tZSB4ODI5IC0+XG4gICAgICAgICAgICAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgeDgyNyBcInR5cGVcIiAoT2pzLnN0cmluZ190b19qcyB4ODI5KVxuICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgIChtYXRjaCB4ODI2IHdpdGhcbiAgICAgICAgICAgICAgICAgfCBTb21lIHg4MjggLT5cbiAgICAgICAgICAgICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSB4ODI3IFwiYWxnXCIgKE9qcy5pbnRfdG9fanMgeDgyOClcbiAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICBrZXlfcGFyYW1fb2ZfanMgeDgyN1xuICAgICAgICB0eXBlIGF1dGhlbnRpY2F0b3Jfb3B0aW9ucyA9IE9qcy50XG4gICAgICAgIGxldCByZWMgYXV0aGVudGljYXRvcl9vcHRpb25zX29mX2pzIDogT2pzLnQgLT4gYXV0aGVudGljYXRvcl9vcHRpb25zXG4gICAgICAgICAgPSBmdW4gKHg4MzEgOiBPanMudCkgLT4geDgzMVxuICAgICAgICBhbmQgYXV0aGVudGljYXRvcl9vcHRpb25zX3RvX2pzIDogYXV0aGVudGljYXRvcl9vcHRpb25zIC0+IE9qcy50ID1cbiAgICAgICAgICBmdW4gKHg4MzAgOiBPanMudCkgLT4geDgzMFxuICAgICAgICBsZXQgKGF1dGhlbnRpY2F0b3Jfb3B0aW9ucyA6XG4gICAgICAgICAgP2F1dGhlbnRpY2F0b3JfYXR0YWNobWVudDpzdHJpbmcgLT5cbiAgICAgICAgICAgID9yZXNpZGVudF9rZXk6c3RyaW5nIC0+XG4gICAgICAgICAgICAgID9yZXF1aXJlX3Jlc2lkZW50X2tleTpib29sIC0+XG4gICAgICAgICAgICAgICAgP3VzZXJfdmVyaWZpY2F0aW9uOnN0cmluZyAtPiB1bml0IC0+IGF1dGhlbnRpY2F0b3Jfb3B0aW9ucylcbiAgICAgICAgICA9XG4gICAgICAgICAgZnVuID9hdXRoZW50aWNhdG9yX2F0dGFjaG1lbnQ6KHg4MzIgOiBzdHJpbmcgb3B0aW9uKSAtPlxuICAgICAgICAgICAgZnVuID9yZXNpZGVudF9rZXk6KHg4MzMgOiBzdHJpbmcgb3B0aW9uKSAtPlxuICAgICAgICAgICAgICBmdW4gP3JlcXVpcmVfcmVzaWRlbnRfa2V5Oih4ODM0IDogYm9vbCBvcHRpb24pIC0+XG4gICAgICAgICAgICAgICAgZnVuID91c2VyX3ZlcmlmaWNhdGlvbjooeDgzNSA6IHN0cmluZyBvcHRpb24pIC0+XG4gICAgICAgICAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHg4MzYgPSBPanMuZW1wdHlfb2JqICgpIGluXG4gICAgICAgICAgICAgICAgICAgIChtYXRjaCB4ODMyIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgIHwgU29tZSB4ODQwIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIHg4MzYgXCJhdXRoZW50aWNhdG9yQXR0YWNobWVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoT2pzLnN0cmluZ190b19qcyB4ODQwKVxuICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgICAgKG1hdGNoIHg4MzMgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgfCBTb21lIHg4MzkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgeDgzNiBcInJlc2lkZW50S2V5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuc3RyaW5nX3RvX2pzIHg4MzkpXG4gICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAobWF0Y2ggeDgzNCB3aXRoXG4gICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDgzOCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSB4ODM2IFwicmVxdWlyZVJlc2lkZW50S2V5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuYm9vbF90b19qcyB4ODM4KVxuICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgICAgKG1hdGNoIHg4MzUgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgfCBTb21lIHg4MzcgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgeDgzNiBcInVzZXJWZXJpZmljYXRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5zdHJpbmdfdG9fanMgeDgzNylcbiAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0b3Jfb3B0aW9uc19vZl9qcyB4ODM2XG4gICAgICAgIHR5cGUgcHVibGljX2tleV9vcHRpb25zID0gT2pzLnRcbiAgICAgICAgbGV0IHJlYyBwdWJsaWNfa2V5X29wdGlvbnNfb2ZfanMgOiBPanMudCAtPiBwdWJsaWNfa2V5X29wdGlvbnMgPVxuICAgICAgICAgIGZ1biAoeDg0MiA6IE9qcy50KSAtPiB4ODQyXG4gICAgICAgIGFuZCBwdWJsaWNfa2V5X29wdGlvbnNfdG9fanMgOiBwdWJsaWNfa2V5X29wdGlvbnMgLT4gT2pzLnQgPVxuICAgICAgICAgIGZ1biAoeDg0MSA6IE9qcy50KSAtPiB4ODQxXG4gICAgICAgIGxldCAocHVibGljX2tleV9vcHRpb25zIDpcbiAgICAgICAgICA/cnA6cnBfb3B0aW9ucyAtPlxuICAgICAgICAgICAgP3VzZXI6dXNlcl9vcHRpb25zIC0+XG4gICAgICAgICAgICAgID9jaGFsbGVuZ2U6QXJyYXlCdWZmZXIudCAtPlxuICAgICAgICAgICAgICAgID9wdWJfa2V5X2NyZWRfcGFyYW1zOmtleV9wYXJhbSBsaXN0IC0+XG4gICAgICAgICAgICAgICAgICA/dGltZW91dDppbnQgLT5cbiAgICAgICAgICAgICAgICAgICAgP2V4Y2x1ZGVfY3JlZGVudGlhbHM6T2pzLnQgbGlzdCAtPlxuICAgICAgICAgICAgICAgICAgICAgID9hdXRoZW50aWNhdG9yX3NlbGVjdGlvbjphdXRoZW50aWNhdG9yX29wdGlvbnMgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgID9hdHRlc3RhdGlvbjpzdHJpbmcgLT4gdW5pdCAtPiBwdWJsaWNfa2V5X29wdGlvbnMpXG4gICAgICAgICAgPVxuICAgICAgICAgIGZ1biA/cnA6KHg4NDMgOiBycF9vcHRpb25zIG9wdGlvbikgLT5cbiAgICAgICAgICAgIGZ1biA/dXNlcjooeDg0NCA6IHVzZXJfb3B0aW9ucyBvcHRpb24pIC0+XG4gICAgICAgICAgICAgIGZ1biA/Y2hhbGxlbmdlOih4ODQ1IDogQXJyYXlCdWZmZXIudCBvcHRpb24pIC0+XG4gICAgICAgICAgICAgICAgZnVuID9wdWJfa2V5X2NyZWRfcGFyYW1zOih4ODQ2IDoga2V5X3BhcmFtIGxpc3Qgb3B0aW9uKSAtPlxuICAgICAgICAgICAgICAgICAgZnVuID90aW1lb3V0Oih4ODQ3IDogaW50IG9wdGlvbikgLT5cbiAgICAgICAgICAgICAgICAgICAgZnVuID9leGNsdWRlX2NyZWRlbnRpYWxzOih4ODQ4IDogT2pzLnQgbGlzdCBvcHRpb24pIC0+XG4gICAgICAgICAgICAgICAgICAgICAgZnVuXG4gICAgICAgICAgICAgICAgICAgICAgICA/YXV0aGVudGljYXRvcl9zZWxlY3Rpb246KHg4NDkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aGVudGljYXRvcl9vcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW4gP2F0dGVzdGF0aW9uOih4ODUwIDogc3RyaW5nIG9wdGlvbikgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHg4NTEgPSBPanMuZW1wdHlfb2JqICgpIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoIHg4NDMgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDg2MSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIHg4NTEgXCJycFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChycF9vcHRpb25zX3RvX2pzIHg4NjEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoIHg4NDQgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDg2MCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIHg4NTEgXCJ1c2VyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHVzZXJfb3B0aW9uc190b19qcyB4ODYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXRjaCB4ODQ1IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTb21lIHg4NTkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSB4ODUxIFwiY2hhbGxlbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEFycmF5QnVmZmVyLnRfdG9fanMgeDg1OSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2ggeDg0NiB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU29tZSB4ODU3IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgeDg1MSBcInB1YktleUNyZWRQYXJhbXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoT2pzLmxpc3RfdG9fanMga2V5X3BhcmFtX3RvX2pzIHg4NTcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoIHg4NDcgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDg1NiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIHg4NTEgXCJ0aW1lb3V0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5pbnRfdG9fanMgeDg1NilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF0Y2ggeDg0OCB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU29tZSB4ODU0IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgeDg1MSBcImV4Y2x1ZGVDcmVkZW50aWFsc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChPanMubGlzdF90b19qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuICh4ODU1IDogT2pzLnQpIC0+IHg4NTUpIHg4NTQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoIHg4NDkgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDg1MyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIHg4NTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhdXRoZW50aWNhdG9yU2VsZWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGF1dGhlbnRpY2F0b3Jfb3B0aW9uc190b19qcyB4ODUzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXRjaCB4ODUwIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTb21lIHg4NTIgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSB4ODUxIFwiYXR0ZXN0YXRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoT2pzLnN0cmluZ190b19qcyB4ODUyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpY19rZXlfb3B0aW9uc19vZl9qcyB4ODUxXG4gICAgICAgIHR5cGUgY3JlYXRlX29wdGlvbnMgPSBPanMudFxuICAgICAgICBsZXQgcmVjIGNyZWF0ZV9vcHRpb25zX29mX2pzIDogT2pzLnQgLT4gY3JlYXRlX29wdGlvbnMgPVxuICAgICAgICAgIGZ1biAoeDg2MyA6IE9qcy50KSAtPiB4ODYzXG4gICAgICAgIGFuZCBjcmVhdGVfb3B0aW9uc190b19qcyA6IGNyZWF0ZV9vcHRpb25zIC0+IE9qcy50ID1cbiAgICAgICAgICBmdW4gKHg4NjIgOiBPanMudCkgLT4geDg2MlxuICAgICAgICBsZXQgKGNyZWF0ZV9vcHRpb25zIDpcbiAgICAgICAgICA/cHVibGljX2tleTpwdWJsaWNfa2V5X29wdGlvbnMgLT4gdW5pdCAtPiBjcmVhdGVfb3B0aW9ucykgPVxuICAgICAgICAgIGZ1biA/cHVibGljX2tleTooeDg2NCA6IHB1YmxpY19rZXlfb3B0aW9ucyBvcHRpb24pIC0+XG4gICAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgICAgbGV0IHg4NjUgPSBPanMuZW1wdHlfb2JqICgpIGluXG4gICAgICAgICAgICAgIChtYXRjaCB4ODY0IHdpdGhcbiAgICAgICAgICAgICAgIHwgU29tZSB4ODY2IC0+XG4gICAgICAgICAgICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIHg4NjUgXCJwdWJsaWNLZXlcIlxuICAgICAgICAgICAgICAgICAgICAgKHB1YmxpY19rZXlfb3B0aW9uc190b19qcyB4ODY2KVxuICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgY3JlYXRlX29wdGlvbnNfb2ZfanMgeDg2NVxuICAgICAgICBsZXQgKGNyZWF0ZSA6IGNyZWF0ZV9vcHRpb25zIC0+IE9qcy50IFByb21pc2UudCkgPVxuICAgICAgICAgIGZ1biAoeDg2NyA6IGNyZWF0ZV9vcHRpb25zKSAtPlxuICAgICAgICAgICAgUHJvbWlzZS50X29mX2pzIChmdW4gKHg4NjggOiBPanMudCkgLT4geDg2OClcbiAgICAgICAgICAgICAgKE9qcy5jYWxsXG4gICAgICAgICAgICAgICAgIChPanMuZ2V0X3Byb3BfYXNjaWlcbiAgICAgICAgICAgICAgICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSBPanMuZ2xvYmFsIFwibmF2aWdhdG9yXCIpIFwiY3JlZGVudGlhbHNcIilcbiAgICAgICAgICAgICAgICAgXCJjcmVhdGVcIiBbfChjcmVhdGVfb3B0aW9uc190b19qcyB4ODY3KXxdKVxuICAgICAgICB0eXBlIGNyZWRlbnRpYWxfZGVzY3JpcHRvciA9IE9qcy50XG4gICAgICAgIGxldCByZWMgY3JlZGVudGlhbF9kZXNjcmlwdG9yX29mX2pzIDogT2pzLnQgLT4gY3JlZGVudGlhbF9kZXNjcmlwdG9yXG4gICAgICAgICAgPSBmdW4gKHg4NzAgOiBPanMudCkgLT4geDg3MFxuICAgICAgICBhbmQgY3JlZGVudGlhbF9kZXNjcmlwdG9yX3RvX2pzIDogY3JlZGVudGlhbF9kZXNjcmlwdG9yIC0+IE9qcy50ID1cbiAgICAgICAgICBmdW4gKHg4NjkgOiBPanMudCkgLT4geDg2OVxuICAgICAgICBsZXQgKGNyZWRlbnRpYWxfZGVzY3JpcHRvciA6XG4gICAgICAgICAgP3R5cGVfOnN0cmluZyAtPlxuICAgICAgICAgICAgP2lkOkFycmF5QnVmZmVyLnQgLT5cbiAgICAgICAgICAgICAgP3RyYW5zcG9ydHM6T2pzLnQgLT4gdW5pdCAtPiBjcmVkZW50aWFsX2Rlc2NyaXB0b3IpXG4gICAgICAgICAgPVxuICAgICAgICAgIGZ1biA/dHlwZV86KHg4NzEgOiBzdHJpbmcgb3B0aW9uKSAtPlxuICAgICAgICAgICAgZnVuID9pZDooeDg3MiA6IEFycmF5QnVmZmVyLnQgb3B0aW9uKSAtPlxuICAgICAgICAgICAgICBmdW4gP3RyYW5zcG9ydHM6KHg4NzMgOiBPanMudCBvcHRpb24pIC0+XG4gICAgICAgICAgICAgICAgZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICBsZXQgeDg3NCA9IE9qcy5lbXB0eV9vYmogKCkgaW5cbiAgICAgICAgICAgICAgICAgIChtYXRjaCB4ODcxIHdpdGhcbiAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDg3NyAtPlxuICAgICAgICAgICAgICAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgeDg3NCBcInR5cGVcIiAoT2pzLnN0cmluZ190b19qcyB4ODc3KVxuICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgICAgICAobWF0Y2ggeDg3MiB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBTb21lIHg4NzYgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIHg4NzQgXCJpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKEFycmF5QnVmZmVyLnRfdG9fanMgeDg3NilcbiAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgKG1hdGNoIHg4NzMgd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgU29tZSB4ODc1IC0+IE9qcy5zZXRfcHJvcF9hc2NpaSB4ODc0IFwidHJhbnNwb3J0c1wiIHg4NzVcbiAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbF9kZXNjcmlwdG9yX29mX2pzIHg4NzRcbiAgICAgICAgdHlwZSBnZXRfcHVibGljX2tleV9vcHRpb25zID0gT2pzLnRcbiAgICAgICAgbGV0IHJlYyBnZXRfcHVibGljX2tleV9vcHRpb25zX29mX2pzIDpcbiAgICAgICAgICBPanMudCAtPiBnZXRfcHVibGljX2tleV9vcHRpb25zID0gZnVuICh4ODc5IDogT2pzLnQpIC0+IHg4NzlcbiAgICAgICAgYW5kIGdldF9wdWJsaWNfa2V5X29wdGlvbnNfdG9fanMgOiBnZXRfcHVibGljX2tleV9vcHRpb25zIC0+IE9qcy50ID1cbiAgICAgICAgICBmdW4gKHg4NzggOiBPanMudCkgLT4geDg3OFxuICAgICAgICBsZXQgKGdldF9wdWJsaWNfa2V5X29wdGlvbnMgOlxuICAgICAgICAgID9jaGFsbGVuZ2U6QXJyYXlCdWZmZXIudCAtPlxuICAgICAgICAgICAgP3RpbWVvdXQ6aW50IC0+XG4gICAgICAgICAgICAgID9ycF9pZDpzdHJpbmcgLT5cbiAgICAgICAgICAgICAgICA/YWxsb3dfY3JlZGVudGlhbHM6Y3JlZGVudGlhbF9kZXNjcmlwdG9yIGxpc3QgLT5cbiAgICAgICAgICAgICAgICAgID91c2VyX3ZlcmlmaWNhdGlvbjpzdHJpbmcgLT5cbiAgICAgICAgICAgICAgICAgICAgP2V4dGVuc2lvbnM6T2pzLnQgLT4gdW5pdCAtPiBnZXRfcHVibGljX2tleV9vcHRpb25zKVxuICAgICAgICAgID1cbiAgICAgICAgICBmdW4gP2NoYWxsZW5nZTooeDg4MCA6IEFycmF5QnVmZmVyLnQgb3B0aW9uKSAtPlxuICAgICAgICAgICAgZnVuID90aW1lb3V0Oih4ODgxIDogaW50IG9wdGlvbikgLT5cbiAgICAgICAgICAgICAgZnVuID9ycF9pZDooeDg4MiA6IHN0cmluZyBvcHRpb24pIC0+XG4gICAgICAgICAgICAgICAgZnVuXG4gICAgICAgICAgICAgICAgICA/YWxsb3dfY3JlZGVudGlhbHM6KHg4ODMgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbF9kZXNjcmlwdG9yIGxpc3Qgb3B0aW9uKVxuICAgICAgICAgICAgICAgICAgLT5cbiAgICAgICAgICAgICAgICAgIGZ1biA/dXNlcl92ZXJpZmljYXRpb246KHg4ODQgOiBzdHJpbmcgb3B0aW9uKSAtPlxuICAgICAgICAgICAgICAgICAgICBmdW4gP2V4dGVuc2lvbnM6KHg4ODUgOiBPanMudCBvcHRpb24pIC0+XG4gICAgICAgICAgICAgICAgICAgICAgZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeDg4NiA9IE9qcy5lbXB0eV9vYmogKCkgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIChtYXRjaCB4ODgwIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDg5MyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgeDg4NiBcImNoYWxsZW5nZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEFycmF5QnVmZmVyLnRfdG9fanMgeDg5MylcbiAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoIHg4ODEgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgIHwgU29tZSB4ODkyIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSB4ODg2IFwidGltZW91dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5pbnRfdG9fanMgeDg5MilcbiAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoIHg4ODIgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgIHwgU29tZSB4ODkxIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSB4ODg2IFwicnBJZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5zdHJpbmdfdG9fanMgeDg5MSlcbiAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoIHg4ODMgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgIHwgU29tZSB4ODg5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSB4ODg2IFwiYWxsb3dDcmVkZW50aWFsc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE9qcy5saXN0X3RvX2pzIGNyZWRlbnRpYWxfZGVzY3JpcHRvcl90b19qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg4ODkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChtYXRjaCB4ODg0IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDg4OCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgeDg4NiBcInVzZXJWZXJpZmljYXRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChPanMuc3RyaW5nX3RvX2pzIHg4ODgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChtYXRjaCB4ODg1IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgeDg4NyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPanMuc2V0X3Byb3BfYXNjaWkgeDg4NiBcImV4dGVuc2lvbnNcIiB4ODg3XG4gICAgICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldF9wdWJsaWNfa2V5X29wdGlvbnNfb2ZfanMgeDg4NlxuICAgICAgICB0eXBlIGdldF9vcHRpb25zID0gT2pzLnRcbiAgICAgICAgbGV0IHJlYyBnZXRfb3B0aW9uc19vZl9qcyA6IE9qcy50IC0+IGdldF9vcHRpb25zID1cbiAgICAgICAgICBmdW4gKHg4OTUgOiBPanMudCkgLT4geDg5NVxuICAgICAgICBhbmQgZ2V0X29wdGlvbnNfdG9fanMgOiBnZXRfb3B0aW9ucyAtPiBPanMudCA9XG4gICAgICAgICAgZnVuICh4ODk0IDogT2pzLnQpIC0+IHg4OTRcbiAgICAgICAgbGV0IChnZXRfb3B0aW9ucyA6XG4gICAgICAgICAgP3B1YmxpY19rZXk6Z2V0X3B1YmxpY19rZXlfb3B0aW9ucyAtPiB1bml0IC0+IGdldF9vcHRpb25zKSA9XG4gICAgICAgICAgZnVuID9wdWJsaWNfa2V5Oih4ODk2IDogZ2V0X3B1YmxpY19rZXlfb3B0aW9ucyBvcHRpb24pIC0+XG4gICAgICAgICAgICBmdW4gKCkgLT5cbiAgICAgICAgICAgICAgbGV0IHg4OTcgPSBPanMuZW1wdHlfb2JqICgpIGluXG4gICAgICAgICAgICAgIChtYXRjaCB4ODk2IHdpdGhcbiAgICAgICAgICAgICAgIHwgU29tZSB4ODk4IC0+XG4gICAgICAgICAgICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIHg4OTcgXCJwdWJsaWNLZXlcIlxuICAgICAgICAgICAgICAgICAgICAgKGdldF9wdWJsaWNfa2V5X29wdGlvbnNfdG9fanMgeDg5OClcbiAgICAgICAgICAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgICAgICAgICAgIGdldF9vcHRpb25zX29mX2pzIHg4OTdcbiAgICAgICAgbGV0IChnZXQgOiBnZXRfb3B0aW9ucyAtPiBPanMudCBQcm9taXNlLnQpID1cbiAgICAgICAgICBmdW4gKHg4OTkgOiBnZXRfb3B0aW9ucykgLT5cbiAgICAgICAgICAgIFByb21pc2UudF9vZl9qcyAoZnVuICh4OTAwIDogT2pzLnQpIC0+IHg5MDApXG4gICAgICAgICAgICAgIChPanMuY2FsbFxuICAgICAgICAgICAgICAgICAoT2pzLmdldF9wcm9wX2FzY2lpXG4gICAgICAgICAgICAgICAgICAgIChPanMuZ2V0X3Byb3BfYXNjaWkgT2pzLmdsb2JhbCBcIm5hdmlnYXRvclwiKSBcImNyZWRlbnRpYWxzXCIpXG4gICAgICAgICAgICAgICAgIFwiZ2V0XCIgW3woZ2V0X29wdGlvbnNfdG9fanMgeDg5OSl8XSlcbiAgICAgIGVuZFxuICBlbmRcbiIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBvY2FtbC12ZG9tIHBhY2thZ2UsIHJlbGVhc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiBhbiBNSVQtbGlrZSBsaWNlbnNlLiAgICAgKilcbigqIFNlZSB0aGUgYXR0YWNoZWQgTElDRU5TRSBmaWxlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqIENvcHlyaWdodCAoQykgMjAwMC0yMDIzIExleGlGaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcblxuXG5vcGVuIEpzX2Jyb3dzZXJcbm9wZW4gVmRvbVxuXG5sZXQgZGVidWcgPSBmYWxzZVxuXG50eXBlIFZkb20uanNfb2JqZWN0ICs9IE9qcyBvZiBPanMudFxuXG5tb2R1bGUgQkRlY29kZXIgPSBzdHJ1Y3RcblxuICB0eXBlIHN0ZXAgPVxuICAgIHwgTnRoIG9mIGludFxuICAgIHwgS2V5IG9mIHN0cmluZ1xuXG4gIHR5cGUgdHlwID1cbiAgICB8IFR5TGlzdFxuICAgIHwgVHlTdHJpbmdcbiAgICB8IFR5Qm9vbFxuICAgIHwgVHlJbnRcbiAgICB8IFR5RmxvYXRcblxuICB0eXBlIHBhdGggPSBzdGVwIGxpc3RcblxuICB0eXBlIGVycm9yX2tpbmQgPVxuICAgIHwgS2V5X3VuYm91bmQgb2Ygc3RyaW5nXG4gICAgfCBNZXRob2RfdW5ib3VuZCBvZiBzdHJpbmdcbiAgICB8IE1zZyBvZiBzdHJpbmdcbiAgICB8IFR5cGVfZXJyb3Igb2YgdHlwICogc3RyaW5nXG5cbiAgdHlwZSBlcnJvciA9XG4gICAgcGF0aCAqIGVycm9yX2tpbmRcblxuICBsZXQgc3RyaW5nX29mX3R5cCA9IGZ1bmN0aW9uXG4gICAgfCBUeUxpc3QgLT4gXCJsaXN0XCJcbiAgICB8IFR5U3RyaW5nIC0+IFwic3RyaW5nXCJcbiAgICB8IFR5Qm9vbCAtPiBcImJvb2xlYW5cIlxuICAgIHwgVHlJbnQgLT4gXCJpbnRcIlxuICAgIHwgVHlGbG9hdCAtPiBcImZsb2F0XCJcblxuICBsZXQgc3RyaW5nX29mX3N0ZXAgPSBmdW5jdGlvblxuICAgIHwgTnRoIG4gLT4gc3RyaW5nX29mX2ludCBuXG4gICAgfCBLZXkgcyAtPiBzXG5cbiAgbGV0IHN0cmluZ19vZl9wYXRoIHBhdGggPVxuICAgIFN0cmluZy5jb25jYXQgXCIuXCIgKExpc3QucmV2X21hcCBzdHJpbmdfb2Zfc3RlcCBwYXRoKVxuXG4gIGxldCBzdHJpbmdfb2ZfZXJyb3Jfa2luZCA9IGZ1bmN0aW9uXG4gICAgfCBLZXlfdW5ib3VuZCBzIC0+IFByaW50Zi5zcHJpbnRmIFwidW5ib3VuZCBmaWVsZDogJVNcIiBzXG4gICAgfCBNZXRob2RfdW5ib3VuZCBzIC0+IFByaW50Zi5zcHJpbnRmIFwidW5ib3VuZCBtZXRob2QgKG9yIHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMpOiAlU1wiIHNcbiAgICB8IE1zZyBzIC0+IHNcbiAgICB8IFR5cGVfZXJyb3IgKGV4cGVjdGVkLCBnb3QpIC0+IFByaW50Zi5zcHJpbnRmIFwiY2Fubm90IGNvbnZlcnQgJXMgdG8gJXNcIiBnb3QgKHN0cmluZ19vZl90eXAgZXhwZWN0ZWQpXG5cbiAgbGV0IHN0cmluZ19vZl9lcnJvciA9IGZ1bmN0aW9uXG4gICAgfCBbXSwgZXJyayAtPlxuICAgICAgICBzdHJpbmdfb2ZfZXJyb3Jfa2luZCBlcnJrXG4gICAgfCAoXyA6OiBfIGFzIHBhdGgpLCBlcnJrIC0+XG4gICAgICAgIFwiQXQgcGF0aCBbXCIgXiBzdHJpbmdfb2ZfcGF0aCBwYXRoIF4gXCJdOiBcIiBeIHN0cmluZ19vZl9lcnJvcl9raW5kIGVycmtcblxuICB0eXBlIG8gPSB7IHBhdGg6IHBhdGg7IG9iajogT2pzLnQgfVxuXG4gIHR5cGUgJ2EgdCA9IG8gLT4gKCdhLCBlcnJvcikgcmVzdWx0XG5cblxuICBsZXQgZmllbGQga2V5IGQgbyA9XG4gICAgbGV0IHJlYyBhdXggbyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IE9rIG9cbiAgICAgIHwga2V5IDo6IGtleXMgLT5cbiAgICAgICAgICBsZXQgb2JqID0gT2pzLmdldF9wcm9wX2FzY2lpIG8ub2JqIGtleSBpblxuICAgICAgICAgIGlmIG9iaiA9IE9qcy51bml0X3RvX2pzICgpIHRoZW5cbiAgICAgICAgICAgIEVycm9yIChvLnBhdGgsIEtleV91bmJvdW5kIGtleSlcbiAgICAgICAgICBlbHNlIGF1eCB7cGF0aCA9IChLZXkga2V5IDo6IG8ucGF0aCk7IG9ian0ga2V5c1xuICAgIGluXG4gICAgbGV0IGtleXMgPSBTdHJpbmcuc3BsaXRfb25fY2hhciAnLicga2V5IGluXG4gICAgUmVzdWx0LmJpbmQgKGF1eCBvIGtleXMpIGRcblxuICBsZXQgbWV0aG9kXyBuYW1lIGFyZyBkIG8gPVxuICAgIGxldCBhcmcgPVxuICAgICAgTGlzdC5tYXAgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBEZWNvZGVyLlN0cmluZ0FyZyBzIC0+IE9qcy5zdHJpbmdfdG9fanMgc1xuICAgICAgICAgIHwgQm9vbEFyZyBiIC0+IE9qcy5ib29sX3RvX2pzIGJcbiAgICAgICAgICB8IEZsb2F0QXJnIGYgLT4gT2pzLmZsb2F0X3RvX2pzIGZcbiAgICAgICAgICB8IEludEFyZyBpIC0+IE9qcy5pbnRfdG9fanMgaVxuICAgICAgICApIGFyZ1xuICAgIGluXG4gICAgbGV0IGFyZyA9IEFycmF5Lm9mX2xpc3QgYXJnIGluXG4gICAgdHJ5XG4gICAgICBsZXQgb2JqID0gT2pzLmNhbGwgby5vYmogbmFtZSBhcmcgaW5cbiAgICAgIGQge3BhdGggPSAoS2V5IG5hbWUgOjogby5wYXRoKTsgb2JqfVxuICAgIHdpdGhcbiAgICAgIE9qc19leG4uRXJyb3IgXyAtPiBFcnJvciAoby5wYXRoLCBNZXRob2RfdW5ib3VuZCBuYW1lKVxuXG5cbiAgbGV0IGJpbmQgKGYgOiAnYSAtPiAnYiB0KSAoZCA6ICdhIHQpIG8gPVxuICAgIG1hdGNoIGQgbyB3aXRoXG4gICAgfCBPayB4IC0+IGYgeCBvXG4gICAgfCBFcnJvciBlcnIgLT4gRXJyb3IgZXJyXG5cbiAgbGV0IGNvbnN0IG1zZyBfbyA9IE9rIG1zZ1xuXG4gIGxldCBmYWlsIG1zZyB7cGF0aDsgX30gPVxuICAgIEVycm9yIChwYXRoLCBNc2cgbXNnKVxuXG4gIGxldCB0cnlfIGQgbyA9XG4gICAgbWF0Y2ggZCBvIHdpdGhcbiAgICB8IE9rIHggLT4gT2sgKFNvbWUgeClcbiAgICB8IEVycm9yIF8gLT4gT2sgTm9uZVxuXG4gIGxldCBmYWN0b3IgKGYgOiAoJ2EgLT4gJ2IgdCkpIG8gPVxuICAgIE9rIChmdW4geCAtPiBSZXN1bHQubWFwX2Vycm9yIHN0cmluZ19vZl9lcnJvciAoZiB4IG8pKVxuXG4gIGxldCB0eXBlcnIgdHkgcGF0aCBnb3QgPVxuICAgIEVycm9yIChwYXRoLCBUeXBlX2Vycm9yICh0eSwgZ290KSlcblxuICBsZXQgc3RyaW5nIHtwYXRoOyBvYmp9ID1cbiAgICBtYXRjaCBPanMudHlwZV9vZiBvYmogd2l0aFxuICAgIHwgXCJzdHJpbmdcIiAtPiBPayAoT2pzLnN0cmluZ19vZl9qcyBvYmopXG4gICAgfCB0eSAtPiB0eXBlcnIgVHlTdHJpbmcgcGF0aCB0eVxuXG4gIGxldCBpbnQge3BhdGg7IG9ian0gPVxuICAgIG1hdGNoIE9qcy50eXBlX29mIG9iaiB3aXRoXG4gICAgfCBcIm51bWJlclwiIC0+IE9rIChPanMuaW50X29mX2pzIG9iailcbiAgICB8IHR5IC0+IHR5cGVyciBUeUludCBwYXRoIHR5XG5cbiAgbGV0IGZsb2F0IHtwYXRoOyBvYmp9ID1cbiAgICBtYXRjaCBPanMudHlwZV9vZiBvYmogd2l0aFxuICAgIHwgXCJudW1iZXJcIiAtPiBPayAoT2pzLmZsb2F0X29mX2pzIG9iailcbiAgICB8IHR5IC0+IHR5cGVyciBUeUZsb2F0IHBhdGggdHlcblxuICBsZXQgYm9vbCB7cGF0aDsgb2JqfSA9XG4gICAgbWF0Y2ggT2pzLnR5cGVfb2Ygb2JqIHdpdGhcbiAgICB8IFwiYm9vbGVhblwiIC0+IE9rIChPanMuYm9vbF9vZl9qcyBvYmopXG4gICAgfCB0eSAtPiB0eXBlcnIgVHlCb29sIHBhdGggdHlcblxuICBsZXQgb2JqZWN0XyB7cGF0aD1fOyBvYmp9ID0gT2sgKE9qcyBvYmopXG5cbiAgbGV0IG1hcGlfbGlzdF9yZXN1bHQgZiBsID1cbiAgICBsZXQgcmVjIGxvb3AgaSBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBPayAoTGlzdC5yZXYgYWNjKVxuICAgICAgfCB4IDo6IHhzIC0+IFJlc3VsdC5iaW5kIChmIGkgeCkgKGZ1biB4IC0+IGxvb3AgKGkgKyAxKSAoeCA6OiBhY2MpIHhzKVxuICAgIGluXG4gICAgbG9vcCAwIFtdIGxcblxuICBsZXQgbGlzdCBkIG8gPVxuICAgIG1hdGNoIE9qcy50eXBlX29mIG8ub2JqIHdpdGhcbiAgICB8IFwib2JqZWN0XCIgLT5cbiAgICAgICAgbWFwaV9saXN0X3Jlc3VsdFxuICAgICAgICAgIChmdW4gaSBvYmogLT4gZCB7cGF0aCA9IE50aCBpIDo6IG8ucGF0aDsgb2JqfSlcbiAgICAgICAgICAoT2pzLmxpc3Rfb2ZfanMgRnVuLmlkIG8ub2JqKVxuICAgIHwgdHkgLT4gdHlwZXJyIFR5TGlzdCBvLnBhdGggdHlcblxuICBsZXQgcnVuIGQgb2JqID1cbiAgICBtYXRjaCBkIHtwYXRoID0gW107IG9ian0gd2l0aFxuICAgIHwgT2sgeCAtPiBPayB4XG4gICAgfCBFcnJvciBlcnIgLT4gRXJyb3IgKHN0cmluZ19vZl9lcnJvciBlcnIpXG5cbiAgbGV0IHJlYyBldmFsIDogdHlwZSBhLiA/ZXh0cmFfZmllbGRzOihzdHJpbmcgKiBPanMudCkgbGlzdCAtPiBhIERlY29kZXIudCAtPiBhIHQgPSBmdW4gPyhleHRyYV9maWVsZHMgPSBbXSkgLT4gZnVuY3Rpb25cbiAgICB8IEZpZWxkIChrZXksIGQpIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIExpc3QuYXNzb2Nfb3B0IGtleSBleHRyYV9maWVsZHMgd2l0aFxuICAgICAgICB8IFNvbWUgb2JqIC0+XG4gICAgICAgICAgICBmdW4gbyAtPiAoKGV2YWwgZCkge3BhdGggPSAoS2V5IGtleSA6OiBvLnBhdGgpOyBvYmp9KVxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgIGZpZWxkIGtleSAoZXZhbCBkKVxuICAgICAgICBlbmRcbiAgICB8IE1ldGhvZCAobmFtZSwgYXJnLCBkKSAtPiBtZXRob2RfIG5hbWUgYXJnIChldmFsIGQpXG4gICAgfCBCaW5kIChmLCBkKSAtPiBiaW5kIChmdW4gYSAtPiBldmFsIH5leHRyYV9maWVsZHMgKGYgYSkpIChldmFsIH5leHRyYV9maWVsZHMgZClcbiAgICB8IEZhY3RvciBmIC0+IGZhY3RvciAoZnVuIGEgLT4gZXZhbCB+ZXh0cmFfZmllbGRzIChmIGEpKVxuICAgIHwgQ29uc3QgbXNnIC0+IGNvbnN0IG1zZ1xuICAgIHwgU3RyaW5nIC0+IHN0cmluZ1xuICAgIHwgSW50IC0+IGludFxuICAgIHwgRmxvYXQgLT4gZmxvYXRcbiAgICB8IEJvb2wgLT4gYm9vbFxuICAgIHwgT2JqZWN0IC0+IG9iamVjdF9cbiAgICB8IExpc3QgZCAtPiBsaXN0IChldmFsIGQpXG4gICAgfCBGYWlsIG1zZyAtPiBmYWlsIG1zZ1xuICAgIHwgVHJ5IGQgLT4gdHJ5XyAoZXZhbCB+ZXh0cmFfZmllbGRzIGQpXG5cbiAgbGV0IGRlY29kZSA/KGV4dHJhX2ZpZWxkcyA9IFtdKSBkID0gcnVuIChldmFsIH5leHRyYV9maWVsZHMgZClcblxuICBsZXQgZGVjb2RlX2ZhaWwgPyhleHRyYV9maWVsZHMgPSBbXSkgZCBvID1cbiAgICBtYXRjaCBkZWNvZGUgfmV4dHJhX2ZpZWxkcyBkIG8gd2l0aFxuICAgIHwgT2sgcmVzIC0+IHJlc1xuICAgIHwgRXJyb3IgZXJyIC0+IGZhaWx3aXRoIGVyclxuZW5kXG5cbm1vZHVsZSBFbmNvZGVyID0gc3RydWN0XG5cbiAgdHlwZSBhcmdfdmFsdWUgPVxuICAgIHwgU3RyaW5nQXJnIG9mIHN0cmluZ1xuICAgIHwgQm9vbEFyZyBvZiBib29sXG4gICAgfCBGbG9hdEFyZyBvZiBmbG9hdFxuXG4gIHR5cGUgdCA9XG4gICAgfCBVbml0XG4gICAgfCBTdHJpbmcgb2Ygc3RyaW5nXG4gICAgfCBJbnQgb2YgaW50XG4gICAgfCBGbG9hdCBvZiBmbG9hdFxuICAgIHwgQm9vbCBvZiBib29sXG4gICAgfCBMaXN0IG9mIHQgbGlzdFxuICAgIHwgT2JqIG9mIChzdHJpbmcgKiB0KSBsaXN0XG4gICAgfCBGdW4gb2YgKGFyZ192YWx1ZSBsaXN0IC0+IHQpXG5cbiAgbGV0IGNvbnZlcnRfYXJnIG8gPVxuICAgIG1hdGNoIE9qcy50eXBlX29mIG8gd2l0aFxuICAgIHwgXCJzdHJpbmdcIiAtPiBTdHJpbmdBcmcgKE9qcy5zdHJpbmdfb2ZfanMgbylcbiAgICB8IFwiYm9vbGVhblwiIC0+IEJvb2xBcmcgKE9qcy5ib29sX29mX2pzIG8pXG4gICAgfCBcIm51bWJlclwiIC0+IEZsb2F0QXJnIChPanMuZmxvYXRfb2ZfanMgbylcbiAgICB8IHR5IC0+IGZhaWx3aXRoIChcIkVuY29kZWQgZnVuY3Rpb24gcmVjZWl2ZWQgYW4gYXJndW1lbnQgd2l0aCB1bnN1cHBvcnRlZCB0eXBlOiBcIiBeIHR5KVxuXG4gIGxldCByZWMgZW5jb2RlID0gZnVuY3Rpb25cbiAgICB8IFVuaXQgLT4gT2pzLnVuaXRfdG9fanMgKClcbiAgICB8IFN0cmluZyBzIC0+IE9qcy5zdHJpbmdfdG9fanMgc1xuICAgIHwgSW50IGkgLT4gT2pzLmludF90b19qcyBpXG4gICAgfCBGbG9hdCBmIC0+IE9qcy5mbG9hdF90b19qcyBmXG4gICAgfCBCb29sIGIgLT4gT2pzLmJvb2xfdG9fanMgYlxuICAgIHwgTGlzdCBsIC0+IE9qcy5saXN0X3RvX2pzIGVuY29kZSBsXG4gICAgfCBPYmogbCAtPiBPanMub2JqIChBcnJheS5vZl9saXN0IChMaXN0Lm1hcCAoZnVuIChzLCBlKSAtPiAocywgZW5jb2RlIGUpKSBsKSlcbiAgICB8IEZ1biBmIC0+IE9qcy5mdW5fdG9fanNfYXJncyAoZnVuIG8gLT4gZW5jb2RlIChmIChPanMubGlzdF9vZl9qcyBjb252ZXJ0X2FyZyBvKSkpXG5cbmVuZFxuXG5cbm1vZHVsZSBDbWQgPSBzdHJ1Y3RcbiAgdHlwZSAnbXNnIGN0eCA9XG4gICAge1xuICAgICAgY29udGFpbmVyOiBKc19icm93c2VyLkVsZW1lbnQudDtcbiAgICAgIHNlbmRfbXNnOiAoJ21zZyAtPiB1bml0KTtcbiAgICAgIGFmdGVyX3JlZHJhdzogKHVuaXQgLT4gdW5pdCkgLT4gdW5pdDtcbiAgICB9XG5cbiAgbGV0IGNvbnRhaW5lciBjdHggPSBjdHguY29udGFpbmVyXG5cbiAgbGV0IHNlbmRfbXNnIGN0eCA9IGN0eC5zZW5kX21zZ1xuXG4gIGxldCBhZnRlcl9yZWRyYXcgY3R4ID0gY3R4LmFmdGVyX3JlZHJhd1xuXG4gIHR5cGUgaGFuZGxlciA9IHtmOiAnbXNnLiAnbXNnIGN0eCAtPiAnbXNnIFZkb20uQ21kLnQgLT4gYm9vbH1cblxuICBsZXQgcmVjIHJ1bjogdHlwZSB0LiAoKHVuaXQgLT4gdW5pdCkgLT4gdW5pdCkgLT4gaGFuZGxlciBsaXN0IC0+ICh0IC0+IHVuaXQpIC0+IEpzX2Jyb3dzZXIuRWxlbWVudC50IC0+IHQgQ21kLnQgLT4gdW5pdCA9XG4gICAgZnVuIGFmdGVyIGggcCBlbHQgLT4gZnVuY3Rpb25cbiAgICAgIHwgQ21kLkVjaG8gbXNnIC0+IHAgbXNnXG4gICAgICB8IENtZC5CYXRjaCBsIC0+IExpc3QuaXRlciAocnVuIGFmdGVyIGggcCBlbHQpIGxcbiAgICAgIHwgQ21kLk1hcCAoZiwgY21kKSAtPiBydW4gYWZ0ZXIgaCAoZnVuIHggLT4gcCAoZiB4KSkgZWx0IGNtZFxuICAgICAgfCBDbWQuQmluZCAoY21kLCBmKSAtPiBydW4gYWZ0ZXIgaCAoZnVuIHggLT4gcnVuIGFmdGVyIGggcCBlbHQgKGYgeCkpIGVsdCBjbWRcbiAgICAgIHwgeCAtPlxuICAgICAgICAgIGxldCBjdHggPSB7c2VuZF9tc2cgPSBwOyBjb250YWluZXIgPSBlbHQ7IGFmdGVyX3JlZHJhdyA9IGFmdGVyfSBpblxuICAgICAgICAgIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICB8IFtdIC0+IFByaW50Zi5rc3ByaW50ZiBmYWlsd2l0aCBcIk5vIGNvbW1hbmQgaGFuZGxlciBmb3VuZCEgKCVzKVwiIChPYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm5hbWUgKE9iai5FeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsIHgpKVxuICAgICAgICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAgICAgICAgIGlmIGhkLmYgY3R4IHggdGhlbiAoKVxuICAgICAgICAgICAgICAgIGVsc2UgbG9vcCB0bFxuICAgICAgICAgIGluXG4gICAgICAgICAgbG9vcCBoXG5lbmRcblxubW9kdWxlIEN1c3RvbSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHtcbiAgICAgIGRvbTogSnNfYnJvd3Nlci5FbGVtZW50LnQ7XG4gICAgICBzeW5jOiAoVmRvbS5DdXN0b20udCAtPiBib29sKTtcbiAgICAgIGRpc3Bvc2U6ICh1bml0IC0+IHVuaXQpO1xuICAgIH1cblxuICB0eXBlIGV2ZW50ID1cbiAgICB8IEN1c3RvbSBvZiBDdXN0b20uZXZlbnRcbiAgICB8IEVuY29kZWQgb2YgeyBldmVudF90eXBlOiBzdHJpbmc7IGVuY29kZXI6IEVuY29kZXIudCB9XG5cbiAgbGV0IGJsdXJfZXZlbnQgPSBFbmNvZGVkIHtldmVudF90eXBlID0gXCJibHVyXCI7IGVuY29kZXIgPSBPYmogW119XG4gIGxldCBpbnB1dF9ldmVudCBzID0gRW5jb2RlZCB7ZXZlbnRfdHlwZSA9IFwiaW5wdXRcIjsgZW5jb2RlciA9IE9iaiBbXCJ0YXJnZXRcIiwgT2JqIFtcInZhbHVlXCIsIFN0cmluZyBzXV19XG4gIGxldCBjaGVja2VkX2V2ZW50IGIgPSBFbmNvZGVkIHtldmVudF90eXBlID0gXCJjbGlja1wiOyBlbmNvZGVyID0gT2JqIFtcInRhcmdldFwiLCBPYmogW1wiY2hlY2tlZFwiLCBCb29sIGJdXX1cbiAgbGV0IGNoYW5nZV9ldmVudCBzID0gRW5jb2RlZCB7ZXZlbnRfdHlwZSA9IFwiY2hhbmdlXCI7IGVuY29kZXIgPSBPYmogW1widGFyZ2V0XCIsIE9iaiBbXCJ2YWx1ZVwiLCBTdHJpbmcgc11dfVxuICBsZXQgY2hhbmdlX2luZGV4X2V2ZW50IGkgPSBFbmNvZGVkIHtldmVudF90eXBlID0gXCJjaGFuZ2VcIjsgZW5jb2RlciA9IE9iaiBbXCJ0YXJnZXRcIiwgT2JqIFtcInNlbGVjdGVkSW5kZXhcIiwgSW50IGldXX1cbiAgbGV0IGN1c3RvbV9ldmVudCBlID0gQ3VzdG9tIGVcblxuICB0eXBlIGN0eCA9XG4gICAge1xuICAgICAgcGFyZW50OiBKc19icm93c2VyLkVsZW1lbnQudDtcbiAgICAgIHNlbmRfZXZlbnQ6IChldmVudCAtPiB1bml0KTtcbiAgICAgIGFmdGVyX3JlZHJhdzogKCh1bml0IC0+IHVuaXQpIC0+IHVuaXQpO1xuICAgIH1cblxuICB0eXBlIGhhbmRsZXIgPSBjdHggLT4gVmRvbS5DdXN0b20udCAtPiB0IG9wdGlvblxuXG4gIGxldCBtYWtlID8oZGlzcG9zZSA9IGlnbm9yZSkgfnN5bmMgZG9tID1cbiAgICB7ZG9tOyBzeW5jOyBkaXNwb3NlfVxuXG4gIGxldCBwYXJlbnQgY3R4ID0gY3R4LnBhcmVudFxuXG4gIGxldCBzZW5kX2V2ZW50IGN0eCA9IGN0eC5zZW5kX2V2ZW50XG5cbiAgbGV0IGFmdGVyX3JlZHJhdyBjdHggPSBjdHguYWZ0ZXJfcmVkcmF3XG5cbiAgbGV0IHJlYyBmaW5kX2hhbmRsZXIgY3R4IHggPSBmdW5jdGlvblxuICAgIHwgW10gLT4gZmFpbHdpdGggXCJWZG9tX2JsaXQ6IG5vIGN1c3RvbSBlbGVtZW50IGhhbmRsZXIgZm91bmRcIlxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgYmVnaW4gbWF0Y2ggaGQgY3R4IHggd2l0aFxuICAgICAgICB8IFNvbWUgZiAtPiBmXG4gICAgICAgIHwgTm9uZSAtPiBmaW5kX2hhbmRsZXIgY3R4IHggdGxcbiAgICAgICAgZW5kXG5cbiAgbGV0IGxvb2t1cCB+cGFyZW50IH5wcm9jZXNzX2N1c3RvbSB+YWZ0ZXJfcmVkcmF3IGVsdCBoYW5kbGVycyA9XG4gICAgbGV0IHJlYyBkb20gPSBsYXp5ICgoTGF6eS5mb3JjZSBlbCkuZG9tKVxuICAgIGFuZCBzZW5kX2V2ZW50IGUgPSBwcm9jZXNzX2N1c3RvbSAoTGF6eS5mb3JjZSBkb20pIGVcbiAgICBhbmQgZWwgPSBsYXp5IChmaW5kX2hhbmRsZXIge3BhcmVudDsgc2VuZF9ldmVudDsgYWZ0ZXJfcmVkcmF3fSBlbHQgaGFuZGxlcnMpIGluXG4gICAgTGF6eS5mb3JjZSBlbFxuZW5kXG5cblxuKCogUmVuZGVyaW5nIChWRE9NIC0+IERPTSkgKilcblxudHlwZSAnbXNnIGN0cmwgPVxuICB8IEJUZXh0IG9mIHt2ZG9tOiAnbXNnIHZkb207IGRvbTogRWxlbWVudC50fVxuICB8IEJGcmFnbWVudCBvZiB7dmRvbTogJ21zZyB2ZG9tOyBkb21zOiBFbGVtZW50LnQgbGlzdDsgY2hpbGRyZW46ICdtc2cgY3RybCBsaXN0fVxuICB8IEJFbGVtZW50IG9mIHt2ZG9tOiAnbXNnIHZkb207IGRvbTogRWxlbWVudC50OyBjaGlsZHJlbjogJ21zZyBjdHJsIGxpc3R9XG4gIHwgQk1hcDoge3Zkb206ICdtc2cgdmRvbTsgZG9tczogRWxlbWVudC50IGxpc3Q7IGY6ICgnc3VibXNnIC0+ICdtc2cpOyBjaGlsZDogJ3N1Ym1zZyBjdHJsfSAtPiAnbXNnIGN0cmxcbiAgfCBCTWVtbzoge3Zkb206ICdtc2cgdmRvbTsgZG9tczogRWxlbWVudC50IGxpc3Q7IGNoaWxkOiAnbXNnIGN0cmx9IC0+ICdtc2cgY3RybFxuICB8IEJDdXN0b20gb2Yge3Zkb206ICdtc2cgdmRvbTsgZWx0OiBDdXN0b20udDsgbnM6IHN0cmluZzsgcHJvcGFnYXRlX2V2ZW50czogYm9vbH1cblxubGV0IGdldF9kb21zID0gZnVuY3Rpb25cbiAgfCBCVGV4dCB4IC0+IFt4LmRvbV1cbiAgfCBCRnJhZ21lbnQgeCAtPiB4LmRvbXNcbiAgfCBCRWxlbWVudCB4IC0+IFt4LmRvbV1cbiAgfCBCTWFwIHggLT4geC5kb21zXG4gIHwgQk1lbW8geCAtPiB4LmRvbXNcbiAgfCBCQ3VzdG9tIHggLT4gW3guZWx0LmRvbV1cblxubGV0IGdldF92ZG9tID0gZnVuY3Rpb25cbiAgfCBCVGV4dCB4IC0+IHgudmRvbVxuICB8IEJGcmFnbWVudCB4IC0+IHgudmRvbVxuICB8IEJFbGVtZW50IHggLT4geC52ZG9tXG4gIHwgQk1hcCB4IC0+IHgudmRvbVxuICB8IEJNZW1vIHggLT4geC52ZG9tXG4gIHwgQkN1c3RvbSB4IC0+IHgudmRvbVxuXG5sZXQga2V5X29mX3Zkb20gPSBmdW5jdGlvblxuICB8IFRleHQge2tleTsgX31cbiAgfCBGcmFnbWVudCB7a2V5OyBffVxuICB8IEVsZW1lbnQge2tleTsgX31cbiAgfCBNYXAge2tleTsgX31cbiAgfCBNZW1vIHtrZXk7IF99XG4gIHwgQ3VzdG9tIHtrZXk7IF99IC0+XG4gICAgICBrZXlcblxuXG5sZXQgZXZhbF9wcm9wID0gZnVuY3Rpb25cbiAgfCBTdHJpbmcgeCAtPiBPanMuc3RyaW5nX3RvX2pzIHhcbiAgfCBJbnQgeCAtPiBPanMuaW50X3RvX2pzIHhcbiAgfCBCb29sIHggLT4gT2pzLmJvb2xfdG9fanMgeFxuICB8IEZsb2F0IHggLT4gT2pzLmZsb2F0X3RvX2pzIHhcblxubGV0IHN0cmluZ19vZl9wcm9wID0gZnVuY3Rpb25cbiAgfCBTdHJpbmcgcyAtPiBzXG4gIHwgSW50IHggLT4gc3RyaW5nX29mX2ludCB4XG4gIHwgQm9vbCB4IC0+IHN0cmluZ19vZl9ib29sIHhcbiAgfCBGbG9hdCB4IC0+IHN0cmluZ19vZl9mbG9hdCB4XG5cbmxldCBzYW1lX3Byb3AgdjEgdjIgPVxuICB2MSA9PSB2MiB8fFxuICBtYXRjaCB2MSwgdjIgd2l0aFxuICB8IFN0cmluZyB4MSwgU3RyaW5nIHgyIC0+IHgxID0geDJcbiAgfCBJbnQgeDEsIEludCB4MiAtPiB4MSA9IHgyXG4gIHwgQm9vbCB4MSwgQm9vbCB4MiAtPiB4MSA9IHgyXG4gIHwgRmxvYXQgeDEsIEZsb2F0IHgyIC0+IHgxID0geDJcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCBibWVtbyB2ZG9tIGNoaWxkID1cbiAgQk1lbW8ge3Zkb207IGRvbXMgPSBnZXRfZG9tcyBjaGlsZDsgY2hpbGR9XG5cbmxldCBpc192aXNpYmxlIGRvbSA9XG4gIGxldCBib3VuZGluZyA9IEVsZW1lbnQuZ2V0X2JvdW5kaW5nX2NsaWVudF9yZWN0IGRvbSBpblxuICBsZXQgdG9wID0gUmVjdC50b3AgYm91bmRpbmcgaW5cbiAgbGV0IGJvdHRvbSA9IFJlY3QuYm90dG9tIGJvdW5kaW5nIGluXG4gIHRvcCA+PSAwLjAgJiYgYm90dG9tIDw9IFdpbmRvdy5pbm5lcl9oZWlnaHQgd2luZG93XG5cbmxldCBjdXN0b21fYXR0cmlidXRlIHByb3AgPVxuICBtYXRjaCBwcm9wIHdpdGhcbiAgfCBcInNjcm9sbC10by1zaG93XCIgLT5cbiAgICAgIFNvbWVcbiAgICAgICAgKGZ1biBkb20gdiAtPlxuICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICBsZXQgYWxpZ25fdG9wID1cbiAgICAgICAgICAgICAgIG1hdGNoIHYgd2l0aFxuICAgICAgICAgICAgICAgfCBCb29sIGZhbHNlIC0+IGZhbHNlXG4gICAgICAgICAgICAgICB8IF8gLT4gdHJ1ZVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgaWYgbm90IChpc192aXNpYmxlIGRvbSkgdGhlblxuICAgICAgICAgICAgICAgRWxlbWVudC5zY3JvbGxfaW50b192aWV3IGRvbSBhbGlnbl90b3A7XG4gICAgICAgICAgIHdpdGggZXhuIC0+IFByaW50Zi5wcmludGYgXCJzY3JvbGw6ICVzXFxuJSFcIiAoUHJpbnRleGMudG9fc3RyaW5nIGV4bilcbiAgICAgICAgKVxuXG4gIHwgXCJhdXRvZm9jdXNcIiAtPlxuICAgICAgU29tZVxuICAgICAgICAoZnVuIGRvbSB2IC0+XG4gICAgICAgICAgIGxldCBkb19mb2N1cyA9XG4gICAgICAgICAgICAgbWF0Y2ggdiB3aXRoXG4gICAgICAgICAgICAgfCBTdHJpbmcgXCJpZi12aXNpYmxlXCIgLT4gaXNfdmlzaWJsZSBkb21cbiAgICAgICAgICAgICB8IF8gLT4gdHJ1ZVxuICAgICAgICAgICBpblxuICAgICAgICAgICBpZiBkb19mb2N1cyB0aGVuIEVsZW1lbnQuZm9jdXMgZG9tXG4gICAgICAgIClcblxuICB8IFwic2VsZWN0XCIgLT5cbiAgICAgIFNvbWUgKGZ1biBkb20gXyAtPiBFbGVtZW50LnNlbGVjdCBkb20pXG5cbiAgfCBcImF1dG9zdWJtaXRcIiAtPlxuICAgICAgU29tZSAoZnVuIGRvbSBfIC0+IEVsZW1lbnQuc3VibWl0IGRvbSlcblxuICB8IF8gLT4gTm9uZVxuXG5cbmxldCBhc3luYyBmID1cbiAgaWdub3JlIChXaW5kb3cuc2V0X3RpbWVvdXQgd2luZG93IGYgMClcblxubGV0IGFwcGx5X2VmZmVjdF9wcm9wIGRvbSBwcm9wIHZhbHVlID1cbiAgbWF0Y2ggY3VzdG9tX2F0dHJpYnV0ZSBwcm9wIHdpdGhcbiAgfCBOb25lIC0+IGZhbHNlXG4gIHwgU29tZSBmIC0+IGFzeW5jIChmdW4gKCkgLT4gZiBkb20gdmFsdWUpOyB0cnVlXG5cbmxldCBzZXRfc3R5bGUgZG9tIGsgdiA9XG4gIGlmIFN0cmluZy5sZW5ndGggayA+IDAgJiYgay5bMF0gPSAnLScgdGhlblxuICAgIE9qcy5jYWxsXG4gICAgICAoT2pzLmdldF9wcm9wX2FzY2lpIChFbGVtZW50LnRfdG9fanMgZG9tKSBcInN0eWxlXCIpXG4gICAgICBcInNldFByb3BlcnR5XCJcbiAgICAgIFt8IE9qcy5zdHJpbmdfdG9fanMgazsgdiB8XSB8PiBpZ25vcmVcbiAgZWxzZVxuICAgIE9qcy5zZXRfcHJvcF9hc2NpaVxuICAgICAgKE9qcy5nZXRfcHJvcF9hc2NpaSAoRWxlbWVudC50X3RvX2pzIGRvbSkgXCJzdHlsZVwiKVxuICAgICAga1xuICAgICAgdlxuXG5sZXQgYXBwbHlfc3BlY2lhbF9wcm9wIG5zIGRvbSBrIHYgPVxuICBtYXRjaCBucywgaywgdiB3aXRoXG4gIHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImNsYXNzTmFtZVwiLCBTdHJpbmcgcyAtPlxuICAgICAgbGV0IGNsYXNzX29iaiA9IE9qcy5nZXRfcHJvcF9hc2NpaSAoRWxlbWVudC50X3RvX2pzIGRvbSkgXCJjbGFzc05hbWVcIiBpblxuICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIGNsYXNzX29iaiBcImJhc2VWYWxcIiAoT2pzLnN0cmluZ190b19qcyBzKTtcbiAgICAgIHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCBqc19lbXB0eV9zdHJpbmcgPSBPanMuc3RyaW5nX3RvX2pzIFwiXCJcblxubGV0IGNsZWFyX3NwZWNpYWxfcHJvcCBucyBkb20gayA9XG4gIG1hdGNoIG5zLCBrIHdpdGhcbiAgfCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiY2xhc3NOYW1lXCIgLT5cbiAgICAgIGxldCBjbGFzc19vYmogPSBPanMuZ2V0X3Byb3BfYXNjaWkgKEVsZW1lbnQudF90b19qcyBkb20pIFwiY2xhc3NOYW1lXCIgaW5cbiAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSBjbGFzc19vYmogXCJiYXNlVmFsXCIganNfZW1wdHlfc3RyaW5nO1xuICAgICAgdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxudHlwZSBlbnYgPVxuICB7XG4gICAgY21kczogQ21kLmhhbmRsZXIgbGlzdDtcbiAgICBjdXN0b21zOiBDdXN0b20uaGFuZGxlciBsaXN0O1xuICB9XG5cbmxldCBlbXB0eSA9IHtjbWRzID0gW107IGN1c3RvbXMgPSBbXX1cbmxldCBjbWQgaCA9IHtlbXB0eSB3aXRoIGNtZHMgPSBbaF19XG5sZXQgY3VzdG9tIGggPSB7ZW1wdHkgd2l0aCBjdXN0b21zID0gW2hdfVxubGV0IG1lcmdlIGVudnMgPVxuICB7XG4gICAgY21kcyA9IExpc3QuY29uY2F0IChMaXN0Lm1hcCAoZnVuIGUgLT4gZS5jbWRzKSBlbnZzKTtcbiAgICBjdXN0b21zID0gTGlzdC5jb25jYXQgKExpc3QubWFwIChmdW4gZSAtPiBlLmN1c3RvbXMpIGVudnMpO1xuICB9XG5cbmxldCBnbG9iYWwgPSByZWYgZW1wdHlcblxubGV0IHJlZ2lzdGVyIGUgPSBnbG9iYWwgOj0gbWVyZ2UgW2U7ICFnbG9iYWxdXG5cbnR5cGUgY3R4ID1cbiAge1xuICAgIHByb2Nlc3NfY3VzdG9tOiAoRWxlbWVudC50IC0+IEN1c3RvbS5ldmVudCAtPiB1bml0KTtcbiAgICBjdXN0b21faGFuZGxlcnM6IEN1c3RvbS5oYW5kbGVyIGxpc3Q7XG4gICAgYWZ0ZXJfcmVkcmF3OiAoKHVuaXQgLT4gdW5pdCkgLT4gdW5pdCk7XG4gICAgYWRkX2xpc3RlbmVyOiBzdHJpbmcgLT4gdW5pdDtcbiAgfVxuXG5sZXQgYXBwbHlfYXR0cmlidXRlcyBjdHggbnMgZG9tIGF0dHJpYnV0ZXMgPVxuICBMaXN0Lml0ZXJcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgUHJvcGVydHkgKGssIHYpIC0+XG4gICAgICAgICAgaWYgbm90IChhcHBseV9zcGVjaWFsX3Byb3AgbnMgZG9tIGsgdikgdGhlblxuICAgICAgICAgICAgaWYgbm90IChhcHBseV9lZmZlY3RfcHJvcCBkb20gayB2KSB0aGVuXG4gICAgICAgICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAoRWxlbWVudC50X3RvX2pzIGRvbSkgayAoZXZhbF9wcm9wIHYpXG5cbiAgICAgIHwgU3R5bGUgKGssIHYpIC0+IHNldF9zdHlsZSBkb20gayAoT2pzLnN0cmluZ190b19qcyB2KVxuXG4gICAgICB8IEF0dHJpYnV0ZSAoaywgdikgLT5cbiAgICAgICAgICBFbGVtZW50LnNldF9hdHRyaWJ1dGUgZG9tIGsgdlxuXG4gICAgICB8IEhhbmRsZXIgRGVjb2RlciB7ZXZlbnRfdHlwZTsgX30gLT4gY3R4LmFkZF9saXN0ZW5lciBldmVudF90eXBlXG5cbiAgICAgIHwgSGFuZGxlciBDdXN0b21FdmVudCBfIC0+ICgpXG4gICAgKVxuICAgIGF0dHJpYnV0ZXNcblxubGV0IHJlYyBibGl0IDogJ21zZy4gcGFyZW50Ol8gLT4gY3R4IC0+ICdtc2cgdmRvbSAtPiAnbXNnIGN0cmwgPVxuICBmdW4gfnBhcmVudCBjdHggdmRvbSAtPlxuICBtYXRjaCB2ZG9tIHdpdGhcbiAgfCBUZXh0IHt0eHQ7IGtleSA9IF99IC0+XG4gICAgICBCVGV4dCB7dmRvbTsgZG9tID0gRG9jdW1lbnQuY3JlYXRlX3RleHRfbm9kZSBkb2N1bWVudCB0eHR9XG5cbiAgfCBGcmFnbWVudCB7Y2hpbGRyZW47IGtleSA9IF99IC0+XG4gICAgICBsZXQgY2hpbGRyZW4gPSBMaXN0Lm1hcCAoYmxpdCB+cGFyZW50IGN0eCkgY2hpbGRyZW4gaW5cbiAgICAgIGxldCBkb21zID0gTGlzdC5jb25jYXRfbWFwIGdldF9kb21zIGNoaWxkcmVuIGluXG4gICAgICBCRnJhZ21lbnQge3Zkb207IGRvbXM7IGNoaWxkcmVuIH1cblxuICB8IE1hcCB7ZjsgY2hpbGQ7IGtleSA9IF99IC0+XG4gICAgICBsZXQgY2hpbGQgPSBibGl0IH5wYXJlbnQgY3R4IGNoaWxkIGluXG4gICAgICBCTWFwIHt2ZG9tOyBkb21zID0gZ2V0X2RvbXMgY2hpbGQ7IGY7IGNoaWxkfVxuXG4gIHwgTWVtbyB7ZjsgYXJnOyBrZXkgPSBffSAtPlxuICAgICAgYm1lbW8gdmRvbSAoYmxpdCB+cGFyZW50IGN0eCAoZiBhcmcpKVxuXG4gIHwgQ3VzdG9tIHtlbHQ7IGF0dHJpYnV0ZXM7IGtleSA9IF87IHByb3BhZ2F0ZV9ldmVudHN9IC0+XG4gICAgICBsZXQgZWx0ID1cbiAgICAgICAgdHJ5IEN1c3RvbS5sb29rdXAgfnBhcmVudCB+cHJvY2Vzc19jdXN0b206Y3R4LnByb2Nlc3NfY3VzdG9tIH5hZnRlcl9yZWRyYXc6Y3R4LmFmdGVyX3JlZHJhdyBlbHQgKGN0eC5jdXN0b21faGFuZGxlcnMgQCAoIWdsb2JhbCkuY3VzdG9tcyk7XG4gICAgICAgIHdpdGggZXhuIC0+XG4gICAgICAgICAgUHJpbnRmLnByaW50ZiBcIkVycm9yIGR1cmluZyB2ZG9tIEN1c3RvbSAlcyBsb29rdXA6ICVzXFxuJSFcIlxuICAgICAgICAgICAgKE9iai5FeHRlbnNpb25fY29uc3RydWN0b3IubmFtZSAoT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWwgZWx0KSlcbiAgICAgICAgICAgIChQcmludGV4Yy50b19zdHJpbmcgZXhuKTtcbiAgICAgICAgICByYWlzZSBleG5cbiAgICAgIGluXG4gICAgICBsZXQgbnMgPVxuICAgICAgICBPanMub3B0aW9uX29mX2pzXG4gICAgICAgICAgT2pzLnN0cmluZ19vZl9qc1xuICAgICAgICAgIChPanMuZ2V0X3Byb3BfYXNjaWkgKEVsZW1lbnQudF90b19qcyBlbHQuZG9tKSBcIm5hbWVzcGFjZVVSSVwiKVxuICAgICAgICB8PiBPcHRpb24udmFsdWUgfmRlZmF1bHQ6XCJcIlxuICAgICAgaW5cbiAgICAgIGFwcGx5X2F0dHJpYnV0ZXMgY3R4IG5zIGVsdC5kb20gYXR0cmlidXRlcztcbiAgICAgIEJDdXN0b20ge3Zkb207IGVsdDsgbnM7IHByb3BhZ2F0ZV9ldmVudHN9XG5cbiAgfCBFbGVtZW50IHtuczsgdGFnOyBjaGlsZHJlbjsgYXR0cmlidXRlczsga2V5ID0gX30gLT5cbiAgICAgIGlmIGRlYnVnIHRoZW4gUHJpbnRmLnByaW50ZiBcImNyZWF0ZSA8JXM+XFxuJSFcIiB0YWc7XG4gICAgICBsZXQgZG9tID1cbiAgICAgICAgaWYgbnMgPSBcIlwiIHRoZW4gRG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQgZG9jdW1lbnQgdGFnXG4gICAgICAgIGVsc2UgRG9jdW1lbnQuY3JlYXRlX2VsZW1lbnRfbnMgZG9jdW1lbnQgbnMgdGFnXG4gICAgICBpblxuICAgICAgbGV0IGNoaWxkcmVuID0gTGlzdC5tYXAgKGJsaXQgfnBhcmVudDpkb20gY3R4KSBjaGlsZHJlbiBpblxuICAgICAgTGlzdC5pdGVyIChmdW4gYyAtPiBMaXN0Lml0ZXIgKEVsZW1lbnQuYXBwZW5kX2NoaWxkIGRvbSkgKGdldF9kb21zIGMpKSBjaGlsZHJlbjtcbiAgICAgIGFwcGx5X2F0dHJpYnV0ZXMgY3R4IG5zIGRvbSBhdHRyaWJ1dGVzO1xuICAgICAgQkVsZW1lbnQge3Zkb207IGRvbTsgY2hpbGRyZW59XG5cbmxldCBibGl0IH5wYXJlbnQgY3R4IHZkb20gPVxuICB0cnkgYmxpdCB+cGFyZW50IGN0eCB2ZG9tXG4gIHdpdGggZXhuIC0+XG4gICAgUHJpbnRmLnByaW50ZiBcIkVycm9yIGR1cmluZyB2ZG9tIGJsaXQ6ICVzXFxuJSFcIiAoUHJpbnRleGMudG9fc3RyaW5nIGV4bik7XG4gICAgcmFpc2UgZXhuXG5cbmxldCBzeW5jX3Byb3BzIHRvX3N0cmluZyBzYW1lIHNldCBjbGVhciBsMSBsMiA9XG4gIGxldCBzb3J0ID0gTGlzdC5zb3J0IChmdW4gKGsxLCBfKSAoazIsIF8pIC0+IFN0cmluZy5jb21wYXJlIGsxIGsyKSBpblxuICBsZXQgbDEgPSBzb3J0IGwxIGFuZCBsMiA9IHNvcnQgbDIgaW5cbiAgbGV0IHJlYyBsb29wIGwxIGwyID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIFtdIC0+ICgpXG5cbiAgICB8IChrMSwgdjEpIDo6IHRsMSwgKGsyLCBfKSA6OiBfIHdoZW4gazEgPCBrMiAtPlxuICAgICAgICBpZiBkZWJ1ZyB0aGVuIFByaW50Zi5wcmludGYgXCJQcm9wZXJ0eSAlcyB1bnNldCAlcyA9PlxcbiUhXCIgazEgKHRvX3N0cmluZyB2MSk7XG4gICAgICAgIGNsZWFyIGsxIHYxO1xuICAgICAgICBsb29wIHRsMSBsMlxuICAgIHwgKGsxLCB2MSkgOjogdGwxLCBbXSAtPlxuICAgICAgICBpZiBkZWJ1ZyB0aGVuIFByaW50Zi5wcmludGYgXCJQcm9wZXJ0eSAlcyB1bnNldCAlcyA9PlxcbiUhXCIgazEgKHRvX3N0cmluZyB2MSk7XG4gICAgICAgIGNsZWFyIGsxIHYxO1xuICAgICAgICBsb29wIHRsMSBbXVxuXG4gICAgfCAoazEsIF8pIDo6IF8sIChrMiwgdjIpIDo6IHRsMiB3aGVuIGsyIDwgazEgLT5cbiAgICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwiUHJvcGVydHkgJXMgc2V0ID0+ICVzXFxuJSFcIiBrMiAodG9fc3RyaW5nIHYyKTtcbiAgICAgICAgc2V0IGsyIHYyO1xuICAgICAgICBsb29wIGwxIHRsMlxuICAgIHwgW10sIChrMiwgdjIpIDo6IHRsMiAtPlxuICAgICAgICBpZiBkZWJ1ZyB0aGVuIFByaW50Zi5wcmludGYgXCJQcm9wZXJ0eSAlcyBzZXQgPT4gJXNcXG4lIVwiIGsyICh0b19zdHJpbmcgdjIpO1xuICAgICAgICBzZXQgazIgdjI7XG4gICAgICAgIGxvb3AgW10gdGwyXG5cbiAgICB8IChfazEsIHYxKSA6OiB0bDEsIChrMiwgdjIpIDo6IHRsMiAtPlxuICAgICAgICAoKiBrMSA9IGsyICopXG4gICAgICAgIGlmIG5vdCAoc2FtZSB2MSB2MikgdGhlbiBiZWdpblxuICAgICAgICAgIGlmIGRlYnVnIHRoZW4gUHJpbnRmLnByaW50ZiBcIlByb3BlcnR5ICVzIGNoYW5nZWQgJXMgPT4gJXNcXG4lIVwiIGsyICh0b19zdHJpbmcgdjEpICh0b19zdHJpbmcgdjIpO1xuICAgICAgICAgIHNldCBrMiB2MjtcbiAgICAgICAgZW5kO1xuICAgICAgICBsb29wIHRsMSB0bDJcbiAgaW5cbiAgbG9vcCBsMSBsMlxuXG5sZXQgcmVjIGNob29zZSBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IGhkIDo6IHRsIC0+XG4gICAgICBtYXRjaCBmIGhkIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBjaG9vc2UgZiB0bFxuICAgICAgfCBTb21lIHggLT4geCA6OiBjaG9vc2UgZiB0bFxuXG5sZXQganNfemVybyA9IE9qcy5pbnRfdG9fanMgMFxubGV0IGpzX2ZhbHNlID0gT2pzLmJvb2xfdG9fanMgZmFsc2VcblxubGV0IGhhc19vd25fcHJvcGVydHkgbyB4ID1cbiAgbGV0IG9wZW4gT2pzIGluXG4gIGJvb2xfb2ZfanMgKGNhbGwgbyBcImhhc093blByb3BlcnR5XCIgW3wgc3RyaW5nX3RvX2pzIHggfF0pXG5cbmxldCBzeW5jX2F0dHJpYnV0ZXMgY3R4IG5zIGRvbSBhMSBhMiA9XG4gIGxldCBwcm9wcyA9IGZ1bmN0aW9uIFByb3BlcnR5IChrLCB2KSAtPiBTb21lIChrLCB2KSB8IFN0eWxlIF8gfCBIYW5kbGVyIF8gfCBBdHRyaWJ1dGUgXyAtPiBOb25lIGluXG4gIGxldCBzZXQgayB2ID1cbiAgICBtYXRjaCBrLCB2IHdpdGhcbiAgICB8IFwidmFsdWVcIiwgU3RyaW5nIHMgd2hlbiBzID0gRWxlbWVudC52YWx1ZSBkb20gLT4gKClcbiAgICB8IF8gLT5cbiAgICAgICAgaWYgbm90IChhcHBseV9zcGVjaWFsX3Byb3AgbnMgZG9tIGsgdikgdGhlblxuICAgICAgICAgIGlmIG5vdCAoYXBwbHlfZWZmZWN0X3Byb3AgZG9tIGsgdikgdGhlblxuICAgICAgICAgICAgT2pzLnNldF9wcm9wX2FzY2lpIChFbGVtZW50LnRfdG9fanMgZG9tKSBrIChldmFsX3Byb3AgdilcbiAgaW5cbiAgbGV0IGNsZWFyIGsgdiA9XG4gICAgaWYgY3VzdG9tX2F0dHJpYnV0ZSBrID0gTm9uZSB0aGVuXG4gICAgICBpZiBoYXNfb3duX3Byb3BlcnR5IChFbGVtZW50LnRfdG9fanMgZG9tKSBrIHRoZW5cbiAgICAgICAgT2pzLmRlbGV0ZV9wcm9wX2FzY2lpIChFbGVtZW50LnRfdG9fanMgZG9tKSBrXG4gICAgICBlbHNlIGlmIG5vdCAoY2xlYXJfc3BlY2lhbF9wcm9wIG5zIGRvbSBrKSB0aGVuXG4gICAgICAgIE9qcy5zZXRfcHJvcF9hc2NpaSAoRWxlbWVudC50X3RvX2pzIGRvbSkga1xuICAgICAgICAgIGJlZ2luIG1hdGNoIHYgd2l0aFxuICAgICAgICAgIHwgU3RyaW5nIF8gLT4ganNfZW1wdHlfc3RyaW5nXG5cbiAgICAgICAgICB8IEludCBfIHwgRmxvYXQgXyAtPiBqc196ZXJvXG4gICAgICAgICAgfCBCb29sIF8gLT4ganNfZmFsc2VcbiAgICAgICAgICBlbmRcbiAgaW5cbiAgc3luY19wcm9wc1xuICAgIHN0cmluZ19vZl9wcm9wXG4gICAgc2FtZV9wcm9wXG4gICAgc2V0IGNsZWFyXG4gICAgKGNob29zZSBwcm9wcyBhMSlcbiAgICAoY2hvb3NlIHByb3BzIGEyKTtcblxuICBsZXQgc3R5bGVzID0gZnVuY3Rpb24gU3R5bGUgKGssIHYpIC0+IFNvbWUgKGssIFN0cmluZyB2KSB8IFByb3BlcnR5IF8gfCBIYW5kbGVyIF8gfCBBdHRyaWJ1dGUgXyAtPiBOb25lIGluXG4gIGxldCBzZXQgayB2ID0gc2V0X3N0eWxlIGRvbSBrIChldmFsX3Byb3AgdilpblxuICBsZXQgY2xlYXIgayBfID0gc2V0X3N0eWxlIGRvbSBrIGpzX2VtcHR5X3N0cmluZyBpblxuICBzeW5jX3Byb3BzXG4gICAgc3RyaW5nX29mX3Byb3BcbiAgICBzYW1lX3Byb3BcbiAgICBzZXQgY2xlYXJcbiAgICAoY2hvb3NlIHN0eWxlcyBhMSlcbiAgICAoY2hvb3NlIHN0eWxlcyBhMik7XG5cbiAgbGV0IGF0dHJzID0gZnVuY3Rpb24gQXR0cmlidXRlIChrLCB2KSAtPiBTb21lIChrLCB2KSB8IFN0eWxlIF8gfCBQcm9wZXJ0eSBfIHwgSGFuZGxlciBfIC0+IE5vbmUgaW5cbiAgbGV0IHNldCBrIHYgPSBFbGVtZW50LnNldF9hdHRyaWJ1dGUgZG9tIGsgdiBpblxuICBsZXQgY2xlYXIgayBfID0gRWxlbWVudC5yZW1vdmVfYXR0cmlidXRlIGRvbSBrIGluXG4gIHN5bmNfcHJvcHNcbiAgICBGdW4uaWRcbiAgICAoZnVuIChzMTogc3RyaW5nKSBzMiAtPiBzMSA9IHMyKVxuICAgIHNldCBjbGVhclxuICAgIChjaG9vc2UgYXR0cnMgYTEpXG4gICAgKGNob29zZSBhdHRycyBhMik7XG5cbiAgTGlzdC5pdGVyXG4gICAgKGZ1bmN0aW9uIHwgSGFuZGxlciBEZWNvZGVyIHtldmVudF90eXBlOyBffSAtPiBjdHguYWRkX2xpc3RlbmVyIGV2ZW50X3R5cGVcbiAgICAgICAgICAgICAgfCBfIC0+ICgpKVxuICAgIGEyXG5cbmxldCByZWMgZGlzcG9zZSA6IHR5cGUgbXNnLiBtc2cgY3RybCAtPiB1bml0ID0gZnVuIGN0cmwgLT5cbiAgbWF0Y2ggY3RybCB3aXRoXG4gIHwgQlRleHQgXyAtPiAoKVxuICB8IEJDdXN0b20ge2VsdDsgX30gLT4gZWx0LmRpc3Bvc2UgKClcbiAgfCBCRnJhZ21lbnQge2NoaWxkcmVuOyBffVxuICB8IEJFbGVtZW50IHtjaGlsZHJlbjsgX30gLT4gTGlzdC5pdGVyIGRpc3Bvc2UgY2hpbGRyZW5cbiAgfCBCTWFwIHtjaGlsZDsgX30gLT4gZGlzcG9zZSBjaGlsZFxuICB8IEJNZW1vIHtjaGlsZDsgX30gLT4gZGlzcG9zZSBjaGlsZFxuXG5sZXQgcHJpbnRfZWxlbWVudCBub2RlID1cbiAgaWYgRWxlbWVudC5udWxsID09IG5vZGUgdGhlblxuICAgIFwibnVsbFwiXG4gIGVsc2VcbiAgICBtYXRjaCBFbGVtZW50Lm5vZGVfdHlwZSBub2RlIHdpdGhcbiAgICB8IEVsZW1lbnQuRUxFTUVOVF9OT0RFIC0+IEVsZW1lbnQub3V0ZXJfSFRNTCBub2RlXG4gICAgfCBFbGVtZW50LlRFWFRfTk9ERSAtPiBFbGVtZW50Lm5vZGVfdmFsdWUgbm9kZVxuICAgIHwgXyAtPiBcIj8/XCJcblxubGV0IHJlbW92ZV9jaGlsZCBwYXJlbnQgY2hpbGQgPVxuICBpZiBkZWJ1ZyB0aGVuXG4gICAgUHJpbnRmLnByaW50ZiBcInJlbW92ZV9jaGlsZCglcywgJXMpXFxuXCIgKHByaW50X2VsZW1lbnQgcGFyZW50KSAocHJpbnRfZWxlbWVudCBjaGlsZCk7XG4gIEVsZW1lbnQucmVtb3ZlX2NoaWxkIHBhcmVudCBjaGlsZFxuXG5sZXQgcmVwbGFjZV9jaGlsZCBwYXJlbnQgbiBvID1cbiAgaWYgZGVidWcgdGhlblxuICAgIFByaW50Zi5wcmludGYgXCJyZXBsYWNlX2NoaWxkKCVzLCAlcywgJXMpXFxuXCIgKHByaW50X2VsZW1lbnQgcGFyZW50KSAocHJpbnRfZWxlbWVudCBuKSAocHJpbnRfZWxlbWVudCBvKTtcbiAgRWxlbWVudC5yZXBsYWNlX2NoaWxkIHBhcmVudCBuIG9cblxubGV0IGluc2VydF9iZWZvcmUgcGFyZW50IG8gbiA9XG4gIGlmIGRlYnVnIHRoZW5cbiAgICBQcmludGYucHJpbnRmIFwiaW5zZXJ0X2JlZm9yZSglcywgJXMsICVzKVxcblwiIChwcmludF9lbGVtZW50IHBhcmVudCkgKHByaW50X2VsZW1lbnQgbykgKHByaW50X2VsZW1lbnQgbik7XG4gIEVsZW1lbnQuaW5zZXJ0X2JlZm9yZSBwYXJlbnQgbyBuXG5cbmxldCByZWMgc3luYyA6IHR5cGUgb2xkX21zZyBtc2cuIGN0eCAtPiBFbGVtZW50LnQgLT4gYm9vbCAtPiBFbGVtZW50LnQgLT4gb2xkX21zZyBjdHJsIC0+IG1zZyB2ZG9tIC0+IG1zZyBjdHJsID1cbiAgZnVuIGN0eCBwYXJlbnQgcHJldl9tb3ZlIG5leHQgb2xkIHZkb20gLT5cblxuICBtYXRjaCBvbGQsIHZkb20gd2l0aFxuICB8IF8gd2hlbiAodmRvbSA6IG1zZyB2ZG9tKSA9PSAoT2JqLm1hZ2ljIChnZXRfdmRvbSBvbGQgOiBvbGRfbXNnIHZkb20pKSAtPlxuICAgICAgKCogSWYgb2xkIGFuZCBuZXcgdmRvbSBhcmUgcGh5c2ljYWxseSBpZGVudGljYWwsIGl0IGlzIHNhZmUgdG8gcmV1c2UgdGhlIG9sZCBjdHJsLiAqKVxuICAgICAgKE9iai5tYWdpYyAob2xkIDogb2xkX21zZyBjdHJsKSA6IG1zZyBjdHJsKVxuICB8IEJUZXh0IHt2ZG9tID0gVGV4dCB7dHh0ID0gczE7IGtleSA9IF99OyBkb219LCBUZXh0IHt0eHQgPSBzMjsga2V5ID0gX30gLT5cbiAgICAgIGlmIHMxIDw+IHMyIHRoZW4gRWxlbWVudC5zZXRfbm9kZV92YWx1ZSBkb20gczI7XG4gICAgICBCVGV4dCB7dmRvbTsgZG9tfVxuXG4gIHwgQk1hcCB7Y2hpbGQgPSBjMTsgX30sIE1hcCB7ZjsgY2hpbGQgPSBjMjsga2V5ID0gX30gLT5cbiAgICAgIGxldCBjaGlsZCA9IHN5bmMgY3R4IHBhcmVudCBwcmV2X21vdmUgbmV4dCBjMSBjMiBpblxuICAgICAgQk1hcCB7dmRvbTsgZG9tcyA9IGdldF9kb21zIGNoaWxkOyBjaGlsZDsgZn1cblxuICB8IEJNZW1vIHtjaGlsZCA9IGMxOyB2ZG9tID0gTWVtbyB7ZiA9IGYxOyBhcmcgPSBhMTsga2V5ID0gX307IF99LCBNZW1vIHtmID0gZjI7IGFyZyA9IGEyOyBrZXkgPSBffSAtPlxuICAgICAgKCogSXMgdGhpcyBzYWZlICE/ICopXG4gICAgICBpZiBPYmoubWFnaWMgZjEgPT0gZjIgJiYgT2JqLm1hZ2ljIGExID09IGEyIHRoZW5cbiAgICAgICAgYm1lbW8gdmRvbSAoT2JqLm1hZ2ljIChjMSA6IG9sZF9tc2cgY3RybCkgOiBtc2cgY3RybClcbiAgICAgIGVsc2VcbiAgICAgICAgYm1lbW8gdmRvbSAoc3luYyBjdHggcGFyZW50IHByZXZfbW92ZSBuZXh0IGMxIChmMiBhMikpXG5cbiAgfCBCQ3VzdG9tIHt2ZG9tID0gQ3VzdG9tIHtrZXk9a2V5MTsgZWx0PWFyZzE7IGF0dHJpYnV0ZXM9YTE7IHByb3BhZ2F0ZV9ldmVudHMgPSBffTsgcHJvcGFnYXRlX2V2ZW50cyA9IF87IGVsdDsgbnN9LCBDdXN0b20ge2tleT1rZXkyOyBlbHQ9YXJnMjsgYXR0cmlidXRlcz1hMjsgcHJvcGFnYXRlX2V2ZW50c31cbiAgICB3aGVuIGtleTEgPSBrZXkyICYmIChhcmcxID09IGFyZzIgfHwgZWx0LnN5bmMgYXJnMikgLT5cbiAgICAgIHN5bmNfYXR0cmlidXRlcyBjdHggbnMgZWx0LmRvbSBhMSBhMjtcbiAgICAgIEJDdXN0b20ge3Zkb207IGVsdDsgbnM7IHByb3BhZ2F0ZV9ldmVudHN9XG5cbiAgfCBCRnJhZ21lbnQge3Zkb20gPSBGcmFnbWVudCBlMTsgY2hpbGRyZW47IF99LCBGcmFnbWVudCBlMiB3aGVuIGUxLmtleSA9IGUyLmtleSAtPlxuICAgICAgbGV0IGNoaWxkcmVuID0gc3luY19jaGlsZHJlbiBjdHggcGFyZW50IHByZXZfbW92ZSBuZXh0IGNoaWxkcmVuIGUyLmNoaWxkcmVuIGluXG4gICAgICBsZXQgZG9tcyA9IExpc3QuY29uY2F0X21hcCBnZXRfZG9tcyBjaGlsZHJlbiBpblxuICAgICAgQkZyYWdtZW50IHt2ZG9tOyBkb21zOyBjaGlsZHJlbiB9XG5cbiAgfCBCRWxlbWVudCB7dmRvbSA9IEVsZW1lbnQgZTE7IGRvbTsgY2hpbGRyZW59LCBFbGVtZW50IGUyIHdoZW4gZTEudGFnID0gZTIudGFnICYmIGUxLm5zID0gZTIubnMgJiYgZTEua2V5ID0gZTIua2V5IC0+XG4gICAgICBsZXQgY2hpbGRyZW4gPSBzeW5jX2NoaWxkcmVuIGN0eCBkb20gZmFsc2UgRWxlbWVudC5udWxsIGNoaWxkcmVuIGUyLmNoaWxkcmVuIGluXG4gICAgICAoKiBzeW5jaHJvbml6ZSBwcm9wZXJ0aWVzICYgc3R5bGVzICopXG4gICAgICBzeW5jX2F0dHJpYnV0ZXMgY3R4IGUxLm5zIGRvbSBlMS5hdHRyaWJ1dGVzIGUyLmF0dHJpYnV0ZXM7XG4gICAgICBCRWxlbWVudCB7dmRvbTsgZG9tOyBjaGlsZHJlbn1cblxuICB8IF8gLT5cbiAgICAgIGxldCB4ID0gYmxpdCB+cGFyZW50IGN0eCB2ZG9tIGluXG4gICAgICBsZXQgcmVjIGxvb3AgbDEgbDIgPVxuICAgICAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgICAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgICAgICByZXBsYWNlX2NoaWxkIHBhcmVudCBoMSBoMjtcbiAgICAgICAgICAgIGxvb3AgdDEgdDJcbiAgICAgICAgfCBbXSwgbCAtPlxuICAgICAgICAgICAgTGlzdC5pdGVyIChyZW1vdmVfY2hpbGQgcGFyZW50KSBsXG4gICAgICAgIHwgbCwgW10gLT5cbiAgICAgICAgICAgIExpc3QuaXRlciAoZnVuIGMgLT4gaW5zZXJ0X2JlZm9yZSBwYXJlbnQgYyBuZXh0KSBsXG4gICAgICBpblxuICAgICAgbG9vcCAoZ2V0X2RvbXMgeCkgKGdldF9kb21zIG9sZCk7XG4gICAgICBkaXNwb3NlIG9sZDtcbiAgICAgIHhcblxuYW5kIHN5bmNfY2hpbGRyZW4gOiB0eXBlIG9sZF9tc2cgbXNnLiBjdHggLT4gRWxlbWVudC50IC0+IGJvb2wgLT4gRWxlbWVudC50IC0+IG9sZF9tc2cgY3RybCBsaXN0IC0+IG1zZyB2ZG9tIGxpc3QgLT4gbXNnIGN0cmwgbGlzdCA9XG4gIGZ1biBjdHggZG9tIHByZXZfbW92ZSBuZXh0IG9sZF9jaGlsZHJlbiBuZXdfY2hpbGRyZW4gLT5cbiAgKCogVE9ETzpcbiAgICAgLSBhZGQgYSBmYXN0LXBhdGggdG8gZGVhbCB3aXRoIHByZWZpeGVzIGFuZCBzdWZmaXhlcyBvZiBvbGQvbmV3IGNoaWxkcmVuIHdpdGggaWRlbnRpY2FsXG4gICAgICAga2V5cywgYXZvaWRpbmcgYSBsb3Qgb2YgYWxsb2NhdGlvbnMuXG4gICAgIC0gdXNlIGEgSlMgb2JqZWN0IChtYXApIGluc3RlYWQgb2YgYW4gT0NhbWwgSGFzaHRibD9cbiAgKilcblxuICAoKiBzeW5jaHJvbml6ZSBjaGlsZHJlbiAqKVxuXG4gIGxldCBvbGRfY2hpbGRyZW4gPSBBcnJheS5vZl9saXN0IG9sZF9jaGlsZHJlbiBpblxuICBsZXQgbmV3X2NoaWxkcmVuID0gQXJyYXkub2ZfbGlzdCBuZXdfY2hpbGRyZW4gaW5cblxuICAoKiBmb3IgZWFjaCBrZXksIGdldCBhIGxpc3Qgb2YgaW5kaWNlcyBpbiBvbGRfY2hpbGRyZW4gKilcbiAgbGV0IGJ5X2tleSA9IEhhc2h0YmwuY3JlYXRlIDggaW5cbiAgZm9yIGkgPSBBcnJheS5sZW5ndGggb2xkX2NoaWxkcmVuIC0gMSBkb3dudG8gMCBkb1xuICAgIGxldCBrID0ga2V5X29mX3Zkb20gKGdldF92ZG9tIG9sZF9jaGlsZHJlbi4oaSkpIGluXG4gICAgSGFzaHRibC5hZGQgYnlfa2V5IGsgaVxuICAgICgqIGVhcmx5IGVsZW1lbnRzIGFyZSBpbnNlcnRlZCBsYXN0OiBmb3VuZCBmaXJzdCEgKilcbiAgZG9uZTtcblxuICAoKiBidWlsZCBhbiBhcnJheSB0ZWxsaW5nIHVzLCBmb3IgZWFjaCBwb3NpdGlvbiBpbiB0aGUgXCJuZXdcIiBzZXF1ZW5jZSxcbiAgICAgd2hlcmUgdG8gcGljayBpdCBmcm9tIHRoZSBcIm9sZFwiIHNlcXVlbmNlLiAqKVxuICBsZXQgaW5kaWNlcyA9IEFycmF5Lm1ha2UgKEFycmF5Lmxlbmd0aCBuZXdfY2hpbGRyZW4pICgtMSkgaW5cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBpbmRpY2VzIC0gMSBkb1xuICAgIGxldCBrID0ga2V5X29mX3Zkb20gbmV3X2NoaWxkcmVuLihpKSBpblxuICAgIG1hdGNoIEhhc2h0YmwuZmluZCBieV9rZXkgayB3aXRoXG4gICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+ICgpICgqIGtlZXAgKC0xKSA9PSBuZWVkIHRvIGJ1aWxkIGZyb20gc2NyYXRjaCAqKVxuICAgIHwgaWR4IC0+XG4gICAgICAgIGluZGljZXMuKGkpIDwtIGlkeDtcbiAgICAgICAgSGFzaHRibC5yZW1vdmUgYnlfa2V5IGs7XG4gIGRvbmU7XG5cbiAgSGFzaHRibC5pdGVyXG4gICAgKGZ1biBfIGkgLT5cbiAgICAgICBpZiBkZWJ1ZyB0aGVuIFByaW50Zi5wcmludGYgXCJyZW1vdmUgJWlcXG4lIVwiIGk7XG4gICAgICAgbGV0IHRvX3JlbW92ZSA9IG9sZF9jaGlsZHJlbi4oaSkgaW5cbiAgICAgICBMaXN0Lml0ZXIgKHJlbW92ZV9jaGlsZCBkb20pIChnZXRfZG9tcyB0b19yZW1vdmUpO1xuICAgICAgIGRpc3Bvc2UgdG9fcmVtb3ZlXG4gICAgKVxuICAgIGJ5X2tleTtcblxuICAoKiBwcm9kdWNlIHRoZSBuZXcgc2VxdWVuY2UsIGZyb20gcmlnaHQtdG8tbGVmdCwgY3JlYXRpbmcgYW5kIHBpY2tpbmcrc3luY2luYyBub2RlcyAqKVxuICBsZXQgY3RybHMgPSByZWYgW10gaW5cbiAgbGV0IHByZXZfbW92ZSA9IHJlZiBwcmV2X21vdmUgaW5cbiAgbGV0IG5leHQgPSByZWYgbmV4dCBpblxuICBmb3IgaSA9IEFycmF5Lmxlbmd0aCBuZXdfY2hpbGRyZW4gLSAxIGRvd250byAwIGRvXG4gICAgbGV0IGlkeCA9IGluZGljZXMuKGkpIGluXG4gICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwib2xkID0gJWk7IG5ldyA9ICVpOiBcIiBpZHggaTtcblxuICAgIGxldCBjID1cbiAgICAgIGlmIGlkeCA8IDAgdGhlbiBiZWdpblxuICAgICAgICAoKiBjcmVhdGUgKilcbiAgICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwiY3JlYXRlXFxuJSFcIjtcbiAgICAgICAgYmxpdCB+cGFyZW50OmRvbSBjdHggbmV3X2NoaWxkcmVuLihpKVxuICAgICAgZW5kXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGlmIGRlYnVnIHRoZW4gUHJpbnRmLnByaW50ZiBcInN5bmMmbW92ZVxcbiUhXCI7XG4gICAgICAgICgqIG5vdGU6IHRoZSBzeW5jIGNvdWxkIGxlYWQgdG8gYSBET00gcmVwbGFjZSxcbiAgICAgICAgICAgZm9sbG93aW5nIGJ5IGEgbW92ZSBiZWxvdzsgaW4gdGhhdCBjYXNlLFxuICAgICAgICAgICBvbmUgc2hvdWxkIGp1c3QgZGVsZXRlIG9sZCArIGluc2VydCBuZXcgKilcbiAgICAgICAgc3luYyBjdHggZG9tICFwcmV2X21vdmUgIW5leHQgb2xkX2NoaWxkcmVuLihpZHgpIG5ld19jaGlsZHJlbi4oaSlcbiAgICAgIGVuZFxuICAgIGluXG4gICAgKCogd2hlbiBuZXh0ID09IG51bGwsIGluc2VydCBhdCB0aGUgZW5kICopXG5cbiAgICAoKiBXZSB0cnkgdG8gYXZvaWQgdXNlbGVzcyBtb3ZlcyBhcyBtdWNoIGFzIHBvc3NpYmxlLCBub3Qgb25seSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uLFxuICAgICAgIGJ1dCBhbHNvIGJlY2F1c2UgaXQgY2F1c2VzIHRoZSBsb3NzIG9mIGZvY3VzIG9uIGlucHV0IGZpZWxkcy5cblxuICAgICAgIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9pbmNyZW1lbnRhbC1kb20vaXNzdWVzLzIzN1xuXG4gICAgICAgQmV0dGVyIHNvbHV0aW9uczpcbiAgICAgICAtIFJlc3RvcmUgdGhlIGZvY3VzIGFmdGVyIHRoZSBlbnRpcmUgc3luY2hyb25pemF0aW9uIChSZWFjdCBzZWVtcyB0byBkbyB0aGF0KS5cbiAgICAgICAtIE5ldmVyIG1vdmUgYSBmb2N1c2VkIHdpZGdldCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyAocmVxdWlyZSBhIGxlc3MgcmVndWxhclxuICAgICAgICAgYWxnb3JpdGhtIHRvIGFwcGx5IHRoZSBkZXNpcmVkIHBlcm11dGF0aW9uKS5cbiAgICAqKVxuICAgIGxldCBkb21zID0gZ2V0X2RvbXMgYyBpblxuICAgIGxldCByZWMgbGFzdCA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IE5vbmVcbiAgICAgIHwgWyBjX2RvbSBdIC0+IFNvbWUgY19kb21cbiAgICAgIHwgXyA6OiB0bCAtPiBsYXN0IHRsXG4gICAgaW5cbiAgICBtYXRjaCBsYXN0IGRvbXMgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSByaWdodF9tb3N0IC0+XG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgbGV0IG1vdmUgPVxuICAgICAgICAgICAgaWR4IDwgMCB8fFxuICAgICAgICAgICAgKChpZiBpID0gQXJyYXkubGVuZ3RoIG5ld19jaGlsZHJlbiAtIDEgdGhlbiBpZHggPD4gQXJyYXkubGVuZ3RoIG9sZF9jaGlsZHJlbiAtIDFcbiAgICAgICAgICAgICAgZWxzZSAhcHJldl9tb3ZlIHx8IGluZGljZXMuKGkgKyAxKSA8PiBpZHggKyAxKVxuICAgICAgICAgICAgICYmIEVsZW1lbnQubmV4dF9zaWJsaW5nIHJpZ2h0X21vc3QgIT0gIW5leHQpKCogY291bGQgYXZvaWQgcmVhZGluZyBmcm9tIHRoZSBET00uLi4gKilcbiAgICAgICAgICBpblxuICAgICAgICAgIGlmIG1vdmUgdGhlbiBiZWdpblxuICAgICAgICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwicmVhbGx5IG1vdmVcXG4lIVwiO1xuICAgICAgICAgICAgTGlzdC5pdGVyIChmdW4gY19kb20gLT5cbiAgICAgICAgICAgICAgICBpbnNlcnRfYmVmb3JlIGRvbSBjX2RvbSAhbmV4dCkgZG9tcztcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgcHJldl9tb3ZlIDo9IG1vdmU7XG4gICAgICAgICAgbmV4dCA6PSBMaXN0LmhkIGRvbXM7XG4gICAgICAgIGVuZDtcbiAgICAgICAgY3RybHMgOj0gYyA6OiAhY3RybHNcbiAgZG9uZTtcbiAgIWN0cmxzXG5cbmxldCBzeW5jIGN0eCBwYXJlbnQgb2xkIHZkb20gPVxuICB0cnkgc3luYyBjdHggcGFyZW50IG9sZCB2ZG9tXG4gIHdpdGggZXhuIC0+XG4gICAgUHJpbnRmLnByaW50ZiBcIkVycm9yIGR1cmluZyB2ZG9tIHN5bmM6ICVzXFxuJSFcIiAoUHJpbnRleGMudG9fc3RyaW5nIGV4bik7XG4gICAgcmFpc2UgZXhuXG5cbnR5cGUgJ21zZyBmaW5kID1cbiAgfCBOb3RGb3VuZFxuICB8IEZvdW5kOiB7bWFwcGVyOiAoJ2lubmVyX21zZyAtPiAnbXNnKTsgaW5uZXI6ICdpbm5lcl9tc2cgY3RybDsgcGFyZW50OiAnbXNnIGZpbmR9IC0+ICdtc2cgZmluZFxuXG5sZXQgcmVjIGZvdW5kOiB0eXBlIGlubmVyX21zZyBtc2cuIChpbm5lcl9tc2cgLT4gbXNnKSAtPiBtc2cgZmluZCAtPiBFbGVtZW50LnQgLT4gaW5uZXJfbXNnIGN0cmwgLT4gbXNnIGZpbmQgPVxuICBmdW4gbWFwcGVyIHBhcmVudCBkb20gLT4gZnVuY3Rpb25cbiAgICB8IEJFbGVtZW50IF8gfCBCVGV4dCBfIHwgQkN1c3RvbSBfIGFzIGlubmVyIC0+IEZvdW5kIHttYXBwZXI7IGlubmVyOyBwYXJlbnR9XG4gICAgfCBCRnJhZ21lbnQge2NoaWxkcmVuOyBffSAtPlxuICAgICAgICBiZWdpbiBtYXRjaCBMaXN0LmZpbmQgKGZ1biBjIC0+IExpc3QubWVtcSBkb20gKGdldF9kb21zIGMpKSBjaGlsZHJlbiB3aXRoXG4gICAgICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgfCBjIC0+IGZvdW5kIG1hcHBlciBwYXJlbnQgZG9tIGNcbiAgICAgICAgZW5kXG4gICAgfCBCTWFwIHtmOyBjaGlsZDsgX30gLT4gZm91bmQgKGZ1biB4IC0+IG1hcHBlciAoZiB4KSkgcGFyZW50IGRvbSBjaGlsZFxuICAgIHwgQk1lbW8ge2NoaWxkOyBffSAtPiBmb3VuZCBtYXBwZXIgcGFyZW50IGRvbSBjaGlsZFxuXG4oKiBGaW5kIGEgY3RybCBhc3NvY2lhdGVkIHRvIGEgRE9NIGVsZW1lbnQuXG4gICBOb3JtYWxpemUgYnkgdHJhdmVyc2luZyBNYXAgbm9kZSwgYW5kIGFsc28gcmV0dXJuIHRoZSBjb21wb3NpdGlvbiBvZiBhbGwgc3VjaCBtYXBwZXJzXG4gICBmcm9tIHRoZSByb290IHRvIHRoZSBjdHJsLiAqKVxuXG5sZXQgcmVjIHZkb21fb2ZfZG9tOiB0eXBlIG1zZy4gbXNnIGN0cmwgLT4gRWxlbWVudC50IC0+IG1zZyBmaW5kID0gZnVuIHJvb3QgZG9tIC0+XG4gICgqIGhhY2sgdG8gY2hlY2sgZG9tID09IG51bGw/ICAgU2hvdWxkIG1vdmUgdGhhdCB0byBPanMuICopXG4gIG1hdGNoIE9qcy5vcHRpb25fb2ZfanMgRWxlbWVudC50X29mX2pzIChFbGVtZW50LnRfdG9fanMgZG9tKSB3aXRoXG4gIHwgTm9uZSAtPiBOb3RGb3VuZFxuICB8IFNvbWUgZG9tIHdoZW4gTGlzdC5tZW1xIGRvbSAoZ2V0X2RvbXMgcm9vdCkgLT5cbiAgICAgIGZvdW5kIEZ1bi5pZCBOb3RGb3VuZCBkb20gcm9vdFxuICB8IFNvbWUgZG9tIC0+XG4gICAgICBiZWdpbiBtYXRjaCB2ZG9tX29mX2RvbSByb290IChFbGVtZW50LnBhcmVudF9ub2RlIGRvbSkgd2l0aFxuICAgICAgfCBOb3RGb3VuZCAtPiBOb3RGb3VuZFxuICAgICAgfCBGb3VuZCB7bWFwcGVyOyBpbm5lciA9IEJFbGVtZW50IHtjaGlsZHJlbjsgX307IF99IGFzIHBhcmVudCAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIExpc3QuZmluZCAoZnVuIGMgLT4gTGlzdC5tZW1xIGRvbSAoZ2V0X2RvbXMgYykpIGNoaWxkcmVuIHdpdGhcbiAgICAgICAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT4gTm90Rm91bmRcbiAgICAgICAgICB8IGMgLT4gZm91bmQgbWFwcGVyIHBhcmVudCBkb20gY1xuICAgICAgICAgIGVuZFxuICAgICAgfCBGb3VuZCB7bWFwcGVyOyBpbm5lciA9IEJDdXN0b20ge3Byb3BhZ2F0ZV9ldmVudHM7IF99IGFzIGlubmVyOyBwYXJlbnR9IC0+XG4gICAgICAgICAgaWYgcHJvcGFnYXRlX2V2ZW50cyB0aGVuXG4gICAgICAgICAgICBmb3VuZCBtYXBwZXIgcGFyZW50IGRvbSBpbm5lclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIE5vdEZvdW5kXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICBlbmRcblxudHlwZSAoJ21vZGVsLCAnbXNnKSBhcHAgPSB7XG4gIGRvbTogSnNfYnJvd3Nlci5FbGVtZW50LnQ7XG4gIHByb2Nlc3M6ICgnbXNnIC0+IHVuaXQpO1xuICBnZXQ6ICh1bml0IC0+ICdtb2RlbCk7XG4gIGFmdGVyX3JlZHJhdzogKHVuaXQgLT4gdW5pdCkgLT4gdW5pdDtcbiAgZGlzcG9zZTogKHVuaXQgLT4gdW5pdCk7XG59XG5cbmxldCBkb20geCA9IHguZG9tXG5sZXQgcHJvY2VzcyB4ID0geC5wcm9jZXNzXG5sZXQgZ2V0IHggPSB4LmdldCAoKVxubGV0IGFmdGVyX3JlZHJhdyB4ID0geC5hZnRlcl9yZWRyYXdcblxuXG5sZXQgcnVuICh0eXBlIG1zZyBtb2RlbCkgPyhlbnYgPSBlbXB0eSkgP2NvbnRhaW5lclxuICAgICh7aW5pdCA9IChtb2RlbDAsIGNtZDApOyB1cGRhdGU7IHZpZXd9IDogKG1vZGVsLCBtc2cpIFZkb20uYXBwKSA9XG4gIGxldCBlbnYgPSBtZXJnZSBbZW52OyAhZ2xvYmFsXSBpblxuICBsZXQgY29udGFpbmVyX2NyZWF0ZWQsIGNvbnRhaW5lciA9XG4gICAgbWF0Y2ggY29udGFpbmVyIHdpdGhcbiAgICB8IE5vbmUgLT4gdHJ1ZSwgRG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQgZG9jdW1lbnQgXCJkaXZcIlxuICAgIHwgU29tZSBjb250YWluZXIgLT4gZmFsc2UsIGNvbnRhaW5lclxuICBpblxuICBsZXQgcG9zdF9yZWRyYXcgPSByZWYgW10gaW5cbiAgbGV0IGFmdGVyX3JlZHJhdyBmID0gcG9zdF9yZWRyYXcgOj0gZiA6OiAhcG9zdF9yZWRyYXcgaW5cbiAgbGV0IGZsdXNoIF8gPVxuICAgIGxldCBsID0gTGlzdC5yZXYgIXBvc3RfcmVkcmF3IGluXG4gICAgcG9zdF9yZWRyYXcgOj0gW107XG4gICAgTGlzdC5pdGVyIChmdW4gZiAtPiBmICgpKSBsXG4gIGluXG5cbiAgbGV0IHByb2Nlc3NfY3VzdG9tX2Z3ZCA9IHJlZiAoZnVuIF8gXyAtPiBhc3NlcnQgZmFsc2UpIGluXG4gIGxldCBwcm9jZXNzX2Z3ZCA9IHJlZiAoZnVuIF8gLT4gYXNzZXJ0IGZhbHNlKSBpblxuXG4gIGxldCBsaXN0ZW5lcnMgPSBIYXNodGJsLmNyZWF0ZSA4IGluXG4gIGxldCBtb2RlbCA9IHJlZiBtb2RlbDAgaW5cbiAgbGV0IGN1cnJlbnQgPSByZWYgTm9uZSBpblxuXG4gIGxldCBwZW5kaW5nX3JlZHJhdyA9IHJlZiBmYWxzZSBpblxuXG4gIGxldCB2aWV3IG1vZGVsID1cbiAgICB0cnkgdmlldyBtb2RlbFxuICAgIHdpdGggZXhuIC0+XG4gICAgICBQcmludGYucHJpbnRmIFwiRXJyb3IgZHVyaW5nIHZkb20gdmlldzogJXNcXG4lIVwiIChQcmludGV4Yy50b19zdHJpbmcgZXhuKTtcbiAgICAgIHJhaXNlIGV4blxuICBpblxuXG4gIGxldCBvbl9ldmVudCBldnQgPVxuICAgIGxldCB0eSA9IEV2ZW50LnR5cGVfIGV2dCBpblxuICAgIHRyeVxuICAgICAgbGV0IHRndCA9IEVsZW1lbnQudF9vZl9qcyAoRXZlbnQudGFyZ2V0IGV2dCkgaW5cbiAgICAgIGxldCBhcHBseV9oYW5kbGVyIGRvbSA9XG4gICAgICAgIExpc3QuZmlsdGVyX21hcCAoZnVuIGF0dHJpYnV0ZSAtPlxuICAgICAgICAgICAgbWF0Y2ggYXR0cmlidXRlIHdpdGhcbiAgICAgICAgICAgIHwgSGFuZGxlciAoRGVjb2RlciB7ZXZlbnRfdHlwZTsgZGVjb2RlcjsgbWFwfSkgd2hlbiB0eSA9IGV2ZW50X3R5cGUgLT5cbiAgICAgICAgICAgICAgICBsZXQge21zZzsgcHJldmVudF9kZWZhdWx0OyBzdG9wX3Byb3BhZ2F0aW9ufSA9XG4gICAgICAgICAgICAgICAgICBCRGVjb2Rlci5kZWNvZGVfZmFpbFxuICAgICAgICAgICAgICAgICAgICB+ZXh0cmFfZmllbGRzOltcImN1cnJlbnRUYXJnZXRcIiwgRWxlbWVudC50X3RvX2pzIGRvbV1cbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlclxuICAgICAgICAgICAgICAgICAgICAoRXZlbnQudF90b19qcyBldnQpXG4gICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICBpZiBwcmV2ZW50X2RlZmF1bHQgdGhlbiBFdmVudC5wcmV2ZW50X2RlZmF1bHQgZXZ0O1xuICAgICAgICAgICAgICAgIGlmIHN0b3BfcHJvcGFnYXRpb24gdGhlbiBFdmVudC5zdG9wX3Byb3BhZ2F0aW9uIGV2dDtcbiAgICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBtYXAgbXNnIHdpdGhcbiAgICAgICAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgICAgICAgIHwgU29tZSBtc2cgLT5cbiAgICAgICAgICAgICAgICAgICAgU29tZSAobXNnLCBzdG9wX3Byb3BhZ2F0aW9uKVxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgfCBfIC0+IE5vbmUpXG4gICAgICBpblxuICAgICAgbGV0IHJlYyBwcm9wYWdhdGUgPSBmdW5jdGlvblxuICAgICAgICB8IEZvdW5kIHtcbiAgICAgICAgICAgIG1hcHBlcjtcbiAgICAgICAgICAgIGlubmVyID0gKCBCRWxlbWVudCB7dmRvbSA9IEVsZW1lbnQge2F0dHJpYnV0ZXM7IF99OyBkb207IF99XG4gICAgICAgICAgICAgICAgICAgIHwgQkN1c3RvbSAge3Zkb20gPSBDdXN0b20gIHthdHRyaWJ1dGVzOyBffTsgZWx0ID0ge2RvbTsgX307IF99ICk7XG4gICAgICAgICAgICBwYXJlbnQ7XG4gICAgICAgICAgfSAtPlxuICAgICAgICAgICAgbGV0IHN0b3BfcHJvcGFnYXRpb24gPVxuICAgICAgICAgICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgICAgICAgICAgIChmdW4gc3RvcHBlZF9wcm9wYWdhdGlvbiAobXNnLCBzdG9wX3Byb3BhZ2F0aW9uKSAtPlxuICAgICAgICAgICAgICAgICAgICFwcm9jZXNzX2Z3ZCAobWFwcGVyIG1zZyk7XG4gICAgICAgICAgICAgICAgICAgc3RvcHBlZF9wcm9wYWdhdGlvbiB8fCBzdG9wX3Byb3BhZ2F0aW9uKVxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgKGFwcGx5X2hhbmRsZXIgZG9tIGF0dHJpYnV0ZXMpXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgaWYgbm90IHN0b3BfcHJvcGFnYXRpb24gdGhlbiBwcm9wYWdhdGUgcGFyZW50XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgKClcbiAgICAgIGluXG4gICAgICBPcHRpb24uaXRlciAoZnVuIHJvb3QgLT5cbiAgICAgICAgICBwcm9wYWdhdGUgKHZkb21fb2ZfZG9tIHJvb3QgdGd0KTtcbiAgICAgICAgKSAhY3VycmVudDtcblxuICAgICAgaWYgdHkgPSBcImlucHV0XCIgfHwgdHkgPSBcImJsdXJcIiB0aGVuXG4gICAgICAgIGxldCBmICgpID1cbiAgICAgICAgICBPcHRpb24uaXRlclxuICAgICAgICAgICAgKGZ1biByb290IC0+XG4gICAgICAgICAgICAgICBtYXRjaCB2ZG9tX29mX2RvbSByb290IHRndCB3aXRoXG4gICAgICAgICAgICAgICAoKiBub3RlOiB0aGUgbmV3IHZkb20gY2FuIGJlIGRpZmZlcmVudCBhZnRlciBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgICB0aGUgZXZlbnQgYWJvdmUgKilcbiAgICAgICAgICAgICAgICgqICEhIFRoaXMgaXMgcHJvYmFibHkgYnJva2VuIG5vdyB0aGF0IHdlIGRlbGF5IHVwZGF0aW5nIHRoZSB2ZG9tXG4gICAgICAgICAgICAgICAgICAgICB3aXRoIHJlcXVlc3RfYW5pbWF0aW9uX2ZyYW1lICEhICopXG4gICAgICAgICAgICAgICB8IEZvdW5kIHttYXBwZXIgPSBfOyBpbm5lciA9IEJFbGVtZW50IHt2ZG9tID0gRWxlbWVudCB7YXR0cmlidXRlczsgX307IF99OyBffSAtPlxuICAgICAgICAgICAgICAgICAgIExpc3QuaXRlclxuICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgIHwgUHJvcGVydHkgKFwidmFsdWVcIiwgU3RyaW5nIHMyKSB3aGVuIHMyIDw+IEVsZW1lbnQudmFsdWUgdGd0IC0+IEVsZW1lbnQuc2V0X3ZhbHVlIHRndCBzMlxuICAgICAgICAgICAgICAgICAgICAgICB8IFByb3BlcnR5IChcImNoZWNrZWRcIiwgQm9vbCBzMikgLT4gRWxlbWVudC5zZXRfY2hlY2tlZCB0Z3QgczJcbiAgICAgICAgICAgICAgICAgICAgICAgfCBfIC0+ICgpXG4gICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICB8IF8gLT4gKClcbiAgICAgICAgICAgICkgIWN1cnJlbnRcbiAgICAgICAgaW5cbiAgICAgICAgaWYgIXBlbmRpbmdfcmVkcmF3IHRoZW4gYWZ0ZXJfcmVkcmF3IGYgZWxzZSBmICgpXG4gICAgd2l0aCBleG4gLT5cbiAgICAgIFByaW50Zi5wcmludGYgXCJFcnJvciBpbiBldmVudCBoYW5kbGVyICVTOiAlc1xcbiUhXCIgdHkgKFByaW50ZXhjLnRvX3N0cmluZyBleG4pXG4gIGluXG5cbiAgbGV0IGFkZF9saXN0ZW5lciBldmVudF90eXBlID1cbiAgICBpZiBub3QgKEhhc2h0YmwubWVtIGxpc3RlbmVycyBldmVudF90eXBlKSB0aGVuIGJlZ2luXG4gICAgICBpZiBkZWJ1ZyB0aGVuIFByaW50Zi5wcmludGYgXCJBZGRpbmcgbGlzdGVuZXIgZm9yICVzXFxuJSFcIiBldmVudF90eXBlO1xuICAgICAgbGV0IHJlbW92ZV9saXN0ZW5lciA9IEVsZW1lbnQuYWRkX2NhbmNlbGxhYmxlX2V2ZW50X2xpc3RlbmVyIGNvbnRhaW5lciAoRXZlbnQuTm9uU3RhbmRhcmQgZXZlbnRfdHlwZSkgb25fZXZlbnQgdHJ1ZSBpblxuICAgICAgSGFzaHRibC5hZGQgbGlzdGVuZXJzIGV2ZW50X3R5cGUgcmVtb3ZlX2xpc3RlbmVyXG4gICAgZW5kXG4gIGluXG5cbiAgbGV0IGN0eCA9XG4gICAge1xuICAgICAgcHJvY2Vzc19jdXN0b20gPSAoZnVuIGVsdCBldnQgLT4gIXByb2Nlc3NfY3VzdG9tX2Z3ZCBlbHQgZXZ0KTtcbiAgICAgIGN1c3RvbV9oYW5kbGVycyA9IGVudi5jdXN0b21zO1xuICAgICAgYWZ0ZXJfcmVkcmF3O1xuICAgICAgYWRkX2xpc3RlbmVyO1xuICAgIH1cbiAgaW5cbiAgbGV0IHggPSBibGl0IH5wYXJlbnQ6Y29udGFpbmVyIGN0eCAodmlldyBtb2RlbDApIGluXG4gIFdpbmRvdy5yZXF1ZXN0X2FuaW1hdGlvbl9mcmFtZSB3aW5kb3cgZmx1c2g7XG5cbiAgY3VycmVudCA6PSBTb21lIHg7XG5cbiAgbGV0IHJlZHJhdyBfID1cbiAgICAoKiBUT0RPOlxuICAgICAgIGNvdWxkIGF2b2lkIGNhbGxpbmcgdmlldy9zeW5jIGlmIG1vZGVsIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAoYmVjYXVzZSB1cGRhdGVzIGFyZSBub3cgYmF0Y2hlZFxuICAgICopXG4gICAgbWF0Y2ggIWN1cnJlbnQgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSByb290IC0+XG4gICAgICAgIHBlbmRpbmdfcmVkcmF3IDo9IGZhbHNlO1xuICAgICAgICBsZXQgeCA9IHN5bmMgY3R4IGNvbnRhaW5lciBmYWxzZSBFbGVtZW50Lm51bGwgcm9vdCAodmlldyAhbW9kZWwpIGluXG4gICAgICAgIGN1cnJlbnQgOj0gU29tZSB4O1xuICAgICAgICBmbHVzaCAoKVxuICBpblxuXG4gIGxldCByZWMgcHJvY2VzcyBtc2cgPVxuICAgIHRyeVxuICAgICAgbGV0IChuZXdfbW9kZWwgOiBtb2RlbCksIChjbWQgOiBtc2cgVmRvbS5DbWQudCkgPSB1cGRhdGUgIW1vZGVsIG1zZyBpblxuICAgICAgbW9kZWwgOj0gbmV3X21vZGVsO1xuICAgICAgcnVuX2NtZCBjb250YWluZXIgY21kO1xuICAgICAgaWYgbm90ICFwZW5kaW5nX3JlZHJhdyB0aGVuIGJlZ2luXG4gICAgICAgIHBlbmRpbmdfcmVkcmF3IDo9IHRydWU7XG4gICAgICAgIFdpbmRvdy5yZXF1ZXN0X2FuaW1hdGlvbl9mcmFtZSB3aW5kb3cgcmVkcmF3XG4gICAgICBlbmRcbiAgICB3aXRoIGV4biAtPlxuICAgICAgUHJpbnRmLnByaW50ZiBcIkVycm9yIGR1cmluZyB2ZG9tIHByb2Nlc3M6ICVzXFxuJSFcIiAoUHJpbnRleGMudG9fc3RyaW5nIGV4bik7XG4gICAgICByYWlzZSBleG5cbiAgYW5kIHJ1bl9jbWQgKHBhcmVudCA6IEpzX2Jyb3dzZXIuRWxlbWVudC50KSBjbWQgPVxuICAgIENtZC5ydW4gYWZ0ZXJfcmVkcmF3IChlbnYuY21kcyBAICghZ2xvYmFsKS5jbWRzKSBwcm9jZXNzIHBhcmVudCBjbWRcbiAgaW5cblxuICBwcm9jZXNzX2Z3ZCA6PSBwcm9jZXNzO1xuXG5cbiAgTGlzdC5pdGVyIChFbGVtZW50LmFwcGVuZF9jaGlsZCBjb250YWluZXIpIChnZXRfZG9tcyB4KTtcblxuICBsZXQgcHJvY2Vzc19jdXN0b20gdGd0IGV2ZW50ID1cbiAgICBPcHRpb24uaXRlclxuICAgICAgKGZ1biByb290IC0+XG4gICAgICAgICBsZXQgcHJvY2VzcyBtYXBwZXIgYXR0cmlidXRlcyA9XG4gICAgICAgICAgIGxldCBzZWxlY3RfaGFuZGxlciBhdHRyID1cbiAgICAgICAgICAgICBtYXRjaCBhdHRyLCBldmVudCB3aXRoXG4gICAgICAgICAgICAgfCBIYW5kbGVyIChEZWNvZGVyIHtkZWNvZGVyOyBtYXA7IGV2ZW50X3R5cGUgPSBldDF9KSwgQ3VzdG9tLkVuY29kZWQge2VuY29kZXI7IGV2ZW50X3R5cGUgPSBldDJ9IHdoZW4gZXQxID0gZXQyIC0+XG4gICAgICAgICAgICAgICAgIGxldCB7bXNnOyBffSA9IEJEZWNvZGVyLmRlY29kZV9mYWlsIGRlY29kZXIgKEVuY29kZXIuZW5jb2RlIGVuY29kZXIpIGluIG1hcCBtc2dcbiAgICAgICAgICAgICB8IEhhbmRsZXIgKEN1c3RvbUV2ZW50IGYpLCBDdXN0b20gZSAtPiBmIGVcbiAgICAgICAgICAgICB8IF8gLT4gTm9uZVxuICAgICAgICAgICBpblxuICAgICAgICAgICBsZXQgbXNncyA9IExpc3QuZmlsdGVyX21hcCBzZWxlY3RfaGFuZGxlciBhdHRyaWJ1dGVzIGluXG4gICAgICAgICAgIExpc3QuaXRlciAoZnVuIG1zZyAtPiBwcm9jZXNzIChtYXBwZXIgbXNnKSkgbXNnc1xuICAgICAgICAgaW5cbiAgICAgICAgIGJlZ2luIG1hdGNoIHZkb21fb2ZfZG9tIHJvb3QgdGd0IHdpdGhcbiAgICAgICAgIHwgRm91bmQge21hcHBlcjsgaW5uZXIgPSBCRWxlbWVudCB7dmRvbSA9IEVsZW1lbnQge2F0dHJpYnV0ZXM7IF99OyBffTsgX30gLT5cbiAgICAgICAgICAgICBwcm9jZXNzIG1hcHBlciBhdHRyaWJ1dGVzXG4gICAgICAgICB8IEZvdW5kIHttYXBwZXI7IGlubmVyID0gQkN1c3RvbSAge3Zkb20gPSBDdXN0b20gIHthdHRyaWJ1dGVzOyBffTsgX307IF99IC0+XG4gICAgICAgICAgICAgcHJvY2VzcyBtYXBwZXIgYXR0cmlidXRlc1xuICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgKClcbiAgICAgICAgIGVuZFxuICAgICAgKSAhY3VycmVudFxuICAgICAgKCogRG8gd2UgbmVlZCB0byBkbyBzb21ldGhpbmcgc2ltaWxhciB0byB0aGUgXCJpbnB1dFwiIGNhc2UgaW4gb25fZXZlbnQ/ICopXG4gIGluXG4gIHByb2Nlc3NfY3VzdG9tX2Z3ZCA6PSBwcm9jZXNzX2N1c3RvbTtcblxuICBydW5fY21kIGNvbnRhaW5lciBjbWQwO1xuICBsZXQgZGlzcG9zZSAoKSA9XG4gICAgT3B0aW9uLml0ZXJcbiAgICAgIChmdW4gcm9vdCAtPlxuICAgICAgICAgY3VycmVudCA6PSBOb25lO1xuICAgICAgICAgZGlzcG9zZSByb290O1xuICAgICAgICAgSGFzaHRibC5pdGVyIChmdW4gXyBmIC0+IGYgKCkpIGxpc3RlbmVycztcbiAgICAgICAgIGlmIGNvbnRhaW5lcl9jcmVhdGVkIHRoZW5cbiAgICAgICAgICAgRWxlbWVudC5yZW1vdmUgY29udGFpbmVyXG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIEVsZW1lbnQuc2V0X2lubmVyX0hUTUwgY29udGFpbmVyIFwiXCJcbiAgICAgICkgIWN1cnJlbnRcbiAgaW5cbiAge2RvbSA9IGNvbnRhaW5lcjsgcHJvY2VzczsgZ2V0ID0gKGZ1biAoKSAtPiAhbW9kZWwpOyBhZnRlcl9yZWRyYXc7IGRpc3Bvc2V9XG5cbmxldCBkaXNwb3NlIHtkaXNwb3NlOyBffSA9IGRpc3Bvc2UgKClcbiIsInR5cGUgdCA9IHsgb3puYWthIDogc3RyaW5nIH1cblxubGV0IGl6X25pemEgb3puYWthID0geyBvem5ha2EgfVxubGV0IHZfbml6IHsgb3puYWthIH0gPSBvem5ha2FcbiIsInR5cGUgc3RhbmplID0gU3RhbmplLnRcblxudHlwZSB0ID0ge1xuICBzdGFuamEgOiBzdGFuamUgbGlzdDtcbiAgemFjZXRub19zdGFuamUgOiBzdGFuamU7XG4gIHNwcmVqZW1uYV9zdGFuamEgOiBzdGFuamUgbGlzdDtcbiAgcHJlaG9kaSA6IChzdGFuamUgKiBjaGFyICogc3RhbmplKSBsaXN0O1xufVxuXG5sZXQgcHJhemVuX2F2dG9tYXQgemFjZXRub19zdGFuamUgPVxuICB7XG4gICAgc3RhbmphID0gWyB6YWNldG5vX3N0YW5qZSBdO1xuICAgIHphY2V0bm9fc3RhbmplO1xuICAgIHNwcmVqZW1uYV9zdGFuamEgPSBbXTtcbiAgICBwcmVob2RpID0gW107XG4gIH1cblxubGV0IGRvZGFqX25lc3ByZWplbW5vX3N0YW5qZSBzdGFuamUgYXZ0b21hdCA9XG4gIHsgYXZ0b21hdCB3aXRoIHN0YW5qYSA9IHN0YW5qZSA6OiBhdnRvbWF0LnN0YW5qYSB9XG5cbmxldCBkb2Rhal9zcHJlamVtbm9fc3RhbmplIHN0YW5qZSBhdnRvbWF0ID1cbiAge1xuICAgIGF2dG9tYXQgd2l0aFxuICAgIHN0YW5qYSA9IHN0YW5qZSA6OiBhdnRvbWF0LnN0YW5qYTtcbiAgICBzcHJlamVtbmFfc3RhbmphID0gc3RhbmplIDo6IGF2dG9tYXQuc3ByZWplbW5hX3N0YW5qYTtcbiAgfVxuXG5sZXQgZG9kYWpfcHJlaG9kIHN0YW5qZTEgem5hayBzdGFuamUyIGF2dG9tYXQgPVxuICB7IGF2dG9tYXQgd2l0aCBwcmVob2RpID0gKHN0YW5qZTEsIHpuYWssIHN0YW5qZTIpIDo6IGF2dG9tYXQucHJlaG9kaSB9XG5cbmxldCBwcmVob2RuYV9mdW5rY2lqYSBhdnRvbWF0IHN0YW5qZSB6bmFrID1cbiAgbWF0Y2hcbiAgICBMaXN0LmZpbmRfb3B0XG4gICAgICAoZnVuIChzdGFuamUxLCB6bmFrJywgX3N0YW5qZTIpIC0+IHN0YW5qZTEgPSBzdGFuamUgJiYgem5hayA9IHpuYWsnKVxuICAgICAgYXZ0b21hdC5wcmVob2RpXG4gIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIChfLCBfLCBzdGFuamUyKSAtPiBTb21lIHN0YW5qZTJcblxubGV0IHphY2V0bm9fc3RhbmplIGF2dG9tYXQgPSBhdnRvbWF0LnphY2V0bm9fc3RhbmplXG5sZXQgc2V6bmFtX3N0YW5qIGF2dG9tYXQgPSBhdnRvbWF0LnN0YW5qYVxubGV0IHNlem5hbV9wcmVob2RvdiBhdnRvbWF0ID0gYXZ0b21hdC5wcmVob2RpXG5cbmxldCBqZV9zcHJlamVtbm9fc3RhbmplIGF2dG9tYXQgc3RhbmplID1cbiAgTGlzdC5tZW0gc3RhbmplIGF2dG9tYXQuc3ByZWplbW5hX3N0YW5qYVxuXG5sZXQgZW5rZV8xbW9kMyA9XG4gIGxldCBxMCA9IFN0YW5qZS5pel9uaXphIFwicTBcIlxuICBhbmQgcTEgPSBTdGFuamUuaXpfbml6YSBcInExXCJcbiAgYW5kIHEyID0gU3RhbmplLml6X25pemEgXCJxMlwiIGluXG4gIHByYXplbl9hdnRvbWF0IHEwIHw+IGRvZGFqX3NwcmVqZW1ub19zdGFuamUgcTFcbiAgfD4gZG9kYWpfbmVzcHJlamVtbm9fc3RhbmplIHEyXG4gIHw+IGRvZGFqX3ByZWhvZCBxMCAnMCcgcTAgfD4gZG9kYWpfcHJlaG9kIHExICcwJyBxMSB8PiBkb2Rhal9wcmVob2QgcTIgJzAnIHEyXG4gIHw+IGRvZGFqX3ByZWhvZCBxMCAnMScgcTEgfD4gZG9kYWpfcHJlaG9kIHExICcxJyBxMiB8PiBkb2Rhal9wcmVob2QgcTIgJzEnIHEwXG5cbmxldCBwcmViZXJpX25peiBhdnRvbWF0IHEgbml6ID1cbiAgbGV0IGF1eCBhY2Mgem5hayA9XG4gICAgbWF0Y2ggYWNjIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSBxIC0+IHByZWhvZG5hX2Z1bmtjaWphIGF2dG9tYXQgcSB6bmFrXG4gIGluXG4gIG5peiB8PiBTdHJpbmcudG9fc2VxIHw+IFNlcS5mb2xkX2xlZnQgYXV4IChTb21lIHEpXG4iLCJ0eXBlIHQgPSB7IG5peiA6IHN0cmluZzsgaW5kZWtzX3RyZW51dG5lZ2Ffem5ha2EgOiBpbnQgfVxuXG5sZXQgdHJlbnV0bmlfem5hayB0cmFrID0gU3RyaW5nLmdldCB0cmFrLm5peiB0cmFrLmluZGVrc190cmVudXRuZWdhX3puYWthXG5sZXQgamVfbmFfa29uY3UgdHJhayA9IFN0cmluZy5sZW5ndGggdHJhay5uaXogPSB0cmFrLmluZGVrc190cmVudXRuZWdhX3puYWthXG5cbmxldCBwcmVtYWtuaV9uYXByZWogdHJhayA9XG4gIHsgdHJhayB3aXRoIGluZGVrc190cmVudXRuZWdhX3puYWthID0gc3VjYyB0cmFrLmluZGVrc190cmVudXRuZWdhX3puYWthIH1cblxubGV0IGl6X25pemEgbml6ID0geyBuaXo7IGluZGVrc190cmVudXRuZWdhX3puYWthID0gMCB9XG5sZXQgcHJhemVuID0gaXpfbml6YSBcIlwiXG5sZXQgdl9uaXogdHJhayA9IHRyYWsubml6XG5cbmxldCBwcmVicmFuaSB0cmFrID0gU3RyaW5nLnN1YiB0cmFrLm5peiAwIHRyYWsuaW5kZWtzX3RyZW51dG5lZ2Ffem5ha2FcblxuYW5kIG5lcHJlYnJhbmkgdHJhayA9XG4gIFN0cmluZy5zdWIgdHJhay5uaXogdHJhay5pbmRla3NfdHJlbnV0bmVnYV96bmFrYVxuICAgIChTdHJpbmcubGVuZ3RoIHRyYWsubml6IC0gdHJhay5pbmRla3NfdHJlbnV0bmVnYV96bmFrYSlcbiIsInR5cGUgdCA9IHsgYXZ0b21hdCA6IEF2dG9tYXQudDsgdHJhayA6IFRyYWsudDsgc3RhbmplIDogU3RhbmplLnQgfVxuXG5sZXQgcG96ZW5pIGF2dG9tYXQgdHJhayA9XG4gIHsgYXZ0b21hdDsgdHJhazsgc3RhbmplID0gQXZ0b21hdC56YWNldG5vX3N0YW5qZSBhdnRvbWF0IH1cblxubGV0IGF2dG9tYXQgeyBhdnRvbWF0OyBfIH0gPSBhdnRvbWF0XG5sZXQgdHJhayB7IHRyYWs7IF8gfSA9IHRyYWtcbmxldCBzdGFuamUgeyBzdGFuamU7IF8gfSA9IHN0YW5qZVxuXG5sZXQga29yYWtfbmFwcmVqIHsgYXZ0b21hdDsgdHJhazsgc3RhbmplIH0gPVxuICBpZiBUcmFrLmplX25hX2tvbmN1IHRyYWsgdGhlbiBOb25lXG4gIGVsc2VcbiAgICBsZXQgc3RhbmplJyA9XG4gICAgICBBdnRvbWF0LnByZWhvZG5hX2Z1bmtjaWphIGF2dG9tYXQgc3RhbmplIChUcmFrLnRyZW51dG5pX3puYWsgdHJhaylcbiAgICBpblxuICAgIG1hdGNoIHN0YW5qZScgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHN0YW5qZScgLT5cbiAgICAgICAgU29tZSB7IGF2dG9tYXQ7IHRyYWsgPSBUcmFrLnByZW1ha25pX25hcHJlaiB0cmFrOyBzdGFuamUgPSBzdGFuamUnIH1cblxubGV0IGplX3Zfc3ByZWplbW5lbV9zdGFuanUgeyBhdnRvbWF0OyBzdGFuamU7IF8gfSA9XG4gIEF2dG9tYXQuamVfc3ByZWplbW5vX3N0YW5qZSBhdnRvbWF0IHN0YW5qZVxuIiwiKCogRGF0b3Rla2EgcyBwcmF2aWxpIHphIHNwcmVtZW1ibyBzdGFuaiAqKVxuXG5cblxuXG4oKiBGdW5rY2lqYSBzcHJlbWVuaV9zdGFuamUgc3ByZWptZSB0dXBsZSBzb3NlZG92IHByZWR2aWRlbmUgZG9sxb5pbmUgKGJvb2wgKiBib29sICogYm9vbCAuLi4gKiBib29sKSBpbiB0cmVudXRubyBzdGFuamUgOiBib29sLCB0ZXIgdnJuZSBrb27EjW5vIHN0YW5qZSA6IGJvb2wgXG50cmVudXRubyBuYXN0YXZsamVubyBuYSBvYmxpa29cblx0ICB8MXwgfDJ8XG5cdHwzfDR8eHw1fDZ8XG5cdCAgfDd8IHw4fCB8OXxcblxua2plciBzbyBwbyB2cnN0aSB2IHNvc2VkaXR1cGxlIGtvdCBzbyBuYXBpc2FuZSDFoXRldmlsa2UsIHggamUgcGEgdHJlbnV0bmEuIFRlaiBva29saWNpIGJvbW8gemRhaiBwcmF2aWxpIGRpbm96YXZlciwgc2FqIG5hcyBsYWhrbyB6IHZlbGlrbyBkb21pxaFsamlqZSBzcG9taW5qYSBuYSBzdGVnb3phdnJhIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0ZWdvc2F1cnVzXG5cbmtha8WhbmUgemFodGV2ZSDFvmVsaW1vOlxuLT4gZGEgxI1lIGltYSB2c2Ugb2tvbGkgc2ViZSBwcmF6bm8gcmF0YSB0dWRpIHNhbSBwcmF6ZW4gKG5lIGdsZWRlIG5hIG9zbm92bm8gc3RhbmplKVxuLT4gb2IgbWFsZW0gxaF0ZXZpbHUgc29zZWRvdiB2IHZlxI1pbmkgc2l0dWFjaWogdW1yZVxuLT4gb2Igc3JlZG5qZW0gxaF0ZXZpbHUgc29zZWRvdiB2IHZlxI1pbmkgc2l0dWFjaWogb8W+aXZpXG4tPiBvYiBwcmV2ZWxpa2VtIMWhdGV2aWx1IHNvc2Vkb3YgdW1yZVxuXG5cbnJlY2ltbyBkYSBkYW1vIHByZXByb3N0byB0YWtvOlxuLT4gxI1lIGplIG1ydGV2IGluIGltYSAzIGFsaSBtYW5qIMW+aXZpaCBzb3NlZG92IHBvdGVtIG9zdGFuZSBtcnRldlxuLT4gxI1lIGplIMW+aXYgaW4gaW1hIDIgYWxpIG1hbmogxb5pdmloIHNvc2Vkb3YgcG90ZW0gdW1yZVxuLT4gxI1lIGplIG1ydGV2IGluIGltYSBtZWQgMyBpbiA5IHNvc2Vkb3YgcG90ZW0gb8W+aXZpXG4tPiDEjWUgamUgxb5pdiBpbiBpbWEgbWVkIDQgaW4gOCDFvml2aWggc29zZWRvdiBwb3RlbSBvc3RhbmUgxb5pdlxuLT4gxb1pdiBpbiA5IHNvc2Vkb3YgcG90ZW0gdW1yZVxuXG4qKVxubGV0IHJlYyBzZXN0ZWpsaXN0IHNlem5hbSA9XG5tYXRjaCBzZXpuYW0gd2l0aFxufCB0cnVlIDo6dGFpbCAtPiAxICsgKHNlc3Rlamxpc3QgdGFpbClcbnwgZmFsc2UgOjogdGFpbCAtPiBzZXN0ZWpsaXN0IHRhaWxcbnxbXSAtPiAwXG5cblxubGV0IHNwcmVtZW5pX3N0YW5qZSBzb3NlZGlsaXN0IHRyZW51dG5vX3N0YW5qZSA9XG5sZXQgeml2aXNvc2VkaSA9IHNlc3Rlamxpc3Qgc29zZWRpbGlzdCBpblxuaWYgeml2aXNvc2VkaSA8PTQgJiYgKG5vdCB0cmVudXRub19zdGFuamUpIHRoZW4gZmFsc2VcbmVsc2UgaWYgeml2aXNvc2VkaSA8PTMgJiYgdHJlbnV0bm9fc3RhbmplIHRoZW4gZmFsc2VcbmVsc2UgaWYgbm90IHRyZW51dG5vX3N0YW5qZSB0aGVuIHRydWVcbmVsc2UgaWYgeml2aXNvc2VkaTw9OCB0aGVuIHRydWVcbmVsc2UgZmFsc2VcblxubGV0IHNwcmVtZW5pX3N0YW5qZV96aXZpIHppdmlzb3NlZGkgdHJlbnV0bm9fc3RhbmplID1cbmlmIHppdmlzb3NlZGkgPD0zICYmIChub3QgdHJlbnV0bm9fc3RhbmplKSB0aGVuIGZhbHNlXG5lbHNlIGlmIHppdmlzb3NlZGkgPD0xICYmIHRyZW51dG5vX3N0YW5qZSB0aGVuIGZhbHNlXG5lbHNlIGlmIG5vdCB0cmVudXRub19zdGFuamUgdGhlbiB0cnVlXG5lbHNlIGlmIHppdmlzb3NlZGk8PTggdGhlbiB0cnVlXG5lbHNlIGZhbHNlXG5cblxubGV0IG1hdHJpa2FzZXN0ZWppemxvY2VuaSBpemxvY2kgbWF0cmlrYSA9XG5sZXQgbSA9IEFycmF5Lmxlbmd0aCBtYXRyaWthIGluXG5sZXQgbiA9IEFycmF5Lmxlbmd0aCBtYXRyaWthLigwKSBpblxuQXJyYXkuaW5pdCBtIChmdW4gaSAtPiBBcnJheS5pbml0IG4gKGZ1biBqIC0+IHNlc3Rlamxpc3QgQEAgaXpsb2NpIG1hdHJpa2EgbSBuIGkgaikpXG5cbmxldCBrb3BpcmFqbWF0cmlrbyBtYXRyaWthID0gKCp6YSBzcHJvYmF2YXQgc2VtIHJhYmlsIHRvIGZ1bmtjaWpvLCBkYSBuaXNlbSBzcHJlbWluamFsIG1hdHJpa2UqKVxuQXJyYXkubWFwIEFycmF5LmNvcHkgbWF0cmlrYVxuXG5sZXQga29yYWsgaXpsb2NpIG1hdHJpa2EgPSAoKmdsYXZuYSBmdW5rY2lqYSBraSBqbyBrbGnEjWVtbyBza3VwYWogcyBmdW5rY2lqbyBpemxvY2lzb3NlZGUgaXogaXpsb2Npc29zZWRlLm1sLCBwcmltZXI6IGxldCB0cmVudXRuYSA9IGtvcmFrIGl6bG9jaXNvc2VkZSB6YWNldG5hbWF0cmlrYSAqKVxubGV0IG0gPSBBcnJheS5sZW5ndGggbWF0cmlrYSBpblxubGV0IG4gPSBBcnJheS5sZW5ndGggbWF0cmlrYS4oMCkgaW5cbkFycmF5LmluaXQgbSAoZnVuIGkgLT4gQXJyYXkuaW5pdCBuIChmdW4gaiAtPiBzcHJlbWVuaV9zdGFuamVfeml2aSAoc2VzdGVqbGlzdCBAQCBpemxvY2kgbWF0cmlrYSBtIG4gaSBqKSBtYXRyaWthLihpKS4oaikgKSlcblxubGV0IHphY2V0bmFtYXRyaWthID0gW3xbfGZhbHNlOyB0cnVlOyB0cnVlOyB0cnVlOyB0cnVlOyB0cnVlOyB0cnVlfF07ICgqIHphIHZlxI1qZSBwcmltZXJlIHNpIGplIG5hamJvbGplIGdlbmVyaXJhdGkgbmFrbGp1xI1ubyBtYXRyaWtvIHogdWthem9tOiBsZXQgbWF0cmlrYSA9IHJhbmRvbW1hdHJpa2EgbSBuLCBraSBqZSB2IGl6bG9jaXNvc2VkZS5tbCopXG4gICAgW3xmYWxzZTsgdHJ1ZTsgdHJ1ZTsgdHJ1ZTsgdHJ1ZTsgdHJ1ZTsgdHJ1ZXxdO1xuICAgIFt8dHJ1ZTsgdHJ1ZTsgdHJ1ZTsgdHJ1ZTsgdHJ1ZTsgdHJ1ZTsgdHJ1ZXxdO1xuICAgIFt8ZmFsc2U7IGZhbHNlOyB0cnVlOyB0cnVlOyB0cnVlOyBmYWxzZTsgdHJ1ZXxdO1xuICAgIFt8ZmFsc2U7IGZhbHNlOyBmYWxzZTsgdHJ1ZTsgZmFsc2U7IHRydWU7IGZhbHNlfF18XVxuICAgIFxuICAgIFxuKCrFvmVsaW0gZnVua2Npam8sIGtpIHZ6YW1lIG1hdHJpa28gZG9ibGplbm8geiBpemxvxI1lbm8gaW4gbmEgcG9kbGFnaSBwcmF2aWxhIGRvbG/EjWkgYWxpIGJvIG5vdiBlbGVtZW50IMW+aXYgYWxpIG5lLCBtb2dvxI1lIG1vZGlmaWNpcmFtIG1hdHJpa28gcyDFoXRldmlsb20gc29zZWRvdiwgZGEgdmtsanXEjXVqZSBwb2RhdGVrLCBhbGkgamUga3ZhZGRyYXRlayBzYW0gxb5pdiBhbGkgbXJ0ZXYqKVxuKCppZGVqYSB6YSBwcmF2aWxhIGplIG5wciB1cmVqZW4gc2V6bmFtIG1laiBtZWQgdGVtLCBhbGkgc28gxb5pdmkgYWxpIG1ydHZpKilcbigqZHJ1Z2EgaWRlamEgamUgc2FtbyBzZXpuYW0gdnNlaCB2cmVkbm9zdGksIHphIGthdGVyZSBvc3RhbmUgxb5pdiopXG5sZXQgcmVjIG5vdHJpIGVsZW1lbnQgbW5vemljYT1cbm1hdGNoIG1ub3ppY2Egd2l0aCAoKnNlbSBzZSBob3RlbCBpem9nbml0aSB0ZW11LCBkYSBwcmV2ZXJqYSBkbyBrb25jYSBhbXBhayBuZSB2ZW0ga2FrbyBiaSB0byBuYXJlZGlsLi4uKilcbnxoOjp0IC0+IChoPT1lbGVtZW50KSB8fCAobm90cmkgZWxlbWVudCB0KVxufFtdIC0+IGZhbHNlXG5cbmxldCBwcmF2aWxvICh0cmVudXRub3N0YW5qZSxzdHNvc2VkKSAocHJhdmlsYXppdmksIHByYXZpbGFtcnR2aSk9XG5tYXRjaCB0cmVudXRub3N0YW5qZSB3aXRoXG58dHJ1ZSAtPiBub3RyaSBzdHNvc2VkIHByYXZpbGF6aXZpXG58ZmFsc2UgLT4gbm90cmkgc3Rzb3NlZCBwcmF2aWxhbXJ0dmlcblxubGV0IGluaXRfbWF0cml4IHJvd3MgY29scyBmID0gKCogUE9aT1IhISFmdW5rY2lqYSBkZWZpbmlyYW5hIHR1a2FqIGluIHYgaXpsb2Npc29zZWRlICopXG4gIEFycmF5LmluaXQgcm93cyAoZnVuIGkgLT4gQXJyYXkuaW5pdCBjb2xzIChmdW4gaiAtPiBmIGkgaikpXG5cblxubGV0IG5hcmVkaWtvcmFrIG1hdHJpa2Fzb3NlZG92IChwcmF2aWxheml2aSwgcHJhdmlsYW1ydHZpKT1cbmxldCBtID0gQXJyYXkubGVuZ3RoIG1hdHJpa2Fzb3NlZG92IGluXG5sZXQgbiA9IEFycmF5Lmxlbmd0aCBtYXRyaWthc29zZWRvdi4oMCkgaW5cbmluaXRfbWF0cml4IG0gbiAoZnVuIGkgaiAtPiBwcmF2aWxvIG1hdHJpa2Fzb3NlZG92LihpKS4oaikgKHByYXZpbGF6aXZpLCBwcmF2aWxhbXJ0dmkpKVxuKCpmdW5rY2lqYSBpbml0X21hdHJpeCBqZSBpeiBpemxvY2lzb3NlZGUsIGEgYm8gdG8gcHJvYmxlbSBrbyBib20gcG9nYW5qYWw/KilcblxuKCpjb253YXkqKVxubGV0IHphY2V0bmFwcmF2aWxhID0gKFsyOzNdLCBbM10pICgqQ29ud2F5KilcbmxldCB6YWNldG5payA9IDNcbmxldCB6YWNldG5pc29zZWRpID0gW3xbfGZhbHNlOyB0cnVlOyBmYWxzZXxdOyBbfHRydWU7IGZhbHNlOyB0cnVlfF07IFt8ZmFsc2U7IHRydWU7IGZhbHNlfF18XSIsIigqIHR1IG5vdCBib2RvIGZ1bmtjaWplLCBraSBuYW0gaXogcG9kYW5lIG1hdHJpa2UgKG5lIHZlbSDFoWUga2FrxaFuYSBibykgaXpsb8SNaWpvIHNvc2VkZSB2IG9ibGlraSBrb3Qgc2VtIGpvIGRvbG/EjWlsIFxudHJlYmEgYm8gcHJ2byBkb2xvxI1pdGkgbWVqZSBzaXN0ZW1hIGFsaSBwYcSNIGRhIGplIG5lc2tvbsSNZW4gaW4gZGEgc2UgYm8gdG9yZWogZG9kYWphbG8gc3R2YXJpXG5cbm1vZ2/EjWUgbmFqcHJlaiByZcSNZW1vLCBkYSBzbyBwZXJpb2RpxI1uaSBib3VuZGFyeSBjb25kaXRpb25pLCBqZSBuYWpsYcW+amVcblxudHJlbnV0bm8gbmFzdGF2bGplbm8gbmEgb2JsaWtvXG5cbiAgICAgai0yLGotMSxqLGorMSxqKzIsIGorM1xuXHQgIHwxfCB8MnxcdGktMVxuXHR8M3w0fHh8NXw2fCAgIHZyc3RpY2EgaVxuXHQgIHw3fCB8OHwgfDl8ICAgaSsxXG5cdHN0b2xwZWMgalxuXG4qKVxubGV0IHJlYyByYW5kb21hcnJheSBuID1cbm1hdGNoIG4gd2l0aFxufCAwIC0+IFt8IHxdXG58IGsgLT4gQXJyYXkuYXBwZW5kIFt8UmFuZG9tLmJvb2woKXxdIChyYW5kb21hcnJheSAoay0xKSlcblxubGV0IHJlYyByYW5kb21tYXRyaWthIG0gbiA9XG5tYXRjaCBtIHdpdGggXG58IDAgLT4gW3wgfF1cbnwgayAtPiBBcnJheS5hcHBlbmQgW3xyYW5kb21hcnJheSBufF0gKHJhbmRvbW1hdHJpa2EgKGstMSkgbilcblxubGV0ICheXl4pIHggeSA9IHggXiBcIiBcIiBeIHlcblxubGV0IGl6cGlzaW1hdHJpa29pbnQgbWF0cmlrYSA9XG4gQXJyYXkubWFwIChmdW4gdnJzdGljYSAtPiBwcmludF9zdHJpbmcgKChBcnJheS5mb2xkX2xlZnQgKF5eXikgXCJcIiBAQCBBcnJheS5tYXAgc3RyaW5nX29mX2ludCB2cnN0aWNhKSBeIFwiXFxuXCIpKSBtYXRyaWthXG5cbmxldCBtYXBtYXRyaXggZiBtYXQgPVxuQXJyYXkubWFwIChmdW4gdnJzdGljYSAtPiBBcnJheS5tYXAgZiB2cnN0aWNhKSBtYXRcblxubGV0IGludG9mYm9vbCA9IGZ1bmN0aW9uXG58IHRydWUgLT4gMVxufCBmYWxzZSAtPiAwXG5cbmxldCBib29sb2ZpbnQgPSBmdW5jdGlvblxufCAxIC0+IHRydWVcbnwgMCAtPiBmYWxzZVxufCBfIC0+IHRydWVcblxubGV0IGl6cGlzaXNvc2VkZWludCBzb3NlZGkgPSBcbm1hdGNoIHNvc2VkaSB3aXRoIFxufCBwcnZpOjpkcnVnaTo6dHJldGppOjpjZXRydGk6OnBldGk6OnNlc3RpOjpzZWRtaTo6b3NtaTo6ZGV2ZXRpOjpbXSAtPiBpenBpc2ltYXRyaWtvaW50IFt8W3wwO3Bydmk7MDtkcnVnaTswOzB8XTsgW3x0cmV0amk7IGNldHJ0aTsgMDsgcGV0aTsgc2VzdGk7IDB8XTsgW3wwOyBzZWRtaTsgMDsgb3NtaTsgMDsgZGV2ZXRpfF18XVxufCBfIC0+IGl6cGlzaW1hdHJpa29pbnQgKEFycmF5Lm1ha2VfbWF0cml4IDMgNiAwKVxuXG5sZXQgaXpsb2Npc29zZWRlIG1hdHJpa2EgbSBuIGkgaiA9ICgqIG0gPSBzdF92cnN0aWMsIG49IHN0X3N0b2xwY2V2LCBpLGogc3RhIGtvb3JkaW5hdGkgdHJlbnV0bmVnYSBwb2xqYSAqKVxubGV0IHBydmkgPSBtYXRyaWthLigoaS0xK20pIG1vZCBtKS4oKGotMStuKSBtb2QgbikgaW5cbmxldCBkcnVnaSA9IG1hdHJpa2EuKChpLTErbSkgbW9kIG0pLigoaisxKSAgbW9kIG4pIGluXG5sZXQgdHJldGppID0gbWF0cmlrYS4oaSBtb2QgbSkuKChqLTIrbikgIG1vZCBuKSBpblxubGV0IGNldHJ0aSA9IG1hdHJpa2EuKGkgbW9kIG0pLigoai0xK24pICBtb2QgbikgaW5cbmxldCBwZXRpID0gbWF0cmlrYS4oaSBtb2QgbSkuKChqKzEpIG1vZCBuKSBpblxubGV0IHNlc3RpID0gbWF0cmlrYS4oaSBtb2QgbSkuKChqKzIpIG1vZCBuKSBpblxubGV0IHNlZG1pID0gbWF0cmlrYS4oKGkrMSkgbW9kIG0pLigoai0xK24pIG1vZCBuKSBpblxubGV0IG9zbWkgPSBtYXRyaWthLigoaSsxKSBtb2QgbSkuKChqKzEpIG1vZCBuKSBpblxubGV0IGRldmV0aSA9IG1hdHJpa2EuKChpKzEpIG1vZCBtKS4oKGorMykgbW9kIG4pIGluXG5wcnZpOjpkcnVnaTo6dHJldGppOjpjZXRydGk6OnBldGk6OnNlc3RpOjpzZWRtaTo6b3NtaTo6ZGV2ZXRpOjpbXVxuXG5cbmxldCBkb3Rwcm9kIG1hdHJpa2FhIG1hdHJpa2FiID0gKCprb3QgZG90IHByb2R1Y3Qgc2FtbyB6IGJvb2xpKilcbiAgbGV0IG0gPSBBcnJheS5sZW5ndGggbWF0cmlrYWEgaW5cbiAgbGV0IG4gPSBBcnJheS5sZW5ndGggbWF0cmlrYWEuKDApIGluXG4gIGxldCB2c290YSA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBtIC0gMSBkb1xuICAgIGZvciBqID0gMCB0byBuIC0gMSBkb1xuICAgICAgdnNvdGEgOj0gIXZzb3RhICsgKGludG9mYm9vbCAobWF0cmlrYWEuKGkpLihqKSAmJiBtYXRyaWthYi4oaSkuKGopKSlcbiAgICBkb25lXG4gIGRvbmU7XG4gICF2c290YVxuXG5sZXQgaW5pdF9tYXRyaXggcm93cyBjb2xzIGYgPSAoKnRhIGZ1bmtjaWphIGJpIG1vZ2xhIGJpdCDFvmUgZGVmaW5pcmFuYSBqZSBwaXNhbCBuYSBzcGxldHU/Pz8gUE9aT1IsIGRlZmluaXJhbmEgdHVrYWogaW4gdiBwcmF2aWxhLm1sICopXG4gIEFycmF5LmluaXQgcm93cyAoZnVuIGkgLT4gQXJyYXkuaW5pdCBjb2xzIChmdW4gaiAtPiBmIGkgaikpXG5cblxubGV0IG1vam1vZCB4IG0gPSAoKHggbW9kIG0pK20pIG1vZCBtICgqxI1lIGplIG5lZ2F0aXZubyBuYW0gZGEgaXogZHJ1Z2Ugc3RyYW5pIG0tamEsIGtlciBkcnVnYcSNZSBuYW0gZGEgLTIgbW9kIDMgPSAtMiwgemRhaiBqZSBwYSAxKilcbiAgXG4gIFxubGV0IGl6bG9jaXNvc2Vkc2tvbWF0cmlrbyBjZWxhbWF0cmlrYSBrIHBydmlpbmRla3MgZHJ1Z2lpbmRla3MgPSAoKiBkb2JpbW8gbWF0cmlrbyBzb3NlZG92IGt2YWRyYXRhIGkgaiAqKVxubGV0IG0gPSBBcnJheS5sZW5ndGggY2VsYW1hdHJpa2EgaW5cbmxldCBuID0gQXJyYXkubGVuZ3RoIGNlbGFtYXRyaWthLigwKSBpblxuaW5pdF9tYXRyaXggayBrIChmdW4gaSBqIC0+IGNlbGFtYXRyaWthLihtb2ptb2QgKGkgKyBwcnZpaW5kZWtzIC1rLzIpIG0pLihtb2ptb2QgKGogKyBkcnVnaWluZGVrcyAtay8yKSBuKSkoKmtlciBtYXRyaWthIHNvc2Vkb3YgamUgMmwrMXgybCsxID1reGssIGluZGVrc2UgcGEgcmFiaW0ga2xpY2F0aSBwcmF2aWxubyopXG5cbmxldCBuYXJlZGltYXRyaWtvdnNvdCBjZWxhbWF0cmlrYSBtYXRyaWthc29zZXNjaW5lID1cbmxldCBtID0gQXJyYXkubGVuZ3RoIGNlbGFtYXRyaWthIGluXG5sZXQgbiA9IEFycmF5Lmxlbmd0aCBjZWxhbWF0cmlrYS4oMCkgaW4gXG5sZXQgayA9IEFycmF5Lmxlbmd0aCBtYXRyaWthc29zZXNjaW5lIGluIFxuaW5pdF9tYXRyaXggbSBuIChmdW4gaSBqIC0+IChkb3Rwcm9kIChpemxvY2lzb3NlZHNrb21hdHJpa28gY2VsYW1hdHJpa2EgayBpIGopIG1hdHJpa2Fzb3Nlc2NpbmUpKVxuIiwidHlwZSB0ID0geyB4IDogZmxvYXQ7IHkgOiBmbG9hdCB9XG5cbmxldCAoICoqLiApIGsgdmVjID0geyB4ID0gayAqLiB2ZWMueDsgeSA9IGsgKi4gdmVjLnkgfVxubGV0ICggKysuICkgdmVjMSB2ZWMyID0geyB4ID0gdmVjMS54ICsuIHZlYzIueDsgeSA9IHZlYzEueSArLiB2ZWMyLnkgfVxubGV0ICggLS0uICkgdmVjMSB2ZWMyID0gdmVjMSArKy4gKC0xLiAqKi4gdmVjMilcbmxldCBkb2x6aW5hIHZlYyA9IHNxcnQgKCh2ZWMueCAqKiAyLikgKy4gKHZlYy55ICoqIDIuKSlcbmxldCBub3JtaXJhaiB2ZWMgPSAoMS4gLy4gZG9semluYSB2ZWMpICoqLiB2ZWNcblxubGV0IHNyZWRpbmEgPyhsYW1iZGEgPSAwLjUpIHphY2V0ZWsga29uZWMgPVxuICAoKDEuIC0uIGxhbWJkYSkgKiouIHphY2V0ZWspICsrLiAobGFtYmRhICoqLiBrb25lYylcblxubGV0IHJhemRhbGphIHphY2V0ZWsga29uZWMgPSBkb2x6aW5hICh6YWNldGVrIC0tLiBrb25lYylcblxubGV0IGtvcmVuaV9lbm90ZSBuIHNpcmluYSB2aXNpbmEgPVxuICBsZXQgcGkgPSA0LiAqLiBhdGFuIDEuIGluXG4gIGxldCBzcmVkaXNjZSA9IHsgeCA9IHNpcmluYSAvLiAyLjsgeSA9IHZpc2luYSAvLiAyLiB9IGluXG4gIExpc3QuaW5pdCBuIChmdW4gaSAtPlxuICAgICAgbGV0IGtvdCA9IDIuICouIHBpICouIGZsb2F0X29mX2ludCBpIC8uIGZsb2F0X29mX2ludCBuXG4gICAgICBhbmQgcG9sbWVyID0gbWluIHNpcmluYSB2aXNpbmEgLy4gMi4gKi4gMC45IGluXG4gICAgICBzcmVkaXNjZSArKy4geyB4ID0gcG9sbWVyICouIGNvcyBrb3Q7IHkgPSBwb2xtZXIgKi4gc2luIGtvdCB9KVxuIiwib3BlbiBEZWZpbmljaWplXG5cbnR5cGUgbmFjaW4gPSBQcml2emV0TmFjaW4gfCBWbmFzYW5qZU5pemEgfCBQcmVtaWthbmplVm96bGlzY2Egb2YgU3RhbmplLnRcblxudHlwZSBtb2RlbCA9IHtcbiAgYXZ0b21hdCA6IFphZ25hbmlBdnRvbWF0LnQ7XG4gIHBvbG96YWppIDogKFN0YW5qZS50ICogVmVrdG9yLnQpIGxpc3Q7XG4gIG5hY2luIDogbmFjaW47XG4gIHNpcmluYSA6IGZsb2F0O1xuICB2aXNpbmEgOiBmbG9hdDtcbn1cblxubGV0IGluaXQgc2lyaW5hIHZpc2luYSBhdnRvbWF0ID1cbiAgbGV0IHBvbG96YWppID1cbiAgICBWZWt0b3Iua29yZW5pX2Vub3RlXG4gICAgICAoTGlzdC5sZW5ndGggKEF2dG9tYXQuc2V6bmFtX3N0YW5qIGF2dG9tYXQpKVxuICAgICAgc2lyaW5hIHZpc2luYVxuICAgIHw+IExpc3QuY29tYmluZSAoQXZ0b21hdC5zZXpuYW1fc3RhbmogYXZ0b21hdClcbiAgaW5cbiAge1xuICAgIGF2dG9tYXQgPSBaYWduYW5pQXZ0b21hdC5wb3plbmkgYXZ0b21hdCBUcmFrLnByYXplbjtcbiAgICBwb2xvemFqaTtcbiAgICBuYWNpbiA9IFByaXZ6ZXROYWNpbjtcbiAgICBzaXJpbmE7XG4gICAgdmlzaW5hO1xuICB9XG5cbnR5cGUgbXNnID1cbiAgfCBQcmViZXJpTmFzbGVkbmppWm5ha1xuICB8IFphY25pUHJlbWlrVm96bGlzY2Egb2YgU3RhbmplLnRcbiAgfCBQcmVtYWtuaVZvemxpc2NlIG9mIFZla3Rvci50XG4gIHwgS29uY2FqUHJlbWlrVm96bGlzY2FcbiAgfCBaYWNuaVZub3NOaXphXG4gIHwgVm5lc2lOaXogb2Ygc3RyaW5nXG5cbmxldCBwb2xvemFqX3N0YW5qYSBtb2RlbCBxID0gTGlzdC5hc3NvYyBxIG1vZGVsLnBvbG96YWppXG5cbmxldCB1cGRhdGUgbW9kZWwgPSBmdW5jdGlvblxuICB8IFByZWJlcmlOYXNsZWRuamlabmFrIC0+IChcbiAgICAgIG1hdGNoIFphZ25hbmlBdnRvbWF0LmtvcmFrX25hcHJlaiBtb2RlbC5hdnRvbWF0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBtb2RlbFxuICAgICAgfCBTb21lIGF2dG9tYXQnIC0+IHsgbW9kZWwgd2l0aCBhdnRvbWF0ID0gYXZ0b21hdCcgfSlcbiAgfCBaYWNuaVByZW1pa1Zvemxpc2NhIHEgLT4geyBtb2RlbCB3aXRoIG5hY2luID0gUHJlbWlrYW5qZVZvemxpc2NhIHEgfVxuICB8IFByZW1ha25pVm96bGlzY2UgcG9zaXRpb24gLT4gKFxuICAgICAgbWF0Y2ggbW9kZWwubmFjaW4gd2l0aFxuICAgICAgfCBQcmVtaWthbmplVm96bGlzY2EgcSAtPlxuICAgICAgICAgIGxldCBwb2xvemFqaSA9XG4gICAgICAgICAgICBMaXN0Lm1hcFxuICAgICAgICAgICAgICAoZnVuIChxJywgcG9zaXRpb24nKSAtPlxuICAgICAgICAgICAgICAgIChxJywgaWYgcSA9IHEnIHRoZW4gcG9zaXRpb24gZWxzZSBwb3NpdGlvbicpKVxuICAgICAgICAgICAgICBtb2RlbC5wb2xvemFqaVxuICAgICAgICAgIGluXG4gICAgICAgICAgeyBtb2RlbCB3aXRoIHBvbG96YWppIH1cbiAgICAgIHwgXyAtPiBtb2RlbClcbiAgfCBLb25jYWpQcmVtaWtWb3psaXNjYSAtPiB7IG1vZGVsIHdpdGggbmFjaW4gPSBQcml2emV0TmFjaW4gfVxuICB8IFphY25pVm5vc05pemEgLT4geyBtb2RlbCB3aXRoIG5hY2luID0gVm5hc2FuamVOaXphIH1cbiAgfCBWbmVzaU5peiB2bmVzZW5pX25peiAtPlxuICAgICAge1xuICAgICAgICBtb2RlbCB3aXRoXG4gICAgICAgIGF2dG9tYXQgPVxuICAgICAgICAgIFphZ25hbmlBdnRvbWF0LnBvemVuaVxuICAgICAgICAgICAgKFphZ25hbmlBdnRvbWF0LmF2dG9tYXQgbW9kZWwuYXZ0b21hdClcbiAgICAgICAgICAgIChUcmFrLml6X25pemEgdm5lc2VuaV9uaXopO1xuICAgICAgICBuYWNpbiA9IFByaXZ6ZXROYWNpbjtcbiAgICAgIH1cbiIsIm9wZW4gVmRvbVxub3BlbiBNb2RlbFxub3BlbiBWZWt0b3Jcbm9wZW4gRGVmaW5pY2lqZVxuXG5tb2R1bGUgUGFyYW1ldHJpID0gc3RydWN0XG4gIGxldCBiYXJ2YV9zcHJlamVtbmVnYV9zdGFuamEgPSBcInJnYig1NiwgMTQyLCA2MClcIlxuICBsZXQgYmFydmFfdHJlbnV0bmVnYV9zdGFuamEgPSBcInJnYigyNTUsIDI0MiwgMjAyKVwiXG4gIGxldCBiYXJ2YV96YWNldG5lZ2Ffc3RhbmphID0gXCJyZ2IoOCwgMTE4LCAxNTUpXCJcbiAgbGV0IGRlYmVsaW5hX2NydCA9IDMuXG4gIGxldCBkb2x6aW5hX2tvbmljZSA9IDEwLlxuICBsZXQgZG9semluYV9wdXNjaWNlX3phY2V0bmVnYV9zdGFuamEgPSAyMC5cbiAgbGV0IG5ha2xvbl9rb25pY2UgPSAwLjRcbiAgbGV0IHBvbG1lcl9vem5ha2UgPSAxMC5cbiAgbGV0IHBvbG1lcl9zcHJlamVtbmVnYV9zdGFuamEgPSA1LlxuICBsZXQgcG9sbWVyX3N0YW5qYSA9IDIwLlxuICBsZXQgcG9sbWVyX3phbmtlID0gMjUuXG4gIGxldCBwcml2emV0YV9iYXJ2YV9jcnQgPSBcImJsYWNrXCJcbiAgbGV0IHByaXZ6ZXRhX2JhcnZhX3BvbG5pbGEgPSBcIndoaXRlXCJcbmVuZFxuXG5sZXQgaW50X29mX2Zsb2F0X2F0dHIgdGFnIHZhbHVlID0gaW50X2F0dHIgdGFnIChpbnRfb2ZfZmxvYXQgdmFsdWUpXG5cbmxldCBzdmdfa3JvZyA/KGEgPSBbXSkgc3JlZGlzY2UgcG9sbWVyID1cbiAgc3ZnX2VsdCBcImNpcmNsZVwiXG4gICAgfmE6XG4gICAgICAoW1xuICAgICAgICAgaW50X29mX2Zsb2F0X2F0dHIgXCJjeFwiIHNyZWRpc2NlLng7XG4gICAgICAgICBpbnRfb2ZfZmxvYXRfYXR0ciBcImN5XCIgc3JlZGlzY2UueTtcbiAgICAgICAgIGludF9vZl9mbG9hdF9hdHRyIFwiclwiIHBvbG1lcjtcbiAgICAgICBdXG4gICAgICBAIGEpXG4gICAgW11cblxubGV0IHN2Z19kYWxqaWNhID8oYSA9IFtdKSB6YWNldGVrIGtvbmVjID1cbiAgc3ZnX2VsdCBcImxpbmVcIlxuICAgIH5hOlxuICAgICAgKFtcbiAgICAgICAgIGludF9vZl9mbG9hdF9hdHRyIFwieDFcIiB6YWNldGVrLng7XG4gICAgICAgICBpbnRfb2ZfZmxvYXRfYXR0ciBcInkxXCIgemFjZXRlay55O1xuICAgICAgICAgaW50X29mX2Zsb2F0X2F0dHIgXCJ4MlwiIGtvbmVjLng7XG4gICAgICAgICBpbnRfb2ZfZmxvYXRfYXR0ciBcInkyXCIga29uZWMueTtcbiAgICAgICBdXG4gICAgICBAIGEpXG4gICAgW11cblxubGV0IHN2Z19wdXNjaWNhID8oYSA9IFtdKSB6YWNldGVrIGtvbmVjID1cbiAgbGV0IHZla3RvciA9IGtvbmVjIC0tLiB6YWNldGVrIGluXG4gIGxldCBub3JtYWxhID0geyB4ID0gLS52ZWt0b3IueTsgeSA9IHZla3Rvci54IH0gaW5cbiAgbGV0IHZla3Rvcl9sZXZlX2tvbmljZSA9XG4gICAgc3JlZGluYSB+bGFtYmRhOlBhcmFtZXRyaS5uYWtsb25fa29uaWNlICgtMS4gKiouIHZla3Rvcikgbm9ybWFsYVxuICBpblxuICBsZXQgdmVrdG9yX2Rlc25lX2tvbmljZSA9XG4gICAgc3JlZGluYSB+bGFtYmRhOlBhcmFtZXRyaS5uYWtsb25fa29uaWNlICgtMS4gKiouIHZla3RvcikgKC0xLiAqKi4gbm9ybWFsYSlcbiAgaW5cbiAgbGV0IGxldmFfa29uaWNhID1cbiAgICBrb25lYyArKy4gKFBhcmFtZXRyaS5kb2x6aW5hX2tvbmljZSAqKi4gbm9ybWlyYWogdmVrdG9yX2xldmVfa29uaWNlKVxuICBpblxuICBsZXQgZGVzbmFfa29uaWNhID1cbiAgICBrb25lYyArKy4gKFBhcmFtZXRyaS5kb2x6aW5hX2tvbmljZSAqKi4gbm9ybWlyYWogdmVrdG9yX2Rlc25lX2tvbmljZSlcbiAgaW5cbiAgc3ZnX2VsdCBcImdcIlxuICAgIFtcbiAgICAgIHN2Z19kYWxqaWNhIH5hIHphY2V0ZWsga29uZWM7XG4gICAgICBzdmdfZGFsamljYSB+YSBrb25lYyBsZXZhX2tvbmljYTtcbiAgICAgIHN2Z19kYWxqaWNhIH5hIGtvbmVjIGRlc25hX2tvbmljYTtcbiAgICBdXG5cbmxldCBzdmdfb3puYWthID8oYSA9IFtdKSBwb2xvemFqIGJlc2VkaWxvID1cbiAgc3ZnX2VsdCBcInRleHRcIlxuICAgIH5hOlxuICAgICAgKFtcbiAgICAgICAgIGludF9vZl9mbG9hdF9hdHRyIFwieFwiIHBvbG96YWoueDtcbiAgICAgICAgIGludF9vZl9mbG9hdF9hdHRyIFwieVwiIHBvbG96YWoueTtcbiAgICAgICAgIGF0dHIgXCJ0ZXh0LWFuY2hvclwiIFwibWlkZGxlXCI7XG4gICAgICAgICBhdHRyIFwiZG9taW5hbnQtYmFzZWxpbmVcIiBcImNlbnRyYWxcIjtcbiAgICAgICBdXG4gICAgICBAIGEpXG4gICAgWyB0ZXh0IGJlc2VkaWxvIF1cblxubGV0IHByaWthel9zdGFuamEgbW9kZWwgcSA9XG4gIGxldCBhdnRvbWF0ID0gWmFnbmFuaUF2dG9tYXQuYXZ0b21hdCBtb2RlbC5hdnRvbWF0IGluXG4gIGxldCBwb2xvemFqID0gcG9sb3phal9zdGFuamEgbW9kZWwgcSBpblxuICBsZXQgYmFydmFfcm9idSA9XG4gICAgaWYgcSA9IEF2dG9tYXQuemFjZXRub19zdGFuamUgYXZ0b21hdCB0aGVuIFBhcmFtZXRyaS5iYXJ2YV96YWNldG5lZ2Ffc3RhbmphXG4gICAgZWxzZSBpZiBBdnRvbWF0LmplX3NwcmVqZW1ub19zdGFuamUgYXZ0b21hdCBxIHRoZW5cbiAgICAgIFBhcmFtZXRyaS5iYXJ2YV9zcHJlamVtbmVnYV9zdGFuamFcbiAgICBlbHNlIFBhcmFtZXRyaS5wcml2emV0YV9iYXJ2YV9jcnRcbiAgaW5cbiAgbGV0IGJhcnZhX3BvbG5pbGEgPVxuICAgIGlmIHEgPSBaYWduYW5pQXZ0b21hdC5zdGFuamUgbW9kZWwuYXZ0b21hdCB0aGVuXG4gICAgICBQYXJhbWV0cmkuYmFydmFfdHJlbnV0bmVnYV9zdGFuamFcbiAgICBlbHNlIFBhcmFtZXRyaS5wcml2emV0YV9iYXJ2YV9wb2xuaWxhXG4gIGluXG4gIGxldCBzdmdfZWxlbWVudGkgPVxuICAgIFtcbiAgICAgIHN2Z19rcm9nXG4gICAgICAgIH5hOlsgYXR0ciBcInN0cm9rZVwiIGJhcnZhX3JvYnU7IGF0dHIgXCJmaWxsXCIgYmFydmFfcG9sbmlsYSBdXG4gICAgICAgIHBvbG96YWogUGFyYW1ldHJpLnBvbG1lcl9zdGFuamE7XG4gICAgICBzdmdfb3puYWthIHBvbG96YWogKFN0YW5qZS52X25peiBxKTtcbiAgICBdXG4gIGluXG4gIGxldCBzdmdfZWxlbWVudGkgPVxuICAgIGlmIHEgPSBBdnRvbWF0LnphY2V0bm9fc3RhbmplIGF2dG9tYXQgdGhlblxuICAgICAgc3ZnX3B1c2NpY2FcbiAgICAgICAgfmE6WyBhdHRyIFwic3Ryb2tlXCIgUGFyYW1ldHJpLmJhcnZhX3phY2V0bmVnYV9zdGFuamEgXVxuICAgICAgICAocG9sb3phalxuICAgICAgICAtLS4ge1xuICAgICAgICAgICAgICB4ID1cbiAgICAgICAgICAgICAgICBQYXJhbWV0cmkucG9sbWVyX3N0YW5qYVxuICAgICAgICAgICAgICAgICsuIFBhcmFtZXRyaS5kb2x6aW5hX3B1c2NpY2VfemFjZXRuZWdhX3N0YW5qYTtcbiAgICAgICAgICAgICAgeSA9IDAuO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKHBvbG96YWogLS0uIHsgeCA9IFBhcmFtZXRyaS5wb2xtZXJfc3RhbmphOyB5ID0gMC4gfSlcbiAgICAgIDo6IHN2Z19lbGVtZW50aVxuICAgIGVsc2Ugc3ZnX2VsZW1lbnRpXG4gIGluXG4gIGxldCBzdmdfZWxlbWVudGkgPVxuICAgIGlmIEF2dG9tYXQuamVfc3ByZWplbW5vX3N0YW5qZSBhdnRvbWF0IHEgdGhlblxuICAgICAgc3ZnX2VsZW1lbnRpXG4gICAgICBAIFtcbiAgICAgICAgICBzdmdfa3JvZ1xuICAgICAgICAgICAgfmE6XG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBhdHRyIFwic3Ryb2tlXCIgUGFyYW1ldHJpLmJhcnZhX3NwcmVqZW1uZWdhX3N0YW5qYTtcbiAgICAgICAgICAgICAgICBhdHRyIFwiZmlsbFwiIFwibm9uZVwiO1xuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBwb2xvemFqXG4gICAgICAgICAgICAoUGFyYW1ldHJpLnBvbG1lcl9zdGFuamEgLS4gUGFyYW1ldHJpLnBvbG1lcl9zcHJlamVtbmVnYV9zdGFuamEpO1xuICAgICAgICBdXG4gICAgZWxzZSBzdmdfZWxlbWVudGlcbiAgaW5cblxuICBzdmdfZWx0IFwiZ1wiXG4gICAgfmE6WyBvbm1vdXNlZG93biB+cHJldmVudF9kZWZhdWx0OigpIChmdW4gXyAtPiBaYWNuaVByZW1pa1Zvemxpc2NhIHEpIF1cbiAgICBzdmdfZWxlbWVudGlcblxubGV0IHByaWthel96YW5rZSB6YWNldGVrIG96bmFrYSA9XG4gIGxldCBwb2xvemFqX296bmFrZSA9XG4gICAgemFjZXRlayAtLS4geyB4ID0gMC47IHkgPSAyLiAqLiBQYXJhbWV0cmkucG9sbWVyX3phbmtlIH1cbiAgaW5cbiAgc3ZnX2VsdCBcImdcIlxuICAgIFtcbiAgICAgIHN2Z19wdXNjaWNhXG4gICAgICAgIH5hOlsgYXR0ciBcInN0cm9rZVwiIFBhcmFtZXRyaS5wcml2emV0YV9iYXJ2YV9jcnQgXVxuICAgICAgICAoemFjZXRlayArKy4geyB4ID0gUGFyYW1ldHJpLnBvbG1lcl9zdGFuamEgKy4gMi47IHkgPSAtMy4gfSlcbiAgICAgICAgKHphY2V0ZWsgKysuIHsgeCA9IFBhcmFtZXRyaS5wb2xtZXJfc3RhbmphOyB5ID0gLTIuIH0pO1xuICAgICAgc3ZnX2tyb2dcbiAgICAgICAgfmE6WyBhdHRyIFwic3Ryb2tlXCIgUGFyYW1ldHJpLnByaXZ6ZXRhX2JhcnZhX2NydDsgYXR0ciBcImZpbGxcIiBcIm5vbmVcIiBdXG4gICAgICAgICh6YWNldGVrIC0tLiB7IHggPSAwLjsgeSA9IFBhcmFtZXRyaS5wb2xtZXJfemFua2UgfSlcbiAgICAgICAgUGFyYW1ldHJpLnBvbG1lcl96YW5rZTtcbiAgICAgIHN2Z19rcm9nIH5hOlsgYXR0ciBcImZpbGxcIiBcIndoaXRlXCIgXSBwb2xvemFqX296bmFrZSBQYXJhbWV0cmkucG9sbWVyX296bmFrZTtcbiAgICAgIHN2Z19vem5ha2EgcG9sb3phal9vem5ha2Ugb3puYWthO1xuICAgIF1cblxubGV0IHByaWthel9wcmVob2RhIHphY2V0ZWsga29uZWMgb3puYWthID1cbiAgbGV0IGxhbWJkYSA9IFBhcmFtZXRyaS5wb2xtZXJfc3RhbmphIC8uIHJhemRhbGphIHphY2V0ZWsga29uZWMgaW5cbiAgbGV0IHphY2V0ZWtfcHVzY2ljZSA9IHNyZWRpbmEgfmxhbWJkYSB6YWNldGVrIGtvbmVjIGluXG4gIGxldCBrb25lY19wdXNjaWNlID0gc3JlZGluYSB+bGFtYmRhOigxLiAtLiBsYW1iZGEpIHphY2V0ZWsga29uZWMgaW5cbiAgbGV0IHBvbG96YWpfb3puYWtlID0gc3JlZGluYSB+bGFtYmRhOjAuMyB6YWNldGVrIGtvbmVjIGluXG4gIHN2Z19lbHQgXCJnXCJcbiAgICBbXG4gICAgICBzdmdfcHVzY2ljYVxuICAgICAgICB+YTpcbiAgICAgICAgICBbXG4gICAgICAgICAgICBpbnRfb2ZfZmxvYXRfYXR0ciBcInN0cm9rZS13aWR0aFwiIFBhcmFtZXRyaS5kZWJlbGluYV9jcnQ7XG4gICAgICAgICAgICBhdHRyIFwic3Ryb2tlXCIgUGFyYW1ldHJpLnByaXZ6ZXRhX2JhcnZhX2NydDtcbiAgICAgICAgICBdXG4gICAgICAgIHphY2V0ZWtfcHVzY2ljZSBrb25lY19wdXNjaWNlO1xuICAgICAgc3ZnX2tyb2cgfmE6WyBhdHRyIFwiZmlsbFwiIFwid2hpdGVcIiBdIHBvbG96YWpfb3puYWtlIFBhcmFtZXRyaS5wb2xtZXJfb3puYWtlO1xuICAgICAgc3ZnX296bmFrYSBwb2xvemFqX296bmFrZSBvem5ha2E7XG4gICAgXVxuXG5sZXQgcHJpa2F6X3RyYWt1IG1vZGVsID1cbiAgbGV0IHRyYWsgPSBaYWduYW5pQXZ0b21hdC50cmFrIG1vZGVsLmF2dG9tYXQgaW5cbiAgbWF0Y2ggbW9kZWwubmFjaW4gd2l0aFxuICB8IFZuYXNhbmplTml6YSAtPlxuICAgICAgZWx0IFwiaDJcIlxuICAgICAgICBbXG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgICAgIH5hOlsgb25jaGFuZ2UgKGZ1biBuaXogLT4gVm5lc2lOaXogbml6KTsgdmFsdWUgKFRyYWsudl9uaXogdHJhaykgXVxuICAgICAgICAgICAgW107XG4gICAgICAgIF1cbiAgfCBfIC0+XG4gICAgICBsZXQgcHJlYnJhbmkgPSBUcmFrLnByZWJyYW5pIHRyYWsgYW5kIG5lcHJlYnJhbmkgPSBUcmFrLm5lcHJlYnJhbmkgdHJhayBpblxuICAgICAgZWx0IFwiaDJcIlxuICAgICAgICB+YTpbIG9uZGJsY2xpY2sgKGZ1biBfIC0+IFphY25pVm5vc05pemEpIF1cbiAgICAgICAgWyB0ZXh0IHByZWJyYW5pOyBlbHQgXCJtYXJrXCIgWyB0ZXh0IG5lcHJlYnJhbmkgXSBdXG5cbmxldCBwcmlrYXpfZ3VtYmFfemFfbmFzbGVkbmppX3puYWsgbW9kZWwgPVxuICBlbHQgXCJhXCJcbiAgICB+YTpcbiAgICAgIFtcbiAgICAgICAgYXR0ciBcInJvbGVcIiBcImJ1dHRvblwiO1xuICAgICAgICBhdHRyIFwiaHJlZlwiIFwiI1wiO1xuICAgICAgICBvbmNsaWNrIChmdW4gXyAtPiBQcmViZXJpTmFzbGVkbmppWm5hayk7XG4gICAgICAgIGRpc2FibGVkXG4gICAgICAgICAgKG1vZGVsLm5hY2luID0gVm5hc2FuamVOaXphXG4gICAgICAgICAgfHwgbW9kZWwuYXZ0b21hdCB8PiBaYWduYW5pQXZ0b21hdC50cmFrIHw+IFRyYWsuamVfbmFfa29uY3UpO1xuICAgICAgXVxuICAgIFsgdGV4dCBcInByZWJlcmkgbmFzbGVkbmppIHpuYWtcIiBdXG5cbmxldCBwcmlrYXpfYXZ0b21hdGEgbW9kZWwgPVxuICBsZXQgYXZ0b21hdCA9IFphZ25hbmlBdnRvbWF0LmF2dG9tYXQgbW9kZWwuYXZ0b21hdCBpblxuICBsZXQgc3RhbmphID1cbiAgICBMaXN0Lm1hcCAocHJpa2F6X3N0YW5qYSBtb2RlbCkgKGF2dG9tYXQgfD4gQXZ0b21hdC5zZXpuYW1fc3RhbmopXG4gIGluXG4gIGxldCBwcmVob2RpID1cbiAgICBMaXN0Lm1hcFxuICAgICAgKGZ1biAoc3JjLCBjaHIsIGRzdCkgLT5cbiAgICAgICAgbGV0IHN2Z19vem5ha2EgPSBTdHJpbmcubWFrZSAxIGNociBpblxuICAgICAgICBpZiBzcmMgPSBkc3QgdGhlbiBwcmlrYXpfemFua2UgKHBvbG96YWpfc3RhbmphIG1vZGVsIHNyYykgc3ZnX296bmFrYVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcHJpa2F6X3ByZWhvZGEgKHBvbG96YWpfc3RhbmphIG1vZGVsIHNyYykgKHBvbG96YWpfc3RhbmphIG1vZGVsIGRzdClcbiAgICAgICAgICAgIHN2Z19vem5ha2EpXG4gICAgICAoQXZ0b21hdC5zZXpuYW1fcHJlaG9kb3YgYXZ0b21hdClcbiAgaW5cbiAgbGV0IGEgPVxuICAgIG1hdGNoIG1vZGVsLm5hY2luIHdpdGhcbiAgICB8IFByZW1pa2FuamVWb3psaXNjYSBfIC0+XG4gICAgICAgIFtcbiAgICAgICAgICBvbm1vdXNlbW92ZSAoZnVuIGV2IC0+XG4gICAgICAgICAgICAgIFByZW1ha25pVm96bGlzY2VcbiAgICAgICAgICAgICAgICB7IHggPSBMYXp5LmZvcmNlIGV2LmVsZW1lbnRfeDsgeSA9IExhenkuZm9yY2UgZXYuZWxlbWVudF95IH0pO1xuICAgICAgICAgIG9ubW91c2V1cCAoZnVuIF8gLT4gS29uY2FqUHJlbWlrVm96bGlzY2EpO1xuICAgICAgICBdXG4gICAgfCBfIC0+IFtdXG4gIGluXG4gIHN2Z19lbHQgXCJzdmdcIlxuICAgIH5hOlxuICAgICAgKGFcbiAgICAgIEAgW1xuICAgICAgICAgIGludF9vZl9mbG9hdF9hdHRyIFwid2lkdGhcIiBtb2RlbC5zaXJpbmE7XG4gICAgICAgICAgaW50X29mX2Zsb2F0X2F0dHIgXCJoZWlnaHRcIiBtb2RlbC52aXNpbmE7XG4gICAgICAgICAgaW50X29mX2Zsb2F0X2F0dHIgXCJzdHJva2Utd2lkdGhcIiBQYXJhbWV0cmkuZGViZWxpbmFfY3J0O1xuICAgICAgICBdKVxuICAgIChwcmVob2RpIEAgc3RhbmphKVxuXG5sZXQgdmlldyBtb2RlbCA9XG4gIGVsdCBcImFydGljbGVcIlxuICAgIFtcbiAgICAgIGVsdCBcImhlYWRlclwiIFsgcHJpa2F6X3RyYWt1IG1vZGVsOyBwcmlrYXpfZ3VtYmFfemFfbmFzbGVkbmppX3puYWsgbW9kZWwgXTtcbiAgICAgIHByaWthel9hdnRvbWF0YSBtb2RlbDtcbiAgICBdXG4iLCJsZXQgYXBwID1cbiAgVmRvbS5zaW1wbGVfYXBwXG4gICAgfmluaXQ6KE1vZGVsLmluaXQgNTAwLiA1MDAuIERlZmluaWNpamUuQXZ0b21hdC5lbmtlXzFtb2QzKVxuICAgIH52aWV3OlZpZXcudmlldyB+dXBkYXRlOk1vZGVsLnVwZGF0ZSAoKVxuXG5sZXQgKCkgPVxuICBsZXQgb3BlbiBKc19icm93c2VyIGluXG4gIGxldCBydW4gKCkgPVxuICAgIFZkb21fYmxpdC5ydW4gYXBwIHw+IFZkb21fYmxpdC5kb21cbiAgICB8PiBKc19icm93c2VyLkVsZW1lbnQuYXBwZW5kX2NoaWxkXG4gICAgICAgICAobWF0Y2hcbiAgICAgICAgICAgIEpzX2Jyb3dzZXIuRG9jdW1lbnQuZ2V0X2VsZW1lbnRzX2J5X2NsYXNzX25hbWUgSnNfYnJvd3Nlci5kb2N1bWVudFxuICAgICAgICAgICAgICBcImNvbnRhaW5lclwiXG4gICAgICAgICAgICB8PiBBcnJheS50b19saXN0XG4gICAgICAgICAgd2l0aFxuICAgICAgICAgfCBlbGVtZW50IDo6IF8gLT4gZWxlbWVudFxuICAgICAgICAgfCBbXSAtPiBKc19icm93c2VyLkRvY3VtZW50LmRvY3VtZW50X2VsZW1lbnQgSnNfYnJvd3Nlci5kb2N1bWVudClcbiAgaW5cbiAgV2luZG93LnNldF9vbmxvYWQgd2luZG93IHJ1blxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFbnN1cmUgdGhhdCBbYXRfZXhpdF0gZnVuY3Rpb25zIGFyZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSBwcm9ncmFtICopXG5cbmxldCBfID0gZG9fYXRfZXhpdCgpXG4iXX0=
